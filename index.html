<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>PolyPaint</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
:root {
    --bg: #0f1026;
    --panel: #151a3a;
    --stroke: rgba(255,255,255,0.08);
    --stroke2: rgba(255,255,255,0.14);
    --text: #e9e9f2;
    --muted: #8a90a6;
    --accent: #e94560;
    --accent-hover: #c73550;
    --accent-dim: rgba(233,69,96,0.18);
    --accent-border: rgba(233,69,96,0.45);
    --blue: #5b6abf;
    --radius: 10px;
    --blur: blur(12px);
}
* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; }
body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: radial-gradient(ellipse 1200px 600px at 20% -10%, rgba(233,69,96,0.12), transparent 60%),
                radial-gradient(ellipse 900px 500px at 90% 0%, rgba(91,106,191,0.10), transparent 60%),
                var(--bg);
    color: var(--text);
    display: grid; grid-template-rows: auto 1fr; height: 100%;
}
/* --- Header --- */
#header {
    padding: 6px 14px; border-bottom: 1px solid var(--stroke);
    display: flex; align-items: center; gap: 10px;
    background: rgba(10,12,30,0.55);
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
}
#header .app-title {
    font-size: 12px; font-weight: 600; color: var(--muted);
    letter-spacing: 0.14em; text-transform: uppercase;
}
.header-sep { width: 1px; height: 18px; background: var(--stroke2); }
/* --- Content: sidebar + main --- */
#content { display: grid; grid-template-columns: 60px 1fr; min-height: 0; }
#sidebar {
    padding: 10px 8px; border-right: 1px solid var(--stroke);
    background: rgba(10,12,30,0.40);
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
    display: flex; flex-direction: column; gap: 16px; align-items: center;
}
.side-group { width: 100%; display: flex; flex-direction: column; gap: 6px; align-items: center; }
.side-label {
    font-size: 9px; color: var(--muted); letter-spacing: 0.12em;
    text-transform: uppercase; opacity: 0.85;
}
.side-btn {
    width: 40px; height: 40px; border-radius: 12px;
    border: 1px solid var(--stroke); background: rgba(255,255,255,0.03);
    color: var(--muted); display: flex; align-items: center; justify-content: center;
    cursor: pointer; font-size: 16px; padding: 0;
    transition: background 0.12s, border-color 0.12s, color 0.12s, transform 0.06s;
}
.side-btn:hover { background: rgba(255,255,255,0.06); border-color: var(--stroke2); color: var(--text); }
.side-btn:active { transform: translateY(1px); }
.side-btn.active { background: var(--accent-dim); border-color: var(--accent-border); color: #fff; }
#main { display: flex; flex-direction: column; min-height: 0; }
.icon-btn {
    width: 28px; height: 28px; border-radius: 8px;
    border: 1px solid var(--stroke); background: rgba(255,255,255,0.03);
    color: var(--muted); display: flex; align-items: center; justify-content: center;
    cursor: pointer; font-size: 13px; padding: 0;
    transition: background 0.12s, border-color 0.12s, color 0.12s;
}
.icon-btn:hover { background: rgba(255,255,255,0.06); border-color: var(--stroke2); color: var(--text); }
.icon-btn.active { background: var(--accent-dim); border-color: var(--accent-border); color: #fff; }
.control-label {
    font-size: 10px; color: var(--muted); text-transform: uppercase;
    letter-spacing: 0.5px; font-weight: 500;
}
.degree-val {
    color: var(--accent); font-size: 14px; font-weight: 600;
    cursor: pointer; min-width: 20px; text-align: center;
    border-bottom: 1px solid transparent;
    transition: border-color 0.12s;
}
.degree-val:hover { border-bottom-color: var(--accent); }
.degree-val.tool-active { border-bottom-color: var(--accent); }
#pattern {
    background: rgba(255,255,255,0.04); color: var(--text);
    border: 1px solid var(--stroke); border-radius: 6px;
    padding: 4px 8px; font-size: 11px; outline: none;
}
/* --- Sidebar OPS --- */
.side-group.ops .side-label { align-self: center; }
#ops-target { opacity: 0.7; font-size: 8px; }
#ops-group.disabled { opacity: 0.35; pointer-events: none; }
#ops-group:not(.disabled) .side-btn { color: var(--text); border-color: var(--stroke2); }
#ops-group .side-btn.tool-active {
    background: var(--accent-dim); border-color: var(--accent-border); color: #fff;
}
/* --- Ops Popover --- */
.ops-pop {
    display: none; position: fixed; z-index: 200;
    background: rgba(15, 16, 38, 0.92);
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
    border: 1px solid var(--stroke2); border-radius: var(--radius);
    box-shadow: 0 12px 40px rgba(0,0,0,0.5);
    padding: 10px; min-width: 52px;
}
.ops-pop.open { display: flex; flex-direction: column; align-items: center; gap: 6px; }
.ops-pop .pop-title {
    font-size: 9px; color: var(--muted); text-transform: uppercase;
    letter-spacing: 0.10em;
}
.ops-pop .pop-val {
    font-size: 11px; color: var(--accent); font-weight: 600; min-width: 40px; text-align: center;
}
/* Scale / Rotate slider track */
.ops-pop .vslider {
    width: 6px; height: 140px; border-radius: 3px;
    background: rgba(255,255,255,0.06); position: relative; cursor: pointer;
    touch-action: none;
}
.ops-pop .vslider .vslider-fill {
    position: absolute; bottom: 0; left: 0; right: 0;
    border-radius: 3px; background: var(--accent-dim);
    pointer-events: none;
}
.ops-pop .vslider .vslider-thumb {
    position: absolute; left: 50%; width: 16px; height: 16px;
    margin-left: -8px; margin-top: -8px;
    border-radius: 50%; background: var(--accent); border: 2px solid #fff;
    box-shadow: 0 0 8px rgba(233,69,96,0.5); pointer-events: none;
}
/* Horizontal slider (rotate) */
.ops-pop .hslider {
    width: 160px; height: 6px; border-radius: 3px;
    background: rgba(255,255,255,0.06); position: relative; cursor: pointer;
    touch-action: none;
}
.ops-pop .hslider .hslider-thumb {
    position: absolute; top: 50%; width: 16px; height: 16px;
    margin-left: -8px; margin-top: -8px;
    border-radius: 50%; background: var(--accent); border: 2px solid #fff;
    box-shadow: 0 0 8px rgba(233,69,96,0.5); pointer-events: none;
}
.ops-pop .hslider .hslider-center {
    position: absolute; left: 50%; top: 0; bottom: 0; width: 1px;
    background: rgba(255,255,255,0.15); pointer-events: none;
}
/* 2D vector pad */
.ops-pop .vec-pad {
    width: 140px; height: 140px; border-radius: 8px;
    background: rgba(255,255,255,0.04); border: 1px solid var(--stroke);
    position: relative; cursor: crosshair; touch-action: none;
}
.ops-pop .vec-pad .pad-axis {
    position: absolute; background: rgba(255,255,255,0.08); pointer-events: none;
}
.ops-pop .vec-pad .pad-axis.h { left: 0; right: 0; top: 50%; height: 1px; }
.ops-pop .vec-pad .pad-axis.v { top: 0; bottom: 0; left: 50%; width: 1px; }
.ops-pop .vec-pad .pad-dot {
    position: absolute; width: 14px; height: 14px;
    margin-left: -7px; margin-top: -7px;
    border-radius: 50%; background: var(--accent); border: 2px solid #fff;
    box-shadow: 0 0 8px rgba(233,69,96,0.5); pointer-events: none;
    left: 50%; top: 50%;
}
.ops-pop .vec-pad .pad-line {
    position: absolute; pointer-events: none;
    left: 50%; top: 50%; width: 0; height: 0;
    transform-origin: 0 0;
}
.ops-pop .pop-row {
    display: flex; gap: 8px; font-size: 10px; color: var(--muted);
}
/* --- Audio config popover rows --- */
.audio-row {
    display: flex; align-items: center; gap: 8px; width: 100%;
}
.audio-row .row-label {
    font-size: 9px; color: var(--muted); width: 56px;
    text-transform: uppercase; letter-spacing: 0.08em; flex-shrink: 0;
}
.audio-row .hslider { flex: 1; min-width: 80px; }
.audio-row .row-val {
    font-size: 10px; color: var(--accent); width: 52px;
    text-align: right; font-variant-numeric: tabular-nums; flex-shrink: 0;
}
.audio-toggle {
    display: flex; align-items: center; gap: 6px;
    cursor: pointer; padding: 4px 0; user-select: none; width: 100%;
}
.audio-toggle .toggle-dot {
    width: 10px; height: 10px; border-radius: 50%;
    border: 1.5px solid var(--muted); transition: all 0.12s;
}
.audio-toggle.on .toggle-dot {
    background: var(--accent); border-color: var(--accent);
}
.audio-toggle .toggle-label {
    font-size: 10px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em;
}
.audio-toggle.on .toggle-label { color: var(--text); }
/* --- Coeff picker rows --- */
.cpick-row {
    display: flex; align-items: center; gap: 6px; width: 100%;
    padding: 2px 0; cursor: pointer; user-select: none;
}
.cpick-row:hover { background: rgba(255,255,255,0.05); }
.cpick-row .cpick-dot {
    width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0;
}
.cpick-row .cpick-label {
    font-size: 10px; color: var(--muted); width: 28px; flex-shrink: 0;
}
.cpick-row .cpick-power {
    font-size: 9px; color: var(--muted); opacity: 0.6; width: 30px; flex-shrink: 0;
}
.cpick-row .cpick-coords {
    font-size: 9px; color: var(--muted); flex: 1; text-align: right;
    font-variant-numeric: tabular-nums;
}
.cpick-row .cpick-cb {
    width: 12px; height: 12px; border: 1.5px solid var(--muted); border-radius: 2px;
    flex-shrink: 0; display: flex; align-items: center; justify-content: center;
    transition: all 0.12s;
}
.cpick-row .cpick-cb.checked {
    background: var(--accent); border-color: var(--accent);
}
.cpick-row .cpick-cb.checked::after {
    content: "‚úì"; font-size: 8px; color: #fff;
}
/* --- Panels --- */
#panels { display: flex; justify-content: center; gap: 12px; padding: 8px 12px 12px 8px; flex: 1; min-height: 0; }
.panel {
    text-align: center; display: flex; flex-direction: column; flex: 1; min-width: 0; min-height: 0;
    background: rgba(255,255,255,0.02); border: 1px solid var(--stroke);
    border-radius: var(--radius); box-shadow: 0 8px 24px rgba(0,0,0,0.3); overflow: hidden;
}
.panel h3 {
    margin: 0; padding: 8px 12px; flex-shrink: 0;
    font-weight: 500; font-size: 11px; text-transform: uppercase; letter-spacing: 0.8px; color: var(--muted);
    border-bottom: 1px solid var(--stroke); background: rgba(10,12,30,0.45);
    display: flex; align-items: center; justify-content: space-between;
}
.panel h3 .icon-btn { width: 22px; height: 22px; font-size: 11px; border-radius: 6px; }
#rec-roots-btn.recording { color: #e94560; animation: rec-blink 1s ease-in-out infinite alternate; }
@keyframes rec-blink { from { opacity: 1; } to { opacity: 0.4; } }
svg { background: var(--panel); border: 0; border-radius: 0; flex: 1; position: relative; }
.grid line { stroke: #1f3354; stroke-width: 0.5; }
.axis line { stroke: #2a4a6b; stroke-width: 1; }
.unit-circle { fill: none; stroke: #2a4a6b; stroke-width: 1; stroke-dasharray: 4 3; }
circle.coeff { cursor: grab; stroke-width: 1.5; }
circle.coeff.dragging { cursor: grabbing; stroke: #fff; stroke-width: 2.5; }
circle.root { cursor: grab; stroke-width: 1.5; }
circle.root.dragging { cursor: grabbing; stroke: #fff; stroke-width: 2.5; }
.coeff-label { font-size: 10px; fill: #aaa; pointer-events: none; }
/* --- Tabs (roots panel) --- */
.tab-bar { display:flex; align-items:stretch; padding:0 8px; gap:0;
           flex-shrink:0; background:rgba(10,12,30,0.45);
           border-bottom:1px solid var(--stroke); }
.tab { padding:7px 14px 8px; font-weight:500; font-size:11px;
       text-transform:uppercase; letter-spacing:0.8px; color:var(--muted);
       background:transparent; border:1px solid transparent; border-bottom:none;
       border-radius:var(--radius) var(--radius) 0 0; cursor:pointer;
       position:relative; top:1px; margin-bottom:-1px; transition:color 0.12s, background 0.12s; }
.tab:not(.active):hover { background:rgba(255,255,255,0.04); color:var(--text); }
.tab.active { background:rgba(255,255,255,0.02); border-color:var(--stroke);
              border-bottom-color:rgba(255,255,255,0.02); color:var(--text); z-index:1; }
.tab-bar .icon-btn { width:22px; height:22px; font-size:11px; border-radius:6px; }
.tab-bar-controls { display:flex; gap:4px; align-items:center; margin-left:auto; padding:0 0 0 8px; }
.tab-panes { flex:1; min-height:0; position:relative; }
.tab-content { position:absolute; top:0; left:0; right:0; bottom:0;
               visibility:hidden; display:flex; flex-direction:column; }
.tab-content.active { visibility:visible; }
.stats-grid { display:grid; grid-template-columns:1fr 1fr; grid-template-rows:1fr 1fr;
              flex:1; gap:0; min-height:0; }
.stats-cell { display:flex; flex-direction:column; min-height:0; border:1px solid var(--stroke);
              margin:-0.5px; overflow:hidden; }
.stats-cell:first-child { border-radius:0; }
.stats-select { flex-shrink:0; width:100%; padding:3px 6px; font-size:10px;
                background:rgba(10,12,30,0.6); color:var(--muted); border:none;
                border-bottom:1px solid var(--stroke); cursor:pointer;
                font-family:inherit; letter-spacing:0.5px; outline:none; }
.stats-select:focus { color:var(--text); }
.stats-canvas { flex:1; width:100%; min-height:0; background:var(--panel); }
#roots-container { position: relative; flex: 1; min-height: 0; }
#domain-canvas { position: absolute; top: 0; left: 0; border-radius: 0; }
#roots-panel.domain-active { background: transparent !important; }
circle.coeff.selected, circle.root.selected {
    stroke: #fff; stroke-width: 3;
    filter: drop-shadow(0 0 4px var(--accent)) drop-shadow(0 0 10px var(--accent)) drop-shadow(0 0 18px rgba(233,69,96,0.4));
    animation: sel-pulse 1.2s ease-in-out infinite alternate;
}
@keyframes sel-pulse {
    from { filter: drop-shadow(0 0 4px var(--accent)) drop-shadow(0 0 10px var(--accent)) drop-shadow(0 0 18px rgba(233,69,96,0.4)); }
    to   { filter: drop-shadow(0 0 6px var(--accent)) drop-shadow(0 0 14px var(--accent)) drop-shadow(0 0 24px rgba(233,69,96,0.5)); }
}
.sel-rect {
    fill: rgba(233,69,96,0.12); stroke: rgba(233,69,96,0.65);
    stroke-width: 1.5; stroke-dasharray: 4 3; pointer-events: none;
}
#coeff-container { position: relative; flex: 1; min-height: 0; }
/* --- Anim bar --- */
#anim-bar {
    position: absolute; top: 8px; left: 8px; right: 8px; z-index: 10;
    display: none; padding: 8px 12px;
    background: rgba(15, 16, 38, 0.88);
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
    border: 1px solid var(--stroke);
    border-radius: var(--radius);
}
#anim-bar.active { display: grid; grid-template-columns: 1fr; gap: 6px; }
.bar-row { display: flex; align-items: center; justify-content: center; gap: 8px; flex-wrap: wrap; }
#anim-bar .bar-title { font-weight: bold; color: var(--accent); font-size: 13px; }
#anim-bar label { font-size: 11px; display: flex; align-items: center; gap: 4px; cursor: pointer; color: var(--muted); }
#anim-bar select {
    background: rgba(255,255,255,0.04); color: var(--text);
    border: 1px solid var(--stroke); border-radius: 6px;
    padding: 2px 6px; font-size: 11px;
}
#anim-bar input[type="range"] { width: 70px; accent-color: var(--accent); }
#anim-bar .bar-val { color: var(--accent); min-width: 24px; text-align: right; font-size: 11px; }
#play-btn {
    background: var(--accent); color: #fff; border: none; border-radius: 6px;
    padding: 4px 12px; font-size: 11px; cursor: pointer; font-weight: 500;
    transition: background 0.12s;
}
#play-btn:hover { background: var(--accent-hover); }
#trails-btn {
    background: transparent; color: var(--muted); border: 1px solid var(--stroke); border-radius: 6px;
    padding: 4px 10px; font-size: 11px; cursor: pointer; transition: all 0.12s;
}
#trails-btn.active { background: var(--accent-dim); color: #fff; border-color: var(--accent-border); }
#trails-btn:hover:not(.active) { color: var(--text); border-color: var(--stroke2); }
#sel2path-btn {
    background: transparent; color: var(--accent); border: 1px solid var(--accent-border); border-radius: 6px;
    padding: 4px 10px; font-size: 11px; cursor: pointer; font-weight: 600; transition: all 0.12s;
}
#sel2path-btn:hover { background: var(--accent); color: #fff; }
#sel2path-btn:disabled { opacity: 0.3; cursor: default; background: transparent; color: var(--accent); }
#path-nav { display: flex; align-items: center; gap: 4px; }
.path-nav-btn {
    background: transparent; color: var(--muted); border: 1px solid var(--stroke); border-radius: 5px;
    width: 22px; height: 22px; font-size: 10px; cursor: pointer; padding: 0;
    display: flex; align-items: center; justify-content: center; transition: all 0.12s;
}
.path-nav-btn:hover { color: #fff; border-color: var(--stroke2); }
#path-label { font-size: 11px; color: var(--muted); min-width: 56px; text-align: center; }
#ccw-btn {
    background: transparent; color: var(--muted); border: 1px solid var(--stroke); border-radius: 6px;
    padding: 3px 8px; font-size: 10px; cursor: pointer; transition: all 0.12s; min-width: 28px;
}
#ccw-btn.active { background: rgba(91,106,191,0.20); color: #fff; border-color: rgba(91,106,191,0.55); }
#del-path-btn {
    background: transparent; color: var(--muted); border: 1px solid var(--stroke); border-radius: 6px;
    width: 22px; height: 22px; font-size: 14px; cursor: pointer; padding: 0;
    display: flex; align-items: center; justify-content: center; transition: all 0.12s;
}
#del-path-btn:hover { color: var(--accent); border-color: var(--accent-border); }
.trail-path { fill: none; stroke-width: 1.5; opacity: 0.6; stroke-linecap: round; stroke-linejoin: round; }
.tooltip {
    position: absolute; background: rgba(10,12,30,0.75); color: var(--text);
    padding: 5px 10px; border-radius: 8px; font-size: 12px; pointer-events: none;
    display: none; white-space: nowrap;
    border: 1px solid var(--stroke);
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
}
</style>
</head>
<body>

<div id="header">
    <span class="app-title">PolyPaint</span>
    <div class="header-sep"></div>
    <span class="control-label">Degree</span>
    <span id="degree-number" class="degree-val">5</span>
    <select id="pattern">
            <optgroup label="Basic">
                <option value="circle">Circle</option>
                <option value="real">Real axis</option>
                <option value="imag">Imaginary axis</option>
                <option value="grid">Grid</option>
                <option value="random">Random</option>
            </optgroup>
            <optgroup label="Coeff patterns">
                <option value="spiral">Spiral</option>
                <option value="star">Star</option>
                <option value="lemniscate">Figure-8</option>
                <option value="conjugate">Conjugate pairs</option>
                <option value="two-clusters">Two clusters</option>
                <option value="geometric">Geometric decay</option>
                <option value="rose">Rose curve</option>
                <option value="cardioid">Cardioid</option>
            </optgroup>
            <optgroup label="Roots shapes">
                <option value="r-heart">Heart</option>
                <option value="r-circle">Circle</option>
                <option value="r-star">Star</option>
                <option value="r-spiral">Spiral</option>
                <option value="r-cross">Cross</option>
                <option value="r-diamond">Diamond</option>
                <option value="r-grid">Chessboard</option>
                <option value="r-smiley">Smiley</option>
                <option value="r-figure8">Figure-8</option>
                <option value="r-butterfly">Butterfly</option>
                <option value="r-trefoil">Trefoil</option>
                <option value="r-polygon">Polygon</option>
                <option value="r-infinity">Infinity</option>
            </optgroup>
    </select>
    <div class="header-sep"></div>
    <button id="reset-btn" class="icon-btn" title="Reset to initial state">‚Ü∫</button>
</div>
<div id="content">
    <div id="sidebar">
        <div class="side-group">
            <div class="side-label">View</div>
            <button id="domain-toggle-btn" class="side-btn" title="Domain coloring">‚óê</button>
            <button id="root-color-btn" class="side-btn active" title="Color roots">üé®</button>
            <button id="base-toggle-btn" class="side-btn" title="Base (drone)">B</button>
            <button id="melody-toggle-btn" class="side-btn" title="Melody (arpeggio)">M</button>
            <button id="voice-toggle-btn" class="side-btn" title="Voice (beeps)">V</button>
        </div>
        <div class="side-group">
            <div class="side-label">Tools</div>
            <button id="deselect-btn" class="side-btn" title="Deselect all (Esc)">‚úï</button>
            <button id="select-all-btn" class="side-btn" title="Select all coefficients">‚äï</button>
            <button id="coeff-picker-btn" class="side-btn" title="Coefficient picker">‚ò∞</button>
            <button id="snap-btn" class="side-btn" title="Export snapshot">‚¨á</button>
        </div>
        <div class="side-group ops disabled" id="ops-group">
            <div class="side-label">Ops <span id="ops-target"></span></div>
            <button id="scale-tool-btn" class="side-btn" title="Scale">‚áï</button>
            <button id="rotate-tool-btn" class="side-btn" title="Rotate">‚ü≤</button>
            <button id="add-tool-btn" class="side-btn" title="Translate">‚úõ</button>
        </div>
    </div>
    <div id="main">
        <div id="panels">
    <div class="panel">
        <h3><span>Coefficients <span id="coeff-sel-count" style="font-size:9px;color:#5ddb6a;opacity:0.85;"></span></span><button id="select-all-coeffs-btn" class="icon-btn" title="Select all">‚äï</button></h3>
        <div id="coeff-container">
            <svg id="coeff-panel"></svg>
            <div id="anim-bar">
                <div class="bar-row">
                    <button id="sel2path-btn">Sel‚ÜíPath</button>
                    <div id="path-nav">
                        <button id="path-prev" class="path-nav-btn">‚óÄ</button>
                        <span id="path-label">Path 1/1</span>
                        <button id="path-next" class="path-nav-btn">‚ñ∂</button>
                    </div>
                    <span class="bar-title" id="bar-title">c‚ÇÄ</span>
                    <label>
                        <select id="anim-path">
                            <option value="none">None</option>
                            <optgroup label="Basic">
                                <option value="circle">Circle</option>
                                <option value="horizontal">Horizontal</option>
                                <option value="vertical">Vertical</option>
                                <option value="spiral">Spiral</option>
                                <option value="random">Random walk</option>
                            </optgroup>
                            <optgroup label="Curves">
                                <option value="lissajous">Lissajous (3:2)</option>
                                <option value="figure8">Figure-8</option>
                                <option value="cardioid">Cardioid</option>
                                <option value="astroid">Astroid</option>
                                <option value="deltoid">Deltoid</option>
                                <option value="rose">Rose (3-petal)</option>
                                <option value="epitrochoid">Spirograph</option>
                                <option value="hypotrochoid">Hypotrochoid</option>
                                <option value="butterfly">Butterfly</option>
                                <option value="star">Star (pentagram)</option>
                                <option value="square">Square</option>
                            </optgroup>
                            <optgroup label="Space-filling">
                                <option value="hilbert">Hilbert (Moore)</option>
                                <option value="peano">Peano</option>
                                <option value="sierpinski">Sierpinski</option>
                            </optgroup>
                        </select>
                    </label>
                    <button id="ccw-btn">CW</button>
                    <button id="del-path-btn">√ó</button>
                </div>
                <div class="bar-row">
                    <label>R: <input type="range" id="anim-radius" min="1" max="100" step="1" value="25"> <span class="bar-val" id="anim-radius-val">25%</span></label>
                    <label>S: <input type="range" id="anim-speed" min="0.01" max="1.0" step="0.01" value="1.0"> <span class="bar-val" id="anim-speed-val">1.0</span></label>
                    <label>A: <input type="range" id="anim-angle" min="0" max="1.0" step="0.01" value="0"> <span class="bar-val" id="anim-angle-val">0.00</span></label>
                    <button id="play-btn">‚ñ∂ Play</button>
                    <button id="home-btn" title="Return to start position">‚åÇ Home</button>
                    <button id="trails-btn">Trails</button>
                </div>
            </div>
        </div>
    </div>
    <div class="panel">
        <div class="tab-bar">
            <button class="tab active" data-tab="roots">Roots <span id="roots-sel-count" style="font-size:9px;color:#e94560;opacity:0.85;"></span></button>
            <button class="tab" data-tab="stats">Stats</button>
            <span class="tab-bar-controls">
                <select id="rec-mode" title="Recording mode" style="font-size:10px;padding:1px 2px;background:rgba(255,255,255,0.06);color:var(--muted);border:1px solid var(--stroke);border-radius:4px;cursor:pointer;"><option value="roots">Roots</option><option value="coeffs">Coeffs</option><option value="both">Both</option></select>
                <button id="rec-roots-btn" class="icon-btn" title="Record (webm)">‚è∫</button>
                <button id="stop-roots-btn" class="icon-btn" title="Stop recording" style="display:none;">‚èπ</button>
            </span>
        </div>
        <div class="tab-panes">
            <div id="roots-content" class="tab-content active">
                <div id="roots-container">
                    <canvas id="domain-canvas"></canvas>
                    <svg id="roots-panel"></svg>
                </div>
            </div>
            <div id="stats-content" class="tab-content">
                <div class="stats-grid">
                    <div class="stats-cell"><select class="stats-select" data-plot="0"></select><canvas class="stats-canvas" data-plot="0"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="1"></select><canvas class="stats-canvas" data-plot="1"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="2"></select><canvas class="stats-canvas" data-plot="2"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="3"></select><canvas class="stats-canvas" data-plot="3"></canvas></div>
                </div>
            </div>
        </div>
    </div>
</div>
    </div>
</div>

<div class="tooltip" id="tooltip"></div>
<div id="ops-pop" class="ops-pop"></div>
<div id="degree-pop" class="ops-pop"></div>
<div id="audio-pop" class="ops-pop" style="min-width:220px"></div>
<div id="color-pop" class="ops-pop" style="min-width:160px"></div>
<div id="coeff-pick-pop" class="ops-pop" style="min-width:240px"></div>

<script>
const MIN_RANGE = 1.5;
const MARGIN = 30;
const RANGE_PAD = 1.3; // 30% padding around data

// Compute panel size from available space
function getPanelSize() {
    const header = document.getElementById("header");
    const sidebar = document.getElementById("sidebar");
    const sidebarW = sidebar ? sidebar.offsetWidth : 0;
    const availH = window.innerHeight - header.offsetHeight - 50;
    const availW = (window.innerWidth - sidebarW - 16 * 3) / 2;
    return Math.max(200, Math.floor(Math.min(availW, availH)));
}

let S = getPanelSize();

// Per-panel state
const panels = {
    coeff: { range: 3, xScale: null, yScale: null, gridG: null, axisG: null, labelRe: null, labelIm: null, unitCircle: null },
    roots: { range: 3, xScale: null, yScale: null, gridG: null, axisG: null, labelRe: null, labelIm: null, unitCircle: null }
};

function makeScales(range) {
    return {
        x: d3.scaleLinear().domain([-range, range]).range([MARGIN, S - MARGIN]),
        y: d3.scaleLinear().domain([-range, range]).range([S - MARGIN, MARGIN])
    };
}

function initPanelScales(p) {
    const s = makeScales(p.range);
    p.xScale = s.x;
    p.yScale = s.y;
}
initPanelScales(panels.coeff);
initPanelScales(panels.roots);

// Convenience aliases (updated when range changes)
function cxs() { return panels.coeff.xScale; }
function cys() { return panels.coeff.yScale; }
function rxs() { return panels.roots.xScale; }
function rys() { return panels.roots.yScale; }

let coefficients = [];
let currentRoots = []; // persistent root data for dragging
let pendingSolve = false;

// Selection & animation state
const selectedCoeffs = new Set(); // indices into coefficients[]
const selectedRoots = new Set();  // indices into currentRoots[]
const animState = { playing: false, startTime: 0, rafId: null, elapsedAtPause: null };
let animPaths = [];    // array of { id, coeffs: Set, pathType, radius, speed, ccw, angle }
let nextPathId = 1;
let viewedPathIdx = 0; // index into animPaths for UI navigation
// Trail state
let trailsEnabled = false;
let trailData = []; // array of arrays: trailData[i] = [{re, im}, ...] for root i
let trailComplete = false; // true once one full loop is detected
const MAX_TRAIL_POINTS = 4000;
const TRAIL_MIN_POINTS = 30; // minimum points before checking for loop closure
// Domain coloring state
let domainColoringEnabled = false;
let rootColorMode = "rainbow";  // "none" | "rainbow" | "derivative"
let rootSensitivities = null;   // Float64Array for derivative mode
let domainCanvas = document.getElementById("domain-canvas");
let domainCtx = domainCanvas.getContext("2d");
let domainPendingRender = false;
const DOMAIN_RES_SCALE = 0.5; // render at half resolution for performance
// Stats tab state
let activeTab = "roots";
const STAT_TYPES = ["Force", "Speed", "MinDist", "MaxDist"];
const STAT_COLORS = { Force: "#e94560", Speed: "#5b6abf", MinDist: "#2ecc71", MaxDist: "#f39c12" };
const statsState = {
    buffers: {},        // { statName: Float64Array ring buffer }
    frameCount: 0,
    writeIdx: 0,
    maxFrames: 4000,
    prevRoots: null,    // for Speed computation
    plotConfigs: [0, 1, 2, 3], // index into STAT_TYPES for each of the 4 plots
    canvases: [],       // 4 canvas elements
    ctxs: [],           // 4 canvas 2D contexts
    dirty: true
};
// Audio sonification state
let baseEnabled = false;
let melodyEnabled = false;
let voiceEnabled = false;
function anySoundEnabled() { return baseEnabled || melodyEnabled || voiceEnabled; }
let audioCtx = null;
let audioNodes = null;
let prevRootsAudio = null;
let smoothE = 0, smoothR = 0, smoothSpread = 0, smoothCoherence = 0;
let lastBeepTime = 0;
let lastAudioUpdateTime = 0;
let audioWatchdogId = null;
let closeEncounters = null;  // Float64Array(n * TOP_K): per-root closest distances seen
let encounterAge = null;     // Float64Array(n * TOP_K): frames since each record was set
let arpPhase = 0;
let arpSmoothVel = 0;
const AUDIO_ALPHA = 0.1;
const ARP_SCALE = [0, 2, 4, 7, 9]; // pentatonic
const ENCOUNTER_TOP_K = 3;         // track top 3 records per root (non-tunable)

// Tunable config objects (sliders modify these in real time)
const baseConfig = {
    freq: 85, octaves: 1.8,
    modRatio: 2.0, modDepth: 300,
    filterLo: 250, filterHi: 3500,
    gainFloor: 0.03, gainRange: 0.22,
    vibDepth: 10, vibRate: 6.0,
};
const melodyConfig = {
    rate: 5, peak: 0.12, cutoff: 5,
    attack: 0.004, decay: 0.064,
    filterLo: 1200, filterHi: 3800,
};
const voiceConfig = {
    decay: 1.001, novelty: 0.85, cooldown: 0.01,
    peak: 0.12, attack: 0.005, ringdown: 0.08,
};

function audioClamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
function frac01(x) { x = x % 1; return x < 0 ? x + 1 : x; }
function quantizeToScale(semi) {
    const oct = Math.floor(semi / 12);
    const inOct = semi - 12 * oct;
    let best = ARP_SCALE[0], bestD = 1e9;
    for (const s of ARP_SCALE) {
        const d = Math.abs(inOct - s);
        if (d < bestD) { bestD = d; best = s; }
    }
    return 12 * oct + best;
}
function midiToHz(m) { return 440 * Math.pow(2, (m - 69) / 12); }
function percentileSorted(sorted, q) {
    const n = sorted.length;
    if (n === 0) return 0;
    const idx = (n - 1) * q;
    const lo = Math.floor(idx), hi = Math.ceil(idx);
    return sorted[lo] * (1 - (idx - lo)) + sorted[hi] * (idx - lo);
}

// --- Audio config popover helpers ---
let activeAudioBtn = null;
let audioDragMove = null;
let audioDragUp = null;

function buildAudioSlider(parent, label, min, max, value, logScale, fmt, onChange) {
    const row = document.createElement("div");
    row.className = "audio-row";
    const lbl = document.createElement("span");
    lbl.className = "row-label"; lbl.textContent = label;
    const slider = document.createElement("div");
    slider.className = "hslider";
    const thumb = document.createElement("div");
    thumb.className = "hslider-thumb";
    slider.appendChild(thumb);
    const val = document.createElement("span");
    val.className = "row-val";

    function valToU(v) {
        if (logScale) return (Math.log(v) - Math.log(min)) / (Math.log(max) - Math.log(min));
        return (v - min) / (max - min);
    }
    function uToVal(u) {
        if (logScale) return Math.exp(Math.log(min) + u * (Math.log(max) - Math.log(min)));
        return min + u * (max - min);
    }

    let u = Math.max(0, Math.min(1, valToU(value)));
    function update() {
        thumb.style.left = (u * 100) + "%";
        const v = uToVal(u);
        val.textContent = fmt(v);
        onChange(v);
    }
    function setFromX(clientX) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        update();
    }
    let dragging = false;
    slider.addEventListener("mousedown", e => { dragging = true; setFromX(e.clientX); e.preventDefault(); });
    const moveFn = e => { if (dragging) setFromX(e.clientX); };
    const upFn = () => { dragging = false; };
    slider.addEventListener("mousemove", moveFn);
    window.addEventListener("mousemove", moveFn);
    window.addEventListener("mouseup", upFn);

    update();
    row.appendChild(lbl);
    row.appendChild(slider);
    row.appendChild(val);
    parent.appendChild(row);
    return { row, setU: newU => { u = newU; update(); } };
}

function buildAudioToggle(parent, label, isOn, onChange) {
    const row = document.createElement("div");
    row.className = "audio-toggle" + (isOn ? " on" : "");
    const dot = document.createElement("span");
    dot.className = "toggle-dot";
    const lbl = document.createElement("span");
    lbl.className = "toggle-label"; lbl.textContent = label;
    row.appendChild(dot);
    row.appendChild(lbl);
    row.addEventListener("click", () => {
        const nowOn = !row.classList.contains("on");
        row.classList.toggle("on", nowOn);
        onChange(nowOn);
    });
    parent.appendChild(row);
    return row;
}

function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0;
    masterGain.connect(audioCtx.destination);
    // Tap audio graph for recording (MediaStreamDestination)
    const mediaDest = audioCtx.createMediaStreamDestination();
    masterGain.connect(mediaDest);
    // FM synthesis: carrier (osc1) + modulator (osc2) ‚Üí modGain ‚Üí carrier.frequency
    const osc1 = audioCtx.createOscillator();   // carrier
    osc1.type = "sine";
    osc1.frequency.value = 110;
    const osc2 = audioCtx.createOscillator();   // FM modulator
    osc2.type = "sine";
    osc2.frequency.value = 220;
    const modGain = audioCtx.createGain();       // FM depth (Hz)
    modGain.gain.value = 0;
    osc2.connect(modGain);
    modGain.connect(osc1.frequency);
    const filter = audioCtx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 800;
    filter.Q.value = 2;
    const gainNode = audioCtx.createGain();
    gainNode.gain.value = 0.06;
    const lfo = audioCtx.createOscillator();
    lfo.type = "sine";
    lfo.frequency.value = 5;
    const lfoGain = audioCtx.createGain();
    lfoGain.gain.value = 0;
    lfo.connect(lfoGain);
    lfoGain.connect(osc1.frequency);
    const beepOsc = audioCtx.createOscillator();
    beepOsc.type = "sine";
    beepOsc.frequency.value = 800;
    const beepGain = audioCtx.createGain();
    beepGain.gain.value = 0;
    osc1.connect(gainNode);  // carrier ‚Üí gain ‚Üí filter (osc2 routes to osc1.frequency via modGain)
    gainNode.connect(filter);
    filter.connect(masterGain);
    beepOsc.connect(beepGain);
    beepGain.connect(masterGain);
    // Arpeggiator oscillator
    const arpOsc = audioCtx.createOscillator();
    arpOsc.type = "triangle";
    arpOsc.frequency.value = 440;
    const arpGain = audioCtx.createGain();
    arpGain.gain.value = 0;
    const arpFilter = audioCtx.createBiquadFilter();
    arpFilter.type = "lowpass";
    arpFilter.frequency.value = 2500;
    arpFilter.Q.value = 0.7;
    arpOsc.connect(arpGain);
    arpGain.connect(arpFilter);
    arpFilter.connect(masterGain);
    osc1.start();
    osc2.start();
    lfo.start();
    beepOsc.start();
    arpOsc.start();
    audioNodes = { osc1, osc2, modGain, lfo, lfoGain, filter, gainNode, masterGain, beepOsc, beepGain, arpOsc, arpGain, arpFilter, mediaDest };
}

function updateAudio() {
    if (!anySoundEnabled() || !audioCtx || !audioNodes) return;
    const n = currentRoots.length;
    if (n === 0) return;
    const range = panels.roots.range;
    const now = audioCtx.currentTime;
    audioNodes.masterGain.gain.setTargetAtTime(1, now, 0.05);

    // --- Centroid ---
    let cx = 0, cy = 0;
    for (const r of currentRoots) { cx += r.re; cy += r.im; }
    cx /= n; cy /= n;

    // --- Dual energy: E_med (stability) and E_hi (excitement) ---
    let eMed = 0, eHi = 0;
    if (prevRootsAudio && prevRootsAudio.length === n) {
        const v = new Array(n);
        for (let i = 0; i < n; i++) {
            v[i] = Math.hypot(
                currentRoots[i].re - prevRootsAudio[i].re,
                currentRoots[i].im - prevRootsAudio[i].im
            );
        }
        v.sort((a, b) => a - b);
        eMed = percentileSorted(v, 0.50);
        eHi  = percentileSorted(v, 0.85);
    }

    // --- Radius distribution around centroid ---
    const radii = new Array(n);
    for (let i = 0; i < n; i++) {
        radii[i] = Math.hypot(currentRoots[i].re - cx, currentRoots[i].im - cy);
    }
    radii.sort((a, b) => a - b);
    const r50 = percentileSorted(radii, 0.50);
    const r10 = percentileSorted(radii, 0.10);
    const r90 = percentileSorted(radii, 0.90);
    const spread = r90 - r10;

    // --- Angular coherence R in [0,1] ---
    let au = 0, av = 0;
    for (let i = 0; i < n; i++) {
        const th = Math.atan2(currentRoots[i].im - cy, currentRoots[i].re - cx);
        au += Math.cos(th);
        av += Math.sin(th);
    }
    au /= n; av /= n;
    const coherence = Math.hypot(au, av); // 1 = clustered, 0 = uniform ring

    // --- Normalize and smooth ---
    const eNormMed = audioClamp(eMed / (range * 0.05), 0, 1);
    const eNormHi  = audioClamp(eHi  / (range * 0.05), 0, 1);
    const rNorm    = audioClamp(r50 / range, 0, 1);
    const sNorm    = audioClamp(spread / range, 0, 1);

    smoothE       += AUDIO_ALPHA * (eNormHi - smoothE);
    smoothR       += AUDIO_ALPHA * (rNorm - smoothR);
    smoothSpread  += AUDIO_ALPHA * (sNorm - smoothSpread);
    smoothCoherence += AUDIO_ALPHA * (coherence - smoothCoherence);

    // --- Base (FM drone): carrier pitch, modulator ratio + depth, filter, gain, vibrato ---
    if (baseEnabled) {
        const pitch = baseConfig.freq * Math.pow(2, (smoothR - 0.5) * baseConfig.octaves);
        audioNodes.osc1.frequency.setTargetAtTime(pitch, now, 0.05);
        // FM modulator: frequency tracks carrier √ó ratio, depth driven by energy
        audioNodes.osc2.frequency.setTargetAtTime(pitch * baseConfig.modRatio, now, 0.05);
        const fmDepth = baseConfig.modDepth * smoothE;
        audioNodes.modGain.gain.setTargetAtTime(fmDepth, now, 0.05);
        const cutoff = baseConfig.filterLo + baseConfig.filterHi * smoothSpread + 1500 * eNormMed;
        audioNodes.filter.frequency.setTargetAtTime(audioClamp(cutoff, 150, 8000), now, 0.05);
        const gain = baseConfig.gainFloor + baseConfig.gainRange * smoothE;
        audioNodes.gainNode.gain.setTargetAtTime(gain, now, 0.05);
        const vibDepthHz = 2 + baseConfig.vibDepth * smoothCoherence;
        audioNodes.lfoGain.gain.setTargetAtTime(vibDepthHz, now, 0.05);
        audioNodes.lfo.frequency.setTargetAtTime(1.5 + baseConfig.vibRate * eNormMed, now, 0.05);
    } else {
        audioNodes.gainNode.gain.setTargetAtTime(0, now, 0.05);
        audioNodes.lfoGain.gain.setTargetAtTime(0, now, 0.05);
        audioNodes.modGain.gain.setTargetAtTime(0, now, 0.05);
    }

    // --- Voice (beeps): close encounters per-root record tracking ---
    if (voiceEnabled) {
        let seeding = false;
        if (!closeEncounters || closeEncounters.length !== n * ENCOUNTER_TOP_K) {
            closeEncounters = new Float64Array(n * ENCOUNTER_TOP_K).fill(Infinity);
            encounterAge = new Float64Array(n * ENCOUNTER_TOP_K).fill(0);
            seeding = true;
        }

        let bestImprovement = 0;
        let bestRoot = -1;

        for (let i = 0; i < n; i++) {
            const closest = [Infinity, Infinity, Infinity];
            for (let j = 0; j < n; j++) {
                if (j === i) continue;
                const d = Math.hypot(currentRoots[i].re - currentRoots[j].re,
                                     currentRoots[i].im - currentRoots[j].im);
                if (d < closest[2]) {
                    closest[2] = d;
                    if (closest[2] < closest[1]) { const t = closest[1]; closest[1] = closest[2]; closest[2] = t; }
                    if (closest[1] < closest[0]) { const t = closest[0]; closest[0] = closest[1]; closest[1] = t; }
                }
            }

            const base = i * ENCOUNTER_TOP_K;
            if (seeding) {
                for (let k = 0; k < ENCOUNTER_TOP_K; k++) {
                    closeEncounters[base + k] = closest[k];
                    encounterAge[base + k] = 0;
                }
            } else {
                for (let k = 0; k < ENCOUNTER_TOP_K; k++) {
                    const worstIdx = base + ENCOUNTER_TOP_K - 1;
                    if (closest[k] < closeEncounters[worstIdx]) {
                        const improvement = closeEncounters[worstIdx] - closest[k];
                        closeEncounters[worstIdx] = closest[k] * voiceConfig.novelty;
                        encounterAge[worstIdx] = 0;
                        for (let a = ENCOUNTER_TOP_K - 1; a > 0; a--) {
                            if (closeEncounters[base + a] < closeEncounters[base + a - 1]) {
                                const td = closeEncounters[base + a]; closeEncounters[base + a] = closeEncounters[base + a - 1]; closeEncounters[base + a - 1] = td;
                                const ta = encounterAge[base + a]; encounterAge[base + a] = encounterAge[base + a - 1]; encounterAge[base + a - 1] = ta;
                            }
                        }
                        if (improvement > bestImprovement) {
                            bestImprovement = improvement;
                            bestRoot = i;
                        }
                    }
                }
            }
        }

        if (bestRoot >= 0 && now - lastBeepTime > voiceConfig.cooldown) {
            lastBeepTime = now;
            const midi = 60 + ARP_SCALE[bestRoot % 5] + 12 * Math.floor(bestRoot / 5);
            const freq = midiToHz(Math.min(midi, 96));
            const improvNorm = audioClamp(bestImprovement / (range * 0.05), 0, 1);
            const peak = 0.05 + voiceConfig.peak * improvNorm;

            audioNodes.beepOsc.frequency.setTargetAtTime(freq, now, 0.01);
            audioNodes.beepGain.gain.cancelScheduledValues(now);
            audioNodes.beepGain.gain.setValueAtTime(0.0001, now);
            audioNodes.beepGain.gain.exponentialRampToValueAtTime(peak, now + voiceConfig.attack);
            audioNodes.beepGain.gain.exponentialRampToValueAtTime(0.0001, now + voiceConfig.attack + voiceConfig.ringdown);
        }

        if (!seeding) {
            for (let k = 0; k < closeEncounters.length; k++) {
                closeEncounters[k] *= voiceConfig.decay;
                encounterAge[k]++;
            }
        }
    }

    // --- Melody (arpeggiator): one note per step, cycling through top-N fastest roots ---
    if (melodyEnabled && audioNodes.arpOsc && audioNodes.arpGain) {
        const tNow = performance.now();
        const dt = lastAudioUpdateTime ? Math.max(0.001, Math.min((tNow - lastAudioUpdateTime) / 1000, 0.05)) : 1 / 60;

        // Build per-root velocity array and sort indices by speed (descending)
        const vels = new Array(n);
        for (let i = 0; i < n; i++) {
            if (prevRootsAudio && prevRootsAudio.length === n) {
                vels[i] = Math.hypot(currentRoots[i].re - prevRootsAudio[i].re,
                                     currentRoots[i].im - prevRootsAudio[i].im);
            } else {
                vels[i] = 0;
            }
        }
        const indices = Array.from({ length: n }, (_, i) => i);
        indices.sort((a, b) => vels[b] - vels[a]);

        // cutoff: top N fastest roots to arpeggio (clamped to [2, n])
        const N = Math.min(Math.max(Math.round(melodyConfig.cutoff), 2), n);

        const prevArpStep = Math.floor(arpPhase);
        arpPhase += melodyConfig.rate * dt;
        const rank = Math.floor(arpPhase) % N;
        const rootIdx = indices[rank];
        const rk = currentRoots[rootIdx];

        // angle ‚Üí scale degree (pentatonic)
        const theta = Math.atan2(rk.im - cy, rk.re - cx);
        const u = frac01((theta + Math.PI) / (2 * Math.PI));
        const degree = Math.floor(u * 12);
        const qSemi = quantizeToScale(degree);

        // radius ‚Üí octave (0‚Äì2, 3 octaves)
        const rad = Math.hypot(rk.re - cx, rk.im - cy);
        const radNorm = audioClamp(rad / (range * 1.2), 0, 1);
        const octave = Math.floor(radNorm * 3);

        const baseMidi = 48; // C3
        const hz = midiToHz(baseMidi + qSemi + 12 * octave);

        // velocity of this root ‚Üí filter brightness
        const velNorm = audioClamp(vels[rootIdx] / (range * 0.03), 0, 1);
        arpSmoothVel = arpSmoothVel * 0.85 + velNorm * 0.15;

        audioNodes.arpOsc.frequency.setTargetAtTime(hz, now, 0.01);
        audioNodes.arpFilter.frequency.setTargetAtTime(melodyConfig.filterLo + melodyConfig.filterHi * arpSmoothVel, now, 0.02);

        // pluck envelope on new step ‚Äî volume scales with rank (fastest = loudest)
        const curArpStep = Math.floor(arpPhase);
        if (curArpStep !== prevArpStep) {
            const rankScale = 1 - rank / N;  // 1.0 for rank 0 (fastest), ~0 for rank N-1
            const peak = (0.02 + melodyConfig.peak * arpSmoothVel) * rankScale;
            const g = audioNodes.arpGain.gain;
            g.cancelScheduledValues(now);
            g.setValueAtTime(0.0001, now);
            g.exponentialRampToValueAtTime(Math.max(peak, 0.0001), now + melodyConfig.attack);
            g.exponentialRampToValueAtTime(0.0001, now + melodyConfig.attack + melodyConfig.decay);
        }
    }
    // Save state for next frame
    prevRootsAudio = currentRoots.map(r => ({ re: r.re, im: r.im }));
    lastAudioUpdateTime = performance.now();
}

function audioWatchdog() {
    if (!anySoundEnabled() || !audioNodes || !audioCtx) return;
    if (performance.now() - lastAudioUpdateTime > 150) {
        audioNodes.masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.15);
    }
}

function resetAudioState() {
    prevRootsAudio = null;
    closeEncounters = null;
    encounterAge = null;
    arpPhase = 0;
    arpSmoothVel = 0;
    smoothE = 0; smoothR = 0; smoothSpread = 0; smoothCoherence = 0;
    if (audioNodes && audioCtx) {
        audioNodes.masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.08);
    }
}

// --- Compute range needed to fit data ---

function computeRange(points) {
    // points: array of {re, im} or [re, im]
    let maxAbs = MIN_RANGE;
    for (const p of points) {
        const re = Array.isArray(p) ? p[0] : p.re;
        const im = Array.isArray(p) ? p[1] : p.im;
        if (isFinite(re)) maxAbs = Math.max(maxAbs, Math.abs(re));
        if (isFinite(im)) maxAbs = Math.max(maxAbs, Math.abs(im));
    }
    // Round up to a nice number and add padding
    return Math.ceil(maxAbs * RANGE_PAD * 2) / 2;
}

// --- SVG setup / grid redraw ---

function drawGrid(svgSel, p) {
    const xs = p.xScale, ys = p.yScale, range = p.range;

    // Clear old grid elements
    if (p.gridG) p.gridG.remove();
    if (p.axisG) p.axisG.remove();
    if (p.labelRe) p.labelRe.remove();
    if (p.labelIm) p.labelIm.remove();
    if (p.unitCircle) p.unitCircle.remove();

    // Grid lines at integers
    p.gridG = svgSel.insert("g", ":first-child").attr("class", "grid");
    const intMax = Math.floor(range);
    for (let v = -intMax; v <= intMax; v++) {
        p.gridG.append("line")
            .attr("x1", xs(v)).attr("y1", ys(-range))
            .attr("x2", xs(v)).attr("y2", ys(range));
        p.gridG.append("line")
            .attr("x1", xs(-range)).attr("y1", ys(v))
            .attr("x2", xs(range)).attr("y2", ys(v));
    }

    // Axes
    p.axisG = svgSel.insert("g", ":first-child").attr("class", "axis");
    p.axisG.append("line")
        .attr("x1", xs(-range)).attr("y1", ys(0))
        .attr("x2", xs(range)).attr("y2", ys(0));
    p.axisG.append("line")
        .attr("x1", xs(0)).attr("y1", ys(-range))
        .attr("x2", xs(0)).attr("y2", ys(range));

    // Axis labels
    p.labelRe = svgSel.append("text").attr("x", S - MARGIN + 4).attr("y", ys(0) + 4)
        .attr("fill", "#556").attr("font-size", 11).text("Re");
    p.labelIm = svgSel.append("text").attr("x", xs(0) + 6).attr("y", MARGIN - 4)
        .attr("fill", "#556").attr("font-size", 11).text("Im");

    // Unit circle
    const r = Math.abs(xs(1) - xs(0));
    p.unitCircle = svgSel.append("circle").attr("class", "unit-circle")
        .attr("cx", xs(0)).attr("cy", ys(0)).attr("r", r);
}

function setupPanel(svgSel, p) {
    svgSel.attr("width", S).attr("height", S).attr("viewBox", `0 0 ${S} ${S}`);
    drawGrid(svgSel, p);
}

function updatePanelRange(svgSel, p, newRange) {
    if (Math.abs(p.range - newRange) < 0.01) return; // no change
    p.range = newRange;
    initPanelScales(p);
    drawGrid(svgSel, p);
}

const coeffSvg = d3.select("#coeff-panel");
const rootsSvg = d3.select("#roots-panel");
setupPanel(coeffSvg, panels.coeff);
setupPanel(rootsSvg, panels.roots);

let coeffTrailLayer = coeffSvg.append("g").attr("class", "trail-layer");
let coeffLayer = coeffSvg.append("g");
let trailLayer = rootsSvg.append("g").attr("class", "trail-layer");
let rootsLayer = rootsSvg.append("g");

// --- Tooltip ---

const tooltip = document.getElementById("tooltip");

function showTooltip(event, re, im) {
    const sign = im >= 0 ? "+" : "‚àí";
    const absIm = Math.abs(im);
    tooltip.textContent = `${re.toFixed(3)} ${sign} ${absIm.toFixed(3)}i`;
    tooltip.style.display = "block";
    tooltip.style.left = (event.pageX + 12) + "px";
    tooltip.style.top = (event.pageY - 12) + "px";
}

function hideTooltip() {
    tooltip.style.display = "none";
}

// --- Coefficient color ---

function coeffColor(i, n) {
    return d3.interpolateRainbow(i / n);
}

function rootColor(i, n) {
    if (rootColorMode === "rainbow") return d3.interpolateRainbow(i / n);
    if (rootColorMode === "derivative" && rootSensitivities && i < rootSensitivities.length) {
        return sensitivityColor(rootSensitivities[i]);
    }
    return "#e94560";
}

function sensitivityColor(normVal) {
    if (normVal <= 0.5) {
        const t = normVal * 2;
        const r = Math.round(t * 255);
        const g = Math.round(t * 255);
        return `rgb(${r},${g},255)`;
    } else {
        const t = (normVal - 0.5) * 2;
        const g = Math.round((1 - t) * 255);
        const b = Math.round((1 - t) * 255);
        return `rgb(255,${g},${b})`;
    }
}

// Rank-based normalization: sort values, assign integer ranks (ties get same rank),
// map linearly to [0,1]. 0=blue, 0.5=white, 1=red in sensitivityColor.
function rankNormalize(raw) {
    const n = raw.length;
    if (n === 0) return null;
    // Build (value, index) pairs, replacing non-finite with largest finite
    let maxFinite = -Infinity;
    for (let i = 0; i < n; i++) if (isFinite(raw[i]) && raw[i] > maxFinite) maxFinite = raw[i];
    if (maxFinite === -Infinity) return null;
    const pairs = [];
    for (let i = 0; i < n; i++) pairs.push({ v: isFinite(raw[i]) ? raw[i] : maxFinite, i });
    pairs.sort((a, b) => a.v - b.v);
    // Assign integer ranks; ties get the same rank
    const result = new Float64Array(n);
    let rank = 0;
    for (let p = 0; p < n; p++) {
        if (p > 0 && pairs[p].v !== pairs[p - 1].v) rank = p;
        result[pairs[p].i] = rank;
    }
    const maxRank = n - 1;
    if (maxRank === 0) { result.fill(0.5); return result; }
    for (let i = 0; i < n; i++) result[i] /= maxRank;
    return result;
}

function computeCoeffSensitivities() {
    const nRoots = currentRoots.length;
    const nCoeffs = coefficients.length;
    const deg = nCoeffs - 1;
    if (nRoots === 0) return null;

    const cRe = new Float64Array(nCoeffs);
    const cIm = new Float64Array(nCoeffs);
    for (let i = 0; i < nCoeffs; i++) { cRe[i] = coefficients[i].re; cIm[i] = coefficients[i].im; }

    // Precompute 1/|p'(rj)| and |rj| for each root
    const invDpMag = new Float64Array(nRoots);
    const rMag = new Float64Array(nRoots);
    for (let j = 0; j < nRoots; j++) {
        const zRe = currentRoots[j].re, zIm = currentRoots[j].im;
        rMag[j] = Math.hypot(zRe, zIm);
        let pRe = cRe[0], pIm = cIm[0], dpRe = 0, dpIm = 0;
        for (let k = 1; k <= deg; k++) {
            const ndRe = dpRe * zRe - dpIm * zIm + pRe;
            const ndIm = dpRe * zIm + dpIm * zRe + pIm;
            dpRe = ndRe; dpIm = ndIm;
            const npRe = pRe * zRe - pIm * zIm + cRe[k];
            const npIm = pRe * zIm + pIm * zRe + cIm[k];
            pRe = npRe; pIm = npIm;
        }
        const dm = Math.hypot(dpRe, dpIm);
        invDpMag[j] = dm < 1e-30 ? 0 : 1 / dm;
    }

    // For each coefficient k: sensitivity_k = Œ£‚±º |r‚±º^(deg-k)| / |p'(r‚±º)|
    const raw = new Float64Array(nCoeffs);
    for (let k = 0; k < nCoeffs; k++) {
        const power = deg - k;
        let sum = 0;
        for (let j = 0; j < nRoots; j++) {
            sum += Math.pow(rMag[j], power) * invDpMag[j];
        }
        raw[k] = sum;
    }

    return rankNormalize(raw);
}

function computeRootSensitivities() {
    const n = currentRoots.length;
    const deg = coefficients.length - 1;
    if (n === 0 || selectedCoeffs.size === 0) { rootSensitivities = null; return; }

    // Build coefficient arrays for Horner evaluation of p'(z)
    const cRe = new Float64Array(coefficients.length);
    const cIm = new Float64Array(coefficients.length);
    for (let i = 0; i < coefficients.length; i++) {
        cRe[i] = coefficients[i].re;
        cIm[i] = coefficients[i].im;
    }

    const raw = new Float64Array(n);
    for (let j = 0; j < n; j++) {
        const zRe = currentRoots[j].re, zIm = currentRoots[j].im;
        // Horner: simultaneous p(z) and p'(z)
        let pRe = cRe[0], pIm = cIm[0];
        let dpRe = 0, dpIm = 0;
        for (let k = 1; k <= deg; k++) {
            const ndRe = dpRe * zRe - dpIm * zIm + pRe;
            const ndIm = dpRe * zIm + dpIm * zRe + pIm;
            dpRe = ndRe; dpIm = ndIm;
            const npRe = pRe * zRe - pIm * zIm + cRe[k];
            const npIm = pRe * zIm + pIm * zRe + cIm[k];
            pRe = npRe; pIm = npIm;
        }
        const dpMag = Math.hypot(dpRe, dpIm);
        if (dpMag < 1e-30) { raw[j] = Infinity; continue; }

        // Sum |rj^(deg-k)| for each selected coefficient k
        const rMag = Math.hypot(zRe, zIm);
        let sum = 0;
        for (const k of selectedCoeffs) {
            sum += Math.pow(rMag, deg - k);
        }
        raw[j] = sum / dpMag;
    }

    rootSensitivities = rankNormalize(raw);
}

// --- Init coefficients with pattern ---

function getPattern() { return document.getElementById("pattern").value; }
function getSpread() { return 1.0; }

function initCoefficients(degree) {
    const n = degree + 1;
    const spread = getSpread();
    const pattern = getPattern();
    coefficients = [];

    if (pattern === "circle") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            coefficients.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
    } else if (pattern === "real") {
        for (let i = 0; i < n; i++) {
            const t = n === 1 ? 0 : -spread + (2 * spread * i) / (n - 1);
            coefficients.push({ re: t, im: 0 });
        }
    } else if (pattern === "imag") {
        for (let i = 0; i < n; i++) {
            const t = n === 1 ? 0 : -spread + (2 * spread * i) / (n - 1);
            coefficients.push({ re: 0, im: t });
        }
    } else if (pattern === "grid") {
        const cols = Math.ceil(Math.sqrt(n));
        const rows = Math.ceil(n / cols);
        for (let i = 0; i < n; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            const re = cols === 1 ? 0 : -spread + (2 * spread * col) / (cols - 1);
            const im = rows === 1 ? 0 : -spread + (2 * spread * row) / (rows - 1);
            coefficients.push({ re, im });
        }
    } else if (pattern === "random") {
        for (let i = 0; i < n; i++) {
            coefficients.push({
                re: (Math.random() * 2 - 1) * spread,
                im: (Math.random() * 2 - 1) * spread
            });
        }
    } else if (pattern === "spiral") {
        // Archimedean spiral ‚Äî roots trace beautiful curves when perturbed
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const r = spread * t;
            const angle = 4 * Math.PI * t;
            coefficients.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "star") {
        // Alternating inner/outer radii ‚Äî gives spiky root patterns
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            const r = (i % 2 === 0) ? spread : spread * 0.4;
            coefficients.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "lemniscate") {
        // Figure-8 (Bernoulli lemniscate) ‚Äî rich root sensitivity
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const cos2t = Math.cos(2 * t);
            const r = spread * Math.sqrt(Math.abs(cos2t));
            const sign = cos2t >= 0 ? 1 : -1;
            coefficients.push({ re: sign * r * Math.cos(t), im: sign * r * Math.sin(t) });
        }
    } else if (pattern === "conjugate") {
        // Conjugate pairs straddling real axis ‚Äî roots tend to stay near real axis then bifurcate
        for (let i = 0; i < n; i++) {
            const pairIdx = Math.floor(i / 2);
            const re = n <= 2 ? 0 : -spread + (2 * spread * pairIdx) / (Math.ceil(n / 2) - 1 || 1);
            const im = (i % 2 === 0) ? spread * 0.5 : -spread * 0.5;
            coefficients.push({ re, im });
        }
    } else if (pattern === "two-clusters") {
        // Two clusters ‚Äî see roots jump between clusters as you drag
        const half = Math.ceil(n / 2);
        for (let i = 0; i < n; i++) {
            const cluster = i < half ? -1 : 1;
            const idx = i < half ? i : i - half;
            const count = i < half ? half : n - half;
            const angle = (2 * Math.PI * idx) / Math.max(count, 1);
            const r = spread * 0.35;
            coefficients.push({
                re: cluster * spread * 0.7 + r * Math.cos(angle),
                im: r * Math.sin(angle)
            });
        }
    } else if (pattern === "geometric") {
        // Geometric decay along real axis ‚Äî classic for ill-conditioned polynomials
        for (let i = 0; i < n; i++) {
            const val = spread * Math.pow(0.7, i);
            const sign = (i % 2 === 0) ? 1 : -1;
            coefficients.push({ re: sign * val, im: 0 });
        }
    } else if (pattern === "rose") {
        // Rose curve r = cos(kŒ∏) ‚Äî petals create interesting symmetry breaking
        const k = 3; // 3-petal rose
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * Math.cos(k * t);
            coefficients.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "cardioid") {
        // Cardioid ‚Äî heart-shaped curve, roots respond dramatically near the cusp
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * 0.5 * (1 + Math.cos(t));
            coefficients.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern.startsWith("r-")) {
        // Root-shape patterns: define roots, compute coefficients
        const roots = generateRootShape(pattern, degree, spread);
        const cs = rootsToCoefficients(roots);
        for (const c of cs) coefficients.push(c);
    }

    // Initialize curve as null (no path assigned yet)
    for (const c of coefficients) c.curve = null;
}

// --- Roots ‚Üí Coefficients ---
// Expand (z - r‚ÇÄ)(z - r‚ÇÅ)...(z - r_{n-1}) into coefficient array
function rootsToCoefficients(roots) {
    // Start with polynomial = [1] (just the leading coefficient)
    let re = [1], im = [0];
    for (const root of roots) {
        const newRe = new Array(re.length + 1).fill(0);
        const newIm = new Array(im.length + 1).fill(0);
        for (let j = 0; j < re.length; j++) {
            // Multiply by z: shift coefficients up
            newRe[j] += re[j];
            newIm[j] += im[j];
            // Multiply by -root: (a+bi)(-c-di) = (-ac+bd) + (-ad-bc)i
            newRe[j + 1] += -re[j] * root.re + im[j] * root.im;
            newIm[j + 1] += -re[j] * root.im - im[j] * root.re;
        }
        re = newRe;
        im = newIm;
    }
    return re.map((r, i) => ({ re: r, im: im[i] }));
}

// --- Root shape generators ---
function generateRootShape(pattern, degree, spread) {
    const n = degree; // number of roots = degree
    const roots = [];

    if (pattern === "r-heart") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const x = spread * 0.8 * 16 * Math.pow(Math.sin(t), 3) / 16;
            const y = spread * 0.8 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 16;
            roots.push({ re: x, im: y });
        }
    } else if (pattern === "r-circle") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            roots.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
    } else if (pattern === "r-star") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            const r = (i % 2 === 0) ? spread : spread * 0.4;
            roots.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "r-spiral") {
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const r = spread * (0.2 + 0.8 * t);
            const angle = 4 * Math.PI * t;
            roots.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "r-cross") {
        // + shape: half on horizontal, half on vertical
        const hCount = Math.ceil(n / 2);
        const vCount = n - hCount;
        for (let i = 0; i < hCount; i++) {
            const t = hCount === 1 ? 0 : -spread + (2 * spread * i) / (hCount - 1);
            roots.push({ re: t, im: 0 });
        }
        for (let i = 0; i < vCount; i++) {
            const t = vCount === 1 ? 0 : -spread + (2 * spread * i) / (vCount - 1);
            if (Math.abs(t) < 1e-10) continue; // skip origin (already in horizontal)
            roots.push({ re: 0, im: t });
        }
        // Fill up if we skipped the origin duplicate
        while (roots.length < n) {
            roots.push({ re: 0, im: spread * 0.1 * roots.length });
        }
    } else if (pattern === "r-diamond") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            // Diamond: |x| + |y| = spread, parametrically
            const x = spread * Math.cos(t);
            const y = spread * Math.sin(t);
            const scale = 1 / (Math.abs(Math.cos(t)) + Math.abs(Math.sin(t)));
            roots.push({ re: x * scale, im: y * scale });
        }
    } else if (pattern === "r-grid") {
        // Chessboard: only "black squares" of a grid
        const side = Math.ceil(Math.sqrt(n * 2));
        let placed = 0;
        for (let row = 0; row < side && placed < n; row++) {
            for (let col = 0; col < side && placed < n; col++) {
                if ((row + col) % 2 === 0) {
                    const re = -spread + (2 * spread * col) / (side - 1);
                    const im = -spread + (2 * spread * row) / (side - 1);
                    roots.push({ re, im });
                    placed++;
                }
            }
        }
    } else if (pattern === "r-smiley") {
        // Eyes + smile arc
        const eyeCount = Math.max(2, Math.floor(n * 0.2));
        const smileCount = n - eyeCount;
        // Left eye
        const leftEye = Math.ceil(eyeCount / 2);
        for (let i = 0; i < leftEye; i++) {
            const angle = (2 * Math.PI * i) / leftEye;
            roots.push({ re: -spread * 0.35 + spread * 0.12 * Math.cos(angle), im: spread * 0.3 + spread * 0.12 * Math.sin(angle) });
        }
        // Right eye
        const rightEye = eyeCount - leftEye;
        for (let i = 0; i < rightEye; i++) {
            const angle = (2 * Math.PI * i) / Math.max(rightEye, 1);
            roots.push({ re: spread * 0.35 + spread * 0.12 * Math.cos(angle), im: spread * 0.3 + spread * 0.12 * Math.sin(angle) });
        }
        // Smile arc (bottom half of circle)
        for (let i = 0; i < smileCount; i++) {
            const angle = Math.PI + (Math.PI * 0.8) * (i / (smileCount - 1)) - Math.PI * 0.4;
            roots.push({ re: spread * 0.6 * Math.cos(angle), im: spread * 0.6 * Math.sin(angle) - spread * 0.1 });
        }
    } else if (pattern === "r-figure8") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const cos2t = Math.cos(2 * t);
            const r = spread * Math.sqrt(Math.abs(cos2t));
            const sign = cos2t >= 0 ? 1 : -1;
            roots.push({ re: sign * r * Math.cos(t), im: sign * r * Math.sin(t) });
        }
    } else if (pattern === "r-butterfly") {
        // Butterfly curve (polar)
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * 0.4 * (Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) + Math.pow(Math.sin(t / 12), 5));
            roots.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "r-trefoil") {
        // 3-leaf clover
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * Math.cos(3 * t);
            roots.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "r-polygon") {
        // Regular polygon outline (not just vertices)
        const sides = Math.min(Math.max(3, Math.floor(degree / 2)), 8);
        const vertices = [];
        for (let s = 0; s < sides; s++) {
            const angle = (2 * Math.PI * s) / sides - Math.PI / 2;
            vertices.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
        // Distribute roots along edges
        for (let i = 0; i < n; i++) {
            const t = (i / n) * sides;
            const edgeIdx = Math.floor(t) % sides;
            const frac = t - Math.floor(t);
            const v1 = vertices[edgeIdx];
            const v2 = vertices[(edgeIdx + 1) % sides];
            roots.push({ re: v1.re + frac * (v2.re - v1.re), im: v1.im + frac * (v2.im - v1.im) });
        }
    } else if (pattern === "r-infinity") {
        // Infinity / lemniscate of Bernoulli: two lobes
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const denom = 1 + Math.sin(t) * Math.sin(t);
            roots.push({
                re: spread * Math.cos(t) / denom,
                im: spread * Math.sin(t) * Math.cos(t) / denom
            });
        }
    }
    return roots;
}

// --- Drag behavior ---

let dragMoved = false;
let dragStartX = 0, dragStartY = 0;
const CLICK_DEAD_ZONE = 3; // px threshold: smaller moves count as clicks, not drags
const drag = d3.drag()
    .on("start", function (event) {
        dragMoved = false;
        dragStartX = event.x;
        dragStartY = event.y;
        d3.select(this).raise().classed("dragging", true);
    })
    .on("drag", function (event, d) {
        if (!dragMoved && Math.hypot(event.x - dragStartX, event.y - dragStartY) < CLICK_DEAD_ZONE) return;
        dragMoved = true;
        const idx = d._idx;
        // Skip if this coefficient is being animated
        if (animState.playing && allPathCoeffs().has(idx)) return;

        const newRe = cxs().invert(event.x);
        const newIm = cys().invert(event.y);

        if (selectedCoeffs.has(idx) && selectedCoeffs.size > 1) {
            // Group drag: apply delta to all selected
            const deltaRe = newRe - d.re;
            const deltaIm = newIm - d.im;
            for (const si of selectedCoeffs) {
                coefficients[si].re += deltaRe;
                coefficients[si].im += deltaIm;
                if (coefficients[si].curve) {
                    for (const pt of coefficients[si].curve) { pt.re += deltaRe; pt.im += deltaIm; }
                }
            }
            coeffLayer.selectAll("circle.coeff")
                .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
            coeffLayer.selectAll(".coeff-label")
                .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);
        } else {
            // Single drag: shift position and all curve points by delta
            const deltaRe = newRe - d.re;
            const deltaIm = newIm - d.im;
            d.re = newRe;
            d.im = newIm;
            if (d.curve) {
                for (const pt of d.curve) { pt.re += deltaRe; pt.im += deltaIm; }
            }
            d3.select(this).attr("cx", cxs()(d.re)).attr("cy", cys()(d.im));
            coeffLayer.selectAll(".coeff-label")
                .filter(ld => ld === d)
                .attr("x", cxs()(d.re) + 12).attr("y", cys()(d.im) + 4);
        }
        showTooltip(event.sourceEvent, d.re, d.im);
        autoScaleCoeffPanel();
        solveRootsThrottled();
        renderDomainColoringThrottled();
        // Update analytical coefficient path curves (they follow the coefficient)
        if (animPaths.length > 0) renderCoeffTrails();
    })
    .on("end", function (event, d) {
        d3.select(this).classed("dragging", false);
        hideTooltip();
        // Click detection: if mouse didn't move, toggle selection
        if (!dragMoved) {
            const idx = d._idx;
            clearRootSelection();
            toggleCoeffSelect(idx);
        }
    });

function autoScaleCoeffPanel() {
    let needed = computeRange(coefficients);
    // During animation, only zoom out ‚Äî never shrink back
    if (animState.playing) needed = Math.max(needed, panels.coeff.range);
    if (needed !== panels.coeff.range) {
        updatePanelRange(coeffSvg, panels.coeff, needed);
        coeffLayer.selectAll("circle.coeff")
            .attr("cx", d => cxs()(d.re)).attr("cy", d => cys()(d.im));
        coeffLayer.selectAll(".coeff-label")
            .attr("x", d => cxs()(d.re) + 12).attr("y", d => cys()(d.im) + 4);
        // Trail SVG paths contain absolute screen coordinates ‚Äî must re-render
        // when the scale changes so trails stay aligned with coefficient dots
        if (animPaths.length > 0) renderCoeffTrails();
    }
}

// --- Coefficient selection & animation ---

function coeffExtent() {
    const n = coefficients.length;
    let maxDist = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const d = Math.hypot(coefficients[i].re - coefficients[j].re,
                                 coefficients[i].im - coefficients[j].im);
            if (d > maxDist) maxDist = d;
        }
    }
    return maxDist || 1;
}

const animBar = document.getElementById("anim-bar");
const barTitle = document.getElementById("bar-title");
const animPathSel = document.getElementById("anim-path");
const animRadiusInput = document.getElementById("anim-radius");
const animSpeedInput = document.getElementById("anim-speed");
const animRadiusVal = document.getElementById("anim-radius-val");
const animSpeedVal = document.getElementById("anim-speed-val");
const animAngleInput = document.getElementById("anim-angle");
const animAngleVal = document.getElementById("anim-angle-val");
const playBtn = document.getElementById("play-btn");
const trailsBtn = document.getElementById("trails-btn");
const sel2pathBtn = document.getElementById("sel2path-btn");
const pathPrevBtn = document.getElementById("path-prev");
const pathNextBtn = document.getElementById("path-next");
const pathLabel = document.getElementById("path-label");
const ccwBtn = document.getElementById("ccw-btn");
const delPathBtn = document.getElementById("del-path-btn");
const pathNav = document.getElementById("path-nav");

function toggleCoeffSelect(idx) {
    // If animation is playing and user clicks a coefficient, stop animation
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "‚ñ∂ Play";
    }

    if (selectedCoeffs.has(idx)) {
        selectedCoeffs.delete(idx);
    } else {
        selectedCoeffs.add(idx);
    }
    updateCoeffSelectionVisual();
    updateAnimBar();
}

function clearCoeffSelection() {
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "‚ñ∂ Play";
    }
    selectedCoeffs.clear();
    updateCoeffSelectionVisual();
    updateAnimBar();
}

function clearRootSelection() {
    selectedRoots.clear();
    updateRootSelectionVisual();
}

function clearAllSelection() {
    clearCoeffSelection();
    clearRootSelection();
}

function updateTransformGroupVisibility() {
    const hasCoeff = selectedCoeffs.size > 0;
    const hasRoot = selectedRoots.size > 0;
    const hasSel = hasCoeff || hasRoot;
    document.getElementById("ops-group").classList.toggle("disabled", !hasSel);
    const t = document.getElementById("ops-target");
    if (!hasSel) {
        t.textContent = "";
        if (typeof closeOpTool === "function") closeOpTool();
    }
    else if (hasCoeff) { t.textContent = "¬∑ coeffs"; t.style.color = "#5ddb6a"; }
    else { t.textContent = "¬∑ roots"; t.style.color = "#e94560"; }
}

function updateCoeffSelectionVisual() {
    coeffLayer.selectAll("circle.coeff")
        .classed("selected", d => selectedCoeffs.has(d._idx));
    const cc = document.getElementById("coeff-sel-count");
    cc.textContent = selectedCoeffs.size > 0 ? `(${selectedCoeffs.size})` : "";
    updateTransformGroupVisibility();
    if (rootColorMode === "derivative") {
        computeRootSensitivities();
        refreshRootColors();
    }
}

function updateRootSelectionVisual() {
    rootsLayer.selectAll("circle.root")
        .classed("selected", d => selectedRoots.has(d._idx));
    const rc = document.getElementById("roots-sel-count");
    rc.textContent = selectedRoots.size > 0 ? `(${selectedRoots.size})` : "";
    updateTransformGroupVisibility();
}

// --- Marquee (area) selection ---

function installMarqueeSelection(svgSel, getCirclesSel, which) {
    const svgNode = svgSel.node();
    let dragging = false;
    let x0 = 0, y0 = 0;
    let rect = null;

    function begin(event) {
        const t = event.target;
        if (t && t.tagName === "circle") return;
        if (event.button != null && event.button !== 0) return;

        if (which === "coeff") clearRootSelection();
        else clearCoeffSelection();

        dragging = true;
        const p = d3.pointer(event, svgNode);
        x0 = p[0]; y0 = p[1];

        rect = svgSel.append("rect")
            .attr("class", "sel-rect")
            .attr("x", x0).attr("y", y0)
            .attr("width", 0).attr("height", 0);
        event.preventDefault();
    }

    function move(event) {
        if (!dragging || !rect) return;
        const p = d3.pointer(event, svgNode);
        const x1 = p[0], y1 = p[1];
        rect.attr("x", Math.min(x0, x1)).attr("y", Math.min(y0, y1))
            .attr("width", Math.abs(x1 - x0)).attr("height", Math.abs(y1 - y0));
        event.preventDefault();
    }

    function end() {
        if (!dragging) return;
        dragging = false;
        if (!rect) return;

        const x = +rect.attr("x"), y = +rect.attr("y");
        const w = +rect.attr("width"), h = +rect.attr("height");
        rect.remove();
        rect = null;

        if (w < 3 || h < 3) return;

        const xMax = x + w, yMax = y + h;
        getCirclesSel().each(function(d) {
            const cx = +this.getAttribute("cx");
            const cy = +this.getAttribute("cy");
            if (cx >= x && cx <= xMax && cy >= y && cy <= yMax) {
                if (which === "coeff") selectedCoeffs.add(d._idx);
                else selectedRoots.add(d._idx);
            }
        });

        if (which === "coeff") {
            updateCoeffSelectionVisual();
            updateAnimBar();
        } else {
            updateRootSelectionVisual();
        }
    }

    svgSel.on("mousedown.marquee", begin);
    window.addEventListener("mousemove", move, { passive: false });
    window.addEventListener("mouseup", end, { passive: false });
}

// --- Path management ---

function createPathFromSelection() {
    if (selectedCoeffs.size === 0) return;
    stopAnimation();
    playBtn.textContent = "‚ñ∂ Play";

    const newCoeffs = new Set(selectedCoeffs);

    // Remove these coefficients from existing paths
    for (let i = animPaths.length - 1; i >= 0; i--) {
        for (const idx of newCoeffs) {
            animPaths[i].coeffs.delete(idx);
        }
        if (animPaths[i].coeffs.size === 0) {
            animPaths.splice(i, 1);
        }
    }

    // Create new path with defaults from current UI
    const pType = animPathSel.value;
    const pRadius = parseFloat(animRadiusInput.value);
    const pAngle = parseFloat(animAngleInput.value);
    const path = {
        id: nextPathId++,
        coeffs: newCoeffs,
        pathType: pType,
        radius: pRadius,
        speed: parseFloat(animSpeedInput.value),
        ccw: false,
        angle: pAngle,
    };
    // Compute per-coefficient absolute curves
    if (pType !== "random" && pType !== "none") {
        const absRadius = pRadius / 100 * coeffExtent();
        for (const idx of newCoeffs) {
            const c = coefficients[idx];
            c.curve = computeCurve(c.re, c.im, pType, absRadius, pAngle);
        }
    }
    animState.elapsedAtPause = null;
    animPaths.push(path);
    viewedPathIdx = animPaths.length - 1;

    updateCoeffSelectionVisual();
    updateAnimBar();
    renderCoeffTrails();
}

function deleteCurrentPath() {
    if (animPaths.length === 0) return;
    // Snap removed coefficients to home, clear curve
    const dying = animPaths[viewedPathIdx];
    for (const idx of dying.coeffs) {
        if (coefficients[idx].curve) {
            coefficients[idx].re = coefficients[idx].curve[0].re;
            coefficients[idx].im = coefficients[idx].curve[0].im;
        }
        coefficients[idx].curve = null;
    }
    stopAnimation();
    playBtn.textContent = "‚ñ∂ Play";
    animState.elapsedAtPause = null;
    animPaths.splice(viewedPathIdx, 1);
    if (viewedPathIdx >= animPaths.length) viewedPathIdx = Math.max(0, animPaths.length - 1);
    updateAnimBar();
    renderCoeffTrails();
}

function coeffListLabel(coeffSet) {
    const n = coefficients.length;
    const sorted = [...coeffSet].sort((a, b) => a - b);
    if (sorted.length <= 4) {
        return sorted.map(i => `c${subscript(n - 1 - i)}`).join(' ');
    }
    return `${sorted.length} coeffs`;
}

function syncBarToPath() {
    if (animPaths.length === 0) return;
    const path = animPaths[viewedPathIdx];
    barTitle.textContent = coeffListLabel(path.coeffs);
    animPathSel.value = path.pathType;
    animRadiusInput.value = path.radius;
    animRadiusVal.textContent = Math.round(path.radius) + "%";
    animSpeedInput.value = path.speed;
    animSpeedVal.textContent = path.speed.toFixed(2);
    animAngleInput.value = path.angle;
    animAngleVal.textContent = path.angle.toFixed(2);
    ccwBtn.textContent = path.ccw ? "CCW" : "CW";
    ccwBtn.classList.toggle("active", path.ccw);
    pathLabel.textContent = `Path ${viewedPathIdx + 1}/${animPaths.length}`;
}

function syncPathFromBar() {
    if (animPaths.length === 0) return;
    const path = animPaths[viewedPathIdx];
    const oldType = path.pathType, oldRadius = path.radius, oldAngle = path.angle;
    path.pathType = animPathSel.value;
    path.radius = parseFloat(animRadiusInput.value);
    path.speed = parseFloat(animSpeedInput.value);
    path.angle = parseFloat(animAngleInput.value);

    if (path.pathType === "random" || path.pathType === "none") {
        // No curve for random/none
        for (const idx of path.coeffs) coefficients[idx].curve = null;
        animState.elapsedAtPause = null;
    } else if (path.pathType !== oldType) {
        // Shape changed: full recompute, reset animation
        computePathCurves(path);
        animState.elapsedAtPause = null;
    } else if (path.radius !== oldRadius || path.angle !== oldAngle) {
        // Radius/angle changed: transform in place, KEEP elapsedAtPause
        transformPathCurves(path, oldRadius, oldAngle);
    }

    // Update dot positions (coefficient may have moved to nearest point)
    coeffLayer.selectAll("circle.coeff")
        .filter(cd => path.coeffs.has(cd._idx))
        .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
    coeffLayer.selectAll(".coeff-label")
        .filter(ld => path.coeffs.has(ld._idx))
        .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);

    renderCoeffTrails();
}

function updateAnimBar() {
    const hasPaths = animPaths.length > 0;
    const hasSelection = selectedCoeffs.size > 0;

    if (!hasPaths && !hasSelection) {
        animBar.classList.remove("active");
        return;
    }
    animBar.classList.add("active");

    // Sel‚ÜíPath button enabled only when coeffs are selected
    sel2pathBtn.disabled = !hasSelection;

    // Path nav and per-path controls visible only when paths exist
    const pathControlsVisible = hasPaths;
    pathNav.style.display = pathControlsVisible ? "flex" : "none";
    barTitle.style.display = pathControlsVisible ? "" : "none";
    animPathSel.parentElement.style.display = pathControlsVisible ? "" : "none";
    animRadiusInput.parentElement.style.display = pathControlsVisible ? "" : "none";
    animSpeedInput.parentElement.style.display = pathControlsVisible ? "" : "none";
    animAngleInput.parentElement.style.display = pathControlsVisible ? "" : "none";
    ccwBtn.style.display = pathControlsVisible ? "" : "none";
    delPathBtn.style.display = pathControlsVisible ? "" : "none";

    if (hasPaths) {
        syncBarToPath();
    } else if (hasSelection) {
        // Show just sel2path + play/trails
        barTitle.style.display = "";
        barTitle.textContent = coeffListLabel(selectedCoeffs);
    }
}

// Slider value displays ‚Äî also sync to current path
animRadiusInput.addEventListener("input", function () {
    animRadiusVal.textContent = Math.round(parseFloat(this.value)) + "%";
    syncPathFromBar();
});
animSpeedInput.addEventListener("input", function () {
    animSpeedVal.textContent = parseFloat(this.value).toFixed(2);
    syncPathFromBar();
});
animAngleInput.addEventListener("input", function () {
    animAngleVal.textContent = parseFloat(this.value).toFixed(2);
    syncPathFromBar();
});
animPathSel.addEventListener("change", syncPathFromBar);

// Sel‚ÜíPath button
sel2pathBtn.addEventListener("click", createPathFromSelection);

// Select the coefficients belonging to the currently viewed path
function selectPathCoeffs() {
    if (animPaths.length === 0) return;
    const path = animPaths[viewedPathIdx];
    clearRootSelection();
    selectedCoeffs.clear();
    for (const idx of path.coeffs) selectedCoeffs.add(idx);
    updateCoeffSelectionVisual();
}

// Path navigation
pathPrevBtn.addEventListener("click", function () {
    if (animPaths.length <= 1) return;
    viewedPathIdx = (viewedPathIdx - 1 + animPaths.length) % animPaths.length;
    syncBarToPath();
    pathLabel.textContent = `Path ${viewedPathIdx + 1}/${animPaths.length}`;
    selectPathCoeffs();
});
pathNextBtn.addEventListener("click", function () {
    if (animPaths.length <= 1) return;
    viewedPathIdx = (viewedPathIdx + 1) % animPaths.length;
    syncBarToPath();
    pathLabel.textContent = `Path ${viewedPathIdx + 1}/${animPaths.length}`;
    selectPathCoeffs();
});

// CCW toggle
ccwBtn.addEventListener("click", function () {
    if (animPaths.length === 0) return;
    const path = animPaths[viewedPathIdx];
    path.ccw = !path.ccw;
    this.textContent = path.ccw ? "CCW" : "CW";
    this.classList.toggle("active", path.ccw);
    animState.elapsedAtPause = null;
    renderCoeffTrails();
});

// Delete path
delPathBtn.addEventListener("click", deleteCurrentPath);

// Play/Pause button
playBtn.addEventListener("click", function () {
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "‚ñ∂ Play";
    } else {
        if (animPaths.length === 0) return;
        // Clear root trails only (accumulated); coeff trails are per-coefficient curves
        if (trailsEnabled) {
            trailData = [];
            trailComplete = false;
            trailLayer.selectAll("path.trail-path").remove();
        }
        startAnimation();
        if (animPaths.length > 0) renderCoeffTrails();
        playBtn.textContent = "‚è∏ Pause";
    }
});

// Home button: reset coefficients to their curve[0] (start) positions
document.getElementById("home-btn").addEventListener("click", function () {
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "‚ñ∂ Play";
    }
    animState.elapsedAtPause = null;
    for (const path of animPaths) {
        for (const idx of path.coeffs) {
            if (coefficients[idx].curve) {
                coefficients[idx].re = coefficients[idx].curve[0].re;
                coefficients[idx].im = coefficients[idx].curve[0].im;
            }
        }
    }
    const animated = allPathCoeffs();
    coeffLayer.selectAll("circle.coeff")
        .filter(cd => animated.has(cd._idx))
        .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
    coeffLayer.selectAll(".coeff-label")
        .filter(ld => animated.has(ld._idx))
        .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);
    if (trailsEnabled) {
        trailData = [];
        trailComplete = false;
        trailLayer.selectAll("path.trail-path").remove();
    }
    resetAudioState();
    renderCoeffTrails();
    autoScaleCoeffPanel();
    solveRootsThrottled();
    renderDomainColoringThrottled();
});

// Trails toggle button
trailsBtn.addEventListener("click", function () {
    trailsEnabled = !trailsEnabled;
    this.classList.toggle("active", trailsEnabled);
    clearTrails();
    if (animPaths.length > 0) renderCoeffTrails();
});

// --- Path functions ---

function animPathFn(name, t, center, radius) {
    const w = 2 * Math.PI; // one full cycle per second (scaled by speed)
    const wt = w * t;
    switch (name) {
        case "circle":
            return { re: center.re + radius * Math.cos(wt), im: center.im + radius * Math.sin(wt) };
        case "horizontal":
            return { re: center.re + radius * Math.cos(wt), im: center.im };
        case "vertical":
            return { re: center.re, im: center.im + radius * Math.cos(wt) };
        case "spiral": {
            const r = radius * (0.5 + 0.5 * Math.sin(wt / 4));
            return { re: center.re + r * Math.cos(wt), im: center.im + r * Math.sin(wt) };
        }
        case "figure8": {
            const d = 1 + Math.sin(wt) * Math.sin(wt);
            return {
                re: center.re + radius * Math.cos(wt) / d,
                im: center.im + radius * Math.sin(wt) * Math.cos(wt) / d
            };
        }
        case "lissajous":
            // 3:2 Lissajous with phase offset
            return {
                re: center.re + radius * Math.sin(3 * wt + Math.PI / 4),
                im: center.im + radius * Math.sin(2 * wt)
            };
        case "cardioid": {
            // r_polar = 0.5*(1 + cos(Œ∏)), parametric
            const s = 0.5 * (1 + Math.cos(wt));
            return {
                re: center.re + radius * s * Math.cos(wt),
                im: center.im + radius * s * Math.sin(wt)
            };
        }
        case "astroid":
            // Hypocycloid with 4 cusps: cos¬≥, sin¬≥
            return {
                re: center.re + radius * Math.cos(wt) * Math.cos(wt) * Math.cos(wt),
                im: center.im + radius * Math.sin(wt) * Math.sin(wt) * Math.sin(wt)
            };
        case "deltoid":
            // Hypocycloid with 3 cusps
            return {
                re: center.re + radius * (2 * Math.cos(wt) + Math.cos(2 * wt)) / 3,
                im: center.im + radius * (2 * Math.sin(wt) - Math.sin(2 * wt)) / 3
            };
        case "rose": {
            // 3-petal rose r = cos(3Œ∏)
            const rr = radius * Math.cos(3 * wt);
            return {
                re: center.re + rr * Math.cos(wt),
                im: center.im + rr * Math.sin(wt)
            };
        }
        case "epitrochoid":
            // Spirograph: R=3, r=1, d=1 ‚Üí 3-lobed, scaled to fit radius
            return {
                re: center.re + radius * (4 * Math.cos(wt) - Math.cos(4 * wt)) / 5,
                im: center.im + radius * (4 * Math.sin(wt) - Math.sin(4 * wt)) / 5
            };
        case "hypotrochoid":
            // Spirograph inner: R=5, r=2, d=1 ‚Üí 5-lobed
            return {
                re: center.re + radius * (3 * Math.cos(wt) + Math.cos(1.5 * wt)) / 4,
                im: center.im + radius * (3 * Math.sin(wt) - Math.sin(1.5 * wt)) / 4
            };
        case "butterfly": {
            // Butterfly curve (polar)
            const rb = Math.exp(Math.cos(wt)) - 2 * Math.cos(4 * wt) + Math.pow(Math.sin(wt / 12), 5);
            const scale = radius / 3.5; // normalize to roughly fit radius
            return {
                re: center.re + scale * rb * Math.cos(wt),
                im: center.im + scale * rb * Math.sin(wt)
            };
        }
        case "star": {
            // 5-pointed star (pentagram) via inner/outer radius alternation
            // 10 vertices: 5 outer, 5 inner, linearly interpolated
            const period = wt / (2 * Math.PI); // 0..1 per cycle
            const seg = ((period % 1) + 1) % 1; // normalized 0..1
            const idx = seg * 10;
            const vi = Math.floor(idx) % 10;
            const frac = idx - Math.floor(idx);
            const angle1 = (vi / 10) * 2 * Math.PI - Math.PI / 2;
            const angle2 = ((vi + 1) / 10) * 2 * Math.PI - Math.PI / 2;
            const r1 = (vi % 2 === 0) ? radius : radius * 0.38;
            const r2 = ((vi + 1) % 2 === 0) ? radius : radius * 0.38;
            return {
                re: center.re + r1 * Math.cos(angle1) * (1 - frac) + r2 * Math.cos(angle2) * frac,
                im: center.im + r1 * Math.sin(angle1) * (1 - frac) + r2 * Math.sin(angle2) * frac
            };
        }
        case "square": {
            // Square path, one full cycle
            const period = wt / (2 * Math.PI);
            const seg = ((period % 1) + 1) % 1; // 0..1
            let x, y;
            if (seg < 0.25)      { const f = seg / 0.25;       x =  1 - 2*f; y =  1; }
            else if (seg < 0.5)  { const f = (seg-0.25) / 0.25; x = -1;       y =  1 - 2*f; }
            else if (seg < 0.75) { const f = (seg-0.5) / 0.25;  x = -1 + 2*f; y = -1; }
            else                 { const f = (seg-0.75) / 0.25;  x =  1;       y = -1 + 2*f; }
            return { re: center.re + radius * x, im: center.im + radius * y };
        }
        case "hilbert": {
            // Moore curve (closed Hilbert variant) ‚Äî order 4, 256 segments
            const ORDER_H = 4, N_H = 1 << (2 * ORDER_H); // 256
            const seg_h = ((((wt / (2 * Math.PI)) % 1) + 1) % 1) * N_H;
            const i0_h = Math.floor(seg_h) % N_H, i1_h = (i0_h + 1) % N_H;
            const fr_h = seg_h - Math.floor(seg_h);
            const p0_h = _mooreXY(i0_h, ORDER_H), p1_h = _mooreXY(i1_h, ORDER_H);
            return {
                re: center.re + radius * (p0_h[0] * (1 - fr_h) + p1_h[0] * fr_h),
                im: center.im + radius * (p0_h[1] * (1 - fr_h) + p1_h[1] * fr_h)
            };
        }
        case "peano": {
            // Peano curve (out-and-back for closure) ‚Äî order 3, 512 points (256 forward + 256 back)
            const ORDER_P = 3, N_P = Math.pow(3, 2 * ORDER_P); // 729 points
            const TOTAL_P = N_P * 2; // out and back
            const seg_p = ((((wt / (2 * Math.PI)) % 1) + 1) % 1) * TOTAL_P;
            let idx_p;
            if (seg_p < N_P) {
                idx_p = Math.floor(seg_p) % N_P;
            } else {
                idx_p = N_P - 1 - (Math.floor(seg_p - N_P) % N_P);
            }
            const idx_p2 = (seg_p < N_P)
                ? (Math.floor(seg_p) + 1 < N_P ? Math.floor(seg_p) + 1 : N_P - 1)
                : (idx_p > 0 ? idx_p - 1 : 0);
            const fr_p = seg_p - Math.floor(seg_p);
            const p0_p = _peanoXY(idx_p, ORDER_P), p1_p = _peanoXY(idx_p2, ORDER_P);
            return {
                re: center.re + radius * (p0_p[0] * (1 - fr_p) + p1_p[0] * fr_p),
                im: center.im + radius * (p0_p[1] * (1 - fr_p) + p1_p[1] * fr_p)
            };
        }
        case "sierpinski": {
            // Sierpinski arrowhead ‚Äî order 5, 243 segments, out-and-back for closure
            const ORDER_S = 5, N_S = Math.pow(3, ORDER_S); // 243 points
            const TOTAL_S = N_S * 2; // out and back
            const seg_s = ((((wt / (2 * Math.PI)) % 1) + 1) % 1) * TOTAL_S;
            let idx_s, idx_s2;
            if (seg_s < N_S) {
                idx_s = Math.floor(seg_s) % N_S;
                idx_s2 = Math.min(idx_s + 1, N_S - 1);
            } else {
                idx_s = N_S - 1 - (Math.floor(seg_s - N_S) % N_S);
                idx_s2 = Math.max(idx_s - 1, 0);
            }
            const fr_s = seg_s - Math.floor(seg_s);
            const p0_s = _sierpinskiXY(idx_s, ORDER_S), p1_s = _sierpinskiXY(idx_s2, ORDER_S);
            return {
                re: center.re + radius * (p0_s[0] * (1 - fr_s) + p1_s[0] * fr_s),
                im: center.im + radius * (p0_s[1] * (1 - fr_s) + p1_s[1] * fr_s)
            };
        }
        case "random": {
            const step = radius * 0.02;
            return {
                re: center.re + (Math.random() - 0.5) * step,
                im: center.im + (Math.random() - 0.5) * step
            };
        }
        default:
            return center;
    }
}

// --- Space-filling curve helpers ---

// Moore curve (closed Hilbert variant) via L-system turtle ‚Äî guarantees continuous path
// Axiom: LFL+F+LFL, L ‚Üí -RF+LFL+FR-, R ‚Üí +LF-RFR-FL+
// + = turn right (CW), - = turn left (CCW)
function _mooreXY(d, order) {
    if (!_mooreXY._cache || _mooreXY._order !== order) {
        // Expand L-system string
        let str = "LFL+F+LFL";
        for (let i = 0; i < order - 1; i++) {
            let next = "";
            for (const ch of str) {
                if (ch === 'L') next += "-RF+LFL+FR-";
                else if (ch === 'R') next += "+LF-RFR-FL+";
                else next += ch;
            }
            str = next;
        }
        // Walk turtle ‚Äî start facing up, + = CW, - = CCW
        const dx = [1, 0, -1, 0], dy = [0, 1, 0, -1];
        let x = 0, y = 0, angle = 1; // 1 = up
        let minX = 0, maxX = 0, minY = 0, maxY = 0;
        const raw = [[0, 0]];
        for (const ch of str) {
            if (ch === 'F') {
                x += dx[angle]; y += dy[angle];
                raw.push([x, y]);
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
            } else if (ch === '+') {
                angle = (angle + 3) % 4; // CW
            } else if (ch === '-') {
                angle = (angle + 1) % 4; // CCW
            }
        }
        // Normalize to [-1, 1]
        const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
        const span = Math.max(maxX - minX, maxY - minY) || 1;
        _mooreXY._cache = raw.map(([px, py]) => [2 * (px - cx) / span, 2 * (py - cy) / span]);
        _mooreXY._order = order;
    }
    const pts = _mooreXY._cache;
    return pts[((d % pts.length) + pts.length) % pts.length];
}
// Peano curve via L-system turtle ‚Äî guarantees continuous path
// Axiom: L, L ‚Üí LFRFL-F-RFLFR+F+LFRFL, R ‚Üí RFLFR+F+LFRFL-F-RFLFR
function _peanoXY(d, order) {
    if (!_peanoXY._cache || _peanoXY._order !== order) {
        let str = "L";
        for (let i = 0; i < order; i++) {
            let next = "";
            for (const ch of str) {
                if (ch === 'L') next += "LFRFL-F-RFLFR+F+LFRFL";
                else if (ch === 'R') next += "RFLFR+F+LFRFL-F-RFLFR";
                else next += ch;
            }
            str = next;
        }
        const dx = [1, 0, -1, 0], dy = [0, 1, 0, -1];
        let x = 0, y = 0, angle = 0; // start facing right
        let minX = 0, maxX = 0, minY = 0, maxY = 0;
        const raw = [[0, 0]];
        for (const ch of str) {
            if (ch === 'F') {
                x += dx[angle]; y += dy[angle];
                raw.push([x, y]);
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
            } else if (ch === '+') {
                angle = (angle + 3) % 4; // CW
            } else if (ch === '-') {
                angle = (angle + 1) % 4; // CCW
            }
        }
        const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
        const span = Math.max(maxX - minX, maxY - minY) || 1;
        _peanoXY._cache = raw.map(([px, py]) => [2 * (px - cx) / span, 2 * (py - cy) / span]);
        _peanoXY._order = order;
    }
    const pts = _peanoXY._cache;
    return pts[((d % pts.length) + pts.length) % pts.length];
}

// Sierpinski arrowhead curve via L-system turtle ‚Äî triangle-filling path
// Axiom: A (even order) or B (odd order), A ‚Üí B-A-B, B ‚Üí A+B+A
// + = turn left 60¬∞, - = turn right 60¬∞, F at depth 0
// 3^order segments, NOT naturally closed ‚Äî animation uses out-and-back
function _sierpinskiXY(d, order) {
    if (!_sierpinskiXY._cache || _sierpinskiXY._order !== order) {
        const n = Math.pow(3, order); // 3^order segments
        let moves = "";
        function expand(ch, depth) {
            if (depth === 0) { moves += "F"; return; }
            if (ch === "A") {
                expand("B", depth - 1); moves += "-";
                expand("A", depth - 1); moves += "-";
                expand("B", depth - 1);
            } else {
                expand("A", depth - 1); moves += "+";
                expand("B", depth - 1); moves += "+";
                expand("A", depth - 1);
            }
        }
        expand(order % 2 === 0 ? "A" : "B", order);
        let angle = 0;
        if (order % 2 === 1) angle = 1;
        let x = 0, y = 0;
        let minX = 0, maxX = 0, minY = 0, maxY = 0;
        const raw = [[0, 0]];
        for (const ch of moves) {
            if (ch === "F") {
                const a = angle * Math.PI / 3;
                x += Math.cos(a); y += Math.sin(a);
                raw.push([x, y]);
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
            } else if (ch === "+") {
                angle = (angle + 1) % 6;
            } else if (ch === "-") {
                angle = ((angle - 1) % 6 + 6) % 6;
            }
        }
        const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
        const span = Math.max(maxX - minX, maxY - minY) || 1;
        _sierpinskiXY._cache = raw.map(([px, py]) => [2 * (px - cx) / span, 2 * (py - cy) / span]);
        _sierpinskiXY._order = order;
        _sierpinskiXY._n = n; // number of segments (n+1 points)
    }
    const pts = _sierpinskiXY._cache;
    return pts[((d % pts.length) + pts.length) % pts.length];
}

// --- Animation engine ---

const COEFF_TRAIL_SAMPLES = 200; // points per analytical curve (basic paths)
const COEFF_TRAIL_SAMPLES_HI = 1500; // points for space-filling curves (need more to capture zigzags)
const _HIRES_PATHS = new Set(["hilbert", "peano", "sierpinski"]);

// Compute a closed curve of absolute positions for a coefficient.
// curve[0] = {homeRe, homeIm} (the "home" position). Angle rotates the shape.
function computeCurve(homeRe, homeIm, pathType, radius, angle) {
    const N = _HIRES_PATHS.has(pathType) ? COEFF_TRAIL_SAMPLES_HI : COEFF_TRAIL_SAMPLES;
    const origin = { re: 0, im: 0 };
    const d0 = animPathFn(pathType, 0, origin, radius);
    const cosA = Math.cos(angle * 2 * Math.PI);
    const sinA = Math.sin(angle * 2 * Math.PI);
    const curve = new Array(N);
    for (let k = 0; k < N; k++) {
        const t = k / N;
        const pt = animPathFn(pathType, t, origin, radius);
        const dx = pt.re - d0.re, dy = pt.im - d0.im;
        curve[k] = { re: homeRe + dx * cosA - dy * sinA,
                      im: homeIm + dx * sinA + dy * cosA };
    }
    return curve;
}

// Recompute curves using the coefficient's current position as home (curve[0]).
// The coefficient is always on the new path. Angle and radius come from the path settings.
function computePathCurves(path) {
    const absRadius = path.radius / 100 * coeffExtent();
    for (const idx of path.coeffs) {
        const c = coefficients[idx];
        c.curve = computeCurve(c.re, c.im, path.pathType, absRadius, path.angle);
    }
}

// Transform existing curve points in place. Two separate operations:
//   Radius change ‚Üí scale around centroid (preserves geometric center)
//   Angle change  ‚Üí rotate around curve[0] (home), matching computeCurve semantics
// Snap coefficient to nearest point. Preserves elapsedAtPause.
function transformPathCurves(path, oldRadius, oldAngle) {
    for (const idx of path.coeffs) {
        const c = coefficients[idx];
        if (!c.curve) continue;

        // Step 1: Scale around coefficient's current position (radius change)
        if (path.radius !== oldRadius && oldRadius > 0) {
            const scale = path.radius / oldRadius;
            const ax = c.re, ay = c.im;
            for (const pt of c.curve) {
                pt.re = ax + (pt.re - ax) * scale;
                pt.im = ay + (pt.im - ay) * scale;
            }
        }

        // Step 2: Rotate around coefficient's current position (angle change)
        if (path.angle !== oldAngle) {
            const dA = (path.angle - oldAngle) * 2 * Math.PI;
            const cosA = Math.cos(dA), sinA = Math.sin(dA);
            const hx = c.re, hy = c.im;
            for (const pt of c.curve) {
                const dx = pt.re - hx, dy = pt.im - hy;
                pt.re = hx + dx * cosA - dy * sinA;
                pt.im = hy + dx * sinA + dy * cosA;
            }
        }

        // Snap coefficient to nearest point on transformed curve
        let bestIdx = 0, bestDist = Infinity;
        for (let k = 0; k < c.curve.length; k++) {
            const d2 = (c.curve[k].re - c.re) ** 2 + (c.curve[k].im - c.im) ** 2;
            if (d2 < bestDist) { bestDist = d2; bestIdx = k; }
        }
        c.re = c.curve[bestIdx].re;
        c.im = c.curve[bestIdx].im;
    }
}

// Derive re/im for all coefficients in a path by interpolating their absolute curve points.
function syncCoeffPositions(path, curveIdx) {
    for (const idx of path.coeffs) {
        const curve = coefficients[idx].curve;
        if (!curve) continue;
        const N = curve.length;
        const lo = Math.floor(curveIdx) % N;
        const hi = (lo + 1) % N;
        const frac = curveIdx - Math.floor(curveIdx);
        coefficients[idx].re = curve[lo].re * (1 - frac) + curve[hi].re * frac;
        coefficients[idx].im = curve[lo].im * (1 - frac) + curve[hi].im * frac;
    }
}

function startAnimation() {
    if (animPaths.length === 0) return;

    const resuming = animState.elapsedAtPause != null;

    if (!resuming) {
        // Fresh start: snap all animated coefficients to their home (curve[0])
        for (const path of animPaths) {
            for (const idx of path.coeffs) {
                if (coefficients[idx].curve) {
                    coefficients[idx].re = coefficients[idx].curve[0].re;
                    coefficients[idx].im = coefficients[idx].curve[0].im;
                }
            }
        }
    }

    animState.playing = true;
    if (resuming) {
        // Resume: adjust startTime so elapsed picks up where it left off
        animState.startTime = performance.now() - animState.elapsedAtPause * 1000;
        animState.elapsedAtPause = null;
    } else {
        animState.startTime = performance.now();
    }
    animState.rafId = requestAnimationFrame(animLoop);
}

// Collect all coefficient indices across all paths
function allPathCoeffs() {
    const s = new Set();
    for (const p of animPaths) for (const idx of p.coeffs) s.add(idx);
    return s;
}

function animLoop(now) {
    if (!animState.playing || animPaths.length === 0) return;
    const elapsed = (now - animState.startTime) / 1000;

    // Advance each path using per-coefficient curves + interpolation
    for (const path of animPaths) {
        if (path.pathType === "none") {
            // None: no movement at all
            continue;
        } else if (path.pathType === "random") {
            // Random walk: special case (not precomputed)
            for (const idx of path.coeffs) {
                const step = (path.radius / 100 * coeffExtent()) * 0.02;
                coefficients[idx].re += (Math.random() - 0.5) * step;
                coefficients[idx].im += (Math.random() - 0.5) * step;
            }
        } else {
            const N = _HIRES_PATHS.has(path.pathType) ? COEFF_TRAIL_SAMPLES_HI : COEFF_TRAIL_SAMPLES;
            const t = elapsed * path.speed * (path.ccw ? -1 : 1);
            const rawIdx = ((t % 1) + 1) % 1 * N; // normalize to [0, N)
            syncCoeffPositions(path, rawIdx);
        }
    }

    // Update visuals for all animated coefficients
    const animated = allPathCoeffs();
    coeffLayer.selectAll("circle.coeff")
        .filter(cd => animated.has(cd._idx))
        .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
    coeffLayer.selectAll(".coeff-label")
        .filter(ld => animated.has(ld._idx))
        .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);

    autoScaleCoeffPanel();
    solveRootsThrottled();
    renderDomainColoringThrottled();
    recordTick();

    animState.rafId = requestAnimationFrame(animLoop);
}

function stopAnimation() {
    if (animState.playing) {
        animState.elapsedAtPause = (performance.now() - animState.startTime) / 1000;
    }
    animState.playing = false;
    if (animState.rafId) {
        cancelAnimationFrame(animState.rafId);
        animState.rafId = null;
    }
    if (anySoundEnabled()) resetAudioState();
}

// --- Render coefficients ---

function renderCoefficients() {
    // Auto-scale coeff panel to fit all coefficients
    const needed = computeRange(coefficients);
    updatePanelRange(coeffSvg, panels.coeff, needed);

    const n = coefficients.length;
    for (let i = 0; i < n; i++) coefficients[i]._idx = i;

    const circles = coeffLayer.selectAll("circle.coeff").data(coefficients, d => d._idx);

    circles.enter()
        .append("circle")
        .attr("class", "coeff")
        .attr("r", 10)
        .attr("stroke", "#fff")
        .call(drag)
        .on("mouseover", function (event, d) { showTooltip(event, d.re, d.im); })
        .on("mouseout", hideTooltip)
      .merge(circles)
        .attr("cx", d => cxs()(d.re))
        .attr("cy", d => cys()(d.im))
        .attr("fill", (_, i) => coeffColor(i, n));

    circles.exit().remove();

    const labels = coeffLayer.selectAll(".coeff-label").data(coefficients, d => d._idx);

    labels.enter()
        .append("text")
        .attr("class", "coeff-label")
      .merge(labels)
        .attr("x", d => cxs()(d.re) + 12)
        .attr("y", d => cys()(d.im) + 4)
        .text((_, i) => `c${subscript(n - 1 - i)}`);

    labels.exit().remove();
}

function subscript(n) {
    const digits = "‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ";
    return String(n).split("").map(d => digits[+d]).join("");
}

// --- Root drag behavior (roots ‚Üí coefficients) ---

let rootDragMoved = false;
let rootDragStartX = 0, rootDragStartY = 0;
const rootDrag = d3.drag()
    .on("start", function (event) {
        rootDragMoved = false;
        rootDragStartX = event.x;
        rootDragStartY = event.y;
        d3.select(this).raise().classed("dragging", true);
    })
    .on("drag", function (event, d) {
        if (!rootDragMoved && Math.hypot(event.x - rootDragStartX, event.y - rootDragStartY) < CLICK_DEAD_ZONE) return;
        rootDragMoved = true;
        const newRe = rxs().invert(event.x);
        const newIm = rys().invert(event.y);
        const idx = d._idx;

        if (selectedRoots.has(idx) && selectedRoots.size > 1) {
            // Group drag: apply delta to all selected roots
            const deltaRe = newRe - d.re;
            const deltaIm = newIm - d.im;
            for (const si of selectedRoots) {
                currentRoots[si].re += deltaRe;
                currentRoots[si].im += deltaIm;
            }
            rootsLayer.selectAll("circle.root")
                .attr("cx", rd => rxs()(rd.re)).attr("cy", rd => rys()(rd.im));
        } else {
            d.re = newRe;
            d.im = newIm;
            d3.select(this).attr("cx", rxs()(d.re)).attr("cy", rys()(d.im));
        }
        showTooltip(event.sourceEvent, d.re, d.im);
        autoScaleRootsPanel();
        // Recompute coefficients from current roots (all client-side)
        const rootsForCoeffs = currentRoots.map(r => ({ re: r.re, im: r.im }));
        const newCoeffs = rootsToCoefficients(rootsForCoeffs);
        // Update coefficient positions in-place, preserving curves and path assignments
        for (let ci = 0; ci < newCoeffs.length; ci++) {
            const deltaRe = newCoeffs[ci].re - coefficients[ci].re;
            const deltaIm = newCoeffs[ci].im - coefficients[ci].im;
            coefficients[ci].re = newCoeffs[ci].re;
            coefficients[ci].im = newCoeffs[ci].im;
            if (coefficients[ci].curve) {
                for (const pt of coefficients[ci].curve) {
                    pt.re += deltaRe;
                    pt.im += deltaIm;
                }
            }
        }
        if (animPaths.length > 0) renderCoeffTrails();
        renderCoefficients();
        renderDomainColoringThrottled();
        if (anySoundEnabled()) updateAudio();
    })
    .on("end", function (event, d) {
        d3.select(this).classed("dragging", false);
        hideTooltip();
        // Click detection: if mouse didn't move, toggle root selection
        if (!rootDragMoved) {
            const idx = d._idx;
            clearCoeffSelection();
            if (selectedRoots.has(idx)) {
                selectedRoots.delete(idx);
            } else {
                selectedRoots.add(idx);
            }
            updateRootSelectionVisual();
        }
    });

function autoScaleRootsPanel() {
    let needed = computeRange(currentRoots);
    if (animState.playing) needed = Math.max(needed, panels.roots.range);
    if (needed !== panels.roots.range) {
        updatePanelRange(rootsSvg, panels.roots, needed);
        rootsLayer.selectAll("circle.root")
            .attr("cx", d => rxs()(d.re)).attr("cy", d => rys()(d.im));
    }
}

// --- Render roots ---

function renderRoots(newRoots) {
    // Update persistent root data
    while (currentRoots.length < newRoots.length) currentRoots.push({ re: 0, im: 0 });
    currentRoots.length = newRoots.length;
    for (let i = 0; i < newRoots.length; i++) {
        currentRoots[i].re = newRoots[i].re;
        currentRoots[i].im = newRoots[i].im;
    }

    // Auto-scale roots panel (zoom-out only during animation)
    let needed = computeRange(currentRoots);
    if (animState.playing) needed = Math.max(needed, panels.roots.range);
    updatePanelRange(rootsSvg, panels.roots, needed);
    renderDomainColoringThrottled();

    const n = currentRoots.length;
    for (let i = 0; i < n; i++) currentRoots[i]._idx = i;

    if (rootColorMode === "derivative") computeRootSensitivities();

    const circles = rootsLayer.selectAll("circle.root").data(currentRoots, d => d._idx);
    circles.enter()
        .append("circle")
        .attr("class", "root")
        .attr("r", 7)
        .attr("stroke", "#fff")
        .attr("stroke-width", 1)
        .call(rootDrag)
        .on("mouseover", function (event, d) { showTooltip(event, d.re, d.im); })
        .on("mouseout", hideTooltip)
      .merge(circles)
        .attr("cx", d => rxs()(d.re))
        .attr("cy", d => rys()(d.im))
        .attr("fill", (_, i) => rootColor(i, n));

    circles.exit().remove();

    // Collect stats snapshot
    collectStatsSnapshot();
    if (activeTab === "stats" && statsState.dirty) drawAllStatsPlots();

    // Record trail points during animation
    if (trailsEnabled && animState.playing && !trailComplete) {
        // Initialize trail arrays if needed
        while (trailData.length < n) trailData.push([]);
        trailData.length = n;
        for (let i = 0; i < n; i++) {
            trailData[i].push({ re: currentRoots[i].re, im: currentRoots[i].im });
            if (trailData[i].length > MAX_TRAIL_POINTS) trailData[i].shift();
        }
        // Check for loop closure: all roots back near their starting positions
        const len = trailData[0].length;
        if (len > TRAIL_MIN_POINTS) {
            let closed = true;
            for (let i = 0; i < n; i++) {
                const start = trailData[i][0];
                const cur = trailData[i][len - 1];
                const dist = Math.hypot(cur.re - start.re, cur.im - start.im);
                if (dist > panels.roots.range * 0.01) { closed = false; break; }
            }
            if (closed) {
                trailComplete = true;
                if (vidRec.recording) stopRecording();
            }
        }
        renderTrails();
    }
    if (anySoundEnabled()) updateAudio();
}

function renderTrails() {
    const xScale = rxs(), yScale = rys();
    const n = trailData.length;
    const jumpThresh = panels.roots.range * 0.3; // 30% of visible range = likely a root swap
    const paths = trailLayer.selectAll("path.trail-path").data(trailData);
    paths.enter()
        .append("path")
        .attr("class", "trail-path")
      .merge(paths)
        .attr("d", pts => {
            if (pts.length < 2) return "";
            let d = `M${xScale(pts[0].re)},${yScale(pts[0].im)}`;
            for (let j = 1; j < pts.length; j++) {
                const dist = Math.hypot(pts[j].re - pts[j-1].re, pts[j].im - pts[j-1].im);
                const cmd = dist > jumpThresh ? "M" : "L";
                d += `${cmd}${xScale(pts[j].re)},${yScale(pts[j].im)}`;
            }
            return d;
        })
        .attr("stroke", (_, i) => rootColor(i, n));
    paths.exit().remove();
}

function renderCoeffTrails() {
    // Draw the absolute curve points for each coefficient that has a curve.
    const xScale = cxs(), yScale = cys();
    const curveData = [];

    for (const path of animPaths) {
        if (path.pathType === "random" || path.pathType === "none") continue;
        for (const idx of path.coeffs) {
            if (coefficients[idx].curve) curveData.push({ idx });
        }
    }

    const nCoeff = coefficients.length;
    const paths = coeffTrailLayer.selectAll("path.trail-path").data(curveData, d => d.idx);
    paths.enter()
        .append("path")
        .attr("class", "trail-path")
      .merge(paths)
        .attr("d", ({ idx }) => {
            const curve = coefficients[idx].curve;
            const N = curve.length;
            let d = "";
            for (let k = 0; k <= N; k++) {
                const pt = curve[k % N];
                d += (k === 0 ? "M" : "L") + xScale(pt.re) + "," + yScale(pt.im);
            }
            return d + "Z";
        })
        .attr("stroke", ({ idx }) => coeffColor(idx, nCoeff));
    paths.exit().remove();
}

function clearTrails() {
    trailData = [];
    trailComplete = false;
    trailLayer.selectAll("path.trail-path").remove();
    // Coefficient paths are always visible ‚Äî don't clear them here
}


// --- Domain coloring ---

function hueToChannel(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1/6) return p + (q - p) * 6 * t;
    if (t < 1/2) return q;
    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
    return p;
}

function hslToRgb(h, s, l) {
    if (s === 0) return [Math.round(l * 255), Math.round(l * 255), Math.round(l * 255)];
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return [
        Math.round(hueToChannel(p, q, h + 1/3) * 255),
        Math.round(hueToChannel(p, q, h) * 255),
        Math.round(hueToChannel(p, q, h - 1/3) * 255)
    ];
}

function renderDomainColoring() {
    if (!domainColoringEnabled) return;

    const range = panels.roots.range;
    // Measure actual SVG position to align canvas precisely
    // (SVG may be centered by text-align:center, shifted by border, etc.)
    const svgEl = document.getElementById("roots-panel");
    const container = document.getElementById("roots-container");
    const svgRect = svgEl.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    const borderW = parseFloat(getComputedStyle(svgEl).borderLeftWidth) || 0;
    const contentW = svgRect.width - 2 * borderW;
    const vbScale = contentW / S; // viewBox units ‚Üí CSS pixels
    const plotSize = (S - 2 * MARGIN) * vbScale;
    const plotLeft = (svgRect.left - containerRect.left) + borderW + MARGIN * vbScale;
    const plotTop = (svgRect.top - containerRect.top) + borderW + MARGIN * vbScale;
    const dpr = window.devicePixelRatio || 1;
    const canvasW = Math.max(1, Math.floor(plotSize * DOMAIN_RES_SCALE * dpr));
    const canvasH = canvasW;

    domainCanvas.width = canvasW;
    domainCanvas.height = canvasH;
    domainCanvas.style.width = plotSize + "px";
    domainCanvas.style.height = plotSize + "px";
    domainCanvas.style.left = plotLeft + "px";
    domainCanvas.style.top = plotTop + "px";

    const imageData = domainCtx.createImageData(canvasW, canvasH);
    const data = imageData.data;

    const n = coefficients.length;
    if (n === 0) { domainCtx.putImageData(imageData, 0, 0); return; }

    // Precompute coefficient arrays for Horner's method
    const cRe = new Float64Array(n);
    const cIm = new Float64Array(n);
    for (let k = 0; k < n; k++) {
        cRe[k] = coefficients[k].re;
        cIm[k] = coefficients[k].im;
    }

    const TWO_PI = 2 * Math.PI;
    const INV_PI_180 = 180 / Math.PI;

    for (let py = 0; py < canvasH; py++) {
        const im = range - (2 * range * (py + 0.5)) / canvasH;
        for (let px = 0; px < canvasW; px++) {
            const re = -range + (2 * range * (px + 0.5)) / canvasW;

            // Horner's method: p(z) = c[0]*z^(n-1) + c[1]*z^(n-2) + ... + c[n-1]
            let pRe = cRe[0], pIm = cIm[0];
            for (let k = 1; k < n; k++) {
                const newRe = pRe * re - pIm * im + cRe[k];
                const newIm = pRe * im + pIm * re + cIm[k];
                pRe = newRe;
                pIm = newIm;
            }

            // Hue from argument
            let hue = Math.atan2(pIm, pRe) * INV_PI_180;
            if (hue < 0) hue += 360;

            // Lightness with log-modulus contour lines
            const mod2 = pRe * pRe + pIm * pIm;
            let lightness;
            if (mod2 < 1e-600) {
                lightness = 0;
            } else {
                const logMod = 0.5 * Math.log2(mod2); // = log2(|p(z)|)
                const frac = logMod - Math.floor(logMod);
                lightness = 0.5 + 0.4 * Math.cos(TWO_PI * frac);
            }

            const [r, g, b] = hslToRgb(hue / 360, 0.8, lightness);
            const idx = (py * canvasW + px) * 4;
            data[idx] = r;
            data[idx + 1] = g;
            data[idx + 2] = b;
            data[idx + 3] = 255;
        }
    }
    domainCtx.putImageData(imageData, 0, 0);
}

function renderDomainColoringThrottled() {
    if (!domainPendingRender) {
        domainPendingRender = true;
        requestAnimationFrame(() => {
            renderDomainColoring();
            domainPendingRender = false;
        });
    }
}

// --- Ehrlich-Aberth client-side root solver ---

function solveRootsEA(coeffs, warmStart) {
    // coeffs: array of {re, im} in descending degree order
    // warmStart: array of {re, im} initial guesses (or null)
    // Returns: array of {re, im} roots

    // Strip leading near-zero coefficients
    let start = 0;
    while (start < coeffs.length - 1 && Math.hypot(coeffs[start].re, coeffs[start].im) < 1e-15) {
        start++;
    }
    const c = coeffs.slice(start);
    const degree = c.length - 1;
    if (degree <= 0) return [];

    // Degree 1: linear case c[0]*z + c[1] = 0
    if (degree === 1) {
        const aRe = c[0].re, aIm = c[0].im;
        const bRe = c[1].re, bIm = c[1].im;
        const denom = aRe * aRe + aIm * aIm;
        if (denom < 1e-30) return [];
        return [{ re: -(bRe * aRe + bIm * aIm) / denom, im: -(bIm * aRe - bRe * aIm) / denom }];
    }

    const MAX_ITER = 100;
    const TOL = 1e-12;

    // Initialize root guesses
    const roots = new Array(degree);
    if (warmStart && warmStart.length === degree) {
        for (let i = 0; i < degree; i++) {
            roots[i] = [warmStart[i].re, warmStart[i].im];
        }
    } else {
        // Spread initial guesses on a circle with radius from coefficient ratio
        const leadMod = Math.hypot(c[0].re, c[0].im);
        const trailMod = Math.hypot(c[degree].re, c[degree].im);
        const radius = leadMod > 1e-30
            ? Math.max(0.1, Math.min(Math.pow(trailMod / leadMod, 1 / degree), 10))
            : 1;
        for (let i = 0; i < degree; i++) {
            const angle = (2 * Math.PI * i) / degree + 0.37; // offset to break symmetry
            roots[i] = [radius * Math.cos(angle), radius * Math.sin(angle)];
        }
    }

    // Precompute coefficient arrays for Horner's method
    const n = c.length;
    const cRe = new Float64Array(n);
    const cIm = new Float64Array(n);
    for (let k = 0; k < n; k++) {
        cRe[k] = c[k].re;
        cIm[k] = c[k].im;
    }

    // Iterate
    for (let iter = 0; iter < MAX_ITER; iter++) {
        let maxCorr = 0;

        for (let i = 0; i < degree; i++) {
            const zRe = roots[i][0], zIm = roots[i][1];

            // Evaluate p(z) and p'(z) simultaneously via Horner
            let pRe = cRe[0], pIm = cIm[0];
            let dpRe = 0, dpIm = 0;
            for (let k = 1; k < n; k++) {
                // dp = dp * z + p
                const ndRe = dpRe * zRe - dpIm * zIm + pRe;
                const ndIm = dpRe * zIm + dpIm * zRe + pIm;
                dpRe = ndRe;
                dpIm = ndIm;
                // p = p * z + c[k]
                const npRe = pRe * zRe - pIm * zIm + cRe[k];
                const npIm = pRe * zIm + pIm * zRe + cIm[k];
                pRe = npRe;
                pIm = npIm;
            }

            // Newton step: w = p(z) / p'(z)
            const dpMod2 = dpRe * dpRe + dpIm * dpIm;
            if (dpMod2 < 1e-60) continue;
            const wRe = (pRe * dpRe + pIm * dpIm) / dpMod2;
            const wIm = (pIm * dpRe - pRe * dpIm) / dpMod2;

            // Aberth sum: S = Œ£_{j‚â†i} 1/(z_i - z_j)
            let sRe = 0, sIm = 0;
            for (let j = 0; j < degree; j++) {
                if (j === i) continue;
                const dRe = zRe - roots[j][0];
                const dIm = zIm - roots[j][1];
                const dMod2 = dRe * dRe + dIm * dIm;
                if (dMod2 < 1e-60) continue;
                sRe += dRe / dMod2;
                sIm += -dIm / dMod2;
            }

            // Aberth correction: correction = w / (1 - w * S)
            const wsRe = wRe * sRe - wIm * sIm;
            const wsIm = wRe * sIm + wIm * sRe;
            const denomRe = 1 - wsRe;
            const denomIm = -wsIm;
            const denomMod2 = denomRe * denomRe + denomIm * denomIm;
            if (denomMod2 < 1e-60) continue;

            const corrRe = (wRe * denomRe + wIm * denomIm) / denomMod2;
            const corrIm = (wIm * denomRe - wRe * denomIm) / denomMod2;

            roots[i][0] -= corrRe;
            roots[i][1] -= corrIm;

            maxCorr = Math.max(maxCorr, Math.hypot(corrRe, corrIm));
        }

        if (maxCorr < TOL) break;
    }

    // Filter NaN/Inf and return
    const result = [];
    for (let i = 0; i < degree; i++) {
        if (isFinite(roots[i][0]) && isFinite(roots[i][1])) {
            result.push({ re: roots[i][0], im: roots[i][1] });
        }
    }
    return result;
}

// Greedy nearest-neighbor matching: reorder newRoots to best match oldRoots indices.
// Preserves root identity across frames so trails track the same root continuously.
function matchRootOrder(newRoots, oldRoots) {
    if (oldRoots.length === 0 || newRoots.length !== oldRoots.length) return newRoots;
    const n = newRoots.length;
    const used = new Uint8Array(n); // which newRoots indices are taken
    const result = new Array(n);
    for (let i = 0; i < n; i++) {
        let bestJ = -1, bestDist = Infinity;
        for (let j = 0; j < n; j++) {
            if (used[j]) continue;
            const d2 = (newRoots[j].re - oldRoots[i].re) ** 2 + (newRoots[j].im - oldRoots[i].im) ** 2;
            if (d2 < bestDist) { bestDist = d2; bestJ = j; }
        }
        result[i] = newRoots[bestJ];
        used[bestJ] = 1;
    }
    return result;
}

function solveRoots() {
    let roots = solveRootsEA(coefficients, currentRoots);
    roots = matchRootOrder(roots, currentRoots);
    renderRoots(roots);
}

function solveRootsThrottled() {
    if (!pendingSolve) {
        pendingSolve = true;
        requestAnimationFrame(() => {
            solveRoots();
            pendingSolve = false;
        });
    }
}

// --- Degree input ---

const degreeNumber = document.getElementById("degree-number");
let currentDegree = 5;

function applyPattern() {
    stopAnimation();
    playBtn.textContent = "‚ñ∂ Play";
    animPaths = [];
    viewedPathIdx = 0;
    nextPathId = 1;
    clearAllSelection();
    clearTrails();
    clearStatsData();
    resetAudioState();
    renderCoeffTrails(); // remove stale coefficient path SVGs
    currentRoots = [];
    rootsLayer.selectAll("circle.root").remove();
    updatePanelRange(rootsSvg, panels.roots, MIN_RANGE);
    initCoefficients(currentDegree);
    renderCoefficients();
    solveRoots();
    renderDomainColoring();
}

function setDegree(v) {
    v = Math.max(3, Math.min(30, Math.round(v)));
    if (v === currentDegree) return;
    currentDegree = v;
    degreeNumber.textContent = v;
    applyPattern();
}

// Degree popover (horizontal slider 3‚Äì30)
let degreePopEl = null;
let degreeToolActive = false;

function closeDegreePopover() {
    if (degreePopEl) { degreePopEl.classList.remove("open"); degreePopEl.innerHTML = ""; }
    degreeNumber.classList.remove("tool-active");
    degreeToolActive = false;
    window.removeEventListener("mousemove", degreeDragMove);
    window.removeEventListener("mouseup", degreeDragUp);
}
let degreeDragMove = null;
let degreeDragUp = null;

degreeNumber.addEventListener("click", function(e) {
    e.stopPropagation();
    if (degreeToolActive) { closeDegreePopover(); return; }
    // close any ops tool first
    if (typeof closeOpTool === "function") closeOpTool();
    degreeToolActive = true;
    degreeNumber.classList.add("tool-active");

    if (!degreePopEl) degreePopEl = document.getElementById("degree-pop");
    degreePopEl.innerHTML = "";

    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Degree";
    const valEl = document.createElement("div");
    valEl.className = "pop-val";
    valEl.textContent = currentDegree;

    const slider = document.createElement("div");
    slider.className = "hslider";
    slider.style.width = "180px";
    const thumb = document.createElement("div");
    thumb.className = "hslider-thumb";
    slider.appendChild(thumb);

    // ticks
    const tickRow = document.createElement("div");
    tickRow.className = "pop-row";
    tickRow.style.justifyContent = "space-between";
    tickRow.style.width = "180px";
    tickRow.style.fontSize = "9px";
    tickRow.textContent = "3 ‚Äî 30";

    function uFromDeg(d) { return (d - 3) / (30 - 3); }
    function degFromU(u) { return Math.round(3 + u * (30 - 3)); }
    let u = uFromDeg(currentDegree);

    function updateVisual() {
        thumb.style.left = (u * 100) + "%";
        const d = degFromU(u);
        valEl.textContent = d;
    }

    function setFromX(clientX) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        updateVisual();
        setDegree(degFromU(u));
    }

    let dragging = false;
    slider.addEventListener("mousedown", ev => {
        dragging = true; setFromX(ev.clientX); ev.preventDefault();
    });
    degreeDragMove = ev => { if (dragging) setFromX(ev.clientX); };
    degreeDragUp = () => { dragging = false; };
    window.addEventListener("mousemove", degreeDragMove);
    window.addEventListener("mouseup", degreeDragUp);

    updateVisual();
    degreePopEl.appendChild(title);
    degreePopEl.appendChild(slider);
    degreePopEl.appendChild(valEl);
    degreePopEl.appendChild(tickRow);
    degreePopEl.classList.add("open");

    // position below the degree label
    const r = degreeNumber.getBoundingClientRect();
    degreePopEl.style.left = r.left + "px";
    degreePopEl.style.top = (r.bottom + 8) + "px";
});

// close degree popover on outside click
document.addEventListener("mousedown", function(e) {
    if (!degreeToolActive) return;
    if (degreePopEl && degreePopEl.contains(e.target)) return;
    if (degreeNumber.contains(e.target)) return;
    closeDegreePopover();
});
document.addEventListener("keydown", function(e) {
    if (e.key === "Escape" && degreeToolActive) { closeDegreePopover(); e.stopImmediatePropagation(); }
}, true);

document.getElementById("pattern").addEventListener("change", applyPattern);
document.getElementById("reset-btn").addEventListener("click", applyPattern);

document.getElementById("deselect-btn").addEventListener("click", clearAllSelection);

document.getElementById("select-all-btn").addEventListener("click", function () {
    clearRootSelection();
    for (let i = 0; i < coefficients.length; i++) selectedCoeffs.add(i);
    updateCoeffSelectionVisual();
    updateAnimBar();
});

document.getElementById("select-all-coeffs-btn").addEventListener("click", function () {
    clearRootSelection();
    for (let i = 0; i < coefficients.length; i++) selectedCoeffs.add(i);
    updateCoeffSelectionVisual();
    updateAnimBar();
});

const domainToggleBtn = document.getElementById("domain-toggle-btn");
domainToggleBtn.addEventListener("click", function () {
    domainColoringEnabled = !domainColoringEnabled;
    this.classList.toggle("active", domainColoringEnabled);
    domainCanvas.style.display = domainColoringEnabled ? "block" : "none";
    rootsSvg.classed("domain-active", domainColoringEnabled);
    if (domainColoringEnabled) renderDomainColoring();
});

// --- Root color popover ---
const colorPop = document.getElementById("color-pop");
const rootColorBtn = document.getElementById("root-color-btn");
let colorPopOpen = false;

function closeColorPop() {
    colorPop.classList.remove("open");
    colorPop.innerHTML = "";
    rootColorBtn.classList.remove("tool-active");
    colorPopOpen = false;
}

function refreshRootColors() {
    rootsLayer.selectAll("circle.root")
        .attr("fill", (_, i) => rootColor(i, currentRoots.length));
}

function buildColorPop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Root Color";
    pop.appendChild(title);

    const modes = [
        { key: "none", label: "None" },
        { key: "rainbow", label: "Index Rainbow" },
        { key: "derivative", label: "Derivative" },
    ];
    const rows = [];
    modes.forEach(m => {
        const row = document.createElement("div");
        row.className = "audio-toggle" + (rootColorMode === m.key ? " on" : "");
        const dot = document.createElement("span");
        dot.className = "toggle-dot";
        const lbl = document.createElement("span");
        lbl.className = "toggle-label"; lbl.textContent = m.label;
        row.appendChild(dot);
        row.appendChild(lbl);
        row.addEventListener("click", () => {
            rootColorMode = m.key;
            rootColorBtn.classList.toggle("active", rootColorMode !== "none");
            rows.forEach(r => r.classList.remove("on"));
            row.classList.add("on");
            if (rootColorMode === "derivative") computeRootSensitivities();
            refreshRootColors();
        });
        pop.appendChild(row);
        rows.push(row);
    });
}

rootColorBtn.addEventListener("click", function () {
    if (colorPopOpen) { closeColorPop(); return; }
    closeColorPop();
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeAudioPop === "function") closeAudioPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();
    colorPopOpen = true;
    rootColorBtn.classList.add("tool-active");
    colorPop.innerHTML = "";
    buildColorPop(colorPop);
    colorPop.classList.add("open");
    const r = rootColorBtn.getBoundingClientRect();
    colorPop.style.left = (r.right + 8) + "px";
    colorPop.style.top = r.top + "px";
});

// --- Coefficient picker popover ---
const coeffPickPop = document.getElementById("coeff-pick-pop");
const coeffPickerBtn = document.getElementById("coeff-picker-btn");
let coeffPickOpen = false;

function closeCoeffPick() {
    coeffPickPop.classList.remove("open");
    coeffPickPop.innerHTML = "";
    coeffPickerBtn.classList.remove("tool-active");
    coeffPickOpen = false;
}

function buildCoeffPickPop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Coefficients";
    pop.appendChild(title);

    const scrollBox = document.createElement("div");
    scrollBox.style.cssText = "max-height:184px;overflow-y:auto;width:100%;";

    const deg = coefficients.length - 1;
    const n = coefficients.length;
    const coeffSens = computeCoeffSensitivities();
    for (let i = 0; i < n; i++) {
        const row = document.createElement("div");
        row.className = "cpick-row";

        const dot = document.createElement("span");
        dot.className = "cpick-dot";
        dot.style.background = coeffColor(i, n);

        const sensDot = document.createElement("span");
        sensDot.className = "cpick-dot";
        sensDot.style.background = coeffSens ? sensitivityColor(coeffSens[i]) : "#555";

        const label = document.createElement("span");
        label.className = "cpick-label";
        label.textContent = "c" + i;

        const power = document.createElement("span");
        power.className = "cpick-power";
        const exp = deg - i;
        power.textContent = exp === 0 ? "1" : exp === 1 ? "z" : "z" + superscript(exp);

        const coords = document.createElement("span");
        coords.className = "cpick-coords";
        const c = coefficients[i];
        const sign = c.im >= 0 ? "+" : "";
        coords.textContent = c.re.toFixed(2) + sign + c.im.toFixed(2) + "i";

        const cb = document.createElement("span");
        cb.className = "cpick-cb" + (selectedCoeffs.has(i) ? " checked" : "");

        row.appendChild(cb);
        row.appendChild(dot);
        row.appendChild(sensDot);
        row.appendChild(label);
        row.appendChild(power);
        row.appendChild(coords);

        const idx = i;
        row.addEventListener("click", () => {
            clearRootSelection();
            if (selectedCoeffs.has(idx)) {
                selectedCoeffs.delete(idx);
                cb.classList.remove("checked");
            } else {
                selectedCoeffs.add(idx);
                cb.classList.add("checked");
            }
            updateCoeffSelectionVisual();
            updateAnimBar();
        });

        scrollBox.appendChild(row);
    }
    pop.appendChild(scrollBox);
}

function superscript(n) {
    const sup = "\u2070\u00B9\u00B2\u00B3\u2074\u2075\u2076\u2077\u2078\u2079";
    if (n < 10) return sup[n];
    return String(n).split("").map(d => sup[+d]).join("");
}

coeffPickerBtn.addEventListener("click", function () {
    if (coeffPickOpen) { closeCoeffPick(); return; }
    closeCoeffPick();
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeAudioPop === "function") closeAudioPop();
    if (typeof closeColorPop === "function") closeColorPop();
    coeffPickOpen = true;
    coeffPickerBtn.classList.add("tool-active");
    coeffPickPop.innerHTML = "";
    buildCoeffPickPop(coeffPickPop);
    coeffPickPop.classList.add("open");
    const r = coeffPickerBtn.getBoundingClientRect();
    coeffPickPop.style.left = (r.right + 8) + "px";
    coeffPickPop.style.top = r.top + "px";
});

// --- Audio instrument config popovers ---
const audioPop = document.getElementById("audio-pop");

function closeAudioPop() {
    audioPop.classList.remove("open");
    audioPop.innerHTML = "";
    if (activeAudioBtn) activeAudioBtn.classList.remove("tool-active");
    activeAudioBtn = null;
}

function openAudioPop(btnEl, buildFn) {
    if (activeAudioBtn === btnEl) { closeAudioPop(); return; }
    closeAudioPop();
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeColorPop === "function") closeColorPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();
    activeAudioBtn = btnEl;
    btnEl.classList.add("tool-active");
    audioPop.innerHTML = "";
    buildFn(audioPop);
    audioPop.classList.add("open");
    const r = btnEl.getBoundingClientRect();
    audioPop.style.left = (r.right + 8) + "px";
    audioPop.style.top = r.top + "px";
}

function toggleSound(flag, setFn, btnEl) {
    const wasAny = anySoundEnabled();
    setFn(flag);
    btnEl.classList.toggle("active", flag);
    const isAny = anySoundEnabled();
    if (isAny && !wasAny) {
        initAudio();
        if (audioCtx.state === "suspended") audioCtx.resume();
        audioWatchdogId = setInterval(audioWatchdog, 100);
    } else if (!isAny && wasAny) {
        if (audioWatchdogId) { clearInterval(audioWatchdogId); audioWatchdogId = null; }
        resetAudioState();
    }
}

const fmtHz = v => v < 100 ? v.toFixed(1) + " Hz" : Math.round(v) + " Hz";
const fmtMs = v => (v * 1000).toFixed(1) + " ms";
const fmtF = (d) => v => v.toFixed(d);
const fmtPct = v => (v * 100).toFixed(0) + "%";

function buildBasePop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Base";
    pop.appendChild(title);
    const btn = document.getElementById("base-toggle-btn");
    buildAudioToggle(pop, "Enabled", baseEnabled, on => toggleSound(on, v => { baseEnabled = v; }, btn));
    buildAudioSlider(pop, "Pitch",      55,    440,  baseConfig.freq,      true,  fmtHz,     v => { baseConfig.freq = v; });
    buildAudioSlider(pop, "Range",      0.5,   4.0,  baseConfig.octaves,   false, fmtF(1),   v => { baseConfig.octaves = v; });
    buildAudioSlider(pop, "FM Ratio",   0.5,   8.0,  baseConfig.modRatio,  false, v => "√ó" + v.toFixed(1), v => { baseConfig.modRatio = v; });
    buildAudioSlider(pop, "FM Depth",   0,     800,  baseConfig.modDepth,  false, fmtHz,     v => { baseConfig.modDepth = v; });
    buildAudioSlider(pop, "Bright",     50,    1000, baseConfig.filterLo,  true,  fmtHz,     v => { baseConfig.filterLo = v; });
    buildAudioSlider(pop, "Volume",     0.05,  0.50, baseConfig.gainRange, false, fmtF(2),   v => { baseConfig.gainRange = v; });
    buildAudioSlider(pop, "Vibrato",    0,     25,   baseConfig.vibDepth,  false, fmtF(1),   v => { baseConfig.vibDepth = v; });
}

function buildMelodyPop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Melody";
    pop.appendChild(title);
    const btn = document.getElementById("melody-toggle-btn");
    buildAudioToggle(pop, "Enabled", melodyEnabled, on => toggleSound(on, v => { melodyEnabled = v; }, btn));
    buildAudioSlider(pop, "Rate",       2,     60,   melodyConfig.rate,     true,  v => Math.round(v) + "/s", v => { melodyConfig.rate = v; });
    buildAudioSlider(pop, "Cutoff",     2,  currentDegree, Math.min(melodyConfig.cutoff, currentDegree), false, v => Math.round(v) + "",  v => { melodyConfig.cutoff = v; });
    buildAudioSlider(pop, "Volume",     0.02,  0.30, melodyConfig.peak,     false, fmtF(2),   v => { melodyConfig.peak = v; });
    buildAudioSlider(pop, "Attack",     0.001, 0.020, melodyConfig.attack,  true,  fmtMs,     v => { melodyConfig.attack = v; });
    buildAudioSlider(pop, "Decay",      0.010, 0.200, melodyConfig.decay,   true,  fmtMs,     v => { melodyConfig.decay = v; });
    buildAudioSlider(pop, "Bright",     200,   4000, melodyConfig.filterLo, true,  fmtHz,     v => { melodyConfig.filterLo = v; });
}

function buildVoicePop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Voice";
    pop.appendChild(title);
    const btn = document.getElementById("voice-toggle-btn");
    buildAudioToggle(pop, "Enabled", voiceEnabled, on => toggleSound(on, v => { voiceEnabled = v; }, btn));
    buildAudioSlider(pop, "Memory",     1.0,    1.02,  voiceConfig.decay,    true,  fmtF(4),  v => { voiceConfig.decay = v; });
    buildAudioSlider(pop, "Novelty",    0.3,   1.0,   voiceConfig.novelty,  false, fmtF(2),   v => { voiceConfig.novelty = v; });
    buildAudioSlider(pop, "Cooldown",   0.01,  0.50,  voiceConfig.cooldown, true,  fmtMs,     v => { voiceConfig.cooldown = v; });
    buildAudioSlider(pop, "Volume",     0.02,  0.30,  voiceConfig.peak,     false, fmtF(2),   v => { voiceConfig.peak = v; });
    buildAudioSlider(pop, "Attack",     0.001, 0.020, voiceConfig.attack,   true,  fmtMs,     v => { voiceConfig.attack = v; });
    buildAudioSlider(pop, "Decay",      0.01,  0.30,  voiceConfig.ringdown, true,  fmtMs,     v => { voiceConfig.ringdown = v; });
}

document.getElementById("base-toggle-btn").addEventListener("click", function () { openAudioPop(this, buildBasePop); });
document.getElementById("melody-toggle-btn").addEventListener("click", function () { openAudioPop(this, buildMelodyPop); });
document.getElementById("voice-toggle-btn").addEventListener("click", function () { openAudioPop(this, buildVoicePop); });

document.addEventListener("visibilitychange", function () {
    if (document.hidden && audioNodes && audioCtx) {
        audioNodes.masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.02);
    }
});

document.addEventListener("keydown", function (e) {
    if (e.key === "Escape") {
        if (typeof activeToolBtn !== "undefined" && activeToolBtn) { closeOpTool(); return; }
        if (activeAudioBtn) { closeAudioPop(); return; }
        if (colorPopOpen) { closeColorPop(); return; }
        if (coeffPickOpen) { closeCoeffPick(); return; }
        clearAllSelection();
    }
});

// --- Transform tools (popover with live preview) ---

const opsPop = document.getElementById("ops-pop");
let activeToolBtn = null;
let opSnapshot = null; // { which: "coeff"|"roots", items: [{idx, re, im}, ...] }

function snapshotSelection() {
    const items = [];
    if (selectedCoeffs.size > 0) {
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            items.push({ idx, re: c.re, im: c.im });
        }
        return { which: "coeff", items };
    } else if (selectedRoots.size > 0) {
        for (const idx of selectedRoots) {
            const r = currentRoots[idx];
            items.push({ idx, re: r.re, im: r.im });
        }
        return { which: "roots", items };
    }
    return null;
}

function applyPreview(snap, fn) {
    if (!snap) return;
    if (snap.which === "coeff") {
        for (const s of snap.items) {
            const c = coefficients[s.idx];
            const r = fn(s.re, s.im);
            c.re = r.re; c.im = r.im;
        }
        for (const path of animPaths) computePathCurves(path);
        autoScaleCoeffPanel();
        renderCoefficients();
        updateCoeffSelectionVisual();
        renderCoeffTrails();
        solveRootsThrottled();
    } else {
        for (const s of snap.items) {
            const r = currentRoots[s.idx];
            const res = fn(s.re, s.im);
            r.re = res.re; r.im = res.im;
        }
        autoScaleRootsPanel();
        coefficients = rootsToCoefficients(currentRoots.map(r => ({ re: r.re, im: r.im })));
        for (const path of animPaths) computePathCurves(path);
        renderCoefficients();
        renderCoeffTrails();
        renderRoots(currentRoots);
        updateRootSelectionVisual();
    }
}

function positionPopover(btnEl) {
    const r = btnEl.getBoundingClientRect();
    opsPop.style.left = (r.right + 8) + "px";
    opsPop.style.top = r.top + "px";
}

function closeOpTool() {
    opsPop.classList.remove("open");
    opsPop.innerHTML = "";
    if (activeToolBtn) activeToolBtn.classList.remove("tool-active");
    activeToolBtn = null;
    opSnapshot = null;
    // remove drag listeners
    window.removeEventListener("mousemove", opToolMouseMove);
    window.removeEventListener("mouseup", opToolMouseUp);
}

let opToolMouseMove = null;
let opToolMouseUp = null;

function openOpTool(btnEl, buildFn) {
    if (activeToolBtn === btnEl) { closeOpTool(); return; }
    closeOpTool();
    closeDegreePopover();
    if (typeof closeAudioPop === "function") closeAudioPop();
    if (typeof closeColorPop === "function") closeColorPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();
    opSnapshot = snapshotSelection();
    if (!opSnapshot) return;
    activeToolBtn = btnEl;
    btnEl.classList.add("tool-active");
    opsPop.innerHTML = "";
    buildFn(opsPop, opSnapshot);
    opsPop.classList.add("open");
    positionPopover(btnEl);
}

// --- Scale tool: vertical slider, exponential mapping ---
// u in [0,1] mapped to scale = exp(k*(u - 0.5)*2) where k=ln(10) ‚Üí range [0.1, 10]
const SCALE_K = Math.log(10);
function uToScale(u) { return Math.exp(SCALE_K * (u * 2 - 1)); }
function scaleToU(s) { return (Math.log(s) / SCALE_K + 1) / 2; }

function buildScaleTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Scale";
    const valEl = document.createElement("div");
    valEl.className = "pop-val"; valEl.textContent = "1.00√ó";

    const slider = document.createElement("div");
    slider.className = "vslider";
    const fill = document.createElement("div");
    fill.className = "vslider-fill";
    const thumb = document.createElement("div");
    thumb.className = "vslider-thumb";
    slider.appendChild(fill);
    slider.appendChild(thumb);

    let u = 0.5; // start at 1√ó
    function updateVisual() {
        const pct = u * 100;
        fill.style.height = pct + "%";
        thumb.style.bottom = pct + "%";
        const s = uToScale(u);
        valEl.textContent = s.toFixed(2) + "√ó";
        applyPreview(snap, (re, im) => ({ re: re * s, im: im * s }));
    }

    function setFromY(clientY) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, 1 - (clientY - rect.top) / rect.height));
        updateVisual();
    }

    let dragging = false;
    slider.addEventListener("mousedown", e => {
        dragging = true; setFromY(e.clientY); e.preventDefault();
    });
    opToolMouseMove = e => { if (dragging) setFromY(e.clientY); };
    opToolMouseUp = () => { dragging = false; };
    window.addEventListener("mousemove", opToolMouseMove);
    window.addEventListener("mouseup", opToolMouseUp);

    updateVisual();
    pop.appendChild(title);
    pop.appendChild(slider);
    pop.appendChild(valEl);
}

// --- Rotate tool: horizontal slider, -0.5 to 0.5 turns ---

function buildRotateTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Rotate";
    const valEl = document.createElement("div");
    valEl.className = "pop-val"; valEl.textContent = "0 turns";

    const slider = document.createElement("div");
    slider.className = "hslider";
    const center = document.createElement("div");
    center.className = "hslider-center";
    const thumb = document.createElement("div");
    thumb.className = "hslider-thumb";
    slider.appendChild(center);
    slider.appendChild(thumb);

    let u = 0.5; // center = 0 turns
    function updateVisual() {
        const pct = u * 100;
        thumb.style.left = pct + "%";
        const turns = u - 0.5; // -0.5 to 0.5
        const sign = turns >= 0 ? "+" : "";
        valEl.textContent = sign + turns.toFixed(3) + " turns";
        const angle = 2 * Math.PI * turns;
        const cosA = Math.cos(angle), sinA = Math.sin(angle);
        applyPreview(snap, (re, im) => ({
            re: re * cosA - im * sinA,
            im: re * sinA + im * cosA
        }));
    }

    function setFromX(clientX) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        updateVisual();
    }

    let dragging = false;
    slider.addEventListener("mousedown", e => {
        dragging = true; setFromX(e.clientX); e.preventDefault();
    });
    opToolMouseMove = e => { if (dragging) setFromX(e.clientX); };
    opToolMouseUp = () => { dragging = false; };
    window.addEventListener("mousemove", opToolMouseMove);
    window.addEventListener("mouseup", opToolMouseUp);

    updateVisual();
    pop.appendChild(title);
    pop.appendChild(slider);
    pop.appendChild(valEl);
}

// --- Add tool: 2D vector pad ---
// Pad maps pixel offset to complex offset. Range: +/-2 in each axis.
const PAD_RANGE = 2;

function buildAddTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Translate";
    const valEl = document.createElement("div");
    valEl.className = "pop-row";

    const pad = document.createElement("div");
    pad.className = "vec-pad";
    const axH = document.createElement("div");
    axH.className = "pad-axis h";
    const axV = document.createElement("div");
    axV.className = "pad-axis v";
    const dot = document.createElement("div");
    dot.className = "pad-dot";
    pad.appendChild(axH);
    pad.appendChild(axV);
    pad.appendChild(dot);

    let ux = 0.5, uy = 0.5; // center = (0,0)
    function updateVisual() {
        dot.style.left = (ux * 100) + "%";
        dot.style.top = (uy * 100) + "%";
        const dx = (ux - 0.5) * 2 * PAD_RANGE;
        const dy = -(uy - 0.5) * 2 * PAD_RANGE; // screen Y is inverted
        const signRe = dx >= 0 ? "+" : "";
        const signIm = dy >= 0 ? "+" : "";
        valEl.textContent = signRe + dx.toFixed(2) + " " + signIm + dy.toFixed(2) + "i";
        applyPreview(snap, (re, im) => ({ re: re + dx, im: im + dy }));
    }

    function setFromXY(clientX, clientY) {
        const rect = pad.getBoundingClientRect();
        ux = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        uy = Math.max(0, Math.min(1, (clientY - rect.top) / rect.height));
        updateVisual();
    }

    let dragging = false;
    pad.addEventListener("mousedown", e => {
        dragging = true; setFromXY(e.clientX, e.clientY); e.preventDefault();
    });
    opToolMouseMove = e => { if (dragging) setFromXY(e.clientX, e.clientY); };
    opToolMouseUp = () => { dragging = false; };
    window.addEventListener("mousemove", opToolMouseMove);
    window.addEventListener("mouseup", opToolMouseUp);

    updateVisual();
    pop.appendChild(title);
    pop.appendChild(pad);
    pop.appendChild(valEl);
}

// Wire up buttons
document.getElementById("scale-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildScaleTool);
});
document.getElementById("rotate-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildRotateTool);
});
document.getElementById("add-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildAddTool);
});

// Close popover on click outside
document.addEventListener("mousedown", e => {
    // Close ops popover
    if (activeToolBtn) {
        if (!opsPop.contains(e.target) && !(e.target.id && e.target.id.endsWith("-tool-btn"))) {
            closeOpTool();
        }
    }
    // Close audio popover
    if (activeAudioBtn) {
        if (!audioPop.contains(e.target) && !(e.target.id && e.target.id.endsWith("-toggle-btn"))) {
            closeAudioPop();
        }
    }
    // Close color popover
    if (colorPopOpen) {
        if (!colorPop.contains(e.target) && e.target.id !== "root-color-btn") {
            closeColorPop();
        }
    }
    // Close coeff picker popover
    if (coeffPickOpen) {
        if (!coeffPickPop.contains(e.target) && e.target.id !== "coeff-picker-btn") {
            closeCoeffPick();
        }
    }
});

// --- Video recording (MediaRecorder ‚Üí WebM) ---

let vidRec = {
    recording: false,
    mode: "roots",   // "roots" | "coeffs" | "both"
    canvas: null,
    ctx: null,
    stream: null,
    mr: null,
    chunks: []
};

// --- Panel drawing helpers for recording ---

function drawPanelGrid(ctx, x0, y0, pW, pH, range) {
    const xs = v => MARGIN + (v + range) / (2 * range) * (pW - 2 * MARGIN) + x0;
    const ys = v => (pH - MARGIN) - (v + range) / (2 * range) * (pH - 2 * MARGIN) + y0;

    // Grid
    ctx.strokeStyle = "#1f3354"; ctx.lineWidth = 0.5;
    const intMax = Math.floor(range);
    for (let v = -intMax; v <= intMax; v++) {
        ctx.beginPath(); ctx.moveTo(xs(v), ys(-range)); ctx.lineTo(xs(v), ys(range)); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(xs(-range), ys(v)); ctx.lineTo(xs(range), ys(v)); ctx.stroke();
    }
    // Axes
    ctx.strokeStyle = "#2a4a6b"; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(xs(-range), ys(0)); ctx.lineTo(xs(range), ys(0)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(xs(0), ys(-range)); ctx.lineTo(xs(0), ys(range)); ctx.stroke();
    // Unit circle
    ctx.setLineDash([4, 3]);
    ctx.beginPath(); ctx.arc(xs(0), ys(0), Math.abs(xs(1) - xs(0)), 0, 2 * Math.PI); ctx.stroke();
    ctx.setLineDash([]);

    return { xs, ys };
}

function drawRootsToCtx(ctx, x0, y0, pW, pH) {
    const range = panels.roots.range;

    // Background + domain coloring
    if (domainColoringEnabled) {
        ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);
        ctx.drawImage(domainCanvas, x0 + MARGIN, y0 + MARGIN, pW - 2 * MARGIN, pH - 2 * MARGIN);
    } else {
        ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);
    }

    const { xs, ys } = drawPanelGrid(ctx, x0, y0, pW, pH, range);

    // Trails
    if (trailData.length > 0) {
        const jumpThresh = range * 0.3;
        ctx.lineWidth = 1.5; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.globalAlpha = 0.6;
        for (let i = 0; i < trailData.length; i++) {
            const pts = trailData[i];
            if (pts.length < 2) continue;
            ctx.strokeStyle = rootColor(i, trailData.length);
            ctx.beginPath(); ctx.moveTo(xs(pts[0].re), ys(pts[0].im));
            for (let j = 1; j < pts.length; j++) {
                const dist = Math.hypot(pts[j].re - pts[j-1].re, pts[j].im - pts[j-1].im);
                if (dist > jumpThresh) { ctx.stroke(); ctx.beginPath(); ctx.moveTo(xs(pts[j].re), ys(pts[j].im)); }
                else ctx.lineTo(xs(pts[j].re), ys(pts[j].im));
            }
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
    }

    // Root dots
    const nRoots = currentRoots.length;
    for (let i = 0; i < nRoots; i++) {
        const r = currentRoots[i];
        ctx.beginPath(); ctx.arc(xs(r.re), ys(r.im), 7, 0, 2 * Math.PI);
        ctx.fillStyle = rootColor(i, nRoots); ctx.fill();
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.stroke();
    }
}

function drawCoeffsToCtx(ctx, x0, y0, pW, pH) {
    const range = panels.coeff.range;

    ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);

    const { xs, ys } = drawPanelGrid(ctx, x0, y0, pW, pH, range);

    // Coefficient curve paths
    const nC = coefficients.length;
    if (animPaths.length > 0) {
        ctx.lineWidth = 1.5; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.globalAlpha = 0.6;
        for (const path of animPaths) {
            if (path.pathType === "random" || path.pathType === "none") continue;
            for (const idx of path.coeffs) {
                const curve = coefficients[idx].curve;
                if (!curve) continue;
                const N = curve.length;
                ctx.strokeStyle = coeffColor(idx, nC);
                ctx.beginPath();
                for (let k = 0; k <= N; k++) {
                    const pt = curve[k % N];
                    if (k === 0) ctx.moveTo(xs(pt.re), ys(pt.im)); else ctx.lineTo(xs(pt.re), ys(pt.im));
                }
                ctx.closePath(); ctx.stroke();
            }
        }
        ctx.globalAlpha = 1.0;
    }

    // Coefficient dots + labels
    for (let i = 0; i < nC; i++) {
        const c = coefficients[i];
        ctx.beginPath(); ctx.arc(xs(c.re), ys(c.im), 7, 0, 2 * Math.PI);
        ctx.fillStyle = coeffColor(i, nC); ctx.fill();
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.stroke();
        ctx.fillStyle = "#aaa"; ctx.font = "10px sans-serif"; ctx.textAlign = "left";
        ctx.fillText("c" + subscript(nC - 1 - i), xs(c.re) + 10, ys(c.im) + 4);
    }
}

function recordTick() {
    if (!vidRec.recording) return;
    const ctx = vidRec.ctx;
    const mode = vidRec.mode;

    if (mode === "roots") {
        ctx.clearRect(0, 0, S, S);
        drawRootsToCtx(ctx, 0, 0, S, S);
    } else if (mode === "coeffs") {
        ctx.clearRect(0, 0, S, S);
        drawCoeffsToCtx(ctx, 0, 0, S, S);
    } else {
        // both ‚Äî side by side
        const gap = 8;
        const totalW = S * 2 + gap;
        ctx.fillStyle = "#0f1026"; ctx.fillRect(0, 0, totalW, S);
        drawCoeffsToCtx(ctx, 0, 0, S, S);
        drawRootsToCtx(ctx, S + gap, 0, S, S);
    }
}

function startRecording() {
    if (vidRec.recording) return;

    const mode = document.getElementById("rec-mode").value;
    vidRec.mode = mode;

    const dpr = window.devicePixelRatio || 1;
    const gap = 8;
    const logW = mode === "both" ? S * 2 + gap : S;
    const logH = S;

    if (!vidRec.canvas) {
        vidRec.canvas = document.createElement("canvas");
        vidRec.ctx = vidRec.canvas.getContext("2d");
    }
    vidRec.canvas.width = Math.floor(logW * dpr);
    vidRec.canvas.height = Math.floor(logH * dpr);
    vidRec.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const stream = vidRec.canvas.captureStream(60);
    // Merge audio track if sound is active
    if (audioNodes && audioNodes.mediaDest) {
        for (const track of audioNodes.mediaDest.stream.getAudioTracks()) {
            stream.addTrack(track);
        }
    }
    vidRec.stream = stream;
    vidRec.chunks = [];

    const candidates = ["video/webm;codecs=vp9", "video/webm;codecs=vp8", "video/webm"];
    let mimeType = "";
    for (const c of candidates) { if (MediaRecorder.isTypeSupported(c)) { mimeType = c; break; } }

    const mr = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
    vidRec.mr = mr;

    mr.ondataavailable = e => { if (e.data && e.data.size) vidRec.chunks.push(e.data); };
    mr.onstop = () => {
        const blob = new Blob(vidRec.chunks, { type: mr.mimeType || "video/webm" });
        const url = URL.createObjectURL(blob);
        const now = new Date();
        const ts = now.toISOString().replace(/[:.]/g, "-").slice(0, 19);
        const suffix = mode === "both" ? "both" : mode === "coeffs" ? "coeffs" : "roots";
        const basename = `polypaint-${suffix}-${ts}`;

        // Download video
        const a = document.createElement("a");
        a.href = url;
        a.download = `${basename}.webm`;
        a.click();
        URL.revokeObjectURL(url);

        // Download JSON metadata (mirrors snap metadata)
        const meta = {
            type: "recording",
            mode: mode,
            timestamp: now.toISOString(),
            degree: coefficients.length - 1,
            pattern: document.getElementById("pattern").value,
            domainColoring: domainColoringEnabled,
            rootColoring: rootColorMode !== "none",
            trails: trailsEnabled,
            animPaths: animPaths.map(p => ({
                id: p.id,
                coeffs: [...p.coeffs],
                pathType: p.pathType,
                radius: p.radius,
                speed: p.speed,
                ccw: p.ccw,
                angle: p.angle
            })),
            selectedCoeffs: [...selectedCoeffs],
            selectedRoots: [...selectedRoots],
            coefficients: coefficients.map(c => ({
                pos: [c.re, c.im],
                home: c.curve ? [c.curve[0].re, c.curve[0].im] : [c.re, c.im]
            })),
            roots: currentRoots.map(r => [r.re, r.im]),
            panels: {
                coeff: { range: panels.coeff.range },
                roots: { range: panels.roots.range }
            }
        };
        const jsonBlob = new Blob([JSON.stringify(meta, null, 2)], { type: "application/json" });
        const a2 = document.createElement("a");
        a2.href = URL.createObjectURL(jsonBlob);
        a2.download = `${basename}.json`;
        a2.click();
        URL.revokeObjectURL(a2.href);
    };

    vidRec.recording = true;
    recordTick();          // draw first frame before recorder starts
    mr.start(200);

    document.getElementById("rec-roots-btn").classList.add("recording");
    document.getElementById("stop-roots-btn").style.display = "";
}

function stopRecording() {
    if (!vidRec.recording) return;
    vidRec.recording = false;
    if (vidRec.mr && vidRec.mr.state !== "inactive") vidRec.mr.stop();
    vidRec.mr = null;
    vidRec.stream = null;

    document.getElementById("rec-roots-btn").classList.remove("recording");
    document.getElementById("stop-roots-btn").style.display = "none";
}

document.getElementById("rec-roots-btn").addEventListener("click", startRecording);
document.getElementById("stop-roots-btn").addEventListener("click", stopRecording);

// --- Snap (capture) ---

function snapCapture() {
    const dpr = window.devicePixelRatio || 1;
    const gap = 16;
    const headerH = 24;
    const cw = 2 * S + gap;
    const ch = S + headerH;
    const canvas = document.createElement("canvas");
    canvas.width = cw * dpr;
    canvas.height = ch * dpr;
    const ctx = canvas.getContext("2d");
    ctx.scale(dpr, dpr);

    // Background
    ctx.fillStyle = "#0f0f23";
    ctx.fillRect(0, 0, cw, ch);

    // Panel headers
    ctx.fillStyle = "#666";
    ctx.font = "11px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("COEFFICIENTS", S / 2, 16);
    ctx.fillText("ROOTS", S + gap + S / 2, 16);

    // Helper: draw a panel
    function drawPanel(offsetX, offsetY, range, skipBg) {
        const x0 = offsetX, y0 = offsetY;
        const xs = v => MARGIN + (v + range) / (2 * range) * (S - 2 * MARGIN) + x0;
        const ys = v => (S - MARGIN) - (v + range) / (2 * range) * (S - 2 * MARGIN) + y0;

        // Panel background
        if (!skipBg) {
            ctx.fillStyle = "#16213e";
            ctx.fillRect(x0, y0, S, S);
        }

        // Grid lines
        ctx.strokeStyle = "#1f3354";
        ctx.lineWidth = 0.5;
        const intMax = Math.floor(range);
        for (let v = -intMax; v <= intMax; v++) {
            ctx.beginPath();
            ctx.moveTo(xs(v), ys(-range)); ctx.lineTo(xs(v), ys(range));
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(xs(-range), ys(v)); ctx.lineTo(xs(range), ys(v));
            ctx.stroke();
        }

        // Axes
        ctx.strokeStyle = "#2a4a6b";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(xs(-range), ys(0)); ctx.lineTo(xs(range), ys(0));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(xs(0), ys(-range)); ctx.lineTo(xs(0), ys(range));
        ctx.stroke();

        // Unit circle
        ctx.strokeStyle = "#2a4a6b";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 3]);
        ctx.beginPath();
        ctx.arc(xs(0), ys(0), Math.abs(xs(1) - xs(0)), 0, 2 * Math.PI);
        ctx.stroke();
        ctx.setLineDash([]);

        return { xs, ys };
    }

    // Draw coefficient panel
    const cp = drawPanel(0, headerH, panels.coeff.range, false);

    // Draw per-coefficient absolute curve trails
    if (animPaths.length > 0) {
        const nC = coefficients.length;
        ctx.lineWidth = 1.5;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.globalAlpha = 0.6;
        for (const path of animPaths) {
            if (path.pathType === "random" || path.pathType === "none") continue;
            for (const idx of path.coeffs) {
                const curve = coefficients[idx].curve;
                if (!curve) continue;
                const N = curve.length;
                ctx.strokeStyle = coeffColor(idx, nC);
                ctx.beginPath();
                for (let k = 0; k <= N; k++) {
                    const pt = curve[k % N];
                    const px = cp.xs(pt.re);
                    const py = cp.ys(pt.im);
                    if (k === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
            }
        }
        ctx.globalAlpha = 1.0;
    }

    // Draw coefficient dots + labels
    const nCoeff = coefficients.length;
    for (let i = 0; i < nCoeff; i++) {
        const c = coefficients[i];
        const cx = cp.xs(c.re), cy = cp.ys(c.im);

        // Selection glow
        if (selectedCoeffs.has(i)) {
            ctx.shadowColor = "#e94560";
            ctx.shadowBlur = 12;
        }
        ctx.beginPath();
        ctx.arc(cx, cy, 7, 0, 2 * Math.PI);
        ctx.fillStyle = coeffColor(i, nCoeff);
        ctx.fill();
        ctx.strokeStyle = selectedCoeffs.has(i) ? "#fff" : "#fff";
        ctx.lineWidth = selectedCoeffs.has(i) ? 2.5 : 1;
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Label
        ctx.fillStyle = "#aaa";
        ctx.font = "10px sans-serif";
        ctx.textAlign = "left";
        ctx.fillText("c" + subscript(nCoeff - 1 - i), cx + 10, cy + 4);
    }

    // Draw roots panel: background first, then domain coloring, then grid on top
    if (domainColoringEnabled) {
        ctx.drawImage(domainCanvas, S + gap, headerH, S, S);
        // Grid/axes/circle on top of domain coloring (skip background fill)
    } else {
        ctx.fillStyle = "#16213e";
        ctx.fillRect(S + gap, headerH, S, S);
    }
    const rp = drawPanel(S + gap, headerH, panels.roots.range, true);

    // Draw trails
    if (trailData.length > 0) {
        const jumpThresh = panels.roots.range * 0.3;
        ctx.lineWidth = 1.5;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.globalAlpha = 0.6;
        for (let i = 0; i < trailData.length; i++) {
            const pts = trailData[i];
            if (pts.length < 2) continue;
            ctx.strokeStyle = rootColor(i, trailData.length);
            ctx.beginPath();
            ctx.moveTo(rp.xs(pts[0].re), rp.ys(pts[0].im));
            for (let j = 1; j < pts.length; j++) {
                const dist = Math.hypot(pts[j].re - pts[j-1].re, pts[j].im - pts[j-1].im);
                if (dist > jumpThresh) {
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(rp.xs(pts[j].re), rp.ys(pts[j].im));
                } else {
                    ctx.lineTo(rp.xs(pts[j].re), rp.ys(pts[j].im));
                }
            }
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
    }

    // Draw root dots
    const nRoots = currentRoots.length;
    for (let i = 0; i < nRoots; i++) {
        const r = currentRoots[i];
        const cx = rp.xs(r.re), cy = rp.ys(r.im);
        if (selectedRoots.has(i)) {
            ctx.shadowColor = "#e94560";
            ctx.shadowBlur = 12;
        }
        ctx.beginPath();
        ctx.arc(cx, cy, 7, 0, 2 * Math.PI);
        ctx.fillStyle = rootColor(i, nRoots);
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = selectedRoots.has(i) ? 2.5 : 1;
        ctx.stroke();
        ctx.shadowBlur = 0;
    }

    // Generate timestamp
    const now = new Date();
    const ts = now.toISOString().replace(/[:.]/g, "-").slice(0, 19);

    // Build metadata
    const meta = {
        timestamp: now.toISOString(),
        degree: coefficients.length - 1,
        pattern: document.getElementById("pattern").value,
        domainColoring: domainColoringEnabled,
        rootColoring: rootColorMode !== "none",
        trails: trailsEnabled,
        trailComplete: trailComplete,
        animPaths: animPaths.map(p => ({
            id: p.id,
            coeffs: [...p.coeffs],
            pathType: p.pathType,
            radius: p.radius,
            speed: p.speed,
            ccw: p.ccw,
            angle: p.angle
        })),
        animPlaying: animState.playing,
        selectedCoeffs: [...selectedCoeffs],
        selectedRoots: [...selectedRoots],
        coefficients: coefficients.map(c => ({
            pos: [c.re, c.im],
            home: c.curve ? [c.curve[0].re, c.curve[0].im] : [c.re, c.im]
        })),
        roots: currentRoots.map(r => [r.re, r.im]),
        panels: {
            coeff: { range: panels.coeff.range },
            roots: { range: panels.roots.range }
        },
        trailData: trailData.map(pts => pts.map(p => [p.re, p.im]))
    };

    // Download PNG
    canvas.toBlob(function (blob) {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `polypaint-${ts}.png`;
        a.click();
        URL.revokeObjectURL(a.href);
    }, "image/png");

    // Download JSON
    const jsonBlob = new Blob([JSON.stringify(meta, null, 2)], { type: "application/json" });
    const a2 = document.createElement("a");
    a2.href = URL.createObjectURL(jsonBlob);
    a2.download = `polypaint-${ts}.json`;
    a2.click();
    URL.revokeObjectURL(a2.href);
}

document.getElementById("snap-btn").addEventListener("click", snapCapture);

// --- Resize handler ---

// --- Stats tab ---

(function initStatsCanvases() {
    const canvases = document.querySelectorAll(".stats-canvas");
    const selects = document.querySelectorAll(".stats-select");
    canvases.forEach((c, i) => {
        statsState.canvases[i] = c;
        statsState.ctxs[i] = c.getContext("2d");
    });
    selects.forEach((sel, plotIdx) => {
        STAT_TYPES.forEach((name, si) => {
            const opt = document.createElement("option");
            opt.value = si; opt.textContent = name;
            sel.appendChild(opt);
        });
        sel.value = statsState.plotConfigs[plotIdx];
        sel.addEventListener("change", () => {
            statsState.plotConfigs[plotIdx] = parseInt(sel.value);
            drawStatsPlot(plotIdx);
        });
    });
    // Init ring buffers
    for (const name of STAT_TYPES) statsState.buffers[name] = new Float64Array(statsState.maxFrames);
})();

function resizeStatsCanvases() {
    const dpr = window.devicePixelRatio || 1;
    for (let i = 0; i < 4; i++) {
        const c = statsState.canvases[i];
        if (!c) continue;
        const rect = c.getBoundingClientRect();
        c.width = Math.floor(rect.width * dpr);
        c.height = Math.floor(rect.height * dpr);
        statsState.ctxs[i].setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    statsState.dirty = true;
}

function computeForce() {
    // Total derivative of all roots w.r.t. moving coefficients (on a non-"none" path)
    const nRoots = currentRoots.length;
    const nCoeffs = coefficients.length;
    const deg = nCoeffs - 1;
    if (nRoots === 0 || nCoeffs === 0) return 0;

    // Find moving coefficient indices
    const movingSet = new Set();
    for (const path of animPaths) {
        if (path.pathType !== "none") {
            for (const idx of path.coeffs) movingSet.add(idx);
        }
    }
    if (movingSet.size === 0) return 0;

    const cRe = new Float64Array(nCoeffs);
    const cIm = new Float64Array(nCoeffs);
    for (let i = 0; i < nCoeffs; i++) { cRe[i] = coefficients[i].re; cIm[i] = coefficients[i].im; }

    // Precompute |p'(rj)| and |rj| for each root
    const invDpMag = new Float64Array(nRoots);
    const rMag = new Float64Array(nRoots);
    for (let j = 0; j < nRoots; j++) {
        const zRe = currentRoots[j].re, zIm = currentRoots[j].im;
        rMag[j] = Math.hypot(zRe, zIm);
        let pRe = cRe[0], pIm = cIm[0], dpRe = 0, dpIm = 0;
        for (let k = 1; k <= deg; k++) {
            const ndRe = dpRe * zRe - dpIm * zIm + pRe;
            const ndIm = dpRe * zIm + dpIm * zRe + pIm;
            dpRe = ndRe; dpIm = ndIm;
            const npRe = pRe * zRe - pIm * zIm + cRe[k];
            const npIm = pRe * zIm + pIm * zRe + cIm[k];
            pRe = npRe; pIm = npIm;
        }
        const dm = Math.hypot(dpRe, dpIm);
        invDpMag[j] = dm < 1e-30 ? 0 : 1 / dm;
    }

    // Sum sensitivities only for moving coefficients
    let total = 0;
    for (const k of movingSet) {
        const power = deg - k;
        for (let j = 0; j < nRoots; j++) {
            total += Math.pow(rMag[j], power) * invDpMag[j];
        }
    }
    return total;
}

function computeSpeed() {
    const n = currentRoots.length;
    if (!statsState.prevRoots || statsState.prevRoots.length !== n) return 0;
    let total = 0;
    for (let i = 0; i < n; i++) {
        const dx = currentRoots[i].re - statsState.prevRoots[i].re;
        const dy = currentRoots[i].im - statsState.prevRoots[i].im;
        total += Math.hypot(dx, dy);
    }
    return total;
}

function computeMinDist() {
    const n = currentRoots.length;
    if (n < 2) return 0;
    let minD = Infinity;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const dx = currentRoots[i].re - currentRoots[j].re;
            const dy = currentRoots[i].im - currentRoots[j].im;
            const d = Math.hypot(dx, dy);
            if (d < minD) minD = d;
        }
    }
    return minD;
}

function computeMaxDist() {
    const n = currentRoots.length;
    if (n < 2) return 0;
    let maxD = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const dx = currentRoots[i].re - currentRoots[j].re;
            const dy = currentRoots[i].im - currentRoots[j].im;
            const d = Math.hypot(dx, dy);
            if (d > maxD) maxD = d;
        }
    }
    return maxD;
}

const statComputeFns = [computeForce, computeSpeed, computeMinDist, computeMaxDist];

function collectStatsSnapshot() {
    const n = currentRoots.length;
    if (n === 0) return;

    const idx = statsState.writeIdx;
    for (let s = 0; s < STAT_TYPES.length; s++) {
        statsState.buffers[STAT_TYPES[s]][idx] = statComputeFns[s]();
    }

    // Save previous roots for Speed computation next frame
    if (!statsState.prevRoots || statsState.prevRoots.length !== n) {
        statsState.prevRoots = [];
        for (let i = 0; i < n; i++) statsState.prevRoots.push({ re: 0, im: 0 });
    }
    for (let i = 0; i < n; i++) {
        statsState.prevRoots[i].re = currentRoots[i].re;
        statsState.prevRoots[i].im = currentRoots[i].im;
    }

    statsState.writeIdx = (idx + 1) % statsState.maxFrames;
    statsState.frameCount = Math.min(statsState.frameCount + 1, statsState.maxFrames);
    statsState.dirty = true;
}

function clearStatsData() {
    for (const name of STAT_TYPES) statsState.buffers[name].fill(0);
    statsState.frameCount = 0;
    statsState.writeIdx = 0;
    statsState.prevRoots = null;
    statsState.dirty = true;
    if (activeTab === "stats") drawAllStatsPlots();
}

function drawStatsPlot(plotIdx) {
    const ctx = statsState.ctxs[plotIdx];
    if (!ctx) return;
    const c = statsState.canvases[plotIdx];
    const W = c.getBoundingClientRect().width;
    const H = c.getBoundingClientRect().height;
    if (W === 0 || H === 0) return;

    const statIdx = statsState.plotConfigs[plotIdx];
    const statName = STAT_TYPES[statIdx];
    const buf = statsState.buffers[statName];
    const nFrames = statsState.frameCount;
    const color = STAT_COLORS[statName];

    const ML = 6, MR = 4, MT = 4, MB = 4; // minimal margins
    const plotW = W - ML - MR;
    const plotH = H - MT - MB;

    // Clear
    ctx.fillStyle = "#151a3a";
    ctx.fillRect(0, 0, W, H);

    // Find max value in visible buffer for normalization
    let yMax = 0;
    const startIdx = (nFrames < statsState.maxFrames) ? 0 : statsState.writeIdx;
    for (let f = 0; f < nFrames; f++) {
        const bufIdx = (startIdx + f) % statsState.maxFrames;
        const v = buf[bufIdx];
        if (v > yMax) yMax = v;
    }
    if (yMax < 1e-12) yMax = 1;

    const xOf = (f) => ML + (nFrames > 1 ? (f / (nFrames - 1)) * plotW : 0);
    const yOf = (v) => MT + plotH - (v / yMax) * plotH;

    // Subtle horizontal gridlines at 0.25, 0.5, 0.75
    ctx.strokeStyle = "rgba(255,255,255,0.04)";
    ctx.lineWidth = 0.5;
    for (const frac of [0.25, 0.5, 0.75]) {
        const y = MT + plotH * (1 - frac);
        ctx.beginPath(); ctx.moveTo(ML, y); ctx.lineTo(ML + plotW, y); ctx.stroke();
    }

    // Bottom axis
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 0.5;
    ctx.beginPath(); ctx.moveTo(ML, MT + plotH); ctx.lineTo(ML + plotW, MT + plotH); ctx.stroke();

    if (nFrames < 2) return;

    // Draw stat line
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    for (let f = 0; f < nFrames; f++) {
        const bufIdx = (startIdx + f) % statsState.maxFrames;
        const x = xOf(f);
        const y = yOf(buf[bufIdx]);
        if (f === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1.0;

    // Current value label (top-right)
    const lastIdx = (startIdx + nFrames - 1) % statsState.maxFrames;
    const curVal = buf[lastIdx];
    ctx.fillStyle = color;
    ctx.font = "bold 9px system-ui";
    ctx.textAlign = "right";
    ctx.fillText(curVal < 100 ? curVal.toFixed(3) : curVal.toFixed(1), W - MR - 2, MT + 10);
}

function drawAllStatsPlots() {
    statsState.dirty = false;
    for (let i = 0; i < 4; i++) drawStatsPlot(i);
}

// Tab switching
const tabButtons = document.querySelectorAll(".tab-bar .tab");
const tabContents = {
    roots: document.getElementById("roots-content"),
    stats: document.getElementById("stats-content")
};

function switchTab(tabName) {
    if (tabName === activeTab) return;
    activeTab = tabName;
    tabButtons.forEach(btn => btn.classList.toggle("active", btn.dataset.tab === tabName));
    for (const [key, el] of Object.entries(tabContents)) el.classList.toggle("active", key === tabName);
    if (tabName === "stats") { resizeStatsCanvases(); drawAllStatsPlots(); }
}
tabButtons.forEach(btn => btn.addEventListener("click", () => switchTab(btn.dataset.tab)));

function rebuild() {
    S = getPanelSize();
    initPanelScales(panels.coeff);
    initPanelScales(panels.roots);

    // Clear and rebuild both SVGs
    coeffSvg.selectAll("*").remove();
    rootsSvg.selectAll("*").remove();
    setupPanel(coeffSvg, panels.coeff);
    setupPanel(rootsSvg, panels.roots);

    // Recreate layers
    coeffTrailLayer = coeffSvg.append("g").attr("class", "trail-layer");
    coeffLayer = coeffSvg.append("g");
    trailLayer = rootsSvg.append("g").attr("class", "trail-layer");
    rootsLayer = rootsSvg.append("g");

    renderCoefficients();
    updateCoeffSelectionVisual();

    // Re-solve roots and re-render domain coloring at new size
    solveRoots();
    rootsSvg.classed("domain-active", domainColoringEnabled);
    renderDomainColoring();
    if (trailData.length > 0) renderTrails();
    if (animPaths.length > 0) renderCoeffTrails();
    resizeStatsCanvases();
    if (activeTab === "stats") drawAllStatsPlots();
}

let resizeTimer;
window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(rebuild, 150);
});

// --- Init ---

rootsSvg.classed("domain-active", domainColoringEnabled);
domainCanvas.style.display = domainColoringEnabled ? "block" : "none";
initCoefficients(currentDegree);
renderCoefficients();
solveRoots();
renderDomainColoring();

// Install marquee selection (once ‚Äî survives rebuild since SVG element persists)
installMarqueeSelection(coeffSvg, () => coeffLayer.selectAll("circle.coeff"), "coeff");
installMarqueeSelection(rootsSvg, () => rootsLayer.selectAll("circle.root"), "roots");
</script>
</body>
</html>
