<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>PolyPaint</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; }
body { font-family: 'Segoe UI', system-ui, sans-serif; background: #1a1a2e; color: #eee; display: flex; flex-direction: column; }
#controls {
    text-align: center; padding: 10px 16px;
    display: flex; align-items: center; justify-content: center; gap: 20px;
    flex-shrink: 0;
}
#controls label { font-size: 15px; display: flex; align-items: center; gap: 8px; }
#degree { width: 180px; accent-color: #e94560; }
#degree-value { font-weight: bold; font-size: 18px; color: #e94560; min-width: 28px; text-align: center; }
#panels { display: flex; justify-content: center; gap: 16px; padding: 0 12px 12px; flex: 1; min-height: 0; }
.panel { text-align: center; display: flex; flex-direction: column; flex: 1; min-width: 0; min-height: 0; }
.panel h3 { margin-bottom: 6px; font-weight: 400; font-size: 14px; color: #aaa; flex-shrink: 0; }
svg { background: #16213e; border: 1px solid #333; border-radius: 8px; flex: 1; position: relative; }
.grid line { stroke: #1f3354; stroke-width: 0.5; }
.axis line { stroke: #2a4a6b; stroke-width: 1; }
.unit-circle { fill: none; stroke: #2a4a6b; stroke-width: 1; stroke-dasharray: 4 3; }
circle.coeff { cursor: grab; stroke-width: 1.5; }
circle.coeff.dragging { cursor: grabbing; stroke: #fff; stroke-width: 2.5; }
circle.root { cursor: grab; stroke-width: 1.5; }
circle.root.dragging { cursor: grabbing; stroke: #fff; stroke-width: 2.5; }
#reset-btn {
    background: #e94560; color: #fff; border: none; border-radius: 4px;
    padding: 6px 14px; font-size: 13px; cursor: pointer;
}
#reset-btn:hover { background: #c73550; }
#pattern { background: #16213e; color: #eee; border: 1px solid #444; border-radius: 4px; padding: 4px 8px; font-size: 13px; }
#spread { width: 100px; accent-color: #e94560; }
#spread-value { font-size: 13px; color: #e94560; min-width: 32px; text-align: center; }
.coeff-label { font-size: 10px; fill: #aaa; pointer-events: none; }
#roots-container { position: relative; flex: 1; min-height: 0; }
#domain-canvas { position: absolute; top: 0; left: 0; border-radius: 8px; }
#roots-panel.domain-active { background: transparent !important; }
#domain-coloring-toggle { accent-color: #e94560; }
circle.coeff.selected { filter: drop-shadow(0 0 6px #e94560) drop-shadow(0 0 12px #e94560); }
#anim-bar {
    display: none; padding: 6px 16px;
    align-items: center; justify-content: center; gap: 16px;
    flex-shrink: 0; border-bottom: 1px solid #333;
}
#anim-bar.active { display: flex; }
#anim-bar .bar-title { font-weight: bold; color: #e94560; font-size: 14px; }
#anim-bar label { font-size: 13px; display: flex; align-items: center; gap: 6px; cursor: pointer; }
#anim-bar .loop-controls { display: none; align-items: center; gap: 16px; }
#anim-bar .loop-controls.active { display: flex; }
#anim-bar select { background: #16213e; color: #eee; border: 1px solid #444; border-radius: 4px; padding: 2px 6px; font-size: 12px; }
#anim-bar input[type="range"] { width: 80px; accent-color: #e94560; }
#anim-bar .bar-val { color: #e94560; min-width: 28px; text-align: right; font-size: 12px; }
#play-btn {
    background: #e94560; color: #fff; border: none; border-radius: 4px;
    padding: 4px 12px; font-size: 12px; cursor: pointer;
}
#play-btn:hover { background: #c73550; }
.tooltip {
    position: absolute; background: rgba(0,0,0,0.85); color: #fff;
    padding: 4px 8px; border-radius: 4px; font-size: 12px; pointer-events: none;
    display: none; white-space: nowrap;
}
</style>
</head>
<body>

<div id="controls">
    <label>Degree:
        <input type="range" id="degree" min="3" max="30" value="5">
        <span id="degree-value">5</span>
    </label>
    <label>Pattern:
        <select id="pattern">
            <optgroup label="Basic">
                <option value="circle">Circle</option>
                <option value="real">Real axis</option>
                <option value="imag">Imaginary axis</option>
                <option value="grid">Grid</option>
                <option value="random">Random</option>
            </optgroup>
            <optgroup label="Coeff patterns">
                <option value="spiral">Spiral</option>
                <option value="star">Star</option>
                <option value="lemniscate">Figure-8</option>
                <option value="conjugate">Conjugate pairs</option>
                <option value="two-clusters">Two clusters</option>
                <option value="geometric">Geometric decay</option>
                <option value="rose">Rose curve</option>
                <option value="cardioid">Cardioid</option>
            </optgroup>
            <optgroup label="Roots shapes">
                <option value="r-heart">Heart</option>
                <option value="r-circle">Circle</option>
                <option value="r-star">Star</option>
                <option value="r-spiral">Spiral</option>
                <option value="r-cross">Cross</option>
                <option value="r-diamond">Diamond</option>
                <option value="r-grid">Chessboard</option>
                <option value="r-smiley">Smiley</option>
                <option value="r-figure8">Figure-8</option>
                <option value="r-butterfly">Butterfly</option>
                <option value="r-trefoil">Trefoil</option>
                <option value="r-polygon">Polygon</option>
                <option value="r-infinity">Infinity</option>
            </optgroup>
        </select>
    </label>
    <label>Spread:
        <input type="range" id="spread" min="0.2" max="2.5" step="0.1" value="1.0">
        <span id="spread-value">1.0</span>
    </label>
    <label><input type="checkbox" id="domain-coloring-toggle" checked> Domain coloring</label>
    <button id="reset-btn">Reset</button>
</div>

<div id="anim-bar">
    <span class="bar-title" id="bar-title">c₀</span>
    <label><input type="radio" name="coeff-mode" value="drag" checked> Drag</label>
    <label><input type="radio" name="coeff-mode" value="loop"> Loop</label>
    <span class="loop-controls" id="loop-controls">
        <label>Path:
            <select id="anim-path">
                <option value="circle">Circle</option>
                <option value="horizontal">Horizontal</option>
                <option value="vertical">Vertical</option>
                <option value="spiral">Spiral</option>
                <option value="figure8">Figure-8</option>
                <option value="random">Random walk</option>
            </select>
        </label>
        <label>Radius: <input type="range" id="anim-radius" min="0.05" max="2.0" step="0.05" value="0.5"> <span class="bar-val" id="anim-radius-val">0.5</span></label>
        <label>Speed: <input type="range" id="anim-speed" min="0.1" max="5.0" step="0.1" value="1.0"> <span class="bar-val" id="anim-speed-val">1.0</span></label>
        <button id="play-btn">▶ Play</button>
    </span>
</div>

<div id="panels">
    <div class="panel">
        <h3>Coefficients (drag to edit)</h3>
        <svg id="coeff-panel"></svg>
    </div>
    <div class="panel">
        <h3>Roots (drag to edit)</h3>
        <div id="roots-container">
            <canvas id="domain-canvas"></canvas>
            <svg id="roots-panel"></svg>
        </div>
    </div>
</div>

<div class="tooltip" id="tooltip"></div>

<script>
const MIN_RANGE = 1.5;
const MARGIN = 30;
const RANGE_PAD = 1.3; // 30% padding around data

// Compute panel size from available space
function getPanelSize() {
    const controls = document.getElementById("controls");
    const availH = window.innerHeight - controls.offsetHeight - 50;
    const availW = (window.innerWidth - 16 * 3) / 2;
    return Math.max(200, Math.floor(Math.min(availW, availH)));
}

let S = getPanelSize();

// Per-panel state
const panels = {
    coeff: { range: 3, xScale: null, yScale: null, gridG: null, axisG: null, labelRe: null, labelIm: null, unitCircle: null },
    roots: { range: 3, xScale: null, yScale: null, gridG: null, axisG: null, labelRe: null, labelIm: null, unitCircle: null }
};

function makeScales(range) {
    return {
        x: d3.scaleLinear().domain([-range, range]).range([MARGIN, S - MARGIN]),
        y: d3.scaleLinear().domain([-range, range]).range([S - MARGIN, MARGIN])
    };
}

function initPanelScales(p) {
    const s = makeScales(p.range);
    p.xScale = s.x;
    p.yScale = s.y;
}
initPanelScales(panels.coeff);
initPanelScales(panels.roots);

// Convenience aliases (updated when range changes)
function cxs() { return panels.coeff.xScale; }
function cys() { return panels.coeff.yScale; }
function rxs() { return panels.roots.xScale; }
function rys() { return panels.roots.yScale; }

let coefficients = [];
let currentRoots = []; // persistent root data for dragging
let pendingSolve = false;

// Selection & animation state
let selectedCoeffIdx = null;
let coeffMode = "drag"; // "drag" or "loop"
const animState = { playing: false, center: null, startTime: 0, rafId: null };
// Domain coloring state
let domainColoringEnabled = true;
let domainCanvas = document.getElementById("domain-canvas");
let domainCtx = domainCanvas.getContext("2d");
let domainPendingRender = false;
const DOMAIN_RES_SCALE = 0.5; // render at half resolution for performance

// --- Compute range needed to fit data ---

function computeRange(points) {
    // points: array of {re, im} or [re, im]
    let maxAbs = MIN_RANGE;
    for (const p of points) {
        const re = Array.isArray(p) ? p[0] : p.re;
        const im = Array.isArray(p) ? p[1] : p.im;
        if (isFinite(re)) maxAbs = Math.max(maxAbs, Math.abs(re));
        if (isFinite(im)) maxAbs = Math.max(maxAbs, Math.abs(im));
    }
    // Round up to a nice number and add padding
    return Math.ceil(maxAbs * RANGE_PAD * 2) / 2;
}

// --- SVG setup / grid redraw ---

function drawGrid(svgSel, p) {
    const xs = p.xScale, ys = p.yScale, range = p.range;

    // Clear old grid elements
    if (p.gridG) p.gridG.remove();
    if (p.axisG) p.axisG.remove();
    if (p.labelRe) p.labelRe.remove();
    if (p.labelIm) p.labelIm.remove();
    if (p.unitCircle) p.unitCircle.remove();

    // Grid lines at integers
    p.gridG = svgSel.insert("g", ":first-child").attr("class", "grid");
    const intMax = Math.floor(range);
    for (let v = -intMax; v <= intMax; v++) {
        p.gridG.append("line")
            .attr("x1", xs(v)).attr("y1", ys(-range))
            .attr("x2", xs(v)).attr("y2", ys(range));
        p.gridG.append("line")
            .attr("x1", xs(-range)).attr("y1", ys(v))
            .attr("x2", xs(range)).attr("y2", ys(v));
    }

    // Axes
    p.axisG = svgSel.insert("g", ":first-child").attr("class", "axis");
    p.axisG.append("line")
        .attr("x1", xs(-range)).attr("y1", ys(0))
        .attr("x2", xs(range)).attr("y2", ys(0));
    p.axisG.append("line")
        .attr("x1", xs(0)).attr("y1", ys(-range))
        .attr("x2", xs(0)).attr("y2", ys(range));

    // Axis labels
    p.labelRe = svgSel.append("text").attr("x", S - MARGIN + 4).attr("y", ys(0) + 4)
        .attr("fill", "#556").attr("font-size", 11).text("Re");
    p.labelIm = svgSel.append("text").attr("x", xs(0) + 6).attr("y", MARGIN - 4)
        .attr("fill", "#556").attr("font-size", 11).text("Im");

    // Unit circle
    const r = Math.abs(xs(1) - xs(0));
    p.unitCircle = svgSel.append("circle").attr("class", "unit-circle")
        .attr("cx", xs(0)).attr("cy", ys(0)).attr("r", r);
}

function setupPanel(svgSel, p) {
    svgSel.attr("width", S).attr("height", S).attr("viewBox", `0 0 ${S} ${S}`);
    drawGrid(svgSel, p);
}

function updatePanelRange(svgSel, p, newRange) {
    if (Math.abs(p.range - newRange) < 0.01) return; // no change
    p.range = newRange;
    initPanelScales(p);
    drawGrid(svgSel, p);
}

const coeffSvg = d3.select("#coeff-panel");
const rootsSvg = d3.select("#roots-panel");
setupPanel(coeffSvg, panels.coeff);
setupPanel(rootsSvg, panels.roots);

let coeffLayer = coeffSvg.append("g");
let rootsLayer = rootsSvg.append("g");

// --- Tooltip ---

const tooltip = document.getElementById("tooltip");

function showTooltip(event, re, im) {
    const sign = im >= 0 ? "+" : "−";
    const absIm = Math.abs(im);
    tooltip.textContent = `${re.toFixed(3)} ${sign} ${absIm.toFixed(3)}i`;
    tooltip.style.display = "block";
    tooltip.style.left = (event.pageX + 12) + "px";
    tooltip.style.top = (event.pageY - 12) + "px";
}

function hideTooltip() {
    tooltip.style.display = "none";
}

// --- Coefficient color ---

function coeffColor(i, n) {
    return d3.interpolateRainbow(i / n);
}

// --- Init coefficients with pattern ---

function getPattern() { return document.getElementById("pattern").value; }
function getSpread() { return parseFloat(document.getElementById("spread").value); }

function initCoefficients(degree) {
    const n = degree + 1;
    const spread = getSpread();
    const pattern = getPattern();
    coefficients = [];

    if (pattern === "circle") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            coefficients.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
    } else if (pattern === "real") {
        for (let i = 0; i < n; i++) {
            const t = n === 1 ? 0 : -spread + (2 * spread * i) / (n - 1);
            coefficients.push({ re: t, im: 0 });
        }
    } else if (pattern === "imag") {
        for (let i = 0; i < n; i++) {
            const t = n === 1 ? 0 : -spread + (2 * spread * i) / (n - 1);
            coefficients.push({ re: 0, im: t });
        }
    } else if (pattern === "grid") {
        const cols = Math.ceil(Math.sqrt(n));
        const rows = Math.ceil(n / cols);
        for (let i = 0; i < n; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            const re = cols === 1 ? 0 : -spread + (2 * spread * col) / (cols - 1);
            const im = rows === 1 ? 0 : -spread + (2 * spread * row) / (rows - 1);
            coefficients.push({ re, im });
        }
    } else if (pattern === "random") {
        for (let i = 0; i < n; i++) {
            coefficients.push({
                re: (Math.random() * 2 - 1) * spread,
                im: (Math.random() * 2 - 1) * spread
            });
        }
    } else if (pattern === "spiral") {
        // Archimedean spiral — roots trace beautiful curves when perturbed
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const r = spread * t;
            const angle = 4 * Math.PI * t;
            coefficients.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "star") {
        // Alternating inner/outer radii — gives spiky root patterns
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            const r = (i % 2 === 0) ? spread : spread * 0.4;
            coefficients.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "lemniscate") {
        // Figure-8 (Bernoulli lemniscate) — rich root sensitivity
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const cos2t = Math.cos(2 * t);
            const r = spread * Math.sqrt(Math.abs(cos2t));
            const sign = cos2t >= 0 ? 1 : -1;
            coefficients.push({ re: sign * r * Math.cos(t), im: sign * r * Math.sin(t) });
        }
    } else if (pattern === "conjugate") {
        // Conjugate pairs straddling real axis — roots tend to stay near real axis then bifurcate
        for (let i = 0; i < n; i++) {
            const pairIdx = Math.floor(i / 2);
            const re = n <= 2 ? 0 : -spread + (2 * spread * pairIdx) / (Math.ceil(n / 2) - 1 || 1);
            const im = (i % 2 === 0) ? spread * 0.5 : -spread * 0.5;
            coefficients.push({ re, im });
        }
    } else if (pattern === "two-clusters") {
        // Two clusters — see roots jump between clusters as you drag
        const half = Math.ceil(n / 2);
        for (let i = 0; i < n; i++) {
            const cluster = i < half ? -1 : 1;
            const idx = i < half ? i : i - half;
            const count = i < half ? half : n - half;
            const angle = (2 * Math.PI * idx) / Math.max(count, 1);
            const r = spread * 0.35;
            coefficients.push({
                re: cluster * spread * 0.7 + r * Math.cos(angle),
                im: r * Math.sin(angle)
            });
        }
    } else if (pattern === "geometric") {
        // Geometric decay along real axis — classic for ill-conditioned polynomials
        for (let i = 0; i < n; i++) {
            const val = spread * Math.pow(0.7, i);
            const sign = (i % 2 === 0) ? 1 : -1;
            coefficients.push({ re: sign * val, im: 0 });
        }
    } else if (pattern === "rose") {
        // Rose curve r = cos(kθ) — petals create interesting symmetry breaking
        const k = 3; // 3-petal rose
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * Math.cos(k * t);
            coefficients.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "cardioid") {
        // Cardioid — heart-shaped curve, roots respond dramatically near the cusp
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * 0.5 * (1 + Math.cos(t));
            coefficients.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern.startsWith("r-")) {
        // Root-shape patterns: define roots, compute coefficients
        const roots = generateRootShape(pattern, degree, spread);
        const cs = rootsToCoefficients(roots);
        for (const c of cs) coefficients.push(c);
    }
}

// --- Roots → Coefficients ---
// Expand (z - r₀)(z - r₁)...(z - r_{n-1}) into coefficient array
function rootsToCoefficients(roots) {
    // Start with polynomial = [1] (just the leading coefficient)
    let re = [1], im = [0];
    for (const root of roots) {
        const newRe = new Array(re.length + 1).fill(0);
        const newIm = new Array(im.length + 1).fill(0);
        for (let j = 0; j < re.length; j++) {
            // Multiply by z: shift coefficients up
            newRe[j] += re[j];
            newIm[j] += im[j];
            // Multiply by -root: (a+bi)(-c-di) = (-ac+bd) + (-ad-bc)i
            newRe[j + 1] += -re[j] * root.re + im[j] * root.im;
            newIm[j + 1] += -re[j] * root.im - im[j] * root.re;
        }
        re = newRe;
        im = newIm;
    }
    return re.map((r, i) => ({ re: r, im: im[i] }));
}

// --- Root shape generators ---
function generateRootShape(pattern, degree, spread) {
    const n = degree; // number of roots = degree
    const roots = [];

    if (pattern === "r-heart") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const x = spread * 0.8 * 16 * Math.pow(Math.sin(t), 3) / 16;
            const y = spread * 0.8 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 16;
            roots.push({ re: x, im: y });
        }
    } else if (pattern === "r-circle") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            roots.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
    } else if (pattern === "r-star") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            const r = (i % 2 === 0) ? spread : spread * 0.4;
            roots.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "r-spiral") {
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const r = spread * (0.2 + 0.8 * t);
            const angle = 4 * Math.PI * t;
            roots.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "r-cross") {
        // + shape: half on horizontal, half on vertical
        const hCount = Math.ceil(n / 2);
        const vCount = n - hCount;
        for (let i = 0; i < hCount; i++) {
            const t = hCount === 1 ? 0 : -spread + (2 * spread * i) / (hCount - 1);
            roots.push({ re: t, im: 0 });
        }
        for (let i = 0; i < vCount; i++) {
            const t = vCount === 1 ? 0 : -spread + (2 * spread * i) / (vCount - 1);
            if (Math.abs(t) < 1e-10) continue; // skip origin (already in horizontal)
            roots.push({ re: 0, im: t });
        }
        // Fill up if we skipped the origin duplicate
        while (roots.length < n) {
            roots.push({ re: 0, im: spread * 0.1 * roots.length });
        }
    } else if (pattern === "r-diamond") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            // Diamond: |x| + |y| = spread, parametrically
            const x = spread * Math.cos(t);
            const y = spread * Math.sin(t);
            const scale = 1 / (Math.abs(Math.cos(t)) + Math.abs(Math.sin(t)));
            roots.push({ re: x * scale, im: y * scale });
        }
    } else if (pattern === "r-grid") {
        // Chessboard: only "black squares" of a grid
        const side = Math.ceil(Math.sqrt(n * 2));
        let placed = 0;
        for (let row = 0; row < side && placed < n; row++) {
            for (let col = 0; col < side && placed < n; col++) {
                if ((row + col) % 2 === 0) {
                    const re = -spread + (2 * spread * col) / (side - 1);
                    const im = -spread + (2 * spread * row) / (side - 1);
                    roots.push({ re, im });
                    placed++;
                }
            }
        }
    } else if (pattern === "r-smiley") {
        // Eyes + smile arc
        const eyeCount = Math.max(2, Math.floor(n * 0.2));
        const smileCount = n - eyeCount;
        // Left eye
        const leftEye = Math.ceil(eyeCount / 2);
        for (let i = 0; i < leftEye; i++) {
            const angle = (2 * Math.PI * i) / leftEye;
            roots.push({ re: -spread * 0.35 + spread * 0.12 * Math.cos(angle), im: spread * 0.3 + spread * 0.12 * Math.sin(angle) });
        }
        // Right eye
        const rightEye = eyeCount - leftEye;
        for (let i = 0; i < rightEye; i++) {
            const angle = (2 * Math.PI * i) / Math.max(rightEye, 1);
            roots.push({ re: spread * 0.35 + spread * 0.12 * Math.cos(angle), im: spread * 0.3 + spread * 0.12 * Math.sin(angle) });
        }
        // Smile arc (bottom half of circle)
        for (let i = 0; i < smileCount; i++) {
            const angle = Math.PI + (Math.PI * 0.8) * (i / (smileCount - 1)) - Math.PI * 0.4;
            roots.push({ re: spread * 0.6 * Math.cos(angle), im: spread * 0.6 * Math.sin(angle) - spread * 0.1 });
        }
    } else if (pattern === "r-figure8") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const cos2t = Math.cos(2 * t);
            const r = spread * Math.sqrt(Math.abs(cos2t));
            const sign = cos2t >= 0 ? 1 : -1;
            roots.push({ re: sign * r * Math.cos(t), im: sign * r * Math.sin(t) });
        }
    } else if (pattern === "r-butterfly") {
        // Butterfly curve (polar)
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * 0.4 * (Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) + Math.pow(Math.sin(t / 12), 5));
            roots.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "r-trefoil") {
        // 3-leaf clover
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * Math.cos(3 * t);
            roots.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "r-polygon") {
        // Regular polygon outline (not just vertices)
        const sides = Math.min(Math.max(3, Math.floor(degree / 2)), 8);
        const vertices = [];
        for (let s = 0; s < sides; s++) {
            const angle = (2 * Math.PI * s) / sides - Math.PI / 2;
            vertices.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
        // Distribute roots along edges
        for (let i = 0; i < n; i++) {
            const t = (i / n) * sides;
            const edgeIdx = Math.floor(t) % sides;
            const frac = t - Math.floor(t);
            const v1 = vertices[edgeIdx];
            const v2 = vertices[(edgeIdx + 1) % sides];
            roots.push({ re: v1.re + frac * (v2.re - v1.re), im: v1.im + frac * (v2.im - v1.im) });
        }
    } else if (pattern === "r-infinity") {
        // Infinity / lemniscate of Bernoulli: two lobes
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const denom = 1 + Math.sin(t) * Math.sin(t);
            roots.push({
                re: spread * Math.cos(t) / denom,
                im: spread * Math.sin(t) * Math.cos(t) / denom
            });
        }
    }
    return roots;
}

// --- Drag behavior ---

let dragMoved = false;
const drag = d3.drag()
    .on("start", function () {
        dragMoved = false;
        d3.select(this).raise().classed("dragging", true);
    })
    .on("drag", function (event, d) {
        dragMoved = true;
        // Skip drag if this coefficient is being animated
        if (d === coefficients[selectedCoeffIdx] && coeffMode === "loop" && animState.playing) return;
        d.re = cxs().invert(event.x);
        d.im = cys().invert(event.y);
        d3.select(this).attr("cx", cxs()(d.re)).attr("cy", cys()(d.im));
        coeffLayer.selectAll(".coeff-label")
            .filter(ld => ld === d)
            .attr("x", cxs()(d.re) + 12).attr("y", cys()(d.im) + 4);
        showTooltip(event.sourceEvent, d.re, d.im);
        autoScaleCoeffPanel();
        solveRootsThrottled();
        renderDomainColoringThrottled();
    })
    .on("end", function (event, d) {
        d3.select(this).classed("dragging", false);
        hideTooltip();
        // Click detection: if mouse didn't move, toggle selection
        if (!dragMoved) {
            const idx = coefficients.indexOf(d);
            selectCoefficient(idx === selectedCoeffIdx ? null : idx);
        }
    });

function autoScaleCoeffPanel() {
    const needed = computeRange(coefficients);
    if (needed !== panels.coeff.range) {
        updatePanelRange(coeffSvg, panels.coeff, needed);
        // Re-position all dots and labels with new scale
        coeffLayer.selectAll("circle.coeff")
            .attr("cx", d => cxs()(d.re)).attr("cy", d => cys()(d.im));
        coeffLayer.selectAll(".coeff-label")
            .attr("x", d => cxs()(d.re) + 12).attr("y", d => cys()(d.im) + 4);
    }
}

// --- Coefficient selection & animation ---

const animBar = document.getElementById("anim-bar");
const loopControls = document.getElementById("loop-controls");
const barTitle = document.getElementById("bar-title");
const animPathSel = document.getElementById("anim-path");
const animRadiusInput = document.getElementById("anim-radius");
const animSpeedInput = document.getElementById("anim-speed");
const animRadiusVal = document.getElementById("anim-radius-val");
const animSpeedVal = document.getElementById("anim-speed-val");
const playBtn = document.getElementById("play-btn");

function selectCoefficient(idx) {
    stopAnimation();
    selectedCoeffIdx = idx;
    coeffMode = "drag";
    // Update visual selection — compare by datum, not DOM index (.raise() reorders DOM)
    const selData = idx !== null ? coefficients[idx] : null;
    coeffLayer.selectAll("circle.coeff").classed("selected", d => d === selData);
    // Update radio buttons
    document.querySelector('input[name="coeff-mode"][value="drag"]').checked = true;
    loopControls.classList.remove("active");
    if (idx === null) {
        animBar.classList.remove("active");
        return;
    }
    barTitle.textContent = `c${subscript(idx)}`;
    animBar.classList.add("active");
}

// Mode radio buttons
document.querySelectorAll('input[name="coeff-mode"]').forEach(radio => {
    radio.addEventListener("change", function () {
        coeffMode = this.value;
        loopControls.classList.toggle("active", coeffMode === "loop");
        if (coeffMode === "drag") stopAnimation();
        playBtn.textContent = "▶ Play";
    });
});

// Slider value displays
animRadiusInput.addEventListener("input", function () { animRadiusVal.textContent = parseFloat(this.value).toFixed(2); });
animSpeedInput.addEventListener("input", function () { animSpeedVal.textContent = parseFloat(this.value).toFixed(1); });

// Play/Pause button
playBtn.addEventListener("click", function () {
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "▶ Play";
    } else {
        startAnimation();
        playBtn.textContent = "⏸ Pause";
    }
});

// --- Path functions ---

function animPathFn(name, t, center, radius) {
    const omega = 2 * Math.PI; // one full cycle per second (scaled by speed)
    switch (name) {
        case "circle":
            return { re: center.re + radius * Math.cos(omega * t), im: center.im + radius * Math.sin(omega * t) };
        case "horizontal":
            return { re: center.re + radius * Math.cos(omega * t), im: center.im };
        case "vertical":
            return { re: center.re, im: center.im + radius * Math.cos(omega * t) };
        case "spiral": {
            const r = radius * (0.5 + 0.5 * Math.sin(omega * t / 4));
            return { re: center.re + r * Math.cos(omega * t), im: center.im + r * Math.sin(omega * t) };
        }
        case "figure8": {
            const denom = 1 + Math.sin(omega * t) * Math.sin(omega * t);
            return {
                re: center.re + radius * Math.cos(omega * t) / denom,
                im: center.im + radius * Math.sin(omega * t) * Math.cos(omega * t) / denom
            };
        }
        case "random": {
            // Brownian-like: small random steps
            const step = radius * 0.02;
            return {
                re: center.re + (Math.random() - 0.5) * step,
                im: center.im + (Math.random() - 0.5) * step
            };
        }
        default:
            return center;
    }
}

// --- Animation engine ---

function startAnimation() {
    if (selectedCoeffIdx === null || selectedCoeffIdx >= coefficients.length) return;
    const d = coefficients[selectedCoeffIdx];
    // For random walk, the center drifts each frame
    const pathName = animPathSel.value;
    if (pathName === "random") {
        animState.center = { re: d.re, im: d.im }; // mutable center for random walk
    } else {
        animState.center = { re: d.re, im: d.im };
    }
    animState.playing = true;
    animState.startTime = performance.now();
    animState.rafId = requestAnimationFrame(animLoop);
}

function animLoop(now) {
    if (!animState.playing || selectedCoeffIdx === null) return;
    const elapsed = (now - animState.startTime) / 1000;
    const speed = parseFloat(animSpeedInput.value);
    const radius = parseFloat(animRadiusInput.value);
    const pathName = animPathSel.value;
    const t = elapsed * speed;

    const d = coefficients[selectedCoeffIdx];
    let newPos;
    if (pathName === "random") {
        // Random walk: center drifts
        newPos = animPathFn("random", t, animState.center, radius);
        animState.center = newPos; // update center for next frame
    } else {
        newPos = animPathFn(pathName, t, animState.center, radius);
    }
    d.re = newPos.re;
    d.im = newPos.im;

    // Update the dot and label visually — compare by datum, not DOM index
    coeffLayer.selectAll("circle.coeff")
        .filter(cd => cd === d)
        .attr("cx", cxs()(d.re)).attr("cy", cys()(d.im));
    coeffLayer.selectAll(".coeff-label")
        .filter(ld => ld === d)
        .attr("x", cxs()(d.re) + 12).attr("y", cys()(d.im) + 4);

    autoScaleCoeffPanel();
    solveRootsThrottled();
    renderDomainColoringThrottled();

    animState.rafId = requestAnimationFrame(animLoop);
}

function stopAnimation() {
    animState.playing = false;
    if (animState.rafId) {
        cancelAnimationFrame(animState.rafId);
        animState.rafId = null;
    }
}

// --- Render coefficients ---

function renderCoefficients() {
    // Auto-scale coeff panel to fit all coefficients
    const needed = computeRange(coefficients);
    updatePanelRange(coeffSvg, panels.coeff, needed);

    const n = coefficients.length;

    const circles = coeffLayer.selectAll("circle.coeff").data(coefficients, (_, i) => i);

    circles.enter()
        .append("circle")
        .attr("class", "coeff")
        .attr("r", 10)
        .attr("stroke", "#fff")
        .call(drag)
        .on("mouseover", function (event, d) { showTooltip(event, d.re, d.im); })
        .on("mouseout", hideTooltip)
      .merge(circles)
        .attr("cx", d => cxs()(d.re))
        .attr("cy", d => cys()(d.im))
        .attr("fill", (_, i) => coeffColor(i, n));

    circles.exit().remove();

    const labels = coeffLayer.selectAll(".coeff-label").data(coefficients, (_, i) => i);

    labels.enter()
        .append("text")
        .attr("class", "coeff-label")
      .merge(labels)
        .attr("x", d => cxs()(d.re) + 12)
        .attr("y", d => cys()(d.im) + 4)
        .text((_, i) => `c${subscript(i)}`);

    labels.exit().remove();
}

function subscript(n) {
    const digits = "₀₁₂₃₄₅₆₇₈₉";
    return String(n).split("").map(d => digits[+d]).join("");
}

// --- Root drag behavior (roots → coefficients) ---

const rootDrag = d3.drag()
    .on("start", function () {
        d3.select(this).raise().classed("dragging", true);
    })
    .on("drag", function (event, d) {
        d.re = rxs().invert(event.x);
        d.im = rys().invert(event.y);
        d3.select(this).attr("cx", rxs()(d.re)).attr("cy", rys()(d.im));
        showTooltip(event.sourceEvent, d.re, d.im);
        autoScaleRootsPanel();
        // Recompute coefficients from current roots (all client-side)
        const rootsForCoeffs = currentRoots.map(r => ({ re: r.re, im: r.im }));
        coefficients = rootsToCoefficients(rootsForCoeffs);
        renderCoefficients();
        renderDomainColoringThrottled();
    })
    .on("end", function () {
        d3.select(this).classed("dragging", false);
        hideTooltip();
    });

function autoScaleRootsPanel() {
    const needed = computeRange(currentRoots);
    if (needed !== panels.roots.range) {
        updatePanelRange(rootsSvg, panels.roots, needed);
        rootsLayer.selectAll("circle.root")
            .attr("cx", d => rxs()(d.re)).attr("cy", d => rys()(d.im));
    }
}

// --- Render roots ---

function renderRoots(newRoots) {
    // Update persistent root data
    while (currentRoots.length < newRoots.length) currentRoots.push({ re: 0, im: 0 });
    currentRoots.length = newRoots.length;
    for (let i = 0; i < newRoots.length; i++) {
        currentRoots[i].re = newRoots[i].re;
        currentRoots[i].im = newRoots[i].im;
    }

    // Auto-scale roots panel
    const needed = computeRange(currentRoots);
    updatePanelRange(rootsSvg, panels.roots, needed);
    renderDomainColoringThrottled();

    const circles = rootsLayer.selectAll("circle.root").data(currentRoots, (_, i) => i);

    circles.enter()
        .append("circle")
        .attr("class", "root")
        .attr("r", 7)
        .attr("fill", "#e94560")
        .attr("stroke", "#fff")
        .attr("stroke-width", 1)
        .call(rootDrag)
        .on("mouseover", function (event, d) { showTooltip(event, d.re, d.im); })
        .on("mouseout", hideTooltip)
      .merge(circles)
        .attr("cx", d => rxs()(d.re))
        .attr("cy", d => rys()(d.im));

    circles.exit().remove();
}

function resetView() {
    currentRoots = [];
    rootsLayer.selectAll("circle.root").remove();
    updatePanelRange(rootsSvg, panels.roots, MIN_RANGE);
    renderDomainColoring();
}

// --- Domain coloring ---

function hueToChannel(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1/6) return p + (q - p) * 6 * t;
    if (t < 1/2) return q;
    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
    return p;
}

function hslToRgb(h, s, l) {
    if (s === 0) return [Math.round(l * 255), Math.round(l * 255), Math.round(l * 255)];
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return [
        Math.round(hueToChannel(p, q, h + 1/3) * 255),
        Math.round(hueToChannel(p, q, h) * 255),
        Math.round(hueToChannel(p, q, h - 1/3) * 255)
    ];
}

function renderDomainColoring() {
    if (!domainColoringEnabled) return;

    const range = panels.roots.range;
    // Measure actual SVG position to align canvas precisely
    // (SVG may be centered by text-align:center, shifted by border, etc.)
    const svgEl = document.getElementById("roots-panel");
    const container = document.getElementById("roots-container");
    const svgRect = svgEl.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    const borderW = parseFloat(getComputedStyle(svgEl).borderLeftWidth) || 0;
    const contentW = svgRect.width - 2 * borderW;
    const vbScale = contentW / S; // viewBox units → CSS pixels
    const plotSize = (S - 2 * MARGIN) * vbScale;
    const plotLeft = (svgRect.left - containerRect.left) + borderW + MARGIN * vbScale;
    const plotTop = (svgRect.top - containerRect.top) + borderW + MARGIN * vbScale;
    const dpr = window.devicePixelRatio || 1;
    const canvasW = Math.max(1, Math.floor(plotSize * DOMAIN_RES_SCALE * dpr));
    const canvasH = canvasW;

    domainCanvas.width = canvasW;
    domainCanvas.height = canvasH;
    domainCanvas.style.width = plotSize + "px";
    domainCanvas.style.height = plotSize + "px";
    domainCanvas.style.left = plotLeft + "px";
    domainCanvas.style.top = plotTop + "px";

    const imageData = domainCtx.createImageData(canvasW, canvasH);
    const data = imageData.data;

    const n = coefficients.length;
    if (n === 0) { domainCtx.putImageData(imageData, 0, 0); return; }

    // Precompute coefficient arrays for Horner's method
    const cRe = new Float64Array(n);
    const cIm = new Float64Array(n);
    for (let k = 0; k < n; k++) {
        cRe[k] = coefficients[k].re;
        cIm[k] = coefficients[k].im;
    }

    const TWO_PI = 2 * Math.PI;
    const INV_PI_180 = 180 / Math.PI;

    for (let py = 0; py < canvasH; py++) {
        const im = range - (2 * range * (py + 0.5)) / canvasH;
        for (let px = 0; px < canvasW; px++) {
            const re = -range + (2 * range * (px + 0.5)) / canvasW;

            // Horner's method: p(z) = c[0]*z^(n-1) + c[1]*z^(n-2) + ... + c[n-1]
            let pRe = cRe[0], pIm = cIm[0];
            for (let k = 1; k < n; k++) {
                const newRe = pRe * re - pIm * im + cRe[k];
                const newIm = pRe * im + pIm * re + cIm[k];
                pRe = newRe;
                pIm = newIm;
            }

            // Hue from argument
            let hue = Math.atan2(pIm, pRe) * INV_PI_180;
            if (hue < 0) hue += 360;

            // Lightness with log-modulus contour lines
            const mod2 = pRe * pRe + pIm * pIm;
            let lightness;
            if (mod2 < 1e-600) {
                lightness = 0;
            } else {
                const logMod = 0.5 * Math.log2(mod2); // = log2(|p(z)|)
                const frac = logMod - Math.floor(logMod);
                lightness = 0.5 + 0.4 * Math.cos(TWO_PI * frac);
            }

            const [r, g, b] = hslToRgb(hue / 360, 0.8, lightness);
            const idx = (py * canvasW + px) * 4;
            data[idx] = r;
            data[idx + 1] = g;
            data[idx + 2] = b;
            data[idx + 3] = 255;
        }
    }
    domainCtx.putImageData(imageData, 0, 0);
}

function renderDomainColoringThrottled() {
    if (!domainPendingRender) {
        domainPendingRender = true;
        requestAnimationFrame(() => {
            renderDomainColoring();
            domainPendingRender = false;
        });
    }
}

// --- Ehrlich-Aberth client-side root solver ---

function solveRootsEA(coeffs, warmStart) {
    // coeffs: array of {re, im} in descending degree order
    // warmStart: array of {re, im} initial guesses (or null)
    // Returns: array of {re, im} roots

    // Strip leading near-zero coefficients
    let start = 0;
    while (start < coeffs.length - 1 && Math.hypot(coeffs[start].re, coeffs[start].im) < 1e-15) {
        start++;
    }
    const c = coeffs.slice(start);
    const degree = c.length - 1;
    if (degree <= 0) return [];

    // Degree 1: linear case c[0]*z + c[1] = 0
    if (degree === 1) {
        const aRe = c[0].re, aIm = c[0].im;
        const bRe = c[1].re, bIm = c[1].im;
        const denom = aRe * aRe + aIm * aIm;
        if (denom < 1e-30) return [];
        return [{ re: -(bRe * aRe + bIm * aIm) / denom, im: -(bIm * aRe - bRe * aIm) / denom }];
    }

    const MAX_ITER = 100;
    const TOL = 1e-12;

    // Initialize root guesses
    const roots = new Array(degree);
    if (warmStart && warmStart.length === degree) {
        for (let i = 0; i < degree; i++) {
            roots[i] = [warmStart[i].re, warmStart[i].im];
        }
    } else {
        // Spread initial guesses on a circle with radius from coefficient ratio
        const leadMod = Math.hypot(c[0].re, c[0].im);
        const trailMod = Math.hypot(c[degree].re, c[degree].im);
        const radius = leadMod > 1e-30
            ? Math.max(0.1, Math.min(Math.pow(trailMod / leadMod, 1 / degree), 10))
            : 1;
        for (let i = 0; i < degree; i++) {
            const angle = (2 * Math.PI * i) / degree + 0.37; // offset to break symmetry
            roots[i] = [radius * Math.cos(angle), radius * Math.sin(angle)];
        }
    }

    // Precompute coefficient arrays for Horner's method
    const n = c.length;
    const cRe = new Float64Array(n);
    const cIm = new Float64Array(n);
    for (let k = 0; k < n; k++) {
        cRe[k] = c[k].re;
        cIm[k] = c[k].im;
    }

    // Iterate
    for (let iter = 0; iter < MAX_ITER; iter++) {
        let maxCorr = 0;

        for (let i = 0; i < degree; i++) {
            const zRe = roots[i][0], zIm = roots[i][1];

            // Evaluate p(z) and p'(z) simultaneously via Horner
            let pRe = cRe[0], pIm = cIm[0];
            let dpRe = 0, dpIm = 0;
            for (let k = 1; k < n; k++) {
                // dp = dp * z + p
                const ndRe = dpRe * zRe - dpIm * zIm + pRe;
                const ndIm = dpRe * zIm + dpIm * zRe + pIm;
                dpRe = ndRe;
                dpIm = ndIm;
                // p = p * z + c[k]
                const npRe = pRe * zRe - pIm * zIm + cRe[k];
                const npIm = pRe * zIm + pIm * zRe + cIm[k];
                pRe = npRe;
                pIm = npIm;
            }

            // Newton step: w = p(z) / p'(z)
            const dpMod2 = dpRe * dpRe + dpIm * dpIm;
            if (dpMod2 < 1e-60) continue;
            const wRe = (pRe * dpRe + pIm * dpIm) / dpMod2;
            const wIm = (pIm * dpRe - pRe * dpIm) / dpMod2;

            // Aberth sum: S = Σ_{j≠i} 1/(z_i - z_j)
            let sRe = 0, sIm = 0;
            for (let j = 0; j < degree; j++) {
                if (j === i) continue;
                const dRe = zRe - roots[j][0];
                const dIm = zIm - roots[j][1];
                const dMod2 = dRe * dRe + dIm * dIm;
                if (dMod2 < 1e-60) continue;
                sRe += dRe / dMod2;
                sIm += -dIm / dMod2;
            }

            // Aberth correction: correction = w / (1 - w * S)
            const wsRe = wRe * sRe - wIm * sIm;
            const wsIm = wRe * sIm + wIm * sRe;
            const denomRe = 1 - wsRe;
            const denomIm = -wsIm;
            const denomMod2 = denomRe * denomRe + denomIm * denomIm;
            if (denomMod2 < 1e-60) continue;

            const corrRe = (wRe * denomRe + wIm * denomIm) / denomMod2;
            const corrIm = (wIm * denomRe - wRe * denomIm) / denomMod2;

            roots[i][0] -= corrRe;
            roots[i][1] -= corrIm;

            maxCorr = Math.max(maxCorr, Math.hypot(corrRe, corrIm));
        }

        if (maxCorr < TOL) break;
    }

    // Filter NaN/Inf and return
    const result = [];
    for (let i = 0; i < degree; i++) {
        if (isFinite(roots[i][0]) && isFinite(roots[i][1])) {
            result.push({ re: roots[i][0], im: roots[i][1] });
        }
    }
    return result;
}

function solveRoots() {
    const roots = solveRootsEA(coefficients, currentRoots);
    renderRoots(roots);
}

function solveRootsThrottled() {
    if (!pendingSolve) {
        pendingSolve = true;
        requestAnimationFrame(() => {
            solveRoots();
            pendingSolve = false;
        });
    }
}

// --- Degree slider ---

const degreeInput = document.getElementById("degree");
const degreeValue = document.getElementById("degree-value");

function applyPattern() {
    selectCoefficient(null); // stop animation, clear selection
    resetView();
    initCoefficients(parseInt(degreeInput.value));
    renderCoefficients();
    solveRoots();
    renderDomainColoring();
}

degreeInput.addEventListener("input", function () {
    degreeValue.textContent = this.value;
    applyPattern();
});

document.getElementById("pattern").addEventListener("change", applyPattern);

document.getElementById("spread").addEventListener("input", function () {
    document.getElementById("spread-value").textContent = parseFloat(this.value).toFixed(1);
    applyPattern();
});

document.getElementById("reset-btn").addEventListener("click", function () {
    resetView();
    solveRoots();
});

document.getElementById("domain-coloring-toggle").addEventListener("change", function () {
    domainColoringEnabled = this.checked;
    domainCanvas.style.display = domainColoringEnabled ? "block" : "none";
    rootsSvg.classed("domain-active", domainColoringEnabled);
    if (domainColoringEnabled) renderDomainColoring();
});

// --- Resize handler ---

function rebuild() {
    S = getPanelSize();
    initPanelScales(panels.coeff);
    initPanelScales(panels.roots);

    // Clear and rebuild both SVGs
    coeffSvg.selectAll("*").remove();
    rootsSvg.selectAll("*").remove();
    setupPanel(coeffSvg, panels.coeff);
    setupPanel(rootsSvg, panels.roots);

    // Recreate layers
    coeffLayer = coeffSvg.append("g");
    rootsLayer = rootsSvg.append("g");

    renderCoefficients();
    // Reapply selection visual if a coefficient is selected
    if (selectedCoeffIdx !== null && selectedCoeffIdx < coefficients.length) {
        const selData = coefficients[selectedCoeffIdx];
        coeffLayer.selectAll("circle.coeff").classed("selected", d => d === selData);
    }

    // Re-solve roots and re-render domain coloring at new size
    solveRoots();
    rootsSvg.classed("domain-active", domainColoringEnabled);
    renderDomainColoring();
}

let resizeTimer;
window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(rebuild, 150);
});

// --- Init ---

rootsSvg.classed("domain-active", domainColoringEnabled);
initCoefficients(parseInt(degreeInput.value));
renderCoefficients();
solveRoots();
renderDomainColoring();
</script>
</body>
</html>
