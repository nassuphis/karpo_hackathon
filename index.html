<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>PolyPaint v23</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<style>
:root {
    --bg: #0f1026;
    --panel: #151a3a;
    --stroke: rgba(255,255,255,0.08);
    --stroke2: rgba(255,255,255,0.14);
    --text: #e9e9f2;
    --muted: #8a90a6;
    --accent: #e94560;
    --accent-hover: #c73550;
    --accent-dim: rgba(233,69,96,0.18);
    --accent-border: rgba(233,69,96,0.45);
    --blue: #5b6abf;
    --radius: 10px;
    --blur: blur(12px);
}
* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; }
body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: radial-gradient(ellipse 1200px 600px at 20% -10%, rgba(233,69,96,0.12), transparent 60%),
                radial-gradient(ellipse 900px 500px at 90% 0%, rgba(91,106,191,0.10), transparent 60%),
                var(--bg);
    color: var(--text);
    display: grid; grid-template-rows: auto 1fr; height: 100%;
}
/* --- Header --- */
#header {
    padding: 6px 14px; border-bottom: 1px solid var(--stroke);
    display: flex; align-items: center; gap: 10px;
    background: rgba(10,12,30,0.55);
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
}
#header .app-title {
    font-size: 12px; font-weight: 600; color: var(--muted);
    letter-spacing: 0.14em; text-transform: uppercase;
}
.header-sep { width: 1px; height: 18px; background: var(--stroke2); }
/* --- Content + main --- */
#content { display: flex; flex-direction: column; min-height: 0; }
#main { display: flex; flex-direction: column; min-height: 0; flex: 1; }
.icon-btn {
    width: 28px; height: 28px; border-radius: 8px;
    border: 1px solid var(--stroke); background: rgba(255,255,255,0.03);
    color: var(--muted); display: flex; align-items: center; justify-content: center;
    cursor: pointer; font-size: 13px; padding: 0;
    transition: background 0.12s, border-color 0.12s, color 0.12s;
}
.icon-btn:hover { background: rgba(255,255,255,0.06); border-color: var(--stroke2); color: var(--text); }
.icon-btn.active { background: var(--accent-dim); border-color: var(--accent-border); color: #fff; }
.control-label {
    font-size: 10px; color: var(--muted); text-transform: uppercase;
    letter-spacing: 0.5px; font-weight: 500;
}
.degree-val {
    color: var(--accent); font-size: 14px; font-weight: 600;
    cursor: pointer; min-width: 20px; text-align: center;
    border-bottom: 1px solid transparent;
    transition: border-color 0.12s;
}
.degree-val:hover { border-bottom-color: var(--accent); }
.degree-val.tool-active { border-bottom-color: var(--accent); }
#pattern {
    background: rgba(255,255,255,0.04); color: var(--text);
    border: 1px solid var(--stroke); border-radius: 6px;
    padding: 4px 8px; font-size: 11px; outline: none;
}
/* --- Mid-bar (Ops between panels) --- */
.mid-bar {
    display: flex; flex-direction: column; gap: 6px; align-items: center;
    justify-content: center; padding: 0 2px; flex-shrink: 0;
}
.mid-label {
    font-size: 8px; color: var(--muted); letter-spacing: 0.10em;
    text-transform: uppercase; opacity: 0.85; text-align: center; line-height: 1.2;
}
.mid-btn {
    width: 32px; height: 32px; border-radius: 10px;
    border: 1px solid var(--stroke); background: rgba(255,255,255,0.03);
    color: var(--muted); display: flex; align-items: center; justify-content: center;
    cursor: pointer; font-size: 14px; padding: 0;
    transition: background 0.12s, border-color 0.12s, color 0.12s, transform 0.06s;
}
.mid-btn:hover { background: rgba(255,255,255,0.06); border-color: var(--stroke2); color: var(--text); }
.mid-btn:active { transform: translateY(1px); }
#ops-target { opacity: 0.7; font-size: 7px; display: block; }
#ops-group.disabled { opacity: 0.35; pointer-events: none; }
#ops-group:not(.disabled) .mid-btn { color: var(--text); border-color: var(--stroke2); }
#ops-group .mid-btn.tool-active {
    background: var(--accent-dim); border-color: var(--accent-border); color: #fff;
}
/* --- Ops Popover --- */
.ops-pop {
    display: none; position: fixed; z-index: 200;
    background: rgba(15, 16, 38, 0.92);
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
    border: 1px solid var(--stroke2); border-radius: var(--radius);
    box-shadow: 0 12px 40px rgba(0,0,0,0.5);
    padding: 10px; min-width: 52px;
}
.ops-pop.open { display: flex; flex-direction: column; align-items: center; gap: 6px; }
.ops-pop .pop-title {
    font-size: 9px; color: var(--muted); text-transform: uppercase;
    letter-spacing: 0.10em;
}
.ops-pop .pop-val {
    font-size: 11px; color: var(--accent); font-weight: 600; min-width: 40px; text-align: center;
}
/* Scale / Rotate slider track */
.ops-pop .vslider {
    width: 6px; height: 140px; border-radius: 3px;
    background: rgba(255,255,255,0.06); position: relative; cursor: pointer;
    touch-action: none;
}
.ops-pop .vslider .vslider-fill {
    position: absolute; bottom: 0; left: 0; right: 0;
    border-radius: 3px; background: var(--accent-dim);
    pointer-events: none;
}
.ops-pop .vslider .vslider-thumb {
    position: absolute; left: 50%; width: 16px; height: 16px;
    margin-left: -8px; margin-top: -8px;
    border-radius: 50%; background: var(--accent); border: 2px solid #fff;
    box-shadow: 0 0 8px rgba(233,69,96,0.5); pointer-events: none;
}
/* Horizontal slider (rotate) */
.ops-pop .hslider {
    width: 160px; height: 6px; border-radius: 3px;
    background: rgba(255,255,255,0.06); position: relative; cursor: pointer;
    touch-action: none;
}
.ops-pop .hslider .hslider-thumb {
    position: absolute; top: 50%; width: 16px; height: 16px;
    margin-left: -8px; margin-top: -8px;
    border-radius: 50%; background: var(--accent); border: 2px solid #fff;
    box-shadow: 0 0 8px rgba(233,69,96,0.5); pointer-events: none;
}
.ops-pop .hslider .hslider-center {
    position: absolute; left: 50%; top: 0; bottom: 0; width: 1px;
    background: rgba(255,255,255,0.15); pointer-events: none;
}
/* 2D vector pad */
.ops-pop .vec-pad {
    width: 140px; height: 140px; border-radius: 8px;
    background: rgba(255,255,255,0.04); border: 1px solid var(--stroke);
    position: relative; cursor: crosshair; touch-action: none;
}
.ops-pop .vec-pad .pad-axis {
    position: absolute; background: rgba(255,255,255,0.08); pointer-events: none;
}
.ops-pop .vec-pad .pad-axis.h { left: 0; right: 0; top: 50%; height: 1px; }
.ops-pop .vec-pad .pad-axis.v { top: 0; bottom: 0; left: 50%; width: 1px; }
.ops-pop .vec-pad .pad-dot {
    position: absolute; width: 14px; height: 14px;
    margin-left: -7px; margin-top: -7px;
    border-radius: 50%; background: var(--accent); border: 2px solid #fff;
    box-shadow: 0 0 8px rgba(233,69,96,0.5); pointer-events: none;
    left: 50%; top: 50%;
}
.ops-pop .vec-pad .pad-line {
    position: absolute; pointer-events: none;
    left: 50%; top: 50%; width: 0; height: 0;
    transform-origin: 0 0;
}
.ops-pop .pop-row {
    display: flex; gap: 8px; font-size: 10px; color: var(--muted);
}
/* --- Coefficient context menu --- */
#coeff-ctx { min-width: 180px; padding: 10px 12px; gap: 6px; }
#coeff-ctx .ctx-title { font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 2px; display: flex; align-items: center; gap: 6px; width: 100%; }
#coeff-ctx .ctx-title .ctx-move { width: 16px; height: 16px; border-radius: 50%; border: 1px solid var(--stroke); background: rgba(255,255,255,0.08); color: var(--muted); font-size: 9px; cursor: pointer; display: flex; align-items: center; justify-content: center; margin-left: auto; flex-shrink: 0; padding: 0; line-height: 1; }
#coeff-ctx .ctx-title .ctx-move:hover { background: rgba(255,255,255,0.18); color: var(--text); }
#coeff-ctx label { display: flex; align-items: center; gap: 6px; font-size: 9px; color: var(--muted); white-space: nowrap; width: 100%; }
#coeff-ctx select, #coeff-ctx input[type=range] { flex: 1; }
#coeff-ctx select { font-size: 9px; background: var(--panel); color: var(--text); border: 1px solid var(--stroke); border-radius: 3px; padding: 2px 4px; }
#coeff-ctx .ctx-val { font-size: 9px; color: var(--text); min-width: 32px; text-align: right; }
#coeff-ctx .ctx-row { display: flex; align-items: center; gap: 6px; width: 100%; }
#coeff-ctx .ctx-accept { margin-top: 4px; padding: 4px 16px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; background: var(--accent); color: #fff; border: none; border-radius: var(--radius); cursor: pointer; align-self: center; }
#coeff-ctx .ctx-accept:hover { filter: brightness(1.2); }
#coeff-ctx .ctx-dir { font-size: 9px; padding: 2px 8px; background: transparent; border: 1px solid var(--stroke); color: var(--muted); border-radius: 3px; cursor: pointer; }
#coeff-ctx .ctx-dir.active { color: var(--text); border-color: var(--accent-dim); }
/* --- Audio config popover rows --- */
.audio-row {
    display: flex; align-items: center; gap: 8px; width: 100%;
}
.audio-row .row-label {
    font-size: 9px; color: var(--muted); width: 56px;
    text-transform: uppercase; letter-spacing: 0.08em; flex-shrink: 0;
}
.audio-row .hslider { flex: 1; min-width: 80px; }
.audio-row .row-val {
    font-size: 10px; color: var(--accent); width: 52px;
    text-align: right; font-variant-numeric: tabular-nums; flex-shrink: 0;
}
.audio-toggle {
    display: flex; align-items: center; gap: 6px;
    cursor: pointer; padding: 4px 0; user-select: none; width: 100%;
}
.audio-toggle .toggle-dot {
    width: 10px; height: 10px; border-radius: 50%;
    border: 1.5px solid var(--muted); transition: all 0.12s;
}
.audio-toggle.on .toggle-dot {
    background: var(--accent); border-color: var(--accent);
}
.audio-toggle .toggle-label {
    font-size: 10px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em;
}
.audio-toggle.on .toggle-label { color: var(--text); }
/* --- Coeff picker rows --- */
.cpick-row {
    display: flex; align-items: center; gap: 6px; width: 100%;
    padding: 2px 0; cursor: pointer; user-select: none;
}
.cpick-row:hover { background: rgba(255,255,255,0.05); }
.cpick-row .cpick-dot {
    width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0;
}
.cpick-row .cpick-label {
    font-size: 10px; color: var(--muted); width: 28px; flex-shrink: 0;
}
.cpick-row .cpick-power {
    font-size: 9px; color: var(--muted); opacity: 0.6; width: 30px; flex-shrink: 0;
}
.cpick-row .cpick-path {
    font-size: 8px; color: var(--muted); opacity: 0.7; flex-shrink: 0;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.cpick-row .cpick-path .cpick-detail { opacity: 0.6; margin-left: 3px; font-size: 7px; }
.cpick-path-btn {
    font-size: 8px; color: var(--text); background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15);
    border-radius: 3px; padding: 1px 2px; cursor: pointer; flex-shrink: 0;
    white-space: nowrap; width: 58px; text-align: center; transition: all 0.12s;
    overflow: hidden; text-overflow: ellipsis;
}
.cpick-path-btn:hover { background: rgba(255,255,255,0.14); border-color: rgba(255,255,255,0.3); }
#path-pick-pop { min-width: 180px; padding: 10px 12px; gap: 6px; }
#path-pick-pop .ctx-title { font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 2px; display: flex; align-items: center; gap: 6px; width: 100%; }
#path-pick-pop label { display: flex; align-items: center; gap: 6px; font-size: 9px; color: var(--muted); white-space: nowrap; width: 100%; }
#path-pick-pop select, #path-pick-pop input[type=range] { flex: 1; }
#path-pick-pop select { font-size: 9px; background: var(--panel); color: var(--text); border: 1px solid var(--stroke); border-radius: 3px; padding: 2px 4px; }
#path-pick-pop .ctx-val { font-size: 9px; color: var(--text); min-width: 32px; text-align: right; }
#path-pick-pop .ctx-row { display: flex; align-items: center; gap: 6px; width: 100%; }
#path-pick-pop .ctx-accept { margin-top: 4px; padding: 4px 16px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; background: var(--accent); color: #fff; border: none; border-radius: var(--radius); cursor: pointer; align-self: center; }
#path-pick-pop .ctx-accept:hover { filter: brightness(1.2); }
#path-pick-pop .ctx-dir { font-size: 9px; padding: 2px 8px; background: transparent; border: 1px solid var(--stroke); color: var(--muted); border-radius: 3px; cursor: pointer; }
#path-pick-pop .ctx-dir.active { color: var(--text); border-color: var(--accent-dim); }
#lce-controls { display: flex; align-items: center; gap: 4px; }
#lce-controls label { display: flex; align-items: center; gap: 2px; font-size: 9px; color: var(--muted); white-space: nowrap; }
#lce-controls input[type=range] { width: 48px; accent-color: var(--accent); }
#lce-controls .ctx-val { font-size: 9px; color: var(--text); min-width: 20px; text-align: right; }
#lce-controls .ctx-dir { font-size: 9px; padding: 1px 6px; background: transparent; border: 1px solid var(--stroke); color: var(--muted); border-radius: 3px; cursor: pointer; }
#lce-controls .ctx-dir.active { color: var(--text); border-color: var(--accent-dim); }
.cpick-row .cpick-pts {
    font-size: 8px; color: var(--muted); opacity: 0.5; flex-shrink: 0;
    min-width: 28px; text-align: right; font-variant-numeric: tabular-nums;
}
.cpick-row .cpick-speed, .cpick-row .cpick-plen, .cpick-row .cpick-pos {
    font-size: 8px; color: var(--muted); opacity: 0.7; flex-shrink: 0;
    min-width: 24px; text-align: right; font-variant-numeric: tabular-nums;
}
.cpick-row .cpick-coords {
    font-size: 9px; color: var(--muted); flex: 1; text-align: right;
    font-variant-numeric: tabular-nums;
}
.cpick-row .cpick-cb {
    width: 12px; height: 12px; border: 1.5px solid var(--muted); border-radius: 2px;
    flex-shrink: 0; display: flex; align-items: center; justify-content: center;
    transition: all 0.12s;
}
.cpick-row .cpick-cb.checked {
    background: var(--accent); border-color: var(--accent);
}
.cpick-row .cpick-cb.checked::after {
    content: "‚úì"; font-size: 8px; color: #fff;
}
/* --- Panels --- */
#panels { display: flex; justify-content: center; gap: 8px; padding: 8px 12px 12px 12px; flex: 1; min-height: 0; }
.panel {
    text-align: center; display: flex; flex-direction: column; flex: 1; min-width: 0; min-height: 0;
    background: rgba(255,255,255,0.02); border: 1px solid var(--stroke);
    border-radius: var(--radius); box-shadow: 0 8px 24px rgba(0,0,0,0.3); overflow: hidden;
}
.panel h3 {
    margin: 0; padding: 8px 12px; flex-shrink: 0;
    font-weight: 500; font-size: 11px; text-transform: uppercase; letter-spacing: 0.8px; color: var(--muted);
    border-bottom: 1px solid var(--stroke); background: rgba(10,12,30,0.45);
    display: flex; align-items: center; justify-content: space-between;
}
.panel h3 .icon-btn { width: 22px; height: 22px; font-size: 11px; border-radius: 6px; }
#rec-roots-btn.recording { color: #e94560; animation: rec-blink 1s ease-in-out infinite alternate; }
@keyframes rec-blink { from { opacity: 1; } to { opacity: 0.4; } }
svg { background: var(--panel); border: 0; border-radius: 0; flex: 1; position: relative; }
.grid line { stroke: #1f3354; stroke-width: 0.5; }
.axis line { stroke: #2a4a6b; stroke-width: 1; }
.unit-circle { fill: none; stroke: #2a4a6b; stroke-width: 1; stroke-dasharray: 4 3; }
circle.coeff { cursor: grab; stroke-width: 1.5; }
circle.coeff.dragging { cursor: grabbing; stroke: #fff; stroke-width: 2.5; }
circle.root { cursor: grab; stroke-width: 1.5; }
circle.root.dragging { cursor: grabbing; stroke: #fff; stroke-width: 2.5; }
.coeff-label { font-size: 10px; fill: #aaa; pointer-events: none; }
/* --- Tabs (roots panel) --- */
.tab-bar { display:flex; align-items:stretch; padding:0 8px; gap:0;
           flex-shrink:0; background:rgba(10,12,30,0.45);
           border-bottom:1px solid var(--stroke); }
.tab { padding:7px 14px 8px; font-weight:500; font-size:11px;
       text-transform:uppercase; letter-spacing:0.8px; color:var(--muted);
       background:transparent; border:1px solid transparent; border-bottom:none;
       border-radius:var(--radius) var(--radius) 0 0; cursor:pointer;
       position:relative; top:1px; margin-bottom:-1px; transition:color 0.12s, background 0.12s; }
.tab:not(.active):hover { background:rgba(255,255,255,0.04); color:var(--text); }
.tab.active { background:rgba(255,255,255,0.02); border-color:var(--stroke);
              border-bottom-color:rgba(255,255,255,0.02); color:var(--text); z-index:1; }
.tab-bar .icon-btn { width:22px; height:22px; font-size:11px; border-radius:6px; }
.tab-bar-controls { display:flex; gap:4px; align-items:center; margin-left:auto; padding:0 0 0 8px; }
.tab-panes { flex:1; min-height:0; position:relative; }
.tab-content { position:absolute; top:0; left:0; right:0; bottom:0;
               visibility:hidden; display:flex; flex-direction:column; }
.tab-content.active { visibility:visible; }
.stats-grid { display:grid; grid-template-columns:1fr 1fr 1fr 1fr; grid-template-rows:1fr 1fr 1fr 1fr;
              flex:1; gap:0; min-height:0; }
.stats-cell { display:flex; flex-direction:column; min-height:0; border:1px solid var(--stroke);
              margin:-0.5px; overflow:hidden; }
.stats-cell:first-child { border-radius:0; }
.stats-select { flex-shrink:0; width:100%; padding:1px 3px; font-size:8px;
                background:rgba(10,12,30,0.6); color:var(--muted); border:none;
                border-bottom:1px solid var(--stroke); cursor:pointer;
                font-family:inherit; letter-spacing:0.3px; outline:none; }
.stats-select:focus { color:var(--text); }
.stats-canvas { flex:1; width:100%; min-height:0; background:var(--panel); }
.config-panel { padding:8px 10px; display:flex; flex-direction:column; gap:6px; overflow-y:auto; align-items:flex-start; }
.config-section { font-size:8px; color:var(--muted); text-transform:uppercase; letter-spacing:0.08em; padding:5px 0 2px; border-bottom:1px solid var(--stroke); text-align:left; }
.config-row-stack { display:flex; flex-direction:column; gap:4px; max-width:220px; }
.config-row-stack .audio-row .row-label { width:42px; font-size:8px; }
.config-row-stack .audio-row .row-val { width:40px; font-size:9px; }
.config-row-stack .audio-row .hslider { min-width:60px; }
.config-panel .hslider {
    height:6px; border-radius:3px; background:rgba(255,255,255,0.06);
    position:relative; cursor:pointer; touch-action:none;
}
.config-panel .hslider .hslider-thumb {
    position:absolute; top:50%; width:14px; height:14px;
    margin-left:-7px; margin-top:-7px; border-radius:50%;
    background:var(--accent); border:2px solid #fff;
    box-shadow:0 0 6px rgba(233,69,96,0.4); pointer-events:none;
}
.route-table { border-collapse:collapse; width:auto; }
.route-table th { font-size:7px; color:var(--muted); text-transform:uppercase; letter-spacing:0.08em;
    padding:2px 4px 2px 0; text-align:left; border-bottom:1px solid var(--stroke); font-weight:500; white-space:nowrap; }
.route-table td { padding:2px 4px 2px 0; vertical-align:middle; white-space:nowrap; }
.route-table select { padding:1px 3px; font-size:8px; width:auto;
    background:rgba(10,12,30,0.6); color:var(--text); border:1px solid var(--stroke);
    border-radius:var(--radius); font-family:inherit; cursor:pointer; outline:none; }
.route-table select:focus { border-color:var(--accent); }
.route-table .target-label { font-size:8px; color:var(--muted); white-space:nowrap; }
.route-table .norm-select { font-size:7px; padding:1px 2px; }
.cell-slider-wrap { display:flex; align-items:center; gap:2px; min-width:48px; }
.cell-slider { flex:1; height:3px; border-radius:2px; background:rgba(255,255,255,0.06);
    position:relative; cursor:pointer; touch-action:none; min-width:24px; }
.cell-slider-thumb { position:absolute; top:50%; width:8px; height:8px;
    margin-left:-4px; margin-top:-4px; border-radius:50%;
    background:var(--accent); border:1px solid #fff; pointer-events:none; }
.cell-slider-val { font-size:7px; color:var(--accent); width:22px;
    text-align:right; font-variant-numeric:tabular-nums; flex-shrink:0; }
#roots-container { position: relative; flex: 1; min-height: 0; }
#domain-canvas { position: absolute; top: 0; left: 0; border-radius: 0; }
#roots-panel.domain-active { background: transparent !important; }
circle.coeff.selected, circle.root.selected {
    stroke: #fff; stroke-width: 3;
    filter: drop-shadow(0 0 4px var(--accent)) drop-shadow(0 0 10px var(--accent)) drop-shadow(0 0 18px rgba(233,69,96,0.4));
    animation: sel-pulse 1.2s ease-in-out infinite alternate;
}
@keyframes sel-pulse {
    from { filter: drop-shadow(0 0 4px var(--accent)) drop-shadow(0 0 10px var(--accent)) drop-shadow(0 0 18px rgba(233,69,96,0.4)); }
    to   { filter: drop-shadow(0 0 6px var(--accent)) drop-shadow(0 0 14px var(--accent)) drop-shadow(0 0 24px rgba(233,69,96,0.5)); }
}
.sel-rect {
    fill: rgba(233,69,96,0.12); stroke: rgba(233,69,96,0.65);
    stroke-width: 1.5; stroke-dasharray: 4 3; pointer-events: none;
}
#coeff-container { position: relative; flex: 1; min-height: 0; }
/* --- Anim bar --- */
#anim-bar {
    display: grid; grid-template-columns: 1fr; gap: 4px;
    padding: 6px 10px; flex-shrink: 0;
    background: rgba(10, 12, 30, 0.45);
    border-bottom: 1px solid var(--stroke);
}
.bar-row { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
#anim-bar .bar-title { font-weight: bold; color: var(--accent); font-size: 11px; }
#anim-bar .bar-title.empty { color: var(--muted); font-weight: normal; font-style: italic; }
#anim-bar label { font-size: 10px; display: flex; align-items: center; gap: 3px; cursor: pointer; color: var(--muted); }
#anim-bar select {
    background: rgba(255,255,255,0.04); color: var(--text);
    border: 1px solid var(--stroke); border-radius: 6px;
    padding: 2px 4px; font-size: 10px;
}
#anim-bar input[type="range"] { width: 52px; accent-color: var(--accent); }
#anim-bar .bar-val { color: var(--accent); min-width: 20px; text-align: right; font-size: 10px; }
#bar-dynamic { display: grid; grid-template-columns: repeat(6, auto); gap: 4px 8px; align-items: center; }
#play-btn {
    background: var(--accent); color: #fff; border: none; border-radius: 6px;
    padding: 2px 8px; font-size: 10px; cursor: pointer; font-weight: 500;
    transition: background 0.12s;
}
#play-btn:hover { background: var(--accent-hover); }
#home-btn {
    background: rgba(255,255,255,0.12); color: #fff; border: 1px solid rgba(255,255,255,0.25); border-radius: 6px;
    padding: 2px 8px; font-size: 10px; cursor: pointer; font-weight: 500;
    transition: all 0.12s;
}
#home-btn:hover { background: rgba(255,255,255,0.22); border-color: rgba(255,255,255,0.4); }
#roots-toolbar {
    position: absolute; top: 6px; left: 6px; z-index: 10;
    display: flex; gap: 4px;
}
#trails-btn, .roots-tool-btn {
    background: rgba(15, 16, 38, 0.75); color: var(--muted); border: 1px solid var(--stroke); border-radius: 6px;
    padding: 3px 8px; font-size: 10px; cursor: pointer; transition: all 0.12s;
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
}
#trails-btn.active, .roots-tool-btn.active { background: var(--accent-dim); color: #fff; border-color: var(--accent-border); }
#trails-btn:hover:not(.active), .roots-tool-btn:hover:not(.active) { color: var(--text); border-color: var(--stroke2); }
#sound-toolbar { display: flex; gap: 6px; padding: 8px 10px; border-bottom: 1px solid var(--stroke); }
.sound-tool-btn {
    background: rgba(255,255,255,0.04); color: var(--muted); border: 1px solid var(--stroke); border-radius: 6px;
    padding: 4px 10px; font-size: 11px; cursor: pointer; font-weight: 500; transition: all 0.12s;
}
.sound-tool-btn:hover { color: var(--text); border-color: var(--stroke2); }
.sound-tool-btn.active { background: var(--accent-dim); color: #fff; border-color: var(--accent-border); }
.bar-sel-btn {
    background: transparent; color: var(--muted); border: 1px solid var(--stroke); border-radius: 5px;
    padding: 2px 7px; font-size: 10px; cursor: pointer; transition: all 0.12s;
}
.bar-sel-btn:hover { color: var(--text); border-color: var(--stroke2); }
#sel2path-btn {
    background: transparent; color: var(--accent); border: 1px solid var(--accent-border); border-radius: 6px;
    padding: 3px 8px; font-size: 10px; cursor: pointer; font-weight: 600; transition: all 0.12s;
}
#sel2path-btn:hover { background: var(--accent); color: #fff; }
#sel2path-btn:disabled { opacity: 0.3; cursor: default; background: transparent; color: var(--accent); }
.bitmap-btn {
    background: transparent; color: var(--accent); border: 1px solid var(--accent-border); border-radius: 6px;
    padding: 3px 8px; font-size: 10px; cursor: pointer; font-weight: 600; transition: all 0.12s;
}
.bitmap-btn:hover { background: var(--accent); color: #fff; }
.bitmap-btn:disabled { opacity: 0.3; cursor: default; background: transparent; color: var(--accent); }
.bitmap-select {
    background: var(--bg); color: var(--fg); border: 1px solid var(--accent-border); border-radius: 6px;
    padding: 2px 4px; font-size: 10px; font-weight: 600; cursor: pointer;
}
body.fast-mode #header,
body.fast-mode .mid-bar,
body.fast-mode .tab-bar,
body.fast-mode #roots-content,
body.fast-mode #stats-content,
body.fast-mode #sound-content,
body.fast-mode #anim-bar,
body.fast-mode .panel:first-child {
    opacity: 0.15; pointer-events: none; filter: grayscale(1);
    transition: opacity 0.3s, filter 0.3s;
}
body.fast-mode #bitmap-toolbar .bitmap-btn:not(#bitmap-fast-btn),
body.fast-mode #bitmap-toolbar .bitmap-select {
    opacity: 0.3; pointer-events: none;
}
body.fast-mode #bitmap-fast-btn {
    background: var(--accent); color: #fff;
}
#anim-bar .bar-controls { opacity: 1; transition: opacity 0.15s; }
#anim-bar .bar-controls.dimmed { opacity: 0.3; pointer-events: none; }
#path-nav { display: flex; align-items: center; gap: 4px; }
.path-nav-btn {
    background: transparent; color: var(--muted); border: 1px solid var(--stroke); border-radius: 5px;
    width: 22px; height: 22px; font-size: 10px; cursor: pointer; padding: 0;
    display: flex; align-items: center; justify-content: center; transition: all 0.12s;
}
.path-nav-btn:hover { color: #fff; border-color: var(--stroke2); }
#path-label { font-size: 11px; color: var(--muted); min-width: 56px; text-align: center; }
#ccw-btn {
    background: transparent; color: var(--muted); border: 1px solid var(--stroke); border-radius: 6px;
    padding: 3px 8px; font-size: 10px; cursor: pointer; transition: all 0.12s; min-width: 28px;
}
#ccw-btn.active { background: rgba(91,106,191,0.20); color: #fff; border-color: rgba(91,106,191,0.55); }
#del-path-btn {
    background: transparent; color: var(--muted); border: 1px solid var(--stroke); border-radius: 6px;
    width: 22px; height: 22px; font-size: 14px; cursor: pointer; padding: 0;
    display: flex; align-items: center; justify-content: center; transition: all 0.12s;
}
#del-path-btn:hover { color: var(--accent); border-color: var(--accent-border); }
.trail-path { fill: none; stroke-width: 1.5; opacity: 0.6; stroke-linecap: round; stroke-linejoin: round; }
.tooltip {
    position: absolute; background: rgba(10,12,30,0.75); color: var(--text);
    padding: 5px 10px; border-radius: 8px; font-size: 12px; pointer-events: none;
    display: none; white-space: nowrap;
    border: 1px solid var(--stroke);
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
}
</style>
</head>
<body>

<div id="header">
    <span class="app-title">PolyPaint v23</span>
    <div class="header-sep"></div>
    <span class="control-label">Degree</span>
    <span id="degree-number" class="degree-val">5</span>
    <select id="pattern">
            <optgroup label="Basic">
                <option value="circle">Circle</option>
                <option value="real">Real axis</option>
                <option value="imag">Imaginary axis</option>
                <option value="grid">Grid</option>
                <option value="random">Random</option>
            </optgroup>
            <optgroup label="Coeff patterns">
                <option value="spiral">Spiral</option>
                <option value="star">Star</option>
                <option value="lemniscate">Figure-8</option>
                <option value="conjugate">Conjugate pairs</option>
                <option value="two-clusters">Two clusters</option>
                <option value="geometric">Geometric decay</option>
                <option value="rose">Rose curve</option>
                <option value="cardioid">Cardioid</option>
            </optgroup>
            <optgroup label="Roots shapes">
                <option value="r-heart">Heart</option>
                <option value="r-circle">Circle</option>
                <option value="r-star">Star</option>
                <option value="r-spiral">Spiral</option>
                <option value="r-cross">Cross</option>
                <option value="r-diamond">Diamond</option>
                <option value="r-grid">Chessboard</option>
                <option value="r-smiley">Smiley</option>
                <option value="r-figure8">Figure-8</option>
                <option value="r-butterfly">Butterfly</option>
                <option value="r-trefoil">Trefoil</option>
                <option value="r-polygon">Polygon</option>
                <option value="r-infinity">Infinity</option>
            </optgroup>
    </select>
    <div class="header-sep"></div>
    <button id="reset-btn" class="icon-btn" title="Reset to initial state">‚Ü∫</button>
    <div class="header-sep"></div>
    <span style="display:flex;gap:4px;align-items:center;">
        <button id="save-btn" class="icon-btn" title="Save state">üíæ</button>
        <button id="load-btn" class="icon-btn" title="Load state">üìÇ</button>
        <button id="snap-btn" class="icon-btn" title="Export snapshot">‚¨á</button>
    </span>
</div>
<div id="content">
    <div id="main">
        <div id="panels">
    <div class="panel" id="left-panel">
        <div class="tab-bar" id="left-tab-bar">
            <button class="tab active" data-ltab="coeffs">Coefficients <span id="coeff-sel-count" style="font-size:9px;color:#5ddb6a;opacity:0.85;"></span></button>
            <button class="tab" data-ltab="list">List</button>
            <span class="tab-bar-controls"><button id="play-btn">‚ñ∂ Play</button><button id="home-btn" title="Return to start position">Home</button></span>
        </div>
        <div class="tab-panes" id="left-tab-panes">
            <div id="coeffs-content" class="tab-content active">
                <div id="anim-bar">
                    <div class="bar-row">
                        <button id="coeff-picker-btn" class="bar-sel-btn" title="Coefficient picker">‚ò∞</button>
                        <button id="select-all-coeffs-btn" class="bar-sel-btn" title="Select all coefficients">‚äï All</button>
                        <button id="deselect-all-btn" class="bar-sel-btn" title="Deselect all (Esc)">‚úï None</button>
                        <span class="bar-title empty" id="bar-title">&lt;no selection&gt;</span>
                        <button id="sel2path-btn">Update Sel</button>
                    </div>
                    <div class="bar-controls dimmed" id="bar-controls">
                        <div class="bar-row">
                            <select id="anim-path">
                                <option value="none">None</option>
                                <optgroup label="Basic">
                                    <option value="circle">Circle</option>
                                    <option value="horizontal">Horizontal</option>
                                    <option value="vertical">Vertical</option>
                                    <option value="spiral">Spiral</option>
                                    <option value="random">Gaussian cloud</option>
                                </optgroup>
                                <optgroup label="Curves">
                                    <option value="lissajous">Lissajous</option>
                                    <option value="figure8">Figure-8</option>
                                    <option value="cardioid">Cardioid</option>
                                    <option value="astroid">Astroid</option>
                                    <option value="deltoid">Deltoid</option>
                                    <option value="rose">Rose (3-petal)</option>
                                    <option value="epitrochoid">Spirograph</option>
                                    <option value="hypotrochoid">Hypotrochoid</option>
                                    <option value="butterfly">Butterfly</option>
                                    <option value="star">Star (pentagram)</option>
                                    <option value="square">Square</option>
                                </optgroup>
                                <optgroup label="Space-filling">
                                    <option value="hilbert">Hilbert (Moore)</option>
                                    <option value="peano">Peano</option>
                                    <option value="sierpinski">Sierpinski</option>
                                </optgroup>
                            </select>
                            <div id="bar-dynamic"></div>
                        </div>
                    </div>
                </div>
                <div id="coeff-container">
                    <svg id="coeff-panel"></svg>
                </div>
            </div>
            <div id="list-content" class="tab-content">
                <div id="coeff-list-toolbar" style="display:flex;gap:6px;padding:4px 8px;align-items:center;border-bottom:1px solid var(--stroke);background:rgba(10,12,30,0.45);flex-shrink:0;">
                    <button id="list-select-all-btn" class="bar-sel-btn" title="Select all">‚äï All</button>
                    <button id="list-deselect-all-btn" class="bar-sel-btn" title="Deselect all">‚úï None</button>
                    <button id="list-all-curves-btn" class="bar-sel-btn" title="Select all coefficients with the displayed curve type">Same Curve</button>
                    <button id="list-curve-prev" class="bar-sel-btn" style="padding:0 4px;font-size:10px;line-height:1;">&#9664;</button>
                    <span id="list-curve-cycle" style="font-size:9px;color:var(--accent);min-width:36px;text-align:center;">‚Äî</span>
                    <button id="list-curve-next" class="bar-sel-btn" style="padding:0 4px;font-size:10px;line-height:1;">&#9654;</button>
                    <span style="flex:1;"></span>
                    <span id="list-count" style="font-size:9px;color:var(--muted);"></span>
                </div>
                <div id="list-curve-editor" style="padding:4px 8px 6px;border-bottom:1px solid var(--stroke);background:rgba(10,12,30,0.55);flex-shrink:0;opacity:0.3;pointer-events:none;transition:opacity 0.15s;">
                    <div style="display:flex;align-items:center;gap:4px;flex-wrap:wrap;">
                        <select id="lce-path-sel" style="font-size:9px;font-weight:600;color:var(--accent);background:rgba(0,0,0,0.3);border:1px solid var(--stroke);border-radius:3px;padding:1px 2px;">
                            <option value="none">&mdash;</option>
                            <optgroup label="Basic">
                                <option value="circle">Circle</option>
                                <option value="horizontal">Horizontal</option>
                                <option value="vertical">Vertical</option>
                                <option value="spiral">Spiral</option>
                                <option value="random">Gaussian cloud</option>
                            </optgroup>
                            <optgroup label="Curves">
                                <option value="lissajous">Lissajous</option>
                                <option value="figure8">Figure-8</option>
                                <option value="cardioid">Cardioid</option>
                                <option value="astroid">Astroid</option>
                                <option value="deltoid">Deltoid</option>
                                <option value="rose">Rose (3-petal)</option>
                                <option value="epitrochoid">Spirograph</option>
                                <option value="hypotrochoid">Hypotrochoid</option>
                                <option value="butterfly">Butterfly</option>
                                <option value="star">Star (pentagram)</option>
                                <option value="square">Square</option>
                            </optgroup>
                            <optgroup label="Space-filling">
                                <option value="hilbert">Hilbert (Moore)</option>
                                <option value="peano">Peano</option>
                                <option value="sierpinski">Sierpinski</option>
                            </optgroup>
                        </select>
                        <button id="lce-prev" class="bar-sel-btn" style="padding:0 4px;font-size:10px;line-height:1;">&#9664;</button>
                        <span id="lce-coeff-name" style="font-size:9px;color:var(--text);min-width:20px;text-align:center;"></span>
                        <button id="lce-next" class="bar-sel-btn" style="padding:0 4px;font-size:10px;line-height:1;">&#9654;</button>
                        <span style="width:6px;"></span>
                        <div id="lce-controls"></div>
                        <span style="width:4px;"></span>
                        <button id="lce-ps-btn" class="bar-sel-btn" style="font-size:8px;" title="Prime Speed ‚Äî set to nearest speed coprime with all others">PS</button>
                        <button id="lce-update-one" class="bar-sel-btn" style="font-size:8px;">Update This</button>
                        <button id="lce-update-sel" class="bar-sel-btn" style="font-size:8px;">Update Whole Selection</button>
                    </div>
                </div>
                <div id="coeff-list-hdr" class="cpick-row" style="padding:1px 8px 1px;border-bottom:1px solid var(--stroke);flex-shrink:0;cursor:default;opacity:0.5;">
                    <span class="cpick-cb" style="visibility:hidden;"></span>
                    <span class="cpick-dot" style="visibility:hidden;"></span>
                    <span class="cpick-dot" style="visibility:hidden;"></span>
                    <span class="cpick-label" style="font-size:7px;">idx</span>
                    <span class="cpick-power" style="font-size:7px;">term</span>
                    <span style="font-size:7px;color:var(--muted);width:58px;text-align:center;flex-shrink:0;">path</span>
                    <span class="cpick-speed" style="font-size:7px;">spd</span>
                    <span class="cpick-plen" style="font-size:7px;">pts</span>
                    <span class="cpick-pos" style="font-size:7px;">pos</span>
                    <span class="cpick-coords" style="font-size:7px;">position</span>
                </div>
                <div id="coeff-list-scroll" style="flex:1;min-height:0;overflow-y:auto;padding:4px 8px;"></div>
            </div>
        </div>
    </div>
    <div class="mid-bar">
        <div id="ops-group" class="disabled" style="display:flex;flex-direction:column;gap:6px;align-items:center;">
            <div class="mid-label">Ops <span id="ops-target"></span></div>
            <button id="scale-tool-btn" class="mid-btn" title="Scale">‚áï</button>
            <button id="rotate-tool-btn" class="mid-btn" title="Rotate">‚ü≤</button>
            <button id="add-tool-btn" class="mid-btn" title="Translate">‚úõ</button>
        </div>
        <div style="display:flex;gap:2px;margin-top:4px;">
            <button id="mid-all-btn" class="mid-btn" style="width:auto;height:auto;font-size:8px;padding:1px 4px;border-radius:4px;" title="Select all (roots if any root selected, else coefficients)">‚äï</button>
            <button id="mid-none-btn" class="mid-btn" style="width:auto;height:auto;font-size:8px;padding:1px 4px;border-radius:4px;" title="Deselect all">‚úï</button>
        </div>
    </div>
    <div class="panel">
        <div class="tab-bar">
            <button class="tab active" data-tab="roots">Roots <span id="roots-sel-count" style="font-size:9px;color:#e94560;opacity:0.85;"></span></button>
            <button class="tab" data-tab="stats">Stats</button>
            <button class="tab" data-tab="sound">Sound</button>
            <button class="tab" data-tab="bitmap">Bitmap</button>
            <span class="tab-bar-controls">
                <select id="rec-mode" title="Recording mode" style="font-size:10px;padding:1px 2px;background:rgba(255,255,255,0.06);color:var(--muted);border:1px solid var(--stroke);border-radius:4px;cursor:pointer;"><option value="roots">Roots</option><option value="coeffs">Coeffs</option><option value="both">Both</option><option value="stats">Stats</option><option value="sound">Sound</option><option value="bitmap">Bitmap</option><option value="full">Full</option></select>
                <button id="rec-roots-btn" class="icon-btn" title="Record (webm)">‚è∫</button>
                <button id="stop-roots-btn" class="icon-btn" title="Stop recording" style="display:none;">‚èπ</button>
            </span>
        </div>
        <div class="tab-panes">
            <div id="roots-content" class="tab-content active">
                <div id="roots-toolbar">
                    <button id="trails-btn">Trails</button>
                    <button id="root-color-btn" class="roots-tool-btn active" title="Color roots">üé®</button>
                    <button id="domain-toggle-btn" class="roots-tool-btn" title="Domain coloring">‚óê</button>
                    <button id="roots-fit-btn" class="roots-tool-btn" title="Resize to fit all roots and trails">Fit</button>
                    <button id="select-all-roots-btn" class="roots-tool-btn" title="Select all roots">‚äï All</button>
                    <button id="deselect-all-roots-btn" class="roots-tool-btn" title="Deselect all roots">‚úï None</button>
                </div>
                <div id="roots-container">
                    <canvas id="domain-canvas"></canvas>
                    <svg id="roots-panel"></svg>
                </div>
            </div>
            <div id="stats-content" class="tab-content">
                <div class="stats-grid">
                    <div class="stats-cell"><select class="stats-select" data-plot="0"></select><canvas class="stats-canvas" data-plot="0"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="1"></select><canvas class="stats-canvas" data-plot="1"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="2"></select><canvas class="stats-canvas" data-plot="2"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="3"></select><canvas class="stats-canvas" data-plot="3"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="4"></select><canvas class="stats-canvas" data-plot="4"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="5"></select><canvas class="stats-canvas" data-plot="5"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="6"></select><canvas class="stats-canvas" data-plot="6"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="7"></select><canvas class="stats-canvas" data-plot="7"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="8"></select><canvas class="stats-canvas" data-plot="8"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="9"></select><canvas class="stats-canvas" data-plot="9"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="10"></select><canvas class="stats-canvas" data-plot="10"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="11"></select><canvas class="stats-canvas" data-plot="11"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="12"></select><canvas class="stats-canvas" data-plot="12"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="13"></select><canvas class="stats-canvas" data-plot="13"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="14"></select><canvas class="stats-canvas" data-plot="14"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="15"></select><canvas class="stats-canvas" data-plot="15"></canvas></div>
                </div>
            </div>
            <div id="sound-content" class="tab-content">
                <div id="sound-toolbar">
                    <button id="base-toggle-btn" class="sound-tool-btn" title="Base (drone)">B Base</button>
                    <button id="melody-toggle-btn" class="sound-tool-btn" title="Melody (arpeggio)">M Melody</button>
                    <button id="voice-toggle-btn" class="sound-tool-btn" title="Voice (beeps)">V Voice</button>
                </div>
                <div class="config-panel" id="config-sliders"></div>
            </div>
            <div id="bitmap-content" class="tab-content">
                <div id="bitmap-toolbar" style="display:flex;gap:6px;padding:4px 6px;align-items:center;flex-wrap:wrap;">
                    <button id="bitmap-start-btn" class="bitmap-btn">start</button>
                    <button id="bitmap-save-btn" class="bitmap-btn" disabled>save</button>
                    <button id="bitmap-clear-btn" class="bitmap-btn" disabled>clear</button>
                    <select id="bitmap-res-select" class="bitmap-select"><option value="1000">1000px</option><option value="2000" selected>2000px</option><option value="5000">5000px</option></select>
                    <button id="bitmap-fast-btn" class="bitmap-btn" disabled>fastmode</button>
                    <select id="bitmap-steps-select" class="bitmap-select"><option value="10">10</option><option value="100">100</option><option value="1000">1K</option><option value="10000">10K</option><option value="50000">50K</option><option value="100000">100K</option><option value="1000000">1M</option></select>
                    <button id="jiggle-btn" class="bitmap-btn" disabled title="Jiggle ‚Äî perturb coefficient paths between cycles">jiggle</button>
                    <button id="bitmap-bg-btn" class="bitmap-btn" title="Canvas background color">bg</button>
                    <div id="bitmap-progress" style="display:none;flex:1;min-width:60px;height:6px;background:var(--stroke);border-radius:3px;margin-left:4px;overflow:hidden;"><div id="bitmap-progress-bar" style="height:100%;width:0%;background:var(--accent);border-radius:3px;transition:width 0.1s;"></div></div>
                    <span id="bitmap-pass-count" style="display:none;font-family:monospace;font-size:10px;color:var(--muted);margin-left:4px;white-space:nowrap;"></span>
                </div>
                <div id="bitmap-container" style="flex:1;min-height:0;position:relative;background:#000;">
                    <canvas id="bitmap-canvas" style="width:100%;height:100%;"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>
    </div>
</div>

<div class="tooltip" id="tooltip"></div>
<div id="ops-pop" class="ops-pop"></div>
<div id="degree-pop" class="ops-pop"></div>
<div id="audio-pop" class="ops-pop" style="min-width:220px"></div>
<div id="color-pop" class="ops-pop" style="min-width:160px"></div>
<div id="coeff-pick-pop" class="ops-pop" style="min-width:300px"></div>
<div id="coeff-ctx" class="ops-pop"></div>
<div id="snap-pop" class="ops-pop" style="min-width:100px"></div>
<div id="bitmap-bg-pop" class="ops-pop" style="min-width:160px"></div>
<div id="jiggle-pop" class="ops-pop" style="min-width:160px"></div>
<div id="fastmode-pop" class="ops-pop" style="min-width:120px"></div>
<div id="path-pick-pop" class="ops-pop"></div>

<script>
// ============================================================================
// COEFFICIENT INDEXING CONVENTION
//
// The polynomial is p(z) = c‚Çôz‚Åø + c‚Çô‚Çã‚ÇÅz‚Åø‚Åª¬π + ¬∑¬∑¬∑ + c‚ÇÅz + c‚ÇÄ
//
// Subscript = power of z:
//   c‚Çô  = leading coefficient (always 1+0i for monic polynomials from roots)
//   c‚ÇÄ  = constant term
//
// Internal array storage is in DESCENDING power order:
//   coefficients[0]   = c‚Çô   (leading, z^n)
//   coefficients[1]   = c‚Çô‚Çã‚ÇÅ (z^(n-1))
//   ...
//   coefficients[n]   = c‚ÇÄ   (constant, z^0)
//
// So array index i corresponds to c‚Çñ where k = degree - i.
// All user-facing labels (SVG dots, picker, bar title, recording canvas)
// display the power-based subscript k, NOT the array index i.
// ============================================================================

const MIN_RANGE = 1.5;
const MARGIN = 30;
const RANGE_PAD = 1.3; // 30% padding around data

// Compute panel size from available space
function getPanelSize() {
    const header = document.getElementById("header");
    const opsBar = document.getElementById("ops-group");
    const opsW = opsBar ? opsBar.offsetWidth : 0;
    const availH = window.innerHeight - header.offsetHeight - 50;
    const availW = (window.innerWidth - opsW - 16 * 3) / 2;
    return Math.max(200, Math.floor(Math.min(availW, availH)));
}

let S = getPanelSize();

// Per-panel state
const panels = {
    coeff: { range: 3, xScale: null, yScale: null, gridG: null, axisG: null, labelRe: null, labelIm: null, unitCircle: null },
    roots: { range: 3, xScale: null, yScale: null, gridG: null, axisG: null, labelRe: null, labelIm: null, unitCircle: null }
};

function makeScales(range) {
    return {
        x: d3.scaleLinear().domain([-range, range]).range([MARGIN, S - MARGIN]),
        y: d3.scaleLinear().domain([-range, range]).range([S - MARGIN, MARGIN])
    };
}

function initPanelScales(p) {
    const s = makeScales(p.range);
    p.xScale = s.x;
    p.yScale = s.y;
}
initPanelScales(panels.coeff);
initPanelScales(panels.roots);

// Convenience aliases (updated when range changes)
function cxs() { return panels.coeff.xScale; }
function cys() { return panels.coeff.yScale; }
function rxs() { return panels.roots.xScale; }
function rys() { return panels.roots.yScale; }

let coefficients = [];
let currentRoots = []; // persistent root data for dragging
let pendingSolve = false;

// Selection & animation state
const selectedCoeffs = new Set(); // indices into coefficients[]
const selectedRoots = new Set();  // indices into currentRoots[]
const animState = { playing: false, startTime: 0, rafId: null, elapsedAtPause: null };
let lastSelectedCoeff = -1; // index of last coefficient added to selection (for editor display)
// Trail state
let trailsEnabled = false;
let trailData = []; // array of arrays: trailData[i] = [{re, im}, ...] for root i
let trailComplete = false; // true once one full loop is detected
const MAX_TRAIL_POINTS = 4000;
const TRAIL_MIN_POINTS = 30; // minimum points before checking for loop closure
// Domain coloring state
let domainColoringEnabled = false;
let rootColorMode = "rainbow";  // "uniform" | "rainbow" | "derivative"
let uniformRootColor = [255, 255, 255];  // RGB for uniform mode (default white)
let rootSensitivities = null;   // Float64Array for derivative mode
let domainCanvas = document.getElementById("domain-canvas");
let domainCtx = domainCanvas.getContext("2d");
let domainPendingRender = false;
const DOMAIN_RES_SCALE = 0.5; // render at half resolution for performance
// Bitmap trail tab state
let bitmapActive = false;
let bitmapCtx = null;
let bitmapRange = null;   // frozen bounding box from roots panel
let bitmapFrameCount = 0;
let bitmapCanvasColor = "#000000"; // canvas background color
// Fast mode state
const FAST_PASS_SECONDS = 1.0; // virtual duration of one fast pass
let fastModeActive = false;
let fastModeCurves = null;      // Map<coeffIndex, hi-res curve>
let fastModeStepIndex = 0;
let fastModeTotalSteps = 0;
let fastModeTimerId = null;
let fastModeRootColors = null;  // pre-computed CSS color strings
let fastModeWorker = null;      // Web Worker instance
let fastModeLastPixels = null;  // last received pixel ArrayBuffer snapshot
let fastModeLastRoots = null;   // last received root positions
let fastModeLastStep = 0;       // last reported step count
let fastModeElapsedOffset = 0;  // accumulated elapsed time across passes
let fastModePassCount = 0;      // completed pass counter
let fastModeTargetPasses = 0;   // passes for full cycle (0 = unlimited)
let jiggleOffsets = null;       // Map<coeffIdx, {re, im}> or null
let jiggleOnTarget = false;     // auto-regenerate on cycle completion
let jiggleSigma = 10;          // œÉ as integer 0-100, read as jiggleSigma/100 %
let jiggleMode = "none";       // "none" | "random" | "rotate" | "walk" | "scale"
let jiggleTheta = 0.01;        // rotate: turns per trigger (0.001‚Äì0.500)
let jiggleScaleStep = 5;       // scale: % per trigger (1‚Äì50)
let jiggleCumulativeAngle = 0; // rotate: accumulated angle in radians
let jiggleCumulativeScale = 1.0; // scale: accumulated scale factor
let fastModeShowProgress = true; // show progress bar + pass counter during fastmode
// Stats tab state
let activeTab = "roots";
const STAT_TYPES = ["Force", "MinForce", "MaxForce", "Speed", "MinSpeed", "MaxSpeed", "MinDist", "MaxDist", "Records", "MeanDist", "\u0394MeanDist", "AngularMom", "\u03c3Speed", "EMASpeed", "\u03c3Dist", "Odometer", "CycleCount", "MedianR", "Spread", "EMed", "EHi", "Coherence", "Encounters"];
const STAT_COLORS = { Force: "#e94560", MinForce: "#f7a1b5", MaxForce: "#c0392b", Speed: "#5b6abf", MinSpeed: "#7eb8da", MaxSpeed: "#ff7b54", MinDist: "#2ecc71", MaxDist: "#f39c12", Records: "#ff6b9d", MeanDist: "#4ecdc4", "\u0394MeanDist": "#a8e6cf", AngularMom: "#e0aaff", "\u03c3Speed": "#48bfe3", EMASpeed: "#64dfdf", "\u03c3Dist": "#f4a261", Odometer: "#d4a373", CycleCount: "#80ed99", MedianR: "#f0a6ca", Spread: "#b8c0ff", EMed: "#a7c957", EHi: "#f77f00", Coherence: "#7209b7", Encounters: "#ff85a1" };
// Phase-space (XY) plot definitions: { label, xStat, yStat, color }
const PHASE_PLOTS = [
    { label: "Force v Speed", xStat: "Force", yStat: "Speed", color: "#c77dff" },
    { label: "MinDist v MaxDist", xStat: "MinDist", yStat: "MaxDist", color: "#ffd166" },
    { label: "MinSpeed v MaxSpeed", xStat: "MinSpeed", yStat: "MaxSpeed", color: "#72efdd" },
    { label: "MeanDist v \u03c3Dist", xStat: "MeanDist", yStat: "\u03c3Dist", color: "#f4845f" },
    { label: "MaxForce v MaxSpeed", xStat: "MaxForce", yStat: "MaxSpeed", color: "#e76f51" }
];
// Spectrum plots: special bar-chart visualizations (not time-series)
const SPECTRUM_PLOTS = [
    { label: "SpeedSpectrum" },
    { label: "OdometerSpectrum" },
    { label: "WindingSpectrum" },
    { label: "TortuositySpectrum" }
];
// Total dropdown options: time-series, then phase-space, then spectrum
const PLOT_OPTIONS = [...STAT_TYPES, ...PHASE_PLOTS.map(p => p.label), ...SPECTRUM_PLOTS.map(p => p.label)];
let pairRecords = null; // Float64Array(n*(n-1)/2): per-pair closest distance records for Records stat
const statsState = {
    buffers: {},        // { statName: Float64Array ring buffer }
    frameCount: 0,
    writeIdx: 0,
    maxFrames: 4000,
    prevRoots: null,    // for Speed computation
    prevMeanDist: null, // for ŒîMeanDist computation
    emaSpeed: 0,        // exponential moving average of Speed
    rootSpeeds: null,   // Float64Array: cached per-root speeds (displacement per tick)
    rootForces: null,   // Float64Array: cached per-root force (sensitivity) for MinForce/MaxForce
    spectrumPeaks: null, // Float64Array: all-time max per-root speed for SpeedSpectrum dots
    rootOdometers: null, // Float64Array: cumulative per-root distance traveled
    odometerCycleLengths: null, // Float64Array: snapshot of odometers at loop completion (cycle arc lengths)
    odometerStartRoots: null, // [{re,im}]: per-root start positions for cycle detection
    odometerFrameCounts: null, // Int32Array: per-root frame count since last reset
    odometerMaxDisps: null, // Float64Array: per-root max displacement from start
    odometerCycleCount: 0, // cumulative number of cycle detections triggered
    rootWindings: null,    // Float64Array: cumulative winding angle per root (in turns, signed)
    rootTortuosityOdo: null, // Float64Array: per-root path length for tortuosity (resets on cycle)
    rootTortuosityNetDx: null, // Float64Array: per-root cumulative signed dx for tortuosity
    rootTortuosityNetDy: null, // Float64Array: per-root cumulative signed dy for tortuosity
    // Sonification feature smoothing (one-pole EMA, same Œ± as audio)
    smoothMedianR: 0,
    smoothSpread: 0,
    smoothEMed: 0,
    smoothEHi: 0,
    smoothCoherence: 0,
    smoothEncounters: 0,
    // Per-root encounter records for Encounters stat (mirrors audio close encounters)
    statsEncounters: null,    // Float64Array(n * 3): per-root top-3 closest distances
    plotConfigs: [0, 3, 6, 8, 17, 18, 19, 20, 21, 22, 11, 9, 28, 29, 30, 31], // index into PLOT_OPTIONS for each of the 16 plots
    canvases: [],       // 4 canvas elements
    ctxs: [],           // 4 canvas 2D contexts
    dirty: true
};
// Audio sonification state
let baseEnabled = false;
let melodyEnabled = false;
let voiceEnabled = false;
function anySoundEnabled() { return baseEnabled || melodyEnabled || voiceEnabled; }
let audioCtx = null;
let audioNodes = null;
let prevRootsAudio = null;
let prevAnglesAudio = null; // per-root angles from centroid (for angular momentum)
let lastBeepTime = 0;
let lastAudioUpdateTime = 0;
let audioWatchdogId = null;
let closeEncounters = null;  // Float64Array(n * TOP_K): per-root closest distances seen
let encounterAge = null;     // Float64Array(n * TOP_K): frames since each record was set
let arpPhase = 0;
let arpSmoothVel = 0;
const AUDIO_ALPHA = 0.1;
const ARP_SCALE = [0, 2, 4, 7, 9]; // pentatonic
const ENCOUNTER_TOP_K = 3;         // track top 3 records per root (non-tunable)

// Tunable config objects (sliders modify these in real time)
const baseConfig = {
    freq: 85, octaves: 1.8,
    modRatio: 2.0, modDepth: 300,
    filterLo: 250, filterHi: 3500,
    gainFloor: 0.03, gainRange: 0.22,
    vibDepth: 10, vibRate: 6.0,
};
const ROUTE_SOURCES = ["‚Äî",
    "MedianR", "Spread", "EMed", "EHi", "Coherence",
    "Speed", "MinSpeed", "MaxSpeed", "œÉSpeed", "EMASpeed",
    "MeanDist", "MinDist", "MaxDist", "œÉDist", "ŒîMeanDist",
    "AngularMom", "Force", "MinForce", "MaxForce",
    "Records", "Encounters", "Odometer", "CycleCount",
    "Const0", "Const1"];
const NORM_MODES = ["fixed", "runmax"];
const RUNMAX_DECAY = 0.9995;
const BIPOLAR_SRC = new Set(["AngularMom"]);
const baseRoutes = [
    { source: "MedianR",   alpha: 0.10, norm: "runmax", target: "Carrier pitch",  smoothed: 0, runMax: 0.001 },
    { source: "EHi",       alpha: 0.10, norm: "runmax", target: "FM mod depth",   smoothed: 0, runMax: 0.001 },
    { source: "Spread",    alpha: 0.10, norm: "runmax", target: "Filter cutoff",  smoothed: 0, runMax: 0.001 },
    { source: "EHi",       alpha: 0.10, norm: "runmax", target: "Gain",           smoothed: 0, runMax: 0.001 },
    { source: "Coherence", alpha: 0.10, norm: "runmax", target: "Vibrato depth",  smoothed: 0, runMax: 0.001 },
    { source: "EMed",      alpha: 0.10, norm: "runmax", target: "Vibrato rate",   smoothed: 0, runMax: 0.001 },
];
const voiceRoutes = [
    { source: "‚Äî",  alpha: 0.10, norm: "runmax", target: "Pitch bias",  smoothed: 0.5, runMax: 0.001 },
    { source: "‚Äî",  alpha: 0.10, norm: "runmax", target: "Volume",      smoothed: 0.5, runMax: 0.001 },
    { source: "‚Äî",  alpha: 0.10, norm: "runmax", target: "Ringdown",    smoothed: 0.5, runMax: 0.001 },
    { source: "‚Äî",  alpha: 0.10, norm: "runmax", target: "Cooldown",    smoothed: 0.5, runMax: 0.001 },
];
const melodyRoutes = [
    { source: "‚Äî",  alpha: 0.10, norm: "runmax", target: "Rate",        smoothed: 0.5, runMax: 0.001 },
    { source: "‚Äî",  alpha: 0.10, norm: "runmax", target: "Brightness",  smoothed: 0.5, runMax: 0.001 },
    { source: "‚Äî",  alpha: 0.10, norm: "runmax", target: "Volume",      smoothed: 0.5, runMax: 0.001 },
    { source: "‚Äî",  alpha: 0.10, norm: "runmax", target: "Decay",       smoothed: 0.5, runMax: 0.001 },
];
const melodyConfig = {
    rate: 5, peak: 0.12, cutoff: 5,
    attack: 0.004, decay: 0.064,
    filterLo: 1200, filterHi: 3800,
};
const voiceConfig = {
    decay: 1.001, novelty: 0.85, cooldown: 0.01,
    peak: 0.12, attack: 0.005, ringdown: 0.08,
};

function audioClamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
function frac01(x) { x = x % 1; return x < 0 ? x + 1 : x; }
function quantizeToScale(semi) {
    const oct = Math.floor(semi / 12);
    const inOct = semi - 12 * oct;
    let best = ARP_SCALE[0], bestD = 1e9;
    for (const s of ARP_SCALE) {
        const d = Math.abs(inOct - s);
        if (d < bestD) { bestD = d; best = s; }
    }
    return 12 * oct + best;
}
function midiToHz(m) { return 440 * Math.pow(2, (m - 69) / 12); }
function percentileSorted(sorted, q) {
    const n = sorted.length;
    if (n === 0) return 0;
    const idx = (n - 1) * q;
    const lo = Math.floor(idx), hi = Math.ceil(idx);
    return sorted[lo] * (1 - (idx - lo)) + sorted[hi] * (idx - lo);
}

// --- Audio config popover helpers ---
let activeAudioBtn = null;
let audioDragMove = null;
let audioDragUp = null;

function buildAudioSlider(parent, label, min, max, value, logScale, fmt, onChange) {
    const row = document.createElement("div");
    row.className = "audio-row";
    const lbl = document.createElement("span");
    lbl.className = "row-label"; lbl.textContent = label;
    const slider = document.createElement("div");
    slider.className = "hslider";
    const thumb = document.createElement("div");
    thumb.className = "hslider-thumb";
    slider.appendChild(thumb);
    const val = document.createElement("span");
    val.className = "row-val";

    function valToU(v) {
        if (logScale) return (Math.log(v) - Math.log(min)) / (Math.log(max) - Math.log(min));
        return (v - min) / (max - min);
    }
    function uToVal(u) {
        if (logScale) return Math.exp(Math.log(min) + u * (Math.log(max) - Math.log(min)));
        return min + u * (max - min);
    }

    let u = Math.max(0, Math.min(1, valToU(value)));
    function update() {
        thumb.style.left = (u * 100) + "%";
        const v = uToVal(u);
        val.textContent = fmt(v);
        onChange(v);
    }
    function setFromX(clientX) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        update();
    }
    let dragging = false;
    slider.addEventListener("mousedown", e => { dragging = true; setFromX(e.clientX); e.preventDefault(); });
    const moveFn = e => { if (dragging) setFromX(e.clientX); };
    const upFn = () => { dragging = false; };
    slider.addEventListener("mousemove", moveFn);
    window.addEventListener("mousemove", moveFn);
    window.addEventListener("mouseup", upFn);

    update();
    row.appendChild(lbl);
    row.appendChild(slider);
    row.appendChild(val);
    parent.appendChild(row);
    return { row, setU: newU => { u = newU; update(); } };
}

function buildAudioToggle(parent, label, isOn, onChange) {
    const row = document.createElement("div");
    row.className = "audio-toggle" + (isOn ? " on" : "");
    const dot = document.createElement("span");
    dot.className = "toggle-dot";
    const lbl = document.createElement("span");
    lbl.className = "toggle-label"; lbl.textContent = label;
    row.appendChild(dot);
    row.appendChild(lbl);
    row.addEventListener("click", () => {
        const nowOn = !row.classList.contains("on");
        row.classList.toggle("on", nowOn);
        onChange(nowOn);
    });
    parent.appendChild(row);
    return row;
}

// Lightweight UI feedback sounds ‚Äî independent of the sonification audio graph
function uiPing(freq = 880, dur = 0.08) {
    try {
        const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        if (!audioCtx) audioCtx = ctx;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "sine";
        o.frequency.value = freq;
        g.gain.setValueAtTime(0.12, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
        o.connect(g);
        g.connect(ctx.destination);
        o.start();
        o.stop(ctx.currentTime + dur + 0.01);
    } catch (e) { /* audio not available */ }
}
// "Unhappy" buzz ‚Äî short descending tone for "nothing to do"
function uiBuzz() {
    try {
        const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        if (!audioCtx) audioCtx = ctx;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "sawtooth";
        o.frequency.setValueAtTime(340, ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(160, ctx.currentTime + 0.15);
        g.gain.setValueAtTime(0.07, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
        o.connect(g);
        g.connect(ctx.destination);
        o.start();
        o.stop(ctx.currentTime + 0.16);
    } catch (e) { /* audio not available */ }
}

function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0;
    masterGain.connect(audioCtx.destination);
    // Tap audio graph for recording (MediaStreamDestination)
    const mediaDest = audioCtx.createMediaStreamDestination();
    masterGain.connect(mediaDest);
    // FM synthesis: carrier (osc1) + modulator (osc2) ‚Üí modGain ‚Üí carrier.frequency
    const osc1 = audioCtx.createOscillator();   // carrier
    osc1.type = "sine";
    osc1.frequency.value = 110;
    const osc2 = audioCtx.createOscillator();   // FM modulator
    osc2.type = "sine";
    osc2.frequency.value = 220;
    const modGain = audioCtx.createGain();       // FM depth (Hz)
    modGain.gain.value = 0;
    osc2.connect(modGain);
    modGain.connect(osc1.frequency);
    const filter = audioCtx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 800;
    filter.Q.value = 2;
    const gainNode = audioCtx.createGain();
    gainNode.gain.value = 0.06;
    const lfo = audioCtx.createOscillator();
    lfo.type = "sine";
    lfo.frequency.value = 5;
    const lfoGain = audioCtx.createGain();
    lfoGain.gain.value = 0;
    lfo.connect(lfoGain);
    lfoGain.connect(osc1.frequency);
    const beepOsc = audioCtx.createOscillator();
    beepOsc.type = "sine";
    beepOsc.frequency.value = 800;
    const beepGain = audioCtx.createGain();
    beepGain.gain.value = 0;
    osc1.connect(gainNode);  // carrier ‚Üí gain ‚Üí filter (osc2 routes to osc1.frequency via modGain)
    gainNode.connect(filter);
    filter.connect(masterGain);
    beepOsc.connect(beepGain);
    beepGain.connect(masterGain);
    // Arpeggiator oscillator
    const arpOsc = audioCtx.createOscillator();
    arpOsc.type = "triangle";
    arpOsc.frequency.value = 440;
    const arpGain = audioCtx.createGain();
    arpGain.gain.value = 0;
    const arpFilter = audioCtx.createBiquadFilter();
    arpFilter.type = "lowpass";
    arpFilter.frequency.value = 2500;
    arpFilter.Q.value = 0.7;
    arpOsc.connect(arpGain);
    arpGain.connect(arpFilter);
    arpFilter.connect(masterGain);
    osc1.start();
    osc2.start();
    lfo.start();
    beepOsc.start();
    arpOsc.start();
    audioNodes = { osc1, osc2, modGain, lfo, lfoGain, filter, gainNode, masterGain, beepOsc, beepGain, arpOsc, arpGain, arpFilter, mediaDest };
}

function updateAudio() {
    if (!anySoundEnabled() || !audioCtx || !audioNodes) return;
    const n = currentRoots.length;
    if (n === 0) return;
    const range = panels.roots.range;
    const now = audioCtx.currentTime;
    audioNodes.masterGain.gain.setTargetAtTime(1, now, 0.05);

    // --- Centroid ---
    let cx = 0, cy = 0;
    for (const r of currentRoots) { cx += r.re; cy += r.im; }
    cx /= n; cy /= n;

    // --- Dual energy: E_med (stability) and E_hi (excitement) ---
    let eMed = 0, eHi = 0, meanSpeed = 0, maxSpeed = 0;
    if (prevRootsAudio && prevRootsAudio.length === n) {
        const v = new Array(n);
        for (let i = 0; i < n; i++) {
            v[i] = Math.hypot(
                currentRoots[i].re - prevRootsAudio[i].re,
                currentRoots[i].im - prevRootsAudio[i].im
            );
        }
        v.sort((a, b) => a - b);
        eMed = percentileSorted(v, 0.50);
        eHi  = percentileSorted(v, 0.85);
        maxSpeed = v[n - 1];
        for (let i = 0; i < n; i++) meanSpeed += v[i];
        meanSpeed /= n;
    }

    // --- Radius distribution around centroid ---
    const radii = new Array(n);
    const angles = new Array(n);
    for (let i = 0; i < n; i++) {
        const dx = currentRoots[i].re - cx, dy = currentRoots[i].im - cy;
        radii[i] = Math.hypot(dx, dy);
        angles[i] = Math.atan2(dy, dx);
    }
    radii.sort((a, b) => a - b);
    const r50 = percentileSorted(radii, 0.50);
    const r10 = percentileSorted(radii, 0.10);
    const r90 = percentileSorted(radii, 0.90);
    const spread = r90 - r10;

    // --- Angular coherence R in [0,1] ---
    let au = 0, av = 0;
    for (let i = 0; i < n; i++) { au += Math.cos(angles[i]); av += Math.sin(angles[i]); }
    au /= n; av /= n;
    const coherence = Math.hypot(au, av); // 1 = clustered, 0 = uniform ring

    // --- Pairwise distances: MeanDist & œÉDist ---
    let pairSum = 0, pairSqSum = 0, pairCount = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const d = Math.hypot(currentRoots[i].re - currentRoots[j].re,
                                 currentRoots[i].im - currentRoots[j].im);
            pairSum += d; pairSqSum += d * d; pairCount++;
        }
    }
    const meanPairDist = pairCount > 0 ? pairSum / pairCount : 0;
    const sigmaPairDist = pairCount > 0 ? Math.sqrt(Math.max(0, pairSqSum / pairCount - meanPairDist * meanPairDist)) : 0;

    // --- Angular momentum: signed rotational velocity ---
    let angMomRaw = 0;
    if (prevAnglesAudio && prevAnglesAudio.length === n) {
        for (let i = 0; i < n; i++) {
            let dth = angles[i] - prevAnglesAudio[i];
            if (dth > Math.PI) dth -= 2 * Math.PI;
            if (dth < -Math.PI) dth += 2 * Math.PI;
            angMomRaw += dth;
        }
        angMomRaw /= n;
    }
    prevAnglesAudio = angles.slice();

    // --- Raw normalized features (unsmoothed) ---
    const eNormMed = audioClamp(eMed / (range * 0.05), 0, 1);
    const eNormHi  = audioClamp(eHi  / (range * 0.05), 0, 1);
    const speedRef = range * 0.05;

    // Read latest stats buffer value (collectStatsSnapshot runs before updateAudio)
    const _si = statsState.frameCount > 0 ? (statsState.writeIdx - 1 + statsState.maxFrames) % statsState.maxFrames : 0;
    const _hs = statsState.frameCount > 0;
    const sv = name => _hs ? (statsState.buffers[name]?.[_si] ?? 0) : 0;

    const rawF = {
        MedianR:    audioClamp(r50 / range, 0, 1),
        Spread:     audioClamp(spread / range, 0, 1),
        EMed:       eNormMed,
        EHi:        eNormHi,
        Coherence:  coherence,
        Speed:      audioClamp(meanSpeed / speedRef, 0, 1),
        MinSpeed:   audioClamp(sv("MinSpeed") / speedRef, 0, 1),
        MaxSpeed:   audioClamp(maxSpeed / speedRef, 0, 1),
        "œÉSpeed":   audioClamp(sv("\u03c3Speed") / speedRef, 0, 1),
        EMASpeed:   audioClamp(sv("EMASpeed") / (speedRef * Math.max(n, 1)), 0, 1),
        MeanDist:   audioClamp(meanPairDist / range, 0, 1),
        MinDist:    audioClamp(sv("MinDist") / range, 0, 1),
        MaxDist:    audioClamp(sv("MaxDist") / (range * 2), 0, 1),
        "œÉDist":    audioClamp(sigmaPairDist / range, 0, 1),
        "ŒîMeanDist": audioClamp(sv("\u0394MeanDist") / (range * 0.02), 0, 1),
        AngularMom: audioClamp(angMomRaw / 0.15 * 0.5 + 0.5, 0, 1),
        Force:      audioClamp(sv("Force") / Math.max(n, 1), 0, 1),
        MinForce:   audioClamp(sv("MinForce") * 5, 0, 1),
        MaxForce:   audioClamp(sv("MaxForce"), 0, 1),
        Records:    audioClamp(sv("Records") / 3, 0, 1),
        Encounters: audioClamp(sv("Encounters") / 3, 0, 1),
        Odometer:   audioClamp(sv("Odometer") / (range * Math.max(n, 1) * 100), 0, 1),
        CycleCount: audioClamp(sv("CycleCount") / (Math.max(n, 1) * 5), 0, 1),
        Const0: 0,
        Const1: 1,
    };
    const rawUnorm = {
        MedianR: r50, Spread: spread, EMed: eMed, EHi: eHi,
        Coherence: coherence, Speed: meanSpeed, MaxSpeed: maxSpeed,
        MeanDist: meanPairDist, "œÉDist": sigmaPairDist, AngularMom: angMomRaw,
        MinSpeed: sv("MinSpeed"), "œÉSpeed": sv("\u03c3Speed"), EMASpeed: sv("EMASpeed"),
        MinDist: sv("MinDist"), MaxDist: sv("MaxDist"), "ŒîMeanDist": sv("\u0394MeanDist"),
        Force: sv("Force"), MinForce: sv("MinForce"), MaxForce: sv("MaxForce"),
        Records: sv("Records"), Encounters: sv("Encounters"),
        Odometer: sv("Odometer"), CycleCount: sv("CycleCount"),
        Const0: 0, Const1: 1,
    };

    // --- Per-route EMA smoothing (base + voice + melody) with normalization ---
    for (const route of baseRoutes.concat(voiceRoutes, melodyRoutes)) {
        if (route.source === "‚Äî") continue;
        let raw;
        if (route.norm === "runmax") {
            const rv = rawUnorm[route.source] ?? 0;
            route.runMax = Math.max(route.runMax * RUNMAX_DECAY, Math.abs(rv));
            if (BIPOLAR_SRC.has(route.source)) {
                raw = route.runMax > 1e-12 ? audioClamp(rv / route.runMax * 0.5 + 0.5, 0, 1) : 0.5;
            } else {
                raw = route.runMax > 1e-12 ? audioClamp(rv / route.runMax, 0, 1) : 0;
            }
        } else {
            raw = rawF[route.source] ?? 0;
        }
        route.smoothed += route.alpha * (raw - route.smoothed);
    }

    // --- Base (FM drone): all 6 params driven by routed + smoothed features ---
    if (baseEnabled) {
        const pitch = baseConfig.freq * Math.pow(2, (baseRoutes[0].smoothed - 0.5) * baseConfig.octaves);
        audioNodes.osc1.frequency.setTargetAtTime(pitch, now, 0.05);
        audioNodes.osc2.frequency.setTargetAtTime(pitch * baseConfig.modRatio, now, 0.05);
        audioNodes.modGain.gain.setTargetAtTime(baseConfig.modDepth * baseRoutes[1].smoothed, now, 0.05);
        const cutoff = baseConfig.filterLo + baseConfig.filterHi * baseRoutes[2].smoothed;
        audioNodes.filter.frequency.setTargetAtTime(audioClamp(cutoff, 150, 8000), now, 0.05);
        audioNodes.gainNode.gain.setTargetAtTime(baseConfig.gainFloor + baseConfig.gainRange * baseRoutes[3].smoothed, now, 0.05);
        audioNodes.lfoGain.gain.setTargetAtTime(2 + baseConfig.vibDepth * baseRoutes[4].smoothed, now, 0.05);
        audioNodes.lfo.frequency.setTargetAtTime(1.5 + baseConfig.vibRate * baseRoutes[5].smoothed, now, 0.05);
    } else {
        audioNodes.gainNode.gain.setTargetAtTime(0, now, 0.05);
        audioNodes.lfoGain.gain.setTargetAtTime(0, now, 0.05);
        audioNodes.modGain.gain.setTargetAtTime(0, now, 0.05);
    }

    // --- Voice (beeps): close encounters per-root record tracking ---
    if (voiceEnabled) {
        let seeding = false;
        if (!closeEncounters || closeEncounters.length !== n * ENCOUNTER_TOP_K) {
            closeEncounters = new Float64Array(n * ENCOUNTER_TOP_K).fill(Infinity);
            encounterAge = new Float64Array(n * ENCOUNTER_TOP_K).fill(0);
            seeding = true;
        }

        let bestImprovement = 0;
        let bestRoot = -1;

        for (let i = 0; i < n; i++) {
            const closest = [Infinity, Infinity, Infinity];
            for (let j = 0; j < n; j++) {
                if (j === i) continue;
                const d = Math.hypot(currentRoots[i].re - currentRoots[j].re,
                                     currentRoots[i].im - currentRoots[j].im);
                if (d < closest[2]) {
                    closest[2] = d;
                    if (closest[2] < closest[1]) { const t = closest[1]; closest[1] = closest[2]; closest[2] = t; }
                    if (closest[1] < closest[0]) { const t = closest[0]; closest[0] = closest[1]; closest[1] = t; }
                }
            }

            const base = i * ENCOUNTER_TOP_K;
            if (seeding) {
                for (let k = 0; k < ENCOUNTER_TOP_K; k++) {
                    closeEncounters[base + k] = closest[k];
                    encounterAge[base + k] = 0;
                }
            } else {
                for (let k = 0; k < ENCOUNTER_TOP_K; k++) {
                    const worstIdx = base + ENCOUNTER_TOP_K - 1;
                    if (closest[k] < closeEncounters[worstIdx]) {
                        const improvement = closeEncounters[worstIdx] - closest[k];
                        closeEncounters[worstIdx] = closest[k] * voiceConfig.novelty;
                        encounterAge[worstIdx] = 0;
                        for (let a = ENCOUNTER_TOP_K - 1; a > 0; a--) {
                            if (closeEncounters[base + a] < closeEncounters[base + a - 1]) {
                                const td = closeEncounters[base + a]; closeEncounters[base + a] = closeEncounters[base + a - 1]; closeEncounters[base + a - 1] = td;
                                const ta = encounterAge[base + a]; encounterAge[base + a] = encounterAge[base + a - 1]; encounterAge[base + a - 1] = ta;
                            }
                        }
                        if (improvement > bestImprovement) {
                            bestImprovement = improvement;
                            bestRoot = i;
                        }
                    }
                }
            }
        }

        if (bestRoot >= 0 && now - lastBeepTime > voiceConfig.cooldown * voiceRoutes[3].smoothed * 2) {
            lastBeepTime = now;
            const midi = 60 + ARP_SCALE[bestRoot % 5] + 12 * Math.floor(bestRoot / 5);
            const pitchBias = (voiceRoutes[0].smoothed - 0.5) * 24;
            const freq = midiToHz(Math.min(Math.max(midi + pitchBias, 36), 108));
            const improvNorm = audioClamp(bestImprovement / (range * 0.05), 0, 1);
            const volScale = voiceRoutes[1].smoothed * 2;
            const peak = audioClamp((0.05 + voiceConfig.peak * improvNorm) * volScale, 0.0001, 0.5);
            const ringdown = Math.max(0.01, voiceConfig.ringdown * voiceRoutes[2].smoothed * 2);

            audioNodes.beepOsc.frequency.setTargetAtTime(freq, now, 0.01);
            audioNodes.beepGain.gain.cancelScheduledValues(now);
            audioNodes.beepGain.gain.setValueAtTime(0.0001, now);
            audioNodes.beepGain.gain.exponentialRampToValueAtTime(peak, now + voiceConfig.attack);
            audioNodes.beepGain.gain.exponentialRampToValueAtTime(0.0001, now + voiceConfig.attack + ringdown);
        }

        if (!seeding) {
            for (let k = 0; k < closeEncounters.length; k++) {
                closeEncounters[k] *= voiceConfig.decay;
                encounterAge[k]++;
            }
        }
    }

    // --- Melody (arpeggiator): one note per step, cycling through top-N fastest roots ---
    if (melodyEnabled && audioNodes.arpOsc && audioNodes.arpGain) {
        const tNow = performance.now();
        const dt = lastAudioUpdateTime ? Math.max(0.001, Math.min((tNow - lastAudioUpdateTime) / 1000, 0.05)) : 1 / 60;

        // Build per-root velocity array and sort indices by speed (descending)
        const vels = new Array(n);
        for (let i = 0; i < n; i++) {
            if (prevRootsAudio && prevRootsAudio.length === n) {
                vels[i] = Math.hypot(currentRoots[i].re - prevRootsAudio[i].re,
                                     currentRoots[i].im - prevRootsAudio[i].im);
            } else {
                vels[i] = 0;
            }
        }
        const indices = Array.from({ length: n }, (_, i) => i);
        indices.sort((a, b) => vels[b] - vels[a]);

        // cutoff: top N fastest roots to arpeggio (clamped to [2, n])
        const N = Math.min(Math.max(Math.round(melodyConfig.cutoff), 2), n);

        const prevArpStep = Math.floor(arpPhase);
        arpPhase += melodyConfig.rate * melodyRoutes[0].smoothed * 2 * dt;
        const rank = Math.floor(arpPhase) % N;
        const rootIdx = indices[rank];
        const rk = currentRoots[rootIdx];

        // angle ‚Üí scale degree (pentatonic)
        const theta = Math.atan2(rk.im - cy, rk.re - cx);
        const u = frac01((theta + Math.PI) / (2 * Math.PI));
        const degree = Math.floor(u * 12);
        const qSemi = quantizeToScale(degree);

        // radius ‚Üí octave (0‚Äì2, 3 octaves)
        const rad = Math.hypot(rk.re - cx, rk.im - cy);
        const radNorm = audioClamp(rad / (range * 1.2), 0, 1);
        const octave = Math.floor(radNorm * 3);

        const baseMidi = 48; // C3
        const hz = midiToHz(baseMidi + qSemi + 12 * octave);

        // velocity of this root ‚Üí filter brightness
        const velNorm = audioClamp(vels[rootIdx] / (range * 0.03), 0, 1);
        arpSmoothVel = arpSmoothVel * 0.85 + velNorm * 0.15;

        audioNodes.arpOsc.frequency.setTargetAtTime(hz, now, 0.01);
        audioNodes.arpFilter.frequency.setTargetAtTime((melodyConfig.filterLo + melodyConfig.filterHi * arpSmoothVel) * melodyRoutes[1].smoothed * 2, now, 0.02);

        // pluck envelope on new step ‚Äî volume scales with rank (fastest = loudest)
        const curArpStep = Math.floor(arpPhase);
        if (curArpStep !== prevArpStep) {
            const rankScale = 1 - rank / N;  // 1.0 for rank 0 (fastest), ~0 for rank N-1
            const melVolScale = melodyRoutes[2].smoothed * 2;
            const peak = (0.02 + melodyConfig.peak * arpSmoothVel) * rankScale * melVolScale;
            const g = audioNodes.arpGain.gain;
            g.cancelScheduledValues(now);
            g.setValueAtTime(0.0001, now);
            const melDecay = Math.max(0.005, melodyConfig.decay * melodyRoutes[3].smoothed * 2);
            g.exponentialRampToValueAtTime(Math.max(peak, 0.0001), now + melodyConfig.attack);
            g.exponentialRampToValueAtTime(0.0001, now + melodyConfig.attack + melDecay);
        }
    }
    // Save state for next frame
    prevRootsAudio = currentRoots.map(r => ({ re: r.re, im: r.im }));
    lastAudioUpdateTime = performance.now();
}

function audioWatchdog() {
    if (!anySoundEnabled() || !audioNodes || !audioCtx) return;
    if (performance.now() - lastAudioUpdateTime > 150) {
        audioNodes.masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.15);
    }
}

function resetAudioState() {
    prevRootsAudio = null;
    closeEncounters = null;
    encounterAge = null;
    arpPhase = 0;
    arpSmoothVel = 0;
    for (const route of baseRoutes) { route.smoothed = 0; route.runMax = 0.001; }
    for (const route of voiceRoutes) { route.smoothed = 0.5; route.runMax = 0.001; }
    for (const route of melodyRoutes) { route.smoothed = 0.5; route.runMax = 0.001; }
    prevAnglesAudio = null;
    if (audioNodes && audioCtx) {
        audioNodes.masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.08);
    }
}

// --- Compute range needed to fit data ---

function computeRange(points) {
    // points: array of {re, im} or [re, im]
    let maxAbs = MIN_RANGE;
    for (const p of points) {
        const re = Array.isArray(p) ? p[0] : p.re;
        const im = Array.isArray(p) ? p[1] : p.im;
        if (isFinite(re)) maxAbs = Math.max(maxAbs, Math.abs(re));
        if (isFinite(im)) maxAbs = Math.max(maxAbs, Math.abs(im));
    }
    // Round up to a nice number and add padding; cap to prevent Infinity
    const raw = maxAbs * RANGE_PAD * 2;
    return isFinite(raw) ? Math.ceil(raw) / 2 : 1e6;
}

// --- SVG setup / grid redraw ---

function drawGrid(svgSel, p) {
    const xs = p.xScale, ys = p.yScale, range = p.range;

    // Clear old grid elements
    if (p.gridG) p.gridG.remove();
    if (p.axisG) p.axisG.remove();
    if (p.labelRe) p.labelRe.remove();
    if (p.labelIm) p.labelIm.remove();
    if (p.unitCircle) p.unitCircle.remove();

    if (!isFinite(range) || range <= 0) return; // bail on bad range

    // Grid lines ‚Äî pick a 1-2-5 step that keeps ‚â§ ~20 lines per axis
    p.gridG = svgSel.insert("g", ":first-child").attr("class", "grid");
    let step = 1;
    if (isFinite(range) && range > 0) {
        const raw = range / 10;
        const mag = Math.pow(10, Math.floor(Math.log10(raw)));
        const norm = raw / mag;
        step = (norm <= 1 ? 1 : norm <= 2 ? 2 : norm <= 5 ? 5 : 10) * mag;
    }
    const gridMax = Math.floor(range / step) * step;
    for (let v = -gridMax; v <= gridMax; v += step) {
        p.gridG.append("line")
            .attr("x1", xs(v)).attr("y1", ys(-range))
            .attr("x2", xs(v)).attr("y2", ys(range));
        p.gridG.append("line")
            .attr("x1", xs(-range)).attr("y1", ys(v))
            .attr("x2", xs(range)).attr("y2", ys(v));
    }

    // Axes
    p.axisG = svgSel.insert("g", ":first-child").attr("class", "axis");
    p.axisG.append("line")
        .attr("x1", xs(-range)).attr("y1", ys(0))
        .attr("x2", xs(range)).attr("y2", ys(0));
    p.axisG.append("line")
        .attr("x1", xs(0)).attr("y1", ys(-range))
        .attr("x2", xs(0)).attr("y2", ys(range));

    // Axis labels
    p.labelRe = svgSel.append("text").attr("x", S - MARGIN + 4).attr("y", ys(0) + 4)
        .attr("fill", "#556").attr("font-size", 11).text("Re");
    p.labelIm = svgSel.append("text").attr("x", xs(0) + 6).attr("y", MARGIN - 4)
        .attr("fill", "#556").attr("font-size", 11).text("Im");

    // Unit circle
    const r = Math.abs(xs(1) - xs(0));
    p.unitCircle = svgSel.append("circle").attr("class", "unit-circle")
        .attr("cx", xs(0)).attr("cy", ys(0)).attr("r", r);
}

function setupPanel(svgSel, p) {
    svgSel.attr("width", S).attr("height", S).attr("viewBox", `0 0 ${S} ${S}`);
    drawGrid(svgSel, p);
}

function updatePanelRange(svgSel, p, newRange) {
    if (Math.abs(p.range - newRange) < 0.01) return; // no change
    p.range = newRange;
    initPanelScales(p);
    drawGrid(svgSel, p);
}

const coeffSvg = d3.select("#coeff-panel");
const rootsSvg = d3.select("#roots-panel");
setupPanel(coeffSvg, panels.coeff);
setupPanel(rootsSvg, panels.roots);

let coeffTrailLayer = coeffSvg.append("g").attr("class", "trail-layer");
let coeffLayer = coeffSvg.append("g");
let coeffChainLine = coeffLayer.append("polyline")
    .attr("class", "coeff-chain")
    .attr("fill", "none")
    .attr("stroke", "rgba(255,255,255,0.35)")
    .attr("stroke-width", 1.5)
    .attr("stroke-dasharray", "4,3")
    .style("display", "none");
let trailLayer = rootsSvg.append("g").attr("class", "trail-layer");
let rootsLayer = rootsSvg.append("g");

// --- Tooltip ---

const tooltip = document.getElementById("tooltip");

function showTooltip(event, re, im) {
    const sign = im >= 0 ? "+" : "‚àí";
    const absIm = Math.abs(im);
    tooltip.textContent = `${re.toFixed(3)} ${sign} ${absIm.toFixed(3)}i`;
    tooltip.style.display = "block";
    tooltip.style.left = (event.pageX + 12) + "px";
    tooltip.style.top = (event.pageY - 12) + "px";
}

function hideTooltip() {
    tooltip.style.display = "none";
}

// --- Coefficient color ---

function coeffColor(i, n) {
    return d3.interpolateRainbow(i / n);
}

function rootColor(i, n) {
    if (rootColorMode === "rainbow") return d3.interpolateRainbow(i / n);
    if (rootColorMode === "derivative" && rootSensitivities && i < rootSensitivities.length) {
        return sensitivityColor(rootSensitivities[i]);
    }
    if (rootColorMode === "uniform") {
        return `rgb(${uniformRootColor[0]},${uniformRootColor[1]},${uniformRootColor[2]})`;
    }
    return "#e94560";
}

function rootColorRGB(i, n) {
    const css = rootColor(i, n);
    // Handle hex format (#rrggbb)
    if (css[0] === "#") {
        const hex = css.length === 4
            ? css[1]+css[1]+css[2]+css[2]+css[3]+css[3]
            : css.slice(1);
        return [parseInt(hex.slice(0,2),16), parseInt(hex.slice(2,4),16), parseInt(hex.slice(4,6),16)];
    }
    // Handle rgb() format from d3
    const m = css.match(/(\d+)/g);
    if (m && m.length >= 3) return [+m[0], +m[1], +m[2]];
    return [233, 69, 96];
}

function sensitivityColor(normVal) {
    if (normVal <= 0.5) {
        const t = normVal * 2;
        const r = Math.round(t * 255);
        const g = Math.round(t * 255);
        return `rgb(${r},${g},255)`;
    } else {
        const t = (normVal - 0.5) * 2;
        const g = Math.round((1 - t) * 255);
        const b = Math.round((1 - t) * 255);
        return `rgb(255,${g},${b})`;
    }
}

// Rank-based normalization: sort values, assign integer ranks (ties get same rank),
// map linearly to [0,1]. 0=blue, 0.5=white, 1=red in sensitivityColor.
function rankNormalize(raw) {
    const n = raw.length;
    if (n === 0) return null;
    // Build (value, index) pairs, replacing non-finite with largest finite
    let maxFinite = -Infinity;
    for (let i = 0; i < n; i++) if (isFinite(raw[i]) && raw[i] > maxFinite) maxFinite = raw[i];
    if (maxFinite === -Infinity) return null;
    const pairs = [];
    for (let i = 0; i < n; i++) pairs.push({ v: isFinite(raw[i]) ? raw[i] : maxFinite, i });
    pairs.sort((a, b) => a.v - b.v);
    // Assign integer ranks; ties get the same rank
    const result = new Float64Array(n);
    let rank = 0;
    for (let p = 0; p < n; p++) {
        if (p > 0 && pairs[p].v !== pairs[p - 1].v) rank = p;
        result[pairs[p].i] = rank;
    }
    const maxRank = n - 1;
    if (maxRank === 0) { result.fill(0.5); return result; }
    for (let i = 0; i < n; i++) result[i] /= maxRank;
    return result;
}

function computeCoeffSensitivities() {
    const nRoots = currentRoots.length;
    const nCoeffs = coefficients.length;
    const deg = nCoeffs - 1;
    if (nRoots === 0) return null;

    const cRe = new Float64Array(nCoeffs);
    const cIm = new Float64Array(nCoeffs);
    for (let i = 0; i < nCoeffs; i++) { cRe[i] = coefficients[i].re; cIm[i] = coefficients[i].im; }

    // Precompute 1/|p'(rj)| and |rj| for each root
    const invDpMag = new Float64Array(nRoots);
    const rMag = new Float64Array(nRoots);
    for (let j = 0; j < nRoots; j++) {
        const zRe = currentRoots[j].re, zIm = currentRoots[j].im;
        rMag[j] = Math.hypot(zRe, zIm);
        let pRe = cRe[0], pIm = cIm[0], dpRe = 0, dpIm = 0;
        for (let k = 1; k <= deg; k++) {
            const ndRe = dpRe * zRe - dpIm * zIm + pRe;
            const ndIm = dpRe * zIm + dpIm * zRe + pIm;
            dpRe = ndRe; dpIm = ndIm;
            const npRe = pRe * zRe - pIm * zIm + cRe[k];
            const npIm = pRe * zIm + pIm * zRe + cIm[k];
            pRe = npRe; pIm = npIm;
        }
        const dm = Math.hypot(dpRe, dpIm);
        invDpMag[j] = dm < 1e-30 ? 0 : 1 / dm;
    }

    // For each coefficient k: sensitivity_k = Œ£‚±º |r‚±º^(deg-k)| / |p'(r‚±º)|
    const raw = new Float64Array(nCoeffs);
    for (let k = 0; k < nCoeffs; k++) {
        const power = deg - k;
        let sum = 0;
        for (let j = 0; j < nRoots; j++) {
            sum += Math.pow(rMag[j], power) * invDpMag[j];
        }
        raw[k] = sum;
    }

    return rankNormalize(raw);
}

function computeRootSensitivities() {
    const n = currentRoots.length;
    const deg = coefficients.length - 1;
    if (n === 0 || selectedCoeffs.size === 0) { rootSensitivities = null; return; }

    // Build coefficient arrays for Horner evaluation of p'(z)
    const cRe = new Float64Array(coefficients.length);
    const cIm = new Float64Array(coefficients.length);
    for (let i = 0; i < coefficients.length; i++) {
        cRe[i] = coefficients[i].re;
        cIm[i] = coefficients[i].im;
    }

    const raw = new Float64Array(n);
    for (let j = 0; j < n; j++) {
        const zRe = currentRoots[j].re, zIm = currentRoots[j].im;
        // Horner: simultaneous p(z) and p'(z)
        let pRe = cRe[0], pIm = cIm[0];
        let dpRe = 0, dpIm = 0;
        for (let k = 1; k <= deg; k++) {
            const ndRe = dpRe * zRe - dpIm * zIm + pRe;
            const ndIm = dpRe * zIm + dpIm * zRe + pIm;
            dpRe = ndRe; dpIm = ndIm;
            const npRe = pRe * zRe - pIm * zIm + cRe[k];
            const npIm = pRe * zIm + pIm * zRe + cIm[k];
            pRe = npRe; pIm = npIm;
        }
        const dpMag = Math.hypot(dpRe, dpIm);
        if (dpMag < 1e-30) { raw[j] = Infinity; continue; }

        // Sum |rj^(deg-k)| for each selected coefficient k
        const rMag = Math.hypot(zRe, zIm);
        let sum = 0;
        for (const k of selectedCoeffs) {
            sum += Math.pow(rMag, deg - k);
        }
        raw[j] = sum / dpMag;
    }

    rootSensitivities = rankNormalize(raw);
}

// --- Init coefficients with pattern ---

function getPattern() { return document.getElementById("pattern").value; }
function getSpread() { return 1.0; }

function initCoefficients(degree) {
    const n = degree + 1;
    const spread = getSpread();
    const pattern = getPattern();
    coefficients = [];

    if (pattern === "circle") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            coefficients.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
    } else if (pattern === "real") {
        for (let i = 0; i < n; i++) {
            const t = n === 1 ? 0 : -spread + (2 * spread * i) / (n - 1);
            coefficients.push({ re: t, im: 0 });
        }
    } else if (pattern === "imag") {
        for (let i = 0; i < n; i++) {
            const t = n === 1 ? 0 : -spread + (2 * spread * i) / (n - 1);
            coefficients.push({ re: 0, im: t });
        }
    } else if (pattern === "grid") {
        const cols = Math.ceil(Math.sqrt(n));
        const rows = Math.ceil(n / cols);
        for (let i = 0; i < n; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            const re = cols === 1 ? 0 : -spread + (2 * spread * col) / (cols - 1);
            const im = rows === 1 ? 0 : -spread + (2 * spread * row) / (rows - 1);
            coefficients.push({ re, im });
        }
    } else if (pattern === "random") {
        for (let i = 0; i < n; i++) {
            coefficients.push({
                re: (Math.random() * 2 - 1) * spread,
                im: (Math.random() * 2 - 1) * spread
            });
        }
    } else if (pattern === "spiral") {
        // Archimedean spiral ‚Äî roots trace beautiful curves when perturbed
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const r = spread * t;
            const angle = 4 * Math.PI * t;
            coefficients.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "star") {
        // Alternating inner/outer radii ‚Äî gives spiky root patterns
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            const r = (i % 2 === 0) ? spread : spread * 0.4;
            coefficients.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "lemniscate") {
        // Figure-8 (Bernoulli lemniscate) ‚Äî rich root sensitivity
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const cos2t = Math.cos(2 * t);
            const r = spread * Math.sqrt(Math.abs(cos2t));
            const sign = cos2t >= 0 ? 1 : -1;
            coefficients.push({ re: sign * r * Math.cos(t), im: sign * r * Math.sin(t) });
        }
    } else if (pattern === "conjugate") {
        // Conjugate pairs straddling real axis ‚Äî roots tend to stay near real axis then bifurcate
        for (let i = 0; i < n; i++) {
            const pairIdx = Math.floor(i / 2);
            const re = n <= 2 ? 0 : -spread + (2 * spread * pairIdx) / (Math.ceil(n / 2) - 1 || 1);
            const im = (i % 2 === 0) ? spread * 0.5 : -spread * 0.5;
            coefficients.push({ re, im });
        }
    } else if (pattern === "two-clusters") {
        // Two clusters ‚Äî see roots jump between clusters as you drag
        const half = Math.ceil(n / 2);
        for (let i = 0; i < n; i++) {
            const cluster = i < half ? -1 : 1;
            const idx = i < half ? i : i - half;
            const count = i < half ? half : n - half;
            const angle = (2 * Math.PI * idx) / Math.max(count, 1);
            const r = spread * 0.35;
            coefficients.push({
                re: cluster * spread * 0.7 + r * Math.cos(angle),
                im: r * Math.sin(angle)
            });
        }
    } else if (pattern === "geometric") {
        // Geometric decay along real axis ‚Äî classic for ill-conditioned polynomials
        for (let i = 0; i < n; i++) {
            const val = spread * Math.pow(0.7, i);
            const sign = (i % 2 === 0) ? 1 : -1;
            coefficients.push({ re: sign * val, im: 0 });
        }
    } else if (pattern === "rose") {
        // Rose curve r = cos(kŒ∏) ‚Äî petals create interesting symmetry breaking
        const k = 3; // 3-petal rose
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * Math.cos(k * t);
            coefficients.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "cardioid") {
        // Cardioid ‚Äî heart-shaped curve, roots respond dramatically near the cusp
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * 0.5 * (1 + Math.cos(t));
            coefficients.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern.startsWith("r-")) {
        // Root-shape patterns: define roots, compute coefficients
        const roots = generateRootShape(pattern, degree, spread);
        const cs = rootsToCoefficients(roots);
        for (const c of cs) coefficients.push(c);
    }

    // Initialize trajectory defaults (no path assigned yet)
    for (const c of coefficients) {
        c.curve = null;
        c.pathType = "none";
        c.radius = 25;
        c.speed = 1.0;
        c.angle = 0;
        c.ccw = false;
        c.extra = {};
    }
}

// --- Roots ‚Üí Coefficients ---
// Expand (z - r‚ÇÄ)(z - r‚ÇÅ)...(z - r_{n-1}) into coefficient array
function rootsToCoefficients(roots) {
    // Start with polynomial = [1] (just the leading coefficient)
    let re = [1], im = [0];
    for (const root of roots) {
        const newRe = new Array(re.length + 1).fill(0);
        const newIm = new Array(im.length + 1).fill(0);
        for (let j = 0; j < re.length; j++) {
            // Multiply by z: shift coefficients up
            newRe[j] += re[j];
            newIm[j] += im[j];
            // Multiply by -root: (a+bi)(-c-di) = (-ac+bd) + (-ad-bc)i
            newRe[j + 1] += -re[j] * root.re + im[j] * root.im;
            newIm[j + 1] += -re[j] * root.im - im[j] * root.re;
        }
        re = newRe;
        im = newIm;
    }
    return re.map((r, i) => ({ re: r, im: im[i] }));
}

// --- Root shape generators ---
function generateRootShape(pattern, degree, spread) {
    const n = degree; // number of roots = degree
    const roots = [];

    if (pattern === "r-heart") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const x = spread * 0.8 * 16 * Math.pow(Math.sin(t), 3) / 16;
            const y = spread * 0.8 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 16;
            roots.push({ re: x, im: y });
        }
    } else if (pattern === "r-circle") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            roots.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
    } else if (pattern === "r-star") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            const r = (i % 2 === 0) ? spread : spread * 0.4;
            roots.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "r-spiral") {
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const r = spread * (0.2 + 0.8 * t);
            const angle = 4 * Math.PI * t;
            roots.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "r-cross") {
        // + shape: half on horizontal, half on vertical
        const hCount = Math.ceil(n / 2);
        const vCount = n - hCount;
        for (let i = 0; i < hCount; i++) {
            const t = hCount === 1 ? 0 : -spread + (2 * spread * i) / (hCount - 1);
            roots.push({ re: t, im: 0 });
        }
        for (let i = 0; i < vCount; i++) {
            const t = vCount === 1 ? 0 : -spread + (2 * spread * i) / (vCount - 1);
            if (Math.abs(t) < 1e-10) continue; // skip origin (already in horizontal)
            roots.push({ re: 0, im: t });
        }
        // Fill up if we skipped the origin duplicate
        while (roots.length < n) {
            roots.push({ re: 0, im: spread * 0.1 * roots.length });
        }
    } else if (pattern === "r-diamond") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            // Diamond: |x| + |y| = spread, parametrically
            const x = spread * Math.cos(t);
            const y = spread * Math.sin(t);
            const scale = 1 / (Math.abs(Math.cos(t)) + Math.abs(Math.sin(t)));
            roots.push({ re: x * scale, im: y * scale });
        }
    } else if (pattern === "r-grid") {
        // Chessboard: only "black squares" of a grid
        const side = Math.ceil(Math.sqrt(n * 2));
        let placed = 0;
        for (let row = 0; row < side && placed < n; row++) {
            for (let col = 0; col < side && placed < n; col++) {
                if ((row + col) % 2 === 0) {
                    const re = -spread + (2 * spread * col) / (side - 1);
                    const im = -spread + (2 * spread * row) / (side - 1);
                    roots.push({ re, im });
                    placed++;
                }
            }
        }
    } else if (pattern === "r-smiley") {
        // Eyes + smile arc
        const eyeCount = Math.max(2, Math.floor(n * 0.2));
        const smileCount = n - eyeCount;
        // Left eye
        const leftEye = Math.ceil(eyeCount / 2);
        for (let i = 0; i < leftEye; i++) {
            const angle = (2 * Math.PI * i) / leftEye;
            roots.push({ re: -spread * 0.35 + spread * 0.12 * Math.cos(angle), im: spread * 0.3 + spread * 0.12 * Math.sin(angle) });
        }
        // Right eye
        const rightEye = eyeCount - leftEye;
        for (let i = 0; i < rightEye; i++) {
            const angle = (2 * Math.PI * i) / Math.max(rightEye, 1);
            roots.push({ re: spread * 0.35 + spread * 0.12 * Math.cos(angle), im: spread * 0.3 + spread * 0.12 * Math.sin(angle) });
        }
        // Smile arc (bottom half of circle)
        for (let i = 0; i < smileCount; i++) {
            const angle = Math.PI + (Math.PI * 0.8) * (i / (smileCount - 1)) - Math.PI * 0.4;
            roots.push({ re: spread * 0.6 * Math.cos(angle), im: spread * 0.6 * Math.sin(angle) - spread * 0.1 });
        }
    } else if (pattern === "r-figure8") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const cos2t = Math.cos(2 * t);
            const r = spread * Math.sqrt(Math.abs(cos2t));
            const sign = cos2t >= 0 ? 1 : -1;
            roots.push({ re: sign * r * Math.cos(t), im: sign * r * Math.sin(t) });
        }
    } else if (pattern === "r-butterfly") {
        // Butterfly curve (polar)
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * 0.4 * (Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) + Math.pow(Math.sin(t / 12), 5));
            roots.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "r-trefoil") {
        // 3-leaf clover
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * Math.cos(3 * t);
            roots.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "r-polygon") {
        // Regular polygon outline (not just vertices)
        const sides = Math.min(Math.max(3, Math.floor(degree / 2)), 8);
        const vertices = [];
        for (let s = 0; s < sides; s++) {
            const angle = (2 * Math.PI * s) / sides - Math.PI / 2;
            vertices.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
        // Distribute roots along edges
        for (let i = 0; i < n; i++) {
            const t = (i / n) * sides;
            const edgeIdx = Math.floor(t) % sides;
            const frac = t - Math.floor(t);
            const v1 = vertices[edgeIdx];
            const v2 = vertices[(edgeIdx + 1) % sides];
            roots.push({ re: v1.re + frac * (v2.re - v1.re), im: v1.im + frac * (v2.im - v1.im) });
        }
    } else if (pattern === "r-infinity") {
        // Infinity / lemniscate of Bernoulli: two lobes
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const denom = 1 + Math.sin(t) * Math.sin(t);
            roots.push({
                re: spread * Math.cos(t) / denom,
                im: spread * Math.sin(t) * Math.cos(t) / denom
            });
        }
    }
    return roots;
}

// --- Drag behavior ---

let dragMoved = false;
let dragStartX = 0, dragStartY = 0;
const CLICK_DEAD_ZONE = 3; // px threshold: smaller moves count as clicks, not drags
const drag = d3.drag()
    .on("start", function (event) {
        dragMoved = false;
        dragStartX = event.x;
        dragStartY = event.y;
        d3.select(this).raise().classed("dragging", true);
    })
    .on("drag", function (event, d) {
        if (!dragMoved && Math.hypot(event.x - dragStartX, event.y - dragStartY) < CLICK_DEAD_ZONE) return;
        dragMoved = true;
        const idx = d._idx;
        // Skip if this coefficient is being animated
        if (animState.playing && allAnimatedCoeffs().has(idx)) return;

        const newRe = cxs().invert(event.x);
        const newIm = cys().invert(event.y);

        if (selectedCoeffs.has(idx) && selectedCoeffs.size > 1) {
            // Group drag: apply delta to all selected
            const deltaRe = newRe - d.re;
            const deltaIm = newIm - d.im;
            for (const si of selectedCoeffs) {
                coefficients[si].re += deltaRe;
                coefficients[si].im += deltaIm;
                if (coefficients[si].curve) {
                    for (const pt of coefficients[si].curve) { pt.re += deltaRe; pt.im += deltaIm; }
                }
            }
            coeffLayer.selectAll("circle.coeff")
                .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
            coeffLayer.selectAll(".coeff-label")
                .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);
        } else {
            // Single drag: shift position and all curve points by delta
            const deltaRe = newRe - d.re;
            const deltaIm = newIm - d.im;
            d.re = newRe;
            d.im = newIm;
            if (d.curve) {
                for (const pt of d.curve) { pt.re += deltaRe; pt.im += deltaIm; }
            }
            d3.select(this).attr("cx", cxs()(d.re)).attr("cy", cys()(d.im));
            coeffLayer.selectAll(".coeff-label")
                .filter(ld => ld === d)
                .attr("x", cxs()(d.re) + 12).attr("y", cys()(d.im) + 4);
        }
        showTooltip(event.sourceEvent, d.re, d.im);
        autoScaleCoeffPanel();
        solveRootsThrottled();
        renderDomainColoringThrottled();
        // Update analytical coefficient path curves (they follow the coefficient)
        renderCoeffTrails();
        updateListCoords();
    })
    .on("end", function (event, d) {
        d3.select(this).classed("dragging", false);
        hideTooltip();
        // Click detection: if mouse didn't move, toggle selection
        if (!dragMoved) {
            const idx = d._idx;
            clearRootSelection();
            toggleCoeffSelect(idx);
        }
    });

function autoScaleCoeffPanel() {
    let needed = computeRange(coefficients);
    // During animation, only zoom out ‚Äî never shrink back
    if (animState.playing) needed = Math.max(needed, panels.coeff.range);
    if (needed !== panels.coeff.range) {
        updatePanelRange(coeffSvg, panels.coeff, needed);
        coeffLayer.selectAll("circle.coeff")
            .attr("cx", d => cxs()(d.re)).attr("cy", d => cys()(d.im));
        coeffLayer.selectAll(".coeff-label")
            .attr("x", d => cxs()(d.re) + 12).attr("y", d => cys()(d.im) + 4);
        // Trail SVG paths contain absolute screen coordinates ‚Äî must re-render
        // when the scale changes so trails stay aligned with coefficient dots
        renderCoeffTrails();
    }
}

// --- Coefficient selection & animation ---

function coeffExtent() {
    const n = coefficients.length;
    let maxDist = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const d = Math.hypot(coefficients[i].re - coefficients[j].re,
                                 coefficients[i].im - coefficients[j].im);
            if (d > maxDist) maxDist = d;
        }
    }
    return maxDist || 1;
}

const animBar = document.getElementById("anim-bar");
const barTitle = document.getElementById("bar-title");
const animPathSel = document.getElementById("anim-path");
const playBtn = document.getElementById("play-btn");
const trailsBtn = document.getElementById("trails-btn");
const sel2pathBtn = document.getElementById("sel2path-btn");
const barControls = document.getElementById("bar-controls");
const barDynamic = document.getElementById("bar-dynamic");

// --- Path parameter schemas ---

const _P = {
    radius: { key: "radius", label: "R", min: 1, max: 100, step: 1, default: 25, fmt: v => Math.round(v) + "%" },
    speed:  { key: "speed",  label: "S", min: 1, max: 100, step: 1, default: 1.0, fmt: v => String(Math.round(v)), toUI: v => Math.round(v * 100), fromUI: v => v / 100 },
    angle:  { key: "angle",  label: "A", min: 0, max: 1.0, step: 0.01, default: 0, fmt: v => v.toFixed(2) },
    ccw:    { key: "ccw", type: "toggle", labels: ["CW", "CCW"], default: false },
};
const _RSAD = [_P.speed, _P.radius, _P.angle, _P.ccw];
const _RSD  = [_P.speed, _P.radius, _P.ccw];
const _STD_KEYS = new Set(["radius", "speed", "angle", "ccw"]);

const PATH_PARAMS = {
    none:          [],
    circle:        _RSAD,
    horizontal:    _RSD,
    vertical:      _RSD,
    spiral:        [_P.speed,
        { key: "mult", label: "R", min: 0, max: 2.0, step: 0.05, default: 1.5, fmt: v => v.toFixed(2) + "√ó" },
        { key: "turns", label: "T", min: 0.5, max: 5, step: 0.5, default: 2, fmt: v => v.toFixed(1) },
        _P.ccw],
    random:        [_P.speed,
        { key: "radius", label: "œÉ", min: 0, max: 10, step: 0.5, default: 2, fmt: v => v.toFixed(1) + "%" }],
    lissajous:     [..._RSAD,
        { key: "freqA", label: "a", min: 1, max: 8, step: 1, default: 3, fmt: v => String(Math.round(v)) },
        { key: "freqB", label: "b", min: 1, max: 8, step: 1, default: 2, fmt: v => String(Math.round(v)) },
    ],
    figure8:       _RSAD,
    cardioid:      _RSAD,
    astroid:       _RSAD,
    deltoid:       _RSAD,
    rose:          _RSAD,
    epitrochoid:   _RSAD,
    hypotrochoid:  _RSAD,
    butterfly:     _RSAD,
    star:          _RSAD,
    square:        _RSAD,
    hilbert:       _RSAD,
    peano:         _RSAD,
    sierpinski:    _RSAD,
};

function getCoeffParam(c, key, schema) {
    if (_STD_KEYS.has(key)) return c[key];
    if (c.extra && c.extra[key] !== undefined) return c.extra[key];
    if (schema) return schema.default;
    return 0;
}

function setCoeffParam(c, key, value) {
    if (_STD_KEYS.has(key)) { c[key] = value; return; }
    if (!c.extra) c.extra = {};
    c.extra[key] = value;
}

// Dynamic bar controls ‚Äî rebuilt when path type changes
let barInputs = {};       // { key: <input element>, ... }
let barCurrentPath = "";  // track which path type is currently shown

function rebuildBarControls(pathType) {
    if (pathType === barCurrentPath) return;
    barCurrentPath = pathType;
    barDynamic.innerHTML = "";
    barInputs = {};
    const schema = PATH_PARAMS[pathType] || [];
    // Render sliders first, toggles last (CW/CCW always at end)
    const sliders = schema.filter(p => p.type !== "toggle");
    const toggles = schema.filter(p => p.type === "toggle");
    for (const p of sliders) {
        const lbl = document.createElement("label");
        const inp = document.createElement("input");
        const uiDef = p.toUI ? p.toUI(p.default) : p.default;
        inp.type = "range"; inp.min = p.min; inp.max = p.max; inp.step = p.step; inp.value = uiDef;
        const valSpan = document.createElement("span");
        valSpan.className = "bar-val";
        valSpan.textContent = p.fmt(uiDef);
        inp.addEventListener("input", function () {
            valSpan.textContent = p.fmt(parseFloat(this.value));
            applyBarToSelection();
        });
        lbl.textContent = p.label + " ";
        lbl.appendChild(inp);
        lbl.appendChild(valSpan);
        barDynamic.appendChild(lbl);
        barInputs[p.key] = inp;
        barInputs[p.key + "_val"] = valSpan;
        barInputs[p.key + "_fmt"] = p.fmt;
    }
    for (const p of toggles) {
        const btn = document.createElement("button");
        btn.id = "ccw-btn";
        btn.textContent = p.labels[0];
        btn.addEventListener("click", function () {
            if (selectedCoeffs.size === 0) return;
            const isActive = !this.classList.contains("active");
            this.textContent = isActive ? p.labels[1] : p.labels[0];
            this.classList.toggle("active", isActive);
            applyBarToSelection();
        });
        barDynamic.appendChild(btn);
        barInputs[p.key] = btn;
    }
    // PS button (only if speed slider exists)
    if (barInputs["speed"]) {
        const psBtn = document.createElement("button");
        psBtn.id = "bar-ps-btn";
        psBtn.textContent = "PS";
        psBtn.title = "Prime Speed ‚Äî set to nearest speed coprime with all others";
        psBtn.style.cssText = "font-size:8px;padding:1px 5px;background:transparent;border:1px solid var(--stroke);color:var(--muted);border-radius:3px;cursor:pointer;";
        psBtn.addEventListener("click", () => {
            if (selectedCoeffs.size === 0) return;
            const sInp = barInputs["speed"];
            const cur = parseInt(sInp.value, 10);
            const ps = findPrimeSpeed(cur, new Set(selectedCoeffs));
            if (ps !== cur) {
                sInp.value = ps;
                const vs = barInputs["speed_val"];
                const fm = barInputs["speed_fmt"];
                if (vs && fm) vs.textContent = fm(ps);
                applyBarToSelection();
                uiPing(1320, 0.06);
            } else { uiBuzz(); }
        });
        barDynamic.appendChild(psBtn);
    }
}

// Initialize with "none" (empty)
rebuildBarControls("none");

function toggleCoeffSelect(idx) {
    // If animation is playing and user clicks a coefficient, stop animation
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "‚ñ∂ Play";
    }

    if (selectedCoeffs.has(idx)) {
        selectedCoeffs.delete(idx);
    } else {
        selectedCoeffs.add(idx);
        lastSelectedCoeff = idx;
    }
    updateCoeffSelectionVisual();
    updateAnimBar();
}

function clearCoeffSelection() {
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "‚ñ∂ Play";
    }
    selectedCoeffs.clear();
    updateCoeffSelectionVisual();
    updateAnimBar();
}

function clearRootSelection() {
    selectedRoots.clear();
    updateRootSelectionVisual();
}

function clearAllSelection() {
    clearCoeffSelection();
    clearRootSelection();
}

function updateTransformGroupVisibility() {
    const hasCoeff = selectedCoeffs.size > 0;
    const hasRoot = selectedRoots.size > 0;
    const hasSel = hasCoeff || hasRoot;
    document.getElementById("ops-group").classList.toggle("disabled", !hasSel);
    const t = document.getElementById("ops-target");
    if (!hasSel) {
        t.textContent = "";
        if (typeof closeOpTool === "function") closeOpTool();
    }
    else if (hasCoeff) { t.textContent = "¬∑ coeffs"; t.style.color = "#5ddb6a"; }
    else { t.textContent = "¬∑ roots"; t.style.color = "#e94560"; }
}

function updateCoeffSelectionVisual() {
    coeffLayer.selectAll("circle.coeff")
        .classed("selected", d => selectedCoeffs.has(d._idx));
    const cc = document.getElementById("coeff-sel-count");
    cc.textContent = selectedCoeffs.size > 0 ? `(${selectedCoeffs.size})` : "";
    updateTransformGroupVisibility();
    if (rootColorMode === "derivative") {
        computeRootSensitivities();
        refreshRootColors();
    }
    // Sync list tab checkboxes and curve editor
    if (typeof leftTab !== "undefined" && leftTab === "list") {
        const rows = document.querySelectorAll("#coeff-list-scroll .cpick-row");
        rows.forEach((row, i) => {
            const cb = row.querySelector(".cpick-cb");
            if (cb) cb.classList.toggle("checked", selectedCoeffs.has(i));
        });
        if (typeof refreshListCurveEditor === "function") refreshListCurveEditor();
    }
}

function updateRootSelectionVisual() {
    rootsLayer.selectAll("circle.root")
        .classed("selected", d => selectedRoots.has(d._idx));
    const rc = document.getElementById("roots-sel-count");
    rc.textContent = selectedRoots.size > 0 ? `(${selectedRoots.size})` : "";
    updateTransformGroupVisibility();
}

// --- Marquee (area) selection ---

function installMarqueeSelection(svgSel, getCirclesSel, which) {
    const svgNode = svgSel.node();
    let dragging = false;
    let x0 = 0, y0 = 0;
    let rect = null;

    function begin(event) {
        const t = event.target;
        if (t && t.tagName === "circle") return;
        if (event.button != null && event.button !== 0) return;

        if (which === "coeff") clearRootSelection();
        else clearCoeffSelection();

        dragging = true;
        const p = d3.pointer(event, svgNode);
        x0 = p[0]; y0 = p[1];

        rect = svgSel.append("rect")
            .attr("class", "sel-rect")
            .attr("x", x0).attr("y", y0)
            .attr("width", 0).attr("height", 0);
        event.preventDefault();
    }

    function move(event) {
        if (!dragging || !rect) return;
        const p = d3.pointer(event, svgNode);
        const x1 = p[0], y1 = p[1];
        rect.attr("x", Math.min(x0, x1)).attr("y", Math.min(y0, y1))
            .attr("width", Math.abs(x1 - x0)).attr("height", Math.abs(y1 - y0));
        event.preventDefault();
    }

    function end() {
        if (!dragging) return;
        dragging = false;
        if (!rect) return;

        const x = +rect.attr("x"), y = +rect.attr("y");
        const w = +rect.attr("width"), h = +rect.attr("height");
        rect.remove();
        rect = null;

        if (w < 3 || h < 3) return;

        const xMax = x + w, yMax = y + h;
        getCirclesSel().each(function(d) {
            const cx = +this.getAttribute("cx");
            const cy = +this.getAttribute("cy");
            if (cx >= x && cx <= xMax && cy >= y && cy <= yMax) {
                if (which === "coeff") {
                    selectedCoeffs.add(d._idx);
                    lastSelectedCoeff = d._idx;
                } else {
                    selectedRoots.add(d._idx);
                }
            }
        });

        if (which === "coeff") {
            updateCoeffSelectionVisual();
            updateAnimBar();
        } else {
            updateRootSelectionVisual();
        }
    }

    svgSel.on("mousedown.marquee", begin);
    window.addEventListener("mousemove", move, { passive: false });
    window.addEventListener("mouseup", end, { passive: false });
}

// --- Coefficient right-click context menu ---

let ctxCoeffIdx = -1;
let ctxSnapshot = null; // snapshot for reverting on cancel: { pathsCopy, curveCopy }
let ctxQuadrant = 0;    // 0=BR, 1=BL, 2=TL, 3=TR ‚Äî cycles on reposition button

function closeCoeffCtx(revert) {
    document.getElementById("coeff-ctx").classList.remove("open");
    if (revert && ctxSnapshot) {
        const c = coefficients[ctxCoeffIdx];
        c.pathType = ctxSnapshot.pathType;
        c.radius = ctxSnapshot.radius;
        c.speed = ctxSnapshot.speed;
        c.angle = ctxSnapshot.angle;
        c.ccw = ctxSnapshot.ccw;
        c.extra = ctxSnapshot.extra || {};
        c.curve = ctxSnapshot.curve;
        updateAnimBar();
        renderCoeffTrails();
    }
    ctxCoeffIdx = -1;
    ctxSnapshot = null;
}

function openCoeffCtx(event, coeffIdx) {
    event.preventDefault();
    if (ctxCoeffIdx >= 0) closeCoeffCtx(false); // close previous without revert
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeAudioPop === "function") closeAudioPop();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeColorPop === "function") closeColorPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();

    ctxCoeffIdx = coeffIdx;

    // Snapshot current state for cancel/revert
    const cc = coefficients[coeffIdx];
    ctxSnapshot = {
        pathType: cc.pathType, radius: cc.radius, speed: cc.speed,
        angle: cc.angle, ccw: cc.ccw, extra: cc.extra ? { ...cc.extra } : {},
        curve: cc.curve ? cc.curve.map(pt => ({ ...pt })) : null,
    };

    const ctx = document.getElementById("coeff-ctx");
    ctx.innerHTML = "";

    const n = coefficients.length;
    const subIdx = n - 1 - coeffIdx;

    // Title with reposition button
    const title = document.createElement("div");
    title.className = "ctx-title";
    const titleText = document.createElement("span");
    titleText.textContent = `c${subscript(subIdx)} trajectory`;
    title.appendChild(titleText);
    const moveBtn = document.createElement("button");
    moveBtn.className = "ctx-move";
    moveBtn.textContent = "\u21BB"; // ‚Üª
    moveBtn.title = "Move menu to another quadrant";
    moveBtn.addEventListener("click", () => {
        ctxQuadrant = (ctxQuadrant + 1) % 4;
        repositionCtx(coeffIdx);
    });
    title.appendChild(moveBtn);
    ctx.appendChild(title);

    // Pre-fill from coefficient's trajectory settings
    const existing = cc;

    // Path type select (clone options from #anim-path)
    const pathSel = document.createElement("select");
    pathSel.innerHTML = document.getElementById("anim-path").innerHTML;
    pathSel.value = existing.pathType;
    const pathRow = document.createElement("label");
    pathRow.textContent = "Path ";
    pathRow.appendChild(pathSel);
    ctx.appendChild(pathRow);

    // Dynamic controls container
    const ctxDynamic = document.createElement("div");
    ctx.appendChild(ctxDynamic);
    const ctxInputs = {};

    function buildCtxControls(pathType) {
        ctxDynamic.innerHTML = "";
        for (const k in ctxInputs) delete ctxInputs[k];
        const schema = PATH_PARAMS[pathType] || [];
        const c = coefficients[coeffIdx];
        for (const p of schema) {
            const val = getCoeffParam(c, p.key, p);
            if (p.type === "toggle") {
                const dirRow = document.createElement("div");
                dirRow.className = "ctx-row";
                const btn = document.createElement("button");
                btn.className = "ctx-dir" + (val ? " active" : "");
                btn.textContent = val ? p.labels[1] : p.labels[0];
                btn.addEventListener("click", () => {
                    const isActive = !btn.classList.contains("active");
                    btn.classList.toggle("active", isActive);
                    btn.textContent = isActive ? p.labels[1] : p.labels[0];
                    previewCtx();
                });
                dirRow.appendChild(btn);
                ctxDynamic.appendChild(dirRow);
                ctxInputs[p.key] = btn;
            } else {
                const row = document.createElement("label");
                const uiVal = p.toUI ? p.toUI(val) : val;
                const valSpan = document.createElement("span");
                valSpan.className = "ctx-val";
                valSpan.textContent = p.fmt(uiVal);
                const inp = document.createElement("input");
                inp.type = "range"; inp.min = p.min; inp.max = p.max; inp.step = p.step; inp.value = uiVal;
                inp.addEventListener("input", () => {
                    valSpan.textContent = p.fmt(parseFloat(inp.value));
                    previewCtx();
                });
                row.textContent = p.label + " ";
                row.appendChild(inp);
                row.appendChild(valSpan);
                ctxDynamic.appendChild(row);
                ctxInputs[p.key] = inp;
            }
        }
    }

    buildCtxControls(existing.pathType);

    // Rebuild controls when path type changes in context menu
    pathSel.addEventListener("change", () => {
        buildCtxControls(pathSel.value);
        previewCtx();
    });

    // PS (prime speed) + Accept buttons row
    const ctxBtnRow = document.createElement("div");
    ctxBtnRow.style.cssText = "display:flex;gap:6px;align-items:center;justify-content:center;margin-top:4px;";
    const ctxPsBtn = document.createElement("button");
    ctxPsBtn.className = "ctx-accept";
    ctxPsBtn.textContent = "PS";
    ctxPsBtn.title = "Prime Speed ‚Äî set to nearest speed coprime with all others";
    ctxPsBtn.style.cssText = "padding:4px 8px;background:transparent;border:1px solid var(--stroke);color:var(--muted);";
    ctxPsBtn.addEventListener("click", () => {
        const sInp = ctxInputs["speed"];
        if (!sInp) return;
        const cur = parseInt(sInp.value, 10);
        const ps = findPrimeSpeed(cur, new Set([coeffIdx]));
        if (ps !== cur) {
            sInp.value = ps;
            const vs = sInp.parentElement.querySelector(".ctx-val");
            if (vs) vs.textContent = _P.speed.fmt(ps);
            previewCtx();
            uiPing(1320, 0.06);
        } else { uiBuzz(); }
    });
    ctxBtnRow.appendChild(ctxPsBtn);
    const acceptBtn = document.createElement("button");
    acceptBtn.className = "ctx-accept";
    acceptBtn.textContent = "Accept";
    acceptBtn.addEventListener("click", () => {
        ctxSnapshot = null; // discard snapshot ‚Äî keep current state
        closeCoeffCtx(false);
    });
    ctxBtnRow.appendChild(acceptBtn);
    ctx.appendChild(ctxBtnRow);

    // Live preview helper ‚Äî applies current menu settings immediately
    function previewCtx() {
        const c = coefficients[coeffIdx];
        c.pathType = pathSel.value;
        const schema = PATH_PARAMS[c.pathType] || [];
        for (const p of schema) {
            if (p.type === "toggle") {
                setCoeffParam(c, p.key, ctxInputs[p.key] ? ctxInputs[p.key].classList.contains("active") : p.default);
            } else {
                const ctxRaw = ctxInputs[p.key] ? parseFloat(ctxInputs[p.key].value) : null;
                setCoeffParam(c, p.key, ctxRaw !== null ? (p.fromUI ? p.fromUI(ctxRaw) : ctxRaw) : p.default);
            }
        }

        if (c.pathType === "none") {
            c.curve = null;
        } else {
            const absRadius = c.radius / 100 * coeffExtent();
            c.curve = computeCurve(c.re, c.im, c.pathType, absRadius, c.angle, c.extra);
        }

        animState.elapsedAtPause = null;
        updateAnimBar();
        renderCoeffTrails();
    }

    // Also preview on path type change
    pathSel.addEventListener("change", previewCtx);

    // Show and position relative to coefficient dot
    ctx.classList.add("open");
    ctxQuadrant = 0; // reset to bottom-right on open
    repositionCtx(coeffIdx);
}

function repositionCtx(coeffIdx) {
    const ctx = document.getElementById("coeff-ctx");
    const c = coefficients[coeffIdx];
    // Get the coefficient's screen position from the SVG scale
    const sx = cxs()(c.re), sy = cys()(c.im);
    const svgRect = coeffSvg.node().getBoundingClientRect();
    const cx = svgRect.left + sx, cy = svgRect.top + sy;
    const GAP = 14;
    const rect = ctx.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const vw = window.innerWidth, vh = window.innerHeight;
    // Quadrant offsets: 0=BR, 1=BL, 2=TL, 3=TR
    const offsets = [
        { left: cx + GAP,     top: cy + GAP },
        { left: cx - w - GAP, top: cy + GAP },
        { left: cx - w - GAP, top: cy - h - GAP },
        { left: cx + GAP,     top: cy - h - GAP },
    ];
    let pos = offsets[ctxQuadrant];
    // Clamp to viewport
    pos.left = Math.max(4, Math.min(pos.left, vw - w - 4));
    pos.top  = Math.max(4, Math.min(pos.top,  vh - h - 4));
    ctx.style.left = pos.left + "px";
    ctx.style.top  = pos.top  + "px";
}

// --- Per-coefficient trajectory management ---

function coeffListLabel(coeffSet) {
    const n = coefficients.length;
    const sorted = [...coeffSet].sort((a, b) => a - b);
    if (sorted.length <= 4) {
        return sorted.map(i => `c${subscript(n - 1 - i)}`).join(' ');
    }
    return `${sorted.length} coeffs`;
}

function allAnimatedCoeffs() {
    const s = new Set();
    for (let i = 0; i < coefficients.length; i++) {
        if (coefficients[i].pathType !== "none") s.add(i);
    }
    return s;
}

function syncBarFromCoeff() {
    if (lastSelectedCoeff < 0 || !selectedCoeffs.has(lastSelectedCoeff)) {
        if (selectedCoeffs.size > 0) lastSelectedCoeff = [...selectedCoeffs][0];
        else return;
    }
    const c = coefficients[lastSelectedCoeff];
    barTitle.textContent = coeffListLabel(selectedCoeffs);
    animPathSel.value = c.pathType;
    rebuildBarControls(c.pathType);
    const schema = PATH_PARAMS[c.pathType] || [];
    for (const p of schema) {
        const val = getCoeffParam(c, p.key, p);
        if (p.type === "toggle") {
            const btn = barInputs[p.key];
            if (btn) { btn.textContent = val ? p.labels[1] : p.labels[0]; btn.classList.toggle("active", !!val); }
        } else {
            const inp = barInputs[p.key];
            if (inp) { const uiVal = p.toUI ? p.toUI(val) : val; inp.value = uiVal; const vs = barInputs[p.key + "_val"]; const fm = barInputs[p.key + "_fmt"]; if (vs && fm) vs.textContent = fm(uiVal); }
        }
    }
}

function readBarParams(pathType) {
    const schema = PATH_PARAMS[pathType] || [];
    const vals = {};
    for (const p of schema) {
        if (p.type === "toggle") {
            vals[p.key] = barInputs[p.key] ? barInputs[p.key].classList.contains("active") : p.default;
        } else {
            const raw = barInputs[p.key] ? parseFloat(barInputs[p.key].value) : null;
            vals[p.key] = raw !== null ? (p.fromUI ? p.fromUI(raw) : raw) : p.default;
        }
    }
    return vals;
}

function applyBarToSelection() {
    if (selectedCoeffs.size === 0) return;
    const pt = animPathSel.value;
    rebuildBarControls(pt);
    const vals = readBarParams(pt);

    for (const idx of selectedCoeffs) {
        const c = coefficients[idx];
        const oldType = c.pathType, oldR = c.radius, oldA = c.angle;
        const oldExtra = c.extra ? { ...c.extra } : {};

        // Write all params
        c.pathType = pt;
        const schema = PATH_PARAMS[pt] || [];
        for (const p of schema) setCoeffParam(c, p.key, vals[p.key] !== undefined ? vals[p.key] : p.default);

        const r = c.radius, a = c.angle;
        // Determine if extra params changed
        let extraChanged = false;
        for (const p of schema) {
            if (!_STD_KEYS.has(p.key) && c.extra[p.key] !== oldExtra[p.key]) { extraChanged = true; break; }
        }

        if (pt === "none") {
            c.curve = null;
            animState.elapsedAtPause = null;
        } else if (pt === "random" || pt !== oldType || extraChanged) {
            const absR = r / 100 * coeffExtent();
            c.curve = computeCurve(c.re, c.im, pt, absR, a, c.extra);
            animState.elapsedAtPause = null;
        } else if (r !== oldR || a !== oldA) {
            transformCoeffCurve(c, oldR, oldA);
        }
    }

    coeffLayer.selectAll("circle.coeff")
        .filter(cd => selectedCoeffs.has(cd._idx))
        .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
    coeffLayer.selectAll(".coeff-label")
        .filter(ld => selectedCoeffs.has(ld._idx))
        .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);

    renderCoeffTrails();
    if (typeof leftTab !== "undefined" && leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
}

function transformCoeffCurve(c, oldRadius, oldAngle) {
    if (!c.curve) return;
    // For cloud (random) or orbital (spiral) paths, regenerate instead of transforming
    if (c.curve._isCloud || c.curve._isOrbital) {
        const absR = c.radius / 100 * coeffExtent();
        c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
        return;
    }
    const home = c.curve[0];
    const newRadius = c.radius;
    const newAngle = c.angle;
    const absOld = oldRadius / 100 * coeffExtent();
    const absNew = newRadius / 100 * coeffExtent();
    const scale = absOld > 1e-12 ? absNew / absOld : 1;
    const dAngle = (newAngle - oldAngle) * 2 * Math.PI;
    const cosD = Math.cos(dAngle), sinD = Math.sin(dAngle);
    for (let k = 0; k < c.curve.length; k++) {
        let dx = c.curve[k].re - home.re, dy = c.curve[k].im - home.im;
        dx *= scale; dy *= scale;
        c.curve[k].re = home.re + dx * cosD - dy * sinD;
        c.curve[k].im = home.im + dx * sinD + dy * cosD;
    }
    // Snap coefficient to nearest curve point
    let bestD = Infinity, bestK = 0;
    for (let k = 0; k < c.curve.length; k++) {
        const dx = c.re - c.curve[k].re, dy = c.im - c.curve[k].im;
        const d = dx * dx + dy * dy;
        if (d < bestD) { bestD = d; bestK = k; }
    }
    c.re = c.curve[bestK].re;
    c.im = c.curve[bestK].im;
}

function updateAnimBar() {
    if (selectedCoeffs.size === 0) {
        barTitle.textContent = "<no selection>";
        barTitle.classList.add("empty");
        barControls.classList.add("dimmed");
        sel2pathBtn.disabled = true;
        return;
    }
    barTitle.classList.remove("empty");
    barControls.classList.remove("dimmed");
    sel2pathBtn.disabled = false;
    syncBarFromCoeff();
}

// Path dropdown change ‚Äî rebuild controls and apply
animPathSel.addEventListener("change", function () {
    rebuildBarControls(this.value);
    applyBarToSelection();
});

// Update Selection button
sel2pathBtn.addEventListener("click", applyBarToSelection);

// Play/Pause button
playBtn.addEventListener("click", function () {
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "‚ñ∂ Play";
    } else {
        if (allAnimatedCoeffs().size === 0) return;
        const resuming = animState.elapsedAtPause != null;
        if (trailsEnabled && !resuming) {
            trailData = [];
            trailComplete = false;
            trailLayer.selectAll("path.trail-path").remove();
        }
        // Always reset loop-complete flag so trail recording continues.
        // The Trails button being ON means trails are collected ‚Äî unconditionally.
        if (trailsEnabled) trailComplete = false;
        startAnimation();
        renderCoeffTrails();
        playBtn.textContent = "‚è∏ Pause";
    }
});

// Home button: reset coefficients to their curve[0] (start) positions
document.getElementById("home-btn").addEventListener("click", function () {
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "‚ñ∂ Play";
    }
    animState.elapsedAtPause = null;
    for (let i = 0; i < coefficients.length; i++) {
        const c = coefficients[i];
        if (c.curve) { c.re = c.curve[0].re; c.im = c.curve[0].im; }
    }
    const animated = allAnimatedCoeffs();
    coeffLayer.selectAll("circle.coeff")
        .filter(cd => animated.has(cd._idx))
        .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
    coeffLayer.selectAll(".coeff-label")
        .filter(ld => animated.has(ld._idx))
        .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);
    if (trailsEnabled) {
        trailData = [];
        trailComplete = false;
        trailLayer.selectAll("path.trail-path").remove();
    }
    resetAudioState();
    resetBitmap();
    clearStatsData();
    renderCoeffTrails();
    autoScaleCoeffPanel();
    solveRootsThrottled();
    renderDomainColoringThrottled();
});

// Trails toggle button
trailsBtn.addEventListener("click", function () {
    trailsEnabled = !trailsEnabled;
    this.classList.toggle("active", trailsEnabled);
    clearTrails();
    renderCoeffTrails();
});

// --- Path functions ---

function animPathFn(name, t, center, radius, extra) {
    const w = 2 * Math.PI; // one full cycle per second (scaled by speed)
    const wt = w * t;
    switch (name) {
        case "circle":
            return { re: center.re + radius * Math.cos(wt), im: center.im + radius * Math.sin(wt) };
        case "horizontal":
            return { re: center.re + radius * Math.cos(wt), im: center.im };
        case "vertical":
            return { re: center.re, im: center.im + radius * Math.cos(wt) };
        case "spiral":
            // Orbital spiral ‚Äî handled directly in computeCurve
            return center;
        case "figure8": {
            const d = 1 + Math.sin(wt) * Math.sin(wt);
            return {
                re: center.re + radius * Math.cos(wt) / d,
                im: center.im + radius * Math.sin(wt) * Math.cos(wt) / d
            };
        }
        case "lissajous": {
            const la = (extra && extra.freqA) || 3;
            const lb = (extra && extra.freqB) || 2;
            return {
                re: center.re + radius * Math.sin(la * wt + Math.PI / 4),
                im: center.im + radius * Math.sin(lb * wt)
            };
        }
        case "cardioid": {
            // r_polar = 0.5*(1 + cos(Œ∏)), parametric
            const s = 0.5 * (1 + Math.cos(wt));
            return {
                re: center.re + radius * s * Math.cos(wt),
                im: center.im + radius * s * Math.sin(wt)
            };
        }
        case "astroid":
            // Hypocycloid with 4 cusps: cos¬≥, sin¬≥
            return {
                re: center.re + radius * Math.cos(wt) * Math.cos(wt) * Math.cos(wt),
                im: center.im + radius * Math.sin(wt) * Math.sin(wt) * Math.sin(wt)
            };
        case "deltoid":
            // Hypocycloid with 3 cusps
            return {
                re: center.re + radius * (2 * Math.cos(wt) + Math.cos(2 * wt)) / 3,
                im: center.im + radius * (2 * Math.sin(wt) - Math.sin(2 * wt)) / 3
            };
        case "rose": {
            // 3-petal rose r = cos(3Œ∏)
            const rr = radius * Math.cos(3 * wt);
            return {
                re: center.re + rr * Math.cos(wt),
                im: center.im + rr * Math.sin(wt)
            };
        }
        case "epitrochoid":
            // Spirograph: R=3, r=1, d=1 ‚Üí 3-lobed, scaled to fit radius
            return {
                re: center.re + radius * (4 * Math.cos(wt) - Math.cos(4 * wt)) / 5,
                im: center.im + radius * (4 * Math.sin(wt) - Math.sin(4 * wt)) / 5
            };
        case "hypotrochoid":
            // Spirograph inner: R=5, r=2, d=1 ‚Üí 5-lobed
            return {
                re: center.re + radius * (3 * Math.cos(wt) + Math.cos(1.5 * wt)) / 4,
                im: center.im + radius * (3 * Math.sin(wt) - Math.sin(1.5 * wt)) / 4
            };
        case "butterfly": {
            // Butterfly curve (polar)
            const rb = Math.exp(Math.cos(wt)) - 2 * Math.cos(4 * wt) + Math.pow(Math.sin(wt / 12), 5);
            const scale = radius / 3.5; // normalize to roughly fit radius
            return {
                re: center.re + scale * rb * Math.cos(wt),
                im: center.im + scale * rb * Math.sin(wt)
            };
        }
        case "star": {
            // 5-pointed star (pentagram) via inner/outer radius alternation
            // 10 vertices: 5 outer, 5 inner, linearly interpolated
            const period = wt / (2 * Math.PI); // 0..1 per cycle
            const seg = ((period % 1) + 1) % 1; // normalized 0..1
            const idx = seg * 10;
            const vi = Math.floor(idx) % 10;
            const frac = idx - Math.floor(idx);
            const angle1 = (vi / 10) * 2 * Math.PI - Math.PI / 2;
            const angle2 = ((vi + 1) / 10) * 2 * Math.PI - Math.PI / 2;
            const r1 = (vi % 2 === 0) ? radius : radius * 0.38;
            const r2 = ((vi + 1) % 2 === 0) ? radius : radius * 0.38;
            return {
                re: center.re + r1 * Math.cos(angle1) * (1 - frac) + r2 * Math.cos(angle2) * frac,
                im: center.im + r1 * Math.sin(angle1) * (1 - frac) + r2 * Math.sin(angle2) * frac
            };
        }
        case "square": {
            // Square path, one full cycle
            const period = wt / (2 * Math.PI);
            const seg = ((period % 1) + 1) % 1; // 0..1
            let x, y;
            if (seg < 0.25)      { const f = seg / 0.25;       x =  1 - 2*f; y =  1; }
            else if (seg < 0.5)  { const f = (seg-0.25) / 0.25; x = -1;       y =  1 - 2*f; }
            else if (seg < 0.75) { const f = (seg-0.5) / 0.25;  x = -1 + 2*f; y = -1; }
            else                 { const f = (seg-0.75) / 0.25;  x =  1;       y = -1 + 2*f; }
            return { re: center.re + radius * x, im: center.im + radius * y };
        }
        case "hilbert": {
            // Moore curve (closed Hilbert variant) ‚Äî order 4, 256 segments
            const ORDER_H = 4, N_H = 1 << (2 * ORDER_H); // 256
            const seg_h = ((((wt / (2 * Math.PI)) % 1) + 1) % 1) * N_H;
            const i0_h = Math.floor(seg_h) % N_H, i1_h = (i0_h + 1) % N_H;
            const fr_h = seg_h - Math.floor(seg_h);
            const p0_h = _mooreXY(i0_h, ORDER_H), p1_h = _mooreXY(i1_h, ORDER_H);
            return {
                re: center.re + radius * (p0_h[0] * (1 - fr_h) + p1_h[0] * fr_h),
                im: center.im + radius * (p0_h[1] * (1 - fr_h) + p1_h[1] * fr_h)
            };
        }
        case "peano": {
            // Peano curve (out-and-back for closure) ‚Äî order 3, 729 points (1458 total with out-and-back)
            const ORDER_P = 3, N_P = Math.pow(3, 2 * ORDER_P); // 729 points
            const TOTAL_P = N_P * 2; // out and back
            const seg_p = ((((wt / (2 * Math.PI)) % 1) + 1) % 1) * TOTAL_P;
            let idx_p;
            if (seg_p < N_P) {
                idx_p = Math.floor(seg_p) % N_P;
            } else {
                idx_p = N_P - 1 - (Math.floor(seg_p - N_P) % N_P);
            }
            const idx_p2 = (seg_p < N_P)
                ? (Math.floor(seg_p) + 1 < N_P ? Math.floor(seg_p) + 1 : N_P - 1)
                : (idx_p > 0 ? idx_p - 1 : 0);
            const fr_p = seg_p - Math.floor(seg_p);
            const p0_p = _peanoXY(idx_p, ORDER_P), p1_p = _peanoXY(idx_p2, ORDER_P);
            return {
                re: center.re + radius * (p0_p[0] * (1 - fr_p) + p1_p[0] * fr_p),
                im: center.im + radius * (p0_p[1] * (1 - fr_p) + p1_p[1] * fr_p)
            };
        }
        case "sierpinski": {
            // Sierpinski arrowhead ‚Äî order 5, 243 segments, out-and-back for closure
            const ORDER_S = 5, N_S = Math.pow(3, ORDER_S); // 243 points
            const TOTAL_S = N_S * 2; // out and back
            const seg_s = ((((wt / (2 * Math.PI)) % 1) + 1) % 1) * TOTAL_S;
            let idx_s, idx_s2;
            if (seg_s < N_S) {
                idx_s = Math.floor(seg_s) % N_S;
                idx_s2 = Math.min(idx_s + 1, N_S - 1);
            } else {
                idx_s = N_S - 1 - (Math.floor(seg_s - N_S) % N_S);
                idx_s2 = Math.max(idx_s - 1, 0);
            }
            const fr_s = seg_s - Math.floor(seg_s);
            const p0_s = _sierpinskiXY(idx_s, ORDER_S), p1_s = _sierpinskiXY(idx_s2, ORDER_S);
            return {
                re: center.re + radius * (p0_s[0] * (1 - fr_s) + p1_s[0] * fr_s),
                im: center.im + radius * (p0_s[1] * (1 - fr_s) + p1_s[1] * fr_s)
            };
        }
        case "random": {
            // Pre-generated Gaussian cloud ‚Äî return the same point for a given t
            // (actual generation happens in computeCurve; animPathFn just places a point at center)
            return { re: center.re, im: center.im };
        }
        default:
            return center;
    }
}

// --- Space-filling curve helpers ---

// Moore curve (closed Hilbert variant) via L-system turtle ‚Äî guarantees continuous path
// Axiom: LFL+F+LFL, L ‚Üí -RF+LFL+FR-, R ‚Üí +LF-RFR-FL+
// + = turn right (CW), - = turn left (CCW)
function _mooreXY(d, order) {
    if (!_mooreXY._cache || _mooreXY._order !== order) {
        // Expand L-system string
        let str = "LFL+F+LFL";
        for (let i = 0; i < order - 1; i++) {
            let next = "";
            for (const ch of str) {
                if (ch === 'L') next += "-RF+LFL+FR-";
                else if (ch === 'R') next += "+LF-RFR-FL+";
                else next += ch;
            }
            str = next;
        }
        // Walk turtle ‚Äî start facing up, + = CW, - = CCW
        const dx = [1, 0, -1, 0], dy = [0, 1, 0, -1];
        let x = 0, y = 0, angle = 1; // 1 = up
        let minX = 0, maxX = 0, minY = 0, maxY = 0;
        const raw = [[0, 0]];
        for (const ch of str) {
            if (ch === 'F') {
                x += dx[angle]; y += dy[angle];
                raw.push([x, y]);
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
            } else if (ch === '+') {
                angle = (angle + 3) % 4; // CW
            } else if (ch === '-') {
                angle = (angle + 1) % 4; // CCW
            }
        }
        // Normalize to [-1, 1]
        const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
        const span = Math.max(maxX - minX, maxY - minY) || 1;
        _mooreXY._cache = raw.map(([px, py]) => [2 * (px - cx) / span, 2 * (py - cy) / span]);
        _mooreXY._order = order;
    }
    const pts = _mooreXY._cache;
    return pts[((d % pts.length) + pts.length) % pts.length];
}
// Peano curve via L-system turtle ‚Äî guarantees continuous path
// Axiom: L, L ‚Üí LFRFL-F-RFLFR+F+LFRFL, R ‚Üí RFLFR+F+LFRFL-F-RFLFR
function _peanoXY(d, order) {
    if (!_peanoXY._cache || _peanoXY._order !== order) {
        let str = "L";
        for (let i = 0; i < order; i++) {
            let next = "";
            for (const ch of str) {
                if (ch === 'L') next += "LFRFL-F-RFLFR+F+LFRFL";
                else if (ch === 'R') next += "RFLFR+F+LFRFL-F-RFLFR";
                else next += ch;
            }
            str = next;
        }
        const dx = [1, 0, -1, 0], dy = [0, 1, 0, -1];
        let x = 0, y = 0, angle = 0; // start facing right
        let minX = 0, maxX = 0, minY = 0, maxY = 0;
        const raw = [[0, 0]];
        for (const ch of str) {
            if (ch === 'F') {
                x += dx[angle]; y += dy[angle];
                raw.push([x, y]);
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
            } else if (ch === '+') {
                angle = (angle + 3) % 4; // CW
            } else if (ch === '-') {
                angle = (angle + 1) % 4; // CCW
            }
        }
        const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
        const span = Math.max(maxX - minX, maxY - minY) || 1;
        _peanoXY._cache = raw.map(([px, py]) => [2 * (px - cx) / span, 2 * (py - cy) / span]);
        _peanoXY._order = order;
    }
    const pts = _peanoXY._cache;
    return pts[((d % pts.length) + pts.length) % pts.length];
}

// Sierpinski arrowhead curve via L-system turtle ‚Äî triangle-filling path
// Axiom: A (even order) or B (odd order), A ‚Üí B-A-B, B ‚Üí A+B+A
// + = turn left 60¬∞, - = turn right 60¬∞, F at depth 0
// 3^order segments, NOT naturally closed ‚Äî animation uses out-and-back
function _sierpinskiXY(d, order) {
    if (!_sierpinskiXY._cache || _sierpinskiXY._order !== order) {
        const n = Math.pow(3, order); // 3^order segments
        let moves = "";
        function expand(ch, depth) {
            if (depth === 0) { moves += "F"; return; }
            if (ch === "A") {
                expand("B", depth - 1); moves += "-";
                expand("A", depth - 1); moves += "-";
                expand("B", depth - 1);
            } else {
                expand("A", depth - 1); moves += "+";
                expand("B", depth - 1); moves += "+";
                expand("A", depth - 1);
            }
        }
        expand(order % 2 === 0 ? "A" : "B", order);
        let angle = 0;
        if (order % 2 === 1) angle = 1;
        let x = 0, y = 0;
        let minX = 0, maxX = 0, minY = 0, maxY = 0;
        const raw = [[0, 0]];
        for (const ch of moves) {
            if (ch === "F") {
                const a = angle * Math.PI / 3;
                x += Math.cos(a); y += Math.sin(a);
                raw.push([x, y]);
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
            } else if (ch === "+") {
                angle = (angle + 1) % 6;
            } else if (ch === "-") {
                angle = ((angle - 1) % 6 + 6) % 6;
            }
        }
        const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
        const span = Math.max(maxX - minX, maxY - minY) || 1;
        _sierpinskiXY._cache = raw.map(([px, py]) => [2 * (px - cx) / span, 2 * (py - cy) / span]);
        _sierpinskiXY._order = order;
        _sierpinskiXY._n = n; // number of segments (n+1 points)
    }
    const pts = _sierpinskiXY._cache;
    return pts[((d % pts.length) + pts.length) % pts.length];
}

// --- Animation engine ---

const COEFF_TRAIL_SAMPLES = 200; // points per analytical curve (basic paths)
const COEFF_TRAIL_SAMPLES_HI = 1500; // points for space-filling curves (need more to capture zigzags)
const _HIRES_PATHS = new Set(["hilbert", "peano", "sierpinski", "spiral"]);

// Box-Muller transform for Gaussian random numbers
function _gaussRand() {
    let u, v;
    do { u = Math.random(); } while (u === 0);
    v = Math.random();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}

// Compute a closed curve of absolute positions for a coefficient.
// curve[0] = {homeRe, homeIm} (the "home" position). Angle rotates the shape.
function computeCurve(homeRe, homeIm, pathType, radius, angle, extra) {
    const N = _HIRES_PATHS.has(pathType) ? COEFF_TRAIL_SAMPLES_HI : COEFF_TRAIL_SAMPLES;
    return computeCurveN(homeRe, homeIm, pathType, radius, angle, extra, N);
}

function computeCurveN(homeRe, homeIm, pathType, radius, angle, extra, N) {
    // Random path: pre-generate Gaussian point cloud (no connecting lines)
    if (pathType === "random") {
        const sigma = radius; // already scaled to absolute units by caller
        const curve = new Array(N);
        for (let k = 0; k < N; k++) {
            curve[k] = { re: homeRe + _gaussRand() * sigma,
                          im: homeIm + _gaussRand() * sigma };
        }
        curve._isCloud = true; // flag for rendering as dots
        return curve;
    }

    // Spiral path: orbital around the origin (0+0i)
    // Coefficient spirals from its current orbit to a wider/tighter orbit and back.
    if (pathType === "spiral") {
        const mult = (extra && extra.mult != null) ? extra.mult : 1.5;
        const turns = (extra && extra.turns) || 2;
        const R0 = Math.sqrt(homeRe * homeRe + homeIm * homeIm);
        const theta0 = Math.atan2(homeIm, homeRe);
        const R1 = R0 * mult;
        const totalTurns = 2 * turns + 1;
        const t1 = turns / totalTurns;        // end of outward spiral
        const t2 = (turns + 1) / totalTurns;  // end of revolution at target
        const W = 2 * Math.PI;

        const curve = new Array(N);
        for (let k = 0; k < N; k++) {
            const t = k / N;
            let r, theta;
            if (t <= t1) {
                const frac = t1 > 0 ? t / t1 : 0;
                r = R0 + (R1 - R0) * frac;
                theta = theta0 + frac * turns * W;
            } else if (t <= t2) {
                const frac = (t2 > t1) ? (t - t1) / (t2 - t1) : 0;
                r = R1;
                theta = theta0 + (turns + frac) * W;
            } else {
                const frac = (1 > t2) ? (t - t2) / (1 - t2) : 0;
                r = R1 + (R0 - R1) * frac;
                theta = theta0 + (turns + 1 + frac * turns) * W;
            }
            curve[k] = { re: r * Math.cos(theta), im: r * Math.sin(theta) };
        }
        curve._isOrbital = true; // flag: absolute positions, not relative to home
        return curve;
    }

    const origin = { re: 0, im: 0 };
    const d0 = animPathFn(pathType, 0, origin, radius, extra);
    const cosA = Math.cos(angle * 2 * Math.PI);
    const sinA = Math.sin(angle * 2 * Math.PI);
    const curve = new Array(N);
    for (let k = 0; k < N; k++) {
        const t = k / N;
        const pt = animPathFn(pathType, t, origin, radius, extra);
        const dx = pt.re - d0.re, dy = pt.im - d0.im;
        curve[k] = { re: homeRe + dx * cosA - dy * sinA,
                      im: homeIm + dx * sinA + dy * cosA };
    }
    return curve;
}

// Recompute curves using the coefficient's current position as home (curve[0]).
// The coefficient is always on the new path. Angle and radius come from the path settings.
function startAnimation() {
    if (fastModeActive) return;
    const animated = allAnimatedCoeffs();
    if (animated.size === 0) return;

    const resuming = animState.elapsedAtPause != null;

    if (!resuming) {
        for (const idx of animated) {
            const c = coefficients[idx];
            if (c.curve) { c.re = c.curve[0].re; c.im = c.curve[0].im; }
        }
    }

    animState.playing = true;
    if (resuming) {
        animState.startTime = performance.now() - animState.elapsedAtPause * 1000;
        animState.elapsedAtPause = null;
    } else {
        animState.startTime = performance.now();
    }
    animState.rafId = requestAnimationFrame(animLoop);
}

function animLoop(now) {
    if (!animState.playing) return;
    if (fastModeActive) return;
    const elapsed = (now - animState.startTime) / 1000;

    for (let i = 0; i < coefficients.length; i++) {
        const c = coefficients[i];
        if (c.pathType === "none") continue;
        if (c.curve) {
            const N = c.curve.length;
            const t = elapsed * c.speed * (c.ccw ? -1 : 1);
            const rawIdx = ((t % 1) + 1) % 1 * N;
            if (c.curve._isCloud) {
                // Random cloud: snap to nearest point (no interpolation)
                const idx = Math.floor(rawIdx) % N;
                c.re = c.curve[idx].re;
                c.im = c.curve[idx].im;
            } else {
                const lo = Math.floor(rawIdx) % N;
                const hi = (lo + 1) % N;
                const frac = rawIdx - Math.floor(rawIdx);
                c.re = c.curve[lo].re * (1 - frac) + c.curve[hi].re * frac;
                c.im = c.curve[lo].im * (1 - frac) + c.curve[hi].im * frac;
            }
        }
    }

    const animated = allAnimatedCoeffs();
    coeffLayer.selectAll("circle.coeff")
        .filter(cd => animated.has(cd._idx))
        .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
    coeffLayer.selectAll(".coeff-label")
        .filter(ld => animated.has(ld._idx))
        .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);

    autoScaleCoeffPanel();
    solveRootsThrottled();
    renderDomainColoringThrottled();
    recordTick();
    updateListCoords();

    animState.rafId = requestAnimationFrame(animLoop);
}

function stopAnimation() {
    if (animState.playing) {
        animState.elapsedAtPause = (performance.now() - animState.startTime) / 1000;
    }
    animState.playing = false;
    if (animState.rafId) {
        cancelAnimationFrame(animState.rafId);
        animState.rafId = null;
    }
    if (anySoundEnabled()) resetAudioState();
}

// --- Coefficient chain line (shown during any root drag) ---

function updateCoeffChainLine() {
    const xScale = cxs(), yScale = cys();
    const pts = coefficients.map(c => xScale(c.re) + "," + yScale(c.im)).join(" ");
    coeffChainLine.attr("points", pts);
}

// --- Render coefficients ---

function renderCoefficients() {
    // Auto-scale coeff panel to fit all coefficients
    const needed = computeRange(coefficients);
    updatePanelRange(coeffSvg, panels.coeff, needed);

    const n = coefficients.length;
    for (let i = 0; i < n; i++) coefficients[i]._idx = i;

    const circles = coeffLayer.selectAll("circle.coeff").data(coefficients, d => d._idx);

    circles.enter()
        .append("circle")
        .attr("class", "coeff")
        .attr("r", 10)
        .attr("stroke", "#fff")
        .call(drag)
        .on("contextmenu", function(event, d) { openCoeffCtx(event, d._idx); })
        .on("mouseover", function (event, d) { showTooltip(event, d.re, d.im); })
        .on("mouseout", hideTooltip)
      .merge(circles)
        .attr("cx", d => cxs()(d.re))
        .attr("cy", d => cys()(d.im))
        .attr("fill", (_, i) => coeffColor(i, n));

    circles.exit().remove();

    const labels = coeffLayer.selectAll(".coeff-label").data(coefficients, d => d._idx);

    labels.enter()
        .append("text")
        .attr("class", "coeff-label")
      .merge(labels)
        .attr("x", d => cxs()(d.re) + 12)
        .attr("y", d => cys()(d.im) + 4)
        .text((_, i) => `c${subscript(n - 1 - i)}`);

    labels.exit().remove();
}

function subscript(n) {
    const digits = "‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ";
    return String(n).split("").map(d => digits[+d]).join("");
}

// --- Root drag behavior (roots ‚Üí coefficients) ---

let rootDragMoved = false;
let rootDragStartX = 0, rootDragStartY = 0;
const rootDrag = d3.drag()
    .on("start", function (event) {
        rootDragMoved = false;
        rootDragStartX = event.x;
        rootDragStartY = event.y;
        d3.select(this).raise().classed("dragging", true);
    })
    .on("drag", function (event, d) {
        if (!rootDragMoved && Math.hypot(event.x - rootDragStartX, event.y - rootDragStartY) < CLICK_DEAD_ZONE) return;
        rootDragMoved = true;
        const newRe = rxs().invert(event.x);
        const newIm = rys().invert(event.y);
        const idx = d._idx;

        if (selectedRoots.has(idx) && selectedRoots.size > 1) {
            // Group drag: apply delta to all selected roots
            const deltaRe = newRe - d.re;
            const deltaIm = newIm - d.im;
            for (const si of selectedRoots) {
                currentRoots[si].re += deltaRe;
                currentRoots[si].im += deltaIm;
            }
            rootsLayer.selectAll("circle.root")
                .attr("cx", rd => rxs()(rd.re)).attr("cy", rd => rys()(rd.im));
        } else {
            d.re = newRe;
            d.im = newIm;
            d3.select(this).attr("cx", rxs()(d.re)).attr("cy", rys()(d.im));
        }
        showTooltip(event.sourceEvent, d.re, d.im);
        autoScaleRootsPanel();
        // Recompute coefficients from current roots (all client-side)
        const rootsForCoeffs = currentRoots.map(r => ({ re: r.re, im: r.im }));
        const newCoeffs = rootsToCoefficients(rootsForCoeffs);
        // Update coefficient positions in-place, preserving curves and path assignments
        for (let ci = 0; ci < newCoeffs.length; ci++) {
            const deltaRe = newCoeffs[ci].re - coefficients[ci].re;
            const deltaIm = newCoeffs[ci].im - coefficients[ci].im;
            coefficients[ci].re = newCoeffs[ci].re;
            coefficients[ci].im = newCoeffs[ci].im;
            if (coefficients[ci].curve) {
                for (const pt of coefficients[ci].curve) {
                    pt.re += deltaRe;
                    pt.im += deltaIm;
                }
            }
        }
        renderCoefficients();  // auto-scales panel (may change scale)
        renderCoeffTrails();   // must come AFTER scale update
        updateListCoords();
        // Show coefficient chain line during root drag
        coeffChainLine.style("display", null);
        updateCoeffChainLine();
        renderDomainColoringThrottled();
        if (anySoundEnabled()) updateAudio();
    })
    .on("end", function (event, d) {
        coeffChainLine.style("display", "none");
        d3.select(this).classed("dragging", false);
        hideTooltip();
        // Click detection: if mouse didn't move, toggle root selection
        if (!rootDragMoved) {
            const idx = d._idx;
            clearCoeffSelection();
            if (selectedRoots.has(idx)) {
                selectedRoots.delete(idx);
            } else {
                selectedRoots.add(idx);
            }
            updateRootSelectionVisual();
        }
    });

function autoScaleRootsPanel() {
    let needed = computeRange(currentRoots);
    if (animState.playing || (trailsEnabled && trailData.length > 0)) {
        needed = Math.max(needed, panels.roots.range);
    }
    if (needed !== panels.roots.range) {
        updatePanelRange(rootsSvg, panels.roots, needed);
        rootsLayer.selectAll("circle.root")
            .attr("cx", d => rxs()(d.re)).attr("cy", d => rys()(d.im));
        if (trailsEnabled && trailData.length > 0) renderTrails();
    }
}

// --- Render roots ---

function renderRoots(newRoots) {
    // Update persistent root data
    while (currentRoots.length < newRoots.length) currentRoots.push({ re: 0, im: 0 });
    currentRoots.length = newRoots.length;
    for (let i = 0; i < newRoots.length; i++) {
        currentRoots[i].re = newRoots[i].re;
        currentRoots[i].im = newRoots[i].im;
    }

    // Auto-scale roots panel ‚Äî zoom-out only while playing OR trails visible,
    // so pausing never shrinks the range and detaches trails from root dots.
    let needed = computeRange(currentRoots);
    if (animState.playing || (trailsEnabled && trailData.length > 0)) {
        needed = Math.max(needed, panels.roots.range);
    }
    updatePanelRange(rootsSvg, panels.roots, needed);

    const n = currentRoots.length;
    for (let i = 0; i < n; i++) currentRoots[i]._idx = i;

    // Bitmap painting (always runs when active, regardless of which tab is visible)
    if (bitmapActive) paintBitmapFrame();

    // Skip SVG rendering when bitmap tab is active (performance)
    if (activeTab !== "bitmap") {
        renderDomainColoringThrottled();

        if (rootColorMode === "derivative") computeRootSensitivities();

        const circles = rootsLayer.selectAll("circle.root").data(currentRoots, d => d._idx);
        circles.enter()
            .append("circle")
            .attr("class", "root")
            .attr("r", 7)
            .attr("stroke", "#fff")
            .attr("stroke-width", 1)
            .call(rootDrag)
            .on("mouseover", function (event, d) { showTooltip(event, d.re, d.im); })
            .on("mouseout", hideTooltip)
          .merge(circles)
            .attr("cx", d => rxs()(d.re))
            .attr("cy", d => rys()(d.im))
            .attr("fill", (_, i) => rootColor(i, n));

        circles.exit().remove();
    }

    // Collect stats snapshot
    collectStatsSnapshot();
    if (activeTab === "stats" && statsState.dirty) drawAllStatsPlots();

    // Record trail points during animation
    if (trailsEnabled && animState.playing && !trailComplete) {
        // Initialize trail arrays if needed
        while (trailData.length < n) trailData.push([]);
        trailData.length = n;
        for (let i = 0; i < n; i++) {
            trailData[i].push({ re: currentRoots[i].re, im: currentRoots[i].im });
            if (trailData[i].length > MAX_TRAIL_POINTS) trailData[i].shift();
        }
        // Check for loop closure: all roots back near their starting positions
        const len = trailData[0].length;
        if (len > TRAIL_MIN_POINTS) {
            let closed = true;
            for (let i = 0; i < n; i++) {
                const start = trailData[i][0];
                const cur = trailData[i][len - 1];
                const dist = Math.hypot(cur.re - start.re, cur.im - start.im);
                if (dist > panels.roots.range * 0.01) { closed = false; break; }
            }
            if (closed) {
                trailComplete = true;
                if (vidRec.recording) stopRecording();
            }
        }
    }
    // Always re-render trails when data exists ‚Äî ensures coherence after
    // pause (the pending throttled solve fires with playing=false).
    if (trailsEnabled && trailData.length > 0 && activeTab !== "bitmap") {
        renderTrails();
    }


    if (anySoundEnabled()) updateAudio();
}

function renderTrails() {
    const xScale = rxs(), yScale = rys();
    const n = trailData.length;
    const jumpThresh = panels.roots.range * 0.3; // 30% of visible range = likely a root swap
    const paths = trailLayer.selectAll("path.trail-path").data(trailData);
    paths.enter()
        .append("path")
        .attr("class", "trail-path")
      .merge(paths)
        .attr("d", pts => {
            if (pts.length < 2) return "";
            let d = `M${xScale(pts[0].re)},${yScale(pts[0].im)}`;
            for (let j = 1; j < pts.length; j++) {
                const dist = Math.hypot(pts[j].re - pts[j-1].re, pts[j].im - pts[j-1].im);
                const cmd = dist > jumpThresh ? "M" : "L";
                d += `${cmd}${xScale(pts[j].re)},${yScale(pts[j].im)}`;
            }
            return d;
        })
        .attr("stroke", (_, i) => rootColor(i, n));
    paths.exit().remove();
}

function renderCoeffTrails() {
    // Draw the absolute curve points for each coefficient that has a curve.
    const xScale = cxs(), yScale = cys();
    const lineData = [];
    const cloudData = [];

    for (let i = 0; i < coefficients.length; i++) {
        const c = coefficients[i];
        if (c.pathType === "none" || !c.curve) continue;
        if (c.curve._isCloud) cloudData.push({ idx: i });
        else lineData.push({ idx: i });
    }

    const nCoeff = coefficients.length;

    // Line paths (closed curves)
    const paths = coeffTrailLayer.selectAll("path.trail-path").data(lineData, d => d.idx);
    paths.enter()
        .append("path")
        .attr("class", "trail-path")
      .merge(paths)
        .attr("d", ({ idx }) => {
            const curve = coefficients[idx].curve;
            const N = curve.length;
            let d = "";
            for (let k = 0; k <= N; k++) {
                const pt = curve[k % N];
                d += (k === 0 ? "M" : "L") + xScale(pt.re) + "," + yScale(pt.im);
            }
            return d + "Z";
        })
        .attr("stroke", ({ idx }) => coeffColor(idx, nCoeff));
    paths.exit().remove();

    // Dot clouds (random/Gaussian paths)
    const clouds = coeffTrailLayer.selectAll("g.trail-cloud").data(cloudData, d => d.idx);
    const cloudEnter = clouds.enter().append("g").attr("class", "trail-cloud");
    const cloudMerge = cloudEnter.merge(clouds);
    cloudMerge.each(function({ idx }) {
        const curve = coefficients[idx].curve;
        const color = coeffColor(idx, nCoeff);
        const g = d3.select(this);
        const dots = g.selectAll("circle").data(curve);
        dots.enter().append("circle")
            .attr("r", 1.5)
            .attr("fill", color)
            .attr("opacity", 0.5)
          .merge(dots)
            .attr("cx", d => xScale(d.re))
            .attr("cy", d => yScale(d.im));
        dots.exit().remove();
    });
    clouds.exit().remove();
}

function clearTrails() {
    trailData = [];
    trailComplete = false;
    trailLayer.selectAll("path.trail-path").remove();
    // Coefficient paths are always visible ‚Äî don't clear them here
}


// --- Domain coloring ---

function hueToChannel(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1/6) return p + (q - p) * 6 * t;
    if (t < 1/2) return q;
    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
    return p;
}

function hslToRgb(h, s, l) {
    if (s === 0) return [Math.round(l * 255), Math.round(l * 255), Math.round(l * 255)];
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return [
        Math.round(hueToChannel(p, q, h + 1/3) * 255),
        Math.round(hueToChannel(p, q, h) * 255),
        Math.round(hueToChannel(p, q, h - 1/3) * 255)
    ];
}

function renderDomainColoring() {
    if (!domainColoringEnabled) return;

    const range = panels.roots.range;
    // Measure actual SVG position to align canvas precisely
    // (SVG may be centered by text-align:center, shifted by border, etc.)
    const svgEl = document.getElementById("roots-panel");
    const container = document.getElementById("roots-container");
    const svgRect = svgEl.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    const borderW = parseFloat(getComputedStyle(svgEl).borderLeftWidth) || 0;
    const contentW = svgRect.width - 2 * borderW;
    const vbScale = contentW / S; // viewBox units ‚Üí CSS pixels
    const plotSize = (S - 2 * MARGIN) * vbScale;
    const plotLeft = (svgRect.left - containerRect.left) + borderW + MARGIN * vbScale;
    const plotTop = (svgRect.top - containerRect.top) + borderW + MARGIN * vbScale;
    const dpr = window.devicePixelRatio || 1;
    const canvasW = Math.max(1, Math.floor(plotSize * DOMAIN_RES_SCALE * dpr));
    const canvasH = canvasW;

    domainCanvas.width = canvasW;
    domainCanvas.height = canvasH;
    domainCanvas.style.width = plotSize + "px";
    domainCanvas.style.height = plotSize + "px";
    domainCanvas.style.left = plotLeft + "px";
    domainCanvas.style.top = plotTop + "px";

    const imageData = domainCtx.createImageData(canvasW, canvasH);
    const data = imageData.data;

    const n = coefficients.length;
    if (n === 0) { domainCtx.putImageData(imageData, 0, 0); return; }

    // Precompute coefficient arrays for Horner's method
    const cRe = new Float64Array(n);
    const cIm = new Float64Array(n);
    for (let k = 0; k < n; k++) {
        cRe[k] = coefficients[k].re;
        cIm[k] = coefficients[k].im;
    }

    const TWO_PI = 2 * Math.PI;
    const INV_PI_180 = 180 / Math.PI;

    for (let py = 0; py < canvasH; py++) {
        const im = range - (2 * range * (py + 0.5)) / canvasH;
        for (let px = 0; px < canvasW; px++) {
            const re = -range + (2 * range * (px + 0.5)) / canvasW;

            // Horner's method: p(z) = c[0]*z^(n-1) + c[1]*z^(n-2) + ... + c[n-1]
            let pRe = cRe[0], pIm = cIm[0];
            for (let k = 1; k < n; k++) {
                const newRe = pRe * re - pIm * im + cRe[k];
                const newIm = pRe * im + pIm * re + cIm[k];
                pRe = newRe;
                pIm = newIm;
            }

            // Hue from argument
            let hue = Math.atan2(pIm, pRe) * INV_PI_180;
            if (hue < 0) hue += 360;

            // Lightness with log-modulus contour lines
            const mod2 = pRe * pRe + pIm * pIm;
            let lightness;
            if (mod2 < 1e-600) {
                lightness = 0;
            } else {
                const logMod = 0.5 * Math.log2(mod2); // = log2(|p(z)|)
                const frac = logMod - Math.floor(logMod);
                lightness = 0.5 + 0.4 * Math.cos(TWO_PI * frac);
            }

            const [r, g, b] = hslToRgb(hue / 360, 0.8, lightness);
            const idx = (py * canvasW + px) * 4;
            data[idx] = r;
            data[idx + 1] = g;
            data[idx + 2] = b;
            data[idx + 3] = 255;
        }
    }
    domainCtx.putImageData(imageData, 0, 0);
}

function renderDomainColoringThrottled() {
    if (!domainPendingRender) {
        domainPendingRender = true;
        requestAnimationFrame(() => {
            renderDomainColoring();
            domainPendingRender = false;
        });
    }
}

// --- Ehrlich-Aberth client-side root solver ---

function solveRootsEA(coeffs, warmStart) {
    // coeffs: array of {re, im} in descending degree order
    // warmStart: array of {re, im} initial guesses (or null)
    // Returns: array of {re, im} roots

    // Strip leading near-zero coefficients
    let start = 0;
    while (start < coeffs.length - 1 && Math.hypot(coeffs[start].re, coeffs[start].im) < 1e-15) {
        start++;
    }
    const c = coeffs.slice(start);
    const degree = c.length - 1;
    if (degree <= 0) return [];

    // Degree 1: linear case c[0]*z + c[1] = 0
    if (degree === 1) {
        const aRe = c[0].re, aIm = c[0].im;
        const bRe = c[1].re, bIm = c[1].im;
        const denom = aRe * aRe + aIm * aIm;
        if (denom < 1e-30) return [];
        return [{ re: -(bRe * aRe + bIm * aIm) / denom, im: -(bIm * aRe - bRe * aIm) / denom }];
    }

    const MAX_ITER = 100;
    const TOL = 1e-12;

    // Initialize root guesses
    const roots = new Array(degree);
    if (warmStart && warmStart.length === degree) {
        for (let i = 0; i < degree; i++) {
            roots[i] = [warmStart[i].re, warmStart[i].im];
        }
    } else {
        // Spread initial guesses on a circle with radius from coefficient ratio
        const leadMod = Math.hypot(c[0].re, c[0].im);
        const trailMod = Math.hypot(c[degree].re, c[degree].im);
        const radius = leadMod > 1e-30
            ? Math.max(0.1, Math.min(Math.pow(trailMod / leadMod, 1 / degree), 10))
            : 1;
        for (let i = 0; i < degree; i++) {
            const angle = (2 * Math.PI * i) / degree + 0.37; // offset to break symmetry
            roots[i] = [radius * Math.cos(angle), radius * Math.sin(angle)];
        }
    }

    // Precompute coefficient arrays for Horner's method
    const n = c.length;
    const cRe = new Float64Array(n);
    const cIm = new Float64Array(n);
    for (let k = 0; k < n; k++) {
        cRe[k] = c[k].re;
        cIm[k] = c[k].im;
    }

    // Iterate
    for (let iter = 0; iter < MAX_ITER; iter++) {
        let maxCorr = 0;

        for (let i = 0; i < degree; i++) {
            const zRe = roots[i][0], zIm = roots[i][1];

            // Evaluate p(z) and p'(z) simultaneously via Horner
            let pRe = cRe[0], pIm = cIm[0];
            let dpRe = 0, dpIm = 0;
            for (let k = 1; k < n; k++) {
                // dp = dp * z + p
                const ndRe = dpRe * zRe - dpIm * zIm + pRe;
                const ndIm = dpRe * zIm + dpIm * zRe + pIm;
                dpRe = ndRe;
                dpIm = ndIm;
                // p = p * z + c[k]
                const npRe = pRe * zRe - pIm * zIm + cRe[k];
                const npIm = pRe * zIm + pIm * zRe + cIm[k];
                pRe = npRe;
                pIm = npIm;
            }

            // Newton step: w = p(z) / p'(z)
            const dpMod2 = dpRe * dpRe + dpIm * dpIm;
            if (dpMod2 < 1e-60) continue;
            const wRe = (pRe * dpRe + pIm * dpIm) / dpMod2;
            const wIm = (pIm * dpRe - pRe * dpIm) / dpMod2;

            // Aberth sum: S = Œ£_{j‚â†i} 1/(z_i - z_j)
            let sRe = 0, sIm = 0;
            for (let j = 0; j < degree; j++) {
                if (j === i) continue;
                const dRe = zRe - roots[j][0];
                const dIm = zIm - roots[j][1];
                const dMod2 = dRe * dRe + dIm * dIm;
                if (dMod2 < 1e-60) continue;
                sRe += dRe / dMod2;
                sIm += -dIm / dMod2;
            }

            // Aberth correction: correction = w / (1 - w * S)
            const wsRe = wRe * sRe - wIm * sIm;
            const wsIm = wRe * sIm + wIm * sRe;
            const denomRe = 1 - wsRe;
            const denomIm = -wsIm;
            const denomMod2 = denomRe * denomRe + denomIm * denomIm;
            if (denomMod2 < 1e-60) continue;

            const corrRe = (wRe * denomRe + wIm * denomIm) / denomMod2;
            const corrIm = (wIm * denomRe - wRe * denomIm) / denomMod2;

            roots[i][0] -= corrRe;
            roots[i][1] -= corrIm;

            maxCorr = Math.max(maxCorr, Math.hypot(corrRe, corrIm));
        }

        if (maxCorr < TOL) break;
    }

    // Filter NaN/Inf and return
    const result = [];
    for (let i = 0; i < degree; i++) {
        if (isFinite(roots[i][0]) && isFinite(roots[i][1])) {
            result.push({ re: roots[i][0], im: roots[i][1] });
        }
    }
    return result;
}

// Greedy nearest-neighbor matching: reorder newRoots to best match oldRoots indices.
// Preserves root identity across frames so trails track the same root continuously.
function matchRootOrder(newRoots, oldRoots) {
    if (oldRoots.length === 0 || newRoots.length !== oldRoots.length) return newRoots;
    const n = newRoots.length;
    const used = new Uint8Array(n); // which newRoots indices are taken
    const result = new Array(n);
    for (let i = 0; i < n; i++) {
        let bestJ = -1, bestDist = Infinity;
        for (let j = 0; j < n; j++) {
            if (used[j]) continue;
            const d2 = (newRoots[j].re - oldRoots[i].re) ** 2 + (newRoots[j].im - oldRoots[i].im) ** 2;
            if (d2 < bestDist) { bestDist = d2; bestJ = j; }
        }
        result[i] = newRoots[bestJ];
        used[bestJ] = 1;
    }
    return result;
}

function solveRoots() {
    let roots = solveRootsEA(coefficients, currentRoots);
    roots = matchRootOrder(roots, currentRoots);
    renderRoots(roots);
}

function solveRootsThrottled() {
    if (fastModeActive) return;
    if (!pendingSolve) {
        pendingSolve = true;
        requestAnimationFrame(() => {
            solveRoots();
            pendingSolve = false;
        });
    }
}

// --- Degree input ---

const degreeNumber = document.getElementById("degree-number");
let currentDegree = 5;

function applyPattern() {
    stopAnimation();
    playBtn.textContent = "‚ñ∂ Play";
    lastSelectedCoeff = -1;
    clearAllSelection();
    clearTrails();
    clearStatsData();
    resetAudioState();
    resetBitmap();
    renderCoeffTrails(); // remove stale coefficient path SVGs
    currentRoots = [];
    rootsLayer.selectAll("circle.root").remove();
    updatePanelRange(rootsSvg, panels.roots, MIN_RANGE);
    initCoefficients(currentDegree);
    renderCoefficients();
    solveRoots();
    renderDomainColoring();
}

function setDegree(v) {
    v = Math.max(3, Math.min(30, Math.round(v)));
    if (v === currentDegree) return;
    currentDegree = v;
    degreeNumber.textContent = v;
    applyPattern();
}

// Degree popover (horizontal slider 3‚Äì30)
let degreePopEl = null;
let degreeToolActive = false;

function closeDegreePopover() {
    if (degreePopEl) { degreePopEl.classList.remove("open"); degreePopEl.innerHTML = ""; }
    degreeNumber.classList.remove("tool-active");
    degreeToolActive = false;
    window.removeEventListener("mousemove", degreeDragMove);
    window.removeEventListener("mouseup", degreeDragUp);
}
let degreeDragMove = null;
let degreeDragUp = null;

degreeNumber.addEventListener("click", function(e) {
    e.stopPropagation();
    if (degreeToolActive) { closeDegreePopover(); return; }
    // close any ops tool first
    if (typeof closeOpTool === "function") closeOpTool();
    degreeToolActive = true;
    degreeNumber.classList.add("tool-active");

    if (!degreePopEl) degreePopEl = document.getElementById("degree-pop");
    degreePopEl.innerHTML = "";

    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Degree";
    const valEl = document.createElement("div");
    valEl.className = "pop-val";
    valEl.textContent = currentDegree;

    const slider = document.createElement("div");
    slider.className = "hslider";
    slider.style.width = "180px";
    const thumb = document.createElement("div");
    thumb.className = "hslider-thumb";
    slider.appendChild(thumb);

    // ticks
    const tickRow = document.createElement("div");
    tickRow.className = "pop-row";
    tickRow.style.justifyContent = "space-between";
    tickRow.style.width = "180px";
    tickRow.style.fontSize = "9px";
    tickRow.textContent = "3 ‚Äî 30";

    function uFromDeg(d) { return (d - 3) / (30 - 3); }
    function degFromU(u) { return Math.round(3 + u * (30 - 3)); }
    let u = uFromDeg(currentDegree);

    function updateVisual() {
        thumb.style.left = (u * 100) + "%";
        const d = degFromU(u);
        valEl.textContent = d;
    }

    function setFromX(clientX) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        updateVisual();
        setDegree(degFromU(u));
    }

    let dragging = false;
    slider.addEventListener("mousedown", ev => {
        dragging = true; setFromX(ev.clientX); ev.preventDefault();
    });
    degreeDragMove = ev => { if (dragging) setFromX(ev.clientX); };
    degreeDragUp = () => { dragging = false; };
    window.addEventListener("mousemove", degreeDragMove);
    window.addEventListener("mouseup", degreeDragUp);

    updateVisual();
    degreePopEl.appendChild(title);
    degreePopEl.appendChild(slider);
    degreePopEl.appendChild(valEl);
    degreePopEl.appendChild(tickRow);
    degreePopEl.classList.add("open");

    // position below the degree label
    const r = degreeNumber.getBoundingClientRect();
    degreePopEl.style.left = r.left + "px";
    degreePopEl.style.top = (r.bottom + 8) + "px";
});

// close degree popover on outside click
document.addEventListener("mousedown", function(e) {
    if (!degreeToolActive) return;
    if (degreePopEl && degreePopEl.contains(e.target)) return;
    if (degreeNumber.contains(e.target)) return;
    closeDegreePopover();
});
document.addEventListener("keydown", function(e) {
    if (e.key === "Escape" && degreeToolActive) { closeDegreePopover(); e.stopImmediatePropagation(); }
}, true);

document.getElementById("pattern").addEventListener("change", applyPattern);
document.getElementById("reset-btn").addEventListener("click", applyPattern);

document.getElementById("deselect-all-btn").addEventListener("click", clearAllSelection);

// Mid-bar All / None buttons ‚Äî context-aware selection
document.getElementById("mid-all-btn").addEventListener("click", function () {
    if (selectedRoots.size > 0) {
        // Roots context: select all roots
        for (let i = 0; i < currentRoots.length; i++) selectedRoots.add(i);
        updateRootSelectionVisual();
    } else {
        // Coefficients context (default): select all coefficients
        clearRootSelection();
        for (let i = 0; i < coefficients.length; i++) selectedCoeffs.add(i);
        if (coefficients.length > 0) lastSelectedCoeff = coefficients.length - 1;
        updateCoeffSelectionVisual();
        updateAnimBar();
    }
});
document.getElementById("mid-none-btn").addEventListener("click", function () {
    if (selectedRoots.size > 0) {
        clearRootSelection();
    } else {
        clearCoeffSelection();
    }
});

document.getElementById("select-all-coeffs-btn").addEventListener("click", function () {
    clearRootSelection();
    for (let i = 0; i < coefficients.length; i++) selectedCoeffs.add(i);
    if (coefficients.length > 0) lastSelectedCoeff = coefficients.length - 1;
    updateCoeffSelectionVisual();
    updateAnimBar();
});

const domainToggleBtn = document.getElementById("domain-toggle-btn");
domainToggleBtn.addEventListener("click", function () {
    domainColoringEnabled = !domainColoringEnabled;
    this.classList.toggle("active", domainColoringEnabled);
    domainCanvas.style.display = domainColoringEnabled ? "block" : "none";
    rootsSvg.classed("domain-active", domainColoringEnabled);
    if (domainColoringEnabled) renderDomainColoring();
});

document.getElementById("select-all-roots-btn").addEventListener("click", function () {
    clearCoeffSelection();
    for (let i = 0; i < currentRoots.length; i++) selectedRoots.add(i);
    updateRootSelectionVisual();
});

document.getElementById("deselect-all-roots-btn").addEventListener("click", function () {
    clearRootSelection();
});

// Fit button ‚Äî resize roots panel to fit all roots + trails
document.getElementById("roots-fit-btn").addEventListener("click", function () {
    const allPts = [...currentRoots];
    if (trailsEnabled) {
        for (const pts of trailData) {
            for (const p of pts) allPts.push(p);
        }
    }
    if (allPts.length === 0) { uiBuzz(); return; }
    const needed = computeRange(allPts);
    if (Math.abs(panels.roots.range - needed) < 0.01) { uiBuzz(); return; }
    // Force range (bypasses zoom-out-only guard)
    updatePanelRange(rootsSvg, panels.roots, needed);
    rootsLayer.selectAll("circle.root")
        .attr("cx", d => rxs()(d.re)).attr("cy", d => rys()(d.im));
    if (trailsEnabled && trailData.length > 0) renderTrails();
    renderDomainColoring();
    uiPing(660, 0.08);
});

// --- Root color popover ---
const colorPop = document.getElementById("color-pop");
const rootColorBtn = document.getElementById("root-color-btn");
let colorPopOpen = false;

function closeColorPop() {
    colorPop.classList.remove("open");
    colorPop.innerHTML = "";
    rootColorBtn.classList.remove("tool-active");
    colorPopOpen = false;
}

function refreshRootColors() {
    rootsLayer.selectAll("circle.root")
        .attr("fill", (_, i) => rootColor(i, currentRoots.length));
}

function buildColorPop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Root Color";
    pop.appendChild(title);

    const modes = [
        { key: "uniform", label: "Uniform" },
        { key: "rainbow", label: "Index Rainbow" },
        { key: "derivative", label: "Derivative" },
    ];
    const rows = [];
    let swatchWrap = null;

    function refreshSwatches() {
        if (swatchWrap) swatchWrap.style.opacity = rootColorMode === "uniform" ? "1" : "0.3";
    }

    modes.forEach(m => {
        const row = document.createElement("div");
        row.className = "audio-toggle" + (rootColorMode === m.key ? " on" : "");
        const dot = document.createElement("span");
        dot.className = "toggle-dot";
        const lbl = document.createElement("span");
        lbl.className = "toggle-label"; lbl.textContent = m.label;
        row.appendChild(dot);
        row.appendChild(lbl);
        row.addEventListener("click", () => {
            rootColorMode = m.key;
            rootColorBtn.classList.toggle("active", rootColorMode !== "uniform");
            rows.forEach(r => r.classList.remove("on"));
            row.classList.add("on");
            if (rootColorMode === "derivative") computeRootSensitivities();
            refreshRootColors();
            refreshSwatches();
        });
        pop.appendChild(row);
        rows.push(row);

        // Add color swatches after the "Uniform" row
        if (m.key === "uniform") {
            swatchWrap = document.createElement("div");
            swatchWrap.style.cssText = "display:flex;flex-wrap:wrap;gap:3px;padding:4px 2px 6px 20px;max-width:180px;";
            swatchWrap.style.opacity = rootColorMode === "uniform" ? "1" : "0.3";

            // White swatch
            const nCoeffs = coefficients.length;
            const colorChoices = [{ label: "White", rgb: [255, 255, 255] }];
            for (let ci = 0; ci < nCoeffs; ci++) {
                const k = (nCoeffs - 1) - ci; // power-based subscript
                const css = d3.interpolateRainbow(ci / nCoeffs);
                const m2 = css.match(/(\d+)/g);
                const rgb = m2 ? [+m2[0], +m2[1], +m2[2]] : [233, 69, 96];
                colorChoices.push({ label: "c" + k, rgb });
            }

            colorChoices.forEach(ch => {
                const sw = document.createElement("div");
                const isActive = uniformRootColor[0] === ch.rgb[0] && uniformRootColor[1] === ch.rgb[1] && uniformRootColor[2] === ch.rgb[2];
                sw.style.cssText = `width:16px;height:16px;border-radius:50%;cursor:pointer;` +
                    `background:rgb(${ch.rgb[0]},${ch.rgb[1]},${ch.rgb[2]});` +
                    `border:2px solid ${isActive ? "#fff" : "rgba(255,255,255,0.15)"};` +
                    `box-sizing:border-box;flex-shrink:0;`;
                sw.title = ch.label;
                sw.addEventListener("click", () => {
                    uniformRootColor = ch.rgb.slice();
                    // Update swatch borders
                    swatchWrap.querySelectorAll("div").forEach(s => {
                        s.style.borderColor = "rgba(255,255,255,0.15)";
                    });
                    sw.style.borderColor = "#fff";
                    // Switch to uniform mode if not already
                    if (rootColorMode !== "uniform") {
                        rootColorMode = "uniform";
                        rootColorBtn.classList.toggle("active", false);
                        rows.forEach(r => r.classList.remove("on"));
                        rows[0].classList.add("on"); // "Uniform" is first
                        refreshSwatches();
                    }
                    refreshRootColors();
                });
                swatchWrap.appendChild(sw);
            });
            pop.appendChild(swatchWrap);
        }
    });
}

rootColorBtn.addEventListener("click", function () {
    if (colorPopOpen) { closeColorPop(); return; }
    closeColorPop();
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeAudioPop === "function") closeAudioPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();
    colorPopOpen = true;
    rootColorBtn.classList.add("tool-active");
    colorPop.innerHTML = "";
    buildColorPop(colorPop);
    colorPop.classList.add("open");
    const r = rootColorBtn.getBoundingClientRect();
    colorPop.style.left = (r.right + 8) + "px";
    colorPop.style.top = r.top + "px";
});

// --- Coefficient picker popover ---
const coeffPickPop = document.getElementById("coeff-pick-pop");
const coeffPickerBtn = document.getElementById("coeff-picker-btn");
let coeffPickOpen = false;

function closeCoeffPick() {
    coeffPickPop.classList.remove("open");
    coeffPickPop.innerHTML = "";
    coeffPickerBtn.classList.remove("tool-active");
    coeffPickOpen = false;
}

function buildCoeffPickPop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Coefficients";
    pop.appendChild(title);

    const scrollBox = document.createElement("div");
    scrollBox.style.cssText = "max-height:184px;overflow-y:auto;width:100%;";

    const deg = coefficients.length - 1;
    const n = coefficients.length;
    const coeffSens = computeCoeffSensitivities();
    for (let i = 0; i < n; i++) {
        const row = document.createElement("div");
        row.className = "cpick-row";

        const dot = document.createElement("span");
        dot.className = "cpick-dot";
        dot.style.background = coeffColor(i, n);

        const sensDot = document.createElement("span");
        sensDot.className = "cpick-dot";
        sensDot.style.background = coeffSens ? sensitivityColor(coeffSens[i]) : "#555";

        const label = document.createElement("span");
        label.className = "cpick-label";
        label.textContent = "c" + (deg - i);

        const power = document.createElement("span");
        power.className = "cpick-power";
        const exp = deg - i;
        power.textContent = exp === 0 ? "1" : exp === 1 ? "z" : "z" + superscript(exp);

        // Path info for this coefficient
        const pathSpan = document.createElement("span");
        pathSpan.className = "cpick-path";
        const ci = coefficients[i];
        if (ci.pathType !== "none") {
            const t = ci.pathType;
            const pName = t === "figure8" ? "Fig-8"
                : t === "epitrochoid" ? "Spiro" : t === "hypotrochoid" ? "Hypo"
                : t.charAt(0).toUpperCase() + t.slice(1);
            pathSpan.textContent = pName;
            const detail = document.createElement("span");
            detail.className = "cpick-detail";
            detail.textContent = ` R${Math.round(ci.radius)} S${Math.round(ci.speed * 100)} A${ci.angle.toFixed(2)} ${ci.ccw ? "CCW" : "CW"}`;
            pathSpan.appendChild(detail);
        } else {
            pathSpan.textContent = "‚Äî";
        }

        // Point count for path curves
        const ptsSpan = document.createElement("span");
        ptsSpan.className = "cpick-pts";
        if (ci.pathType !== "none" && ci.curve) {
            ptsSpan.textContent = ci.curve.length;
        } else {
            ptsSpan.textContent = "";
        }

        const coords = document.createElement("span");
        coords.className = "cpick-coords";
        const c = coefficients[i];
        const sign = c.im >= 0 ? "+" : "";
        coords.textContent = c.re.toFixed(2) + sign + c.im.toFixed(2) + "i";

        const cb = document.createElement("span");
        cb.className = "cpick-cb" + (selectedCoeffs.has(i) ? " checked" : "");

        row.appendChild(cb);
        row.appendChild(dot);
        row.appendChild(sensDot);
        row.appendChild(label);
        row.appendChild(power);
        row.appendChild(pathSpan);
        row.appendChild(ptsSpan);
        row.appendChild(coords);

        const idx = i;
        row.addEventListener("click", () => {
            clearRootSelection();
            if (selectedCoeffs.has(idx)) {
                selectedCoeffs.delete(idx);
                cb.classList.remove("checked");
            } else {
                selectedCoeffs.add(idx);
                cb.classList.add("checked");
                lastSelectedCoeff = idx;
            }
            updateCoeffSelectionVisual();
            updateAnimBar();
        });

        scrollBox.appendChild(row);
    }
    pop.appendChild(scrollBox);
}

function superscript(n) {
    const sup = "\u2070\u00B9\u00B2\u00B3\u2074\u2075\u2076\u2077\u2078\u2079";
    if (n < 10) return sup[n];
    return String(n).split("").map(d => sup[+d]).join("");
}

coeffPickerBtn.addEventListener("click", function () {
    if (coeffPickOpen) { closeCoeffPick(); return; }
    closeCoeffPick();
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeAudioPop === "function") closeAudioPop();
    if (typeof closeColorPop === "function") closeColorPop();
    coeffPickOpen = true;
    coeffPickerBtn.classList.add("tool-active");
    coeffPickPop.innerHTML = "";
    buildCoeffPickPop(coeffPickPop);
    coeffPickPop.classList.add("open");
    const r = coeffPickerBtn.getBoundingClientRect();
    coeffPickPop.style.left = (r.right + 8) + "px";
    coeffPickPop.style.top = r.top + "px";
});

// --- Audio instrument config popovers ---
const audioPop = document.getElementById("audio-pop");

function closeAudioPop() {
    audioPop.classList.remove("open");
    audioPop.innerHTML = "";
    if (activeAudioBtn) activeAudioBtn.classList.remove("tool-active");
    activeAudioBtn = null;
}

function openAudioPop(btnEl, buildFn) {
    if (activeAudioBtn === btnEl) { closeAudioPop(); return; }
    closeAudioPop();
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeColorPop === "function") closeColorPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();
    activeAudioBtn = btnEl;
    btnEl.classList.add("tool-active");
    audioPop.innerHTML = "";
    buildFn(audioPop);
    audioPop.classList.add("open");
    const r = btnEl.getBoundingClientRect();
    audioPop.style.left = r.left + "px";
    audioPop.style.top = (r.bottom + 6) + "px";
}

function toggleSound(flag, setFn, btnEl) {
    const wasAny = anySoundEnabled();
    setFn(flag);
    btnEl.classList.toggle("active", flag);
    const isAny = anySoundEnabled();
    if (isAny && !wasAny) {
        initAudio();
        if (audioCtx.state === "suspended") audioCtx.resume();
        audioWatchdogId = setInterval(audioWatchdog, 100);
    } else if (!isAny && wasAny) {
        if (audioWatchdogId) { clearInterval(audioWatchdogId); audioWatchdogId = null; }
        resetAudioState();
    }
}

const fmtHz = v => v < 100 ? v.toFixed(1) + " Hz" : Math.round(v) + " Hz";
const fmtMs = v => (v * 1000).toFixed(1) + " ms";
const fmtF = (d) => v => v.toFixed(d);
const fmtPct = v => (v * 100).toFixed(0) + "%";

function buildBasePop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Base";
    pop.appendChild(title);
    const btn = document.getElementById("base-toggle-btn");
    buildAudioToggle(pop, "Enabled", baseEnabled, on => toggleSound(on, v => { baseEnabled = v; }, btn));
    buildAudioSlider(pop, "Pitch",      55,    440,  baseConfig.freq,      true,  fmtHz,     v => { baseConfig.freq = v; });
    buildAudioSlider(pop, "Range",      0.5,   4.0,  baseConfig.octaves,   false, fmtF(1),   v => { baseConfig.octaves = v; });
    buildAudioSlider(pop, "FM Ratio",   0.5,   8.0,  baseConfig.modRatio,  false, v => "√ó" + v.toFixed(1), v => { baseConfig.modRatio = v; });
    buildAudioSlider(pop, "FM Depth",   0,     800,  baseConfig.modDepth,  false, fmtHz,     v => { baseConfig.modDepth = v; });
    buildAudioSlider(pop, "Bright",     50,    1000, baseConfig.filterLo,  true,  fmtHz,     v => { baseConfig.filterLo = v; });
    buildAudioSlider(pop, "Volume",     0.05,  0.50, baseConfig.gainRange, false, fmtF(2),   v => { baseConfig.gainRange = v; });
    buildAudioSlider(pop, "Vibrato",    0,     25,   baseConfig.vibDepth,  false, fmtF(1),   v => { baseConfig.vibDepth = v; });
}

function buildMelodyPop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Melody";
    pop.appendChild(title);
    const btn = document.getElementById("melody-toggle-btn");
    buildAudioToggle(pop, "Enabled", melodyEnabled, on => toggleSound(on, v => { melodyEnabled = v; }, btn));
    buildAudioSlider(pop, "Rate",       2,     60,   melodyConfig.rate,     true,  v => Math.round(v) + "/s", v => { melodyConfig.rate = v; });
    buildAudioSlider(pop, "Cutoff",     2,  currentDegree, Math.min(melodyConfig.cutoff, currentDegree), false, v => Math.round(v) + "",  v => { melodyConfig.cutoff = v; });
    buildAudioSlider(pop, "Volume",     0.02,  0.30, melodyConfig.peak,     false, fmtF(2),   v => { melodyConfig.peak = v; });
    buildAudioSlider(pop, "Attack",     0.001, 0.020, melodyConfig.attack,  true,  fmtMs,     v => { melodyConfig.attack = v; });
    buildAudioSlider(pop, "Decay",      0.010, 0.200, melodyConfig.decay,   true,  fmtMs,     v => { melodyConfig.decay = v; });
    buildAudioSlider(pop, "Bright",     200,   4000, melodyConfig.filterLo, true,  fmtHz,     v => { melodyConfig.filterLo = v; });
}

function buildVoicePop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Voice";
    pop.appendChild(title);
    const btn = document.getElementById("voice-toggle-btn");
    buildAudioToggle(pop, "Enabled", voiceEnabled, on => toggleSound(on, v => { voiceEnabled = v; }, btn));
    buildAudioSlider(pop, "Cooldown",   0.01,  0.50,  voiceConfig.cooldown, true,  fmtMs,     v => { voiceConfig.cooldown = v; });
    buildAudioSlider(pop, "Volume",     0.02,  0.30,  voiceConfig.peak,     false, fmtF(2),   v => { voiceConfig.peak = v; });
    buildAudioSlider(pop, "Attack",     0.001, 0.020, voiceConfig.attack,   true,  fmtMs,     v => { voiceConfig.attack = v; });
    buildAudioSlider(pop, "Decay",      0.01,  0.30,  voiceConfig.ringdown, true,  fmtMs,     v => { voiceConfig.ringdown = v; });
}

document.getElementById("base-toggle-btn").addEventListener("click", function () { openAudioPop(this, buildBasePop); });
document.getElementById("melody-toggle-btn").addEventListener("click", function () { openAudioPop(this, buildMelodyPop); });
document.getElementById("voice-toggle-btn").addEventListener("click", function () { openAudioPop(this, buildVoicePop); });

// --- Config tab ---
(function initConfigTab() {
    const container = document.getElementById("config-sliders");

    // -- Encounters / Records --
    const sec1 = document.createElement("div");
    sec1.className = "config-section"; sec1.textContent = "Encounters ¬∑ Records";
    container.appendChild(sec1);
    const stack = document.createElement("div");
    stack.className = "config-row-stack";
    buildAudioSlider(stack, "Memory",  1.0,  1.02, voiceConfig.decay,   true,  fmtF(4), v => { voiceConfig.decay = v; });
    buildAudioSlider(stack, "Novelty", 0.3,  1.0,  voiceConfig.novelty, false, fmtF(2), v => { voiceConfig.novelty = v; });
    container.appendChild(stack);

    // Mini slider builder for table cells
    function buildCellSlider(parent, min, max, value, logScale, fmt, onChange) {
        const wrap = document.createElement("div");
        wrap.className = "cell-slider-wrap";
        const track = document.createElement("div");
        track.className = "cell-slider";
        const thumb = document.createElement("div");
        thumb.className = "cell-slider-thumb";
        track.appendChild(thumb);
        const val = document.createElement("span");
        val.className = "cell-slider-val";
        function valToU(v) {
            if (logScale) return (Math.log(v) - Math.log(min)) / (Math.log(max) - Math.log(min));
            return (v - min) / (max - min);
        }
        function uToVal(u) {
            if (logScale) return Math.exp(Math.log(min) + u * (Math.log(max) - Math.log(min)));
            return min + u * (max - min);
        }
        let u = Math.max(0, Math.min(1, valToU(value)));
        function update() {
            thumb.style.left = (u * 100) + "%";
            const v = uToVal(u);
            val.textContent = fmt(v);
            onChange(v);
        }
        function setFromX(clientX) {
            const rect = track.getBoundingClientRect();
            u = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
            update();
        }
        let dragging = false;
        track.addEventListener("mousedown", e => { dragging = true; setFromX(e.clientX); e.preventDefault(); });
        window.addEventListener("mousemove", e => { if (dragging) setFromX(e.clientX); });
        window.addEventListener("mouseup", () => { dragging = false; });
        update();
        wrap.appendChild(track);
        wrap.appendChild(val);
        parent.appendChild(wrap);
    }

    // Builds a routing table for a given routes array
    function buildRouteTable(routes) {
        const table = document.createElement("table");
        table.className = "route-table";
        const thead = document.createElement("thead");
        const hrow = document.createElement("tr");
        ["Input signal", "Smooth", "Norm", "Feeding into"].forEach(t => {
            const th = document.createElement("th"); th.textContent = t; hrow.appendChild(th);
        });
        thead.appendChild(hrow); table.appendChild(thead);

        const tbody = document.createElement("tbody");
        for (let i = 0; i < routes.length; i++) {
            const route = routes[i];
            const tr = document.createElement("tr");

            // Col 1: Input signal dropdown
            const td1 = document.createElement("td");
            const sel = document.createElement("select");
            for (const src of ROUTE_SOURCES) {
                const opt = document.createElement("option");
                opt.value = src; opt.textContent = src;
                if (src === route.source) opt.selected = true;
                sel.appendChild(opt);
            }
            sel.addEventListener("change", () => { route.source = sel.value; });
            td1.appendChild(sel); tr.appendChild(td1);

            // Col 2: Smoothing slider (alpha 0.01‚Äì1.0, log scale)
            const td2 = document.createElement("td");
            buildCellSlider(td2, 0.01, 1.0, route.alpha, true, v => v.toFixed(2), v => { route.alpha = v; });
            tr.appendChild(td2);

            // Col 3: Normalization mode dropdown
            const td3 = document.createElement("td");
            const normSel = document.createElement("select");
            normSel.className = "norm-select";
            for (const m of NORM_MODES) {
                const opt = document.createElement("option");
                opt.value = m; opt.textContent = m === "fixed" ? "Fixed" : "RunMax";
                if (m === route.norm) opt.selected = true;
                normSel.appendChild(opt);
            }
            normSel.addEventListener("change", () => { route.norm = normSel.value; route.runMax = 0.001; });
            td3.appendChild(normSel); tr.appendChild(td3);

            // Col 4: Target label
            const td4 = document.createElement("td");
            td4.className = "target-label"; td4.textContent = route.target;
            tr.appendChild(td4);

            tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        return table;
    }

    // -- Base Routing Table --
    const sec2 = document.createElement("div");
    sec2.className = "config-section"; sec2.textContent = "Base Routing";
    container.appendChild(sec2);
    container.appendChild(buildRouteTable(baseRoutes));

    // -- Voice Routing Table --
    const sec3 = document.createElement("div");
    sec3.className = "config-section"; sec3.textContent = "Voice Routing";
    container.appendChild(sec3);
    container.appendChild(buildRouteTable(voiceRoutes));

    // -- Melody Routing Table --
    const sec4 = document.createElement("div");
    sec4.className = "config-section"; sec4.textContent = "Melody Routing";
    container.appendChild(sec4);
    container.appendChild(buildRouteTable(melodyRoutes));
})();

document.addEventListener("visibilitychange", function () {
    if (document.hidden && audioNodes && audioCtx) {
        audioNodes.masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.02);
    }
});

document.addEventListener("keydown", function (e) {
    if (e.key === "Escape") {
        if (ctxCoeffIdx >= 0) { closeCoeffCtx(true); return; }
        if (typeof activeToolBtn !== "undefined" && activeToolBtn) { closeOpTool(); return; }
        if (activeAudioBtn) { closeAudioPop(); return; }
        if (colorPopOpen) { closeColorPop(); return; }
        if (coeffPickOpen) { closeCoeffPick(); return; }
        if (typeof snapPopOpen !== "undefined" && snapPopOpen) { closeSnapPop(); return; }
        if (typeof bitmapBgPopOpen !== "undefined" && bitmapBgPopOpen) { closeBitmapBgPop(); return; }
        if (typeof jigglePopOpen !== "undefined" && jigglePopOpen) { closeJigglePop(); return; }
        if (typeof fastmodePopOpen !== "undefined" && fastmodePopOpen) { closeFastmodePop(); return; }
        if (typeof pathPickOpen !== "undefined" && pathPickOpen) { closePathPickPop(true); return; }
        clearAllSelection();
    }
});

// --- Transform tools (popover with live preview) ---

const opsPop = document.getElementById("ops-pop");
let activeToolBtn = null;
let opSnapshot = null; // { which: "coeff"|"roots", items: [{idx, re, im}, ...] }

function snapshotSelection() {
    const items = [];
    if (selectedCoeffs.size > 0) {
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            items.push({ idx, re: c.re, im: c.im });
        }
        return { which: "coeff", items };
    } else if (selectedRoots.size > 0) {
        for (const idx of selectedRoots) {
            const r = currentRoots[idx];
            items.push({ idx, re: r.re, im: r.im });
        }
        return { which: "roots", items };
    }
    return null;
}

function applyPreview(snap, fn) {
    if (!snap) return;
    if (snap.which === "coeff") {
        for (const s of snap.items) {
            const c = coefficients[s.idx];
            const r = fn(s.re, s.im);
            c.re = r.re; c.im = r.im;
        }
        for (const c of coefficients) {
            if (c.pathType !== "none") {
                c.curve = computeCurve(c.re, c.im, c.pathType, c.radius / 100 * coeffExtent(), c.angle, c.extra);
            }
        }
        autoScaleCoeffPanel();
        renderCoefficients();
        updateCoeffSelectionVisual();
        renderCoeffTrails();
        updateListCoords();
        solveRootsThrottled();
    } else {
        for (const s of snap.items) {
            const r = currentRoots[s.idx];
            const res = fn(s.re, s.im);
            r.re = res.re; r.im = res.im;
        }
        autoScaleRootsPanel();
        // Update coefficients in-place (preserving trajectory metadata), same as root drag
        const newCoeffs = rootsToCoefficients(currentRoots.map(r => ({ re: r.re, im: r.im })));
        for (let ci = 0; ci < newCoeffs.length; ci++) {
            const deltaRe = newCoeffs[ci].re - coefficients[ci].re;
            const deltaIm = newCoeffs[ci].im - coefficients[ci].im;
            coefficients[ci].re = newCoeffs[ci].re;
            coefficients[ci].im = newCoeffs[ci].im;
            if (coefficients[ci].curve) {
                for (const pt of coefficients[ci].curve) {
                    pt.re += deltaRe;
                    pt.im += deltaIm;
                }
            }
        }
        renderCoefficients();
        renderCoeffTrails();
        renderRoots(currentRoots);
        updateRootSelectionVisual();
        updateListCoords();
    }
}

function positionPopover(btnEl) {
    const r = btnEl.getBoundingClientRect();
    opsPop.style.left = (r.right + 8) + "px";
    opsPop.style.top = r.top + "px";
}

function closeOpTool() {
    opsPop.classList.remove("open");
    opsPop.innerHTML = "";
    if (activeToolBtn) activeToolBtn.classList.remove("tool-active");
    activeToolBtn = null;
    opSnapshot = null;
    // remove drag listeners
    window.removeEventListener("mousemove", opToolMouseMove);
    window.removeEventListener("mouseup", opToolMouseUp);
}

let opToolMouseMove = null;
let opToolMouseUp = null;

function openOpTool(btnEl, buildFn) {
    if (activeToolBtn === btnEl) { closeOpTool(); return; }
    closeOpTool();
    closeDegreePopover();
    if (typeof closeAudioPop === "function") closeAudioPop();
    if (typeof closeColorPop === "function") closeColorPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();
    opSnapshot = snapshotSelection();
    if (!opSnapshot) return;
    activeToolBtn = btnEl;
    btnEl.classList.add("tool-active");
    opsPop.innerHTML = "";
    buildFn(opsPop, opSnapshot);
    opsPop.classList.add("open");
    positionPopover(btnEl);
}

// --- Scale tool: vertical slider, exponential mapping ---
// u in [0,1] mapped to scale = exp(k*(u - 0.5)*2) where k=ln(10) ‚Üí range [0.1, 10]
const SCALE_K = Math.log(10);
function uToScale(u) { return Math.exp(SCALE_K * (u * 2 - 1)); }
function scaleToU(s) { return (Math.log(s) / SCALE_K + 1) / 2; }

function buildScaleTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Scale";
    const valEl = document.createElement("div");
    valEl.className = "pop-val"; valEl.textContent = "1.00√ó";

    const slider = document.createElement("div");
    slider.className = "vslider";
    const fill = document.createElement("div");
    fill.className = "vslider-fill";
    const thumb = document.createElement("div");
    thumb.className = "vslider-thumb";
    slider.appendChild(fill);
    slider.appendChild(thumb);

    let u = 0.5; // start at 1√ó
    function updateVisual() {
        const pct = u * 100;
        fill.style.height = pct + "%";
        thumb.style.bottom = pct + "%";
        const s = uToScale(u);
        valEl.textContent = s.toFixed(2) + "√ó";
        applyPreview(snap, (re, im) => ({ re: re * s, im: im * s }));
    }

    function setFromY(clientY) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, 1 - (clientY - rect.top) / rect.height));
        updateVisual();
    }

    let dragging = false;
    slider.addEventListener("mousedown", e => {
        dragging = true; setFromY(e.clientY); e.preventDefault();
    });
    opToolMouseMove = e => { if (dragging) setFromY(e.clientY); };
    opToolMouseUp = () => { dragging = false; };
    window.addEventListener("mousemove", opToolMouseMove);
    window.addEventListener("mouseup", opToolMouseUp);

    updateVisual();
    pop.appendChild(title);
    pop.appendChild(slider);
    pop.appendChild(valEl);
}

// --- Rotate tool: horizontal slider, -0.5 to 0.5 turns ---

function buildRotateTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Rotate";
    const valEl = document.createElement("div");
    valEl.className = "pop-val"; valEl.textContent = "0 turns";

    const slider = document.createElement("div");
    slider.className = "hslider";
    const center = document.createElement("div");
    center.className = "hslider-center";
    const thumb = document.createElement("div");
    thumb.className = "hslider-thumb";
    slider.appendChild(center);
    slider.appendChild(thumb);

    let u = 0.5; // center = 0 turns
    function updateVisual() {
        const pct = u * 100;
        thumb.style.left = pct + "%";
        const turns = u - 0.5; // -0.5 to 0.5
        const sign = turns >= 0 ? "+" : "";
        valEl.textContent = sign + turns.toFixed(3) + " turns";
        const angle = 2 * Math.PI * turns;
        const cosA = Math.cos(angle), sinA = Math.sin(angle);
        applyPreview(snap, (re, im) => ({
            re: re * cosA - im * sinA,
            im: re * sinA + im * cosA
        }));
    }

    function setFromX(clientX) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        updateVisual();
    }

    let dragging = false;
    slider.addEventListener("mousedown", e => {
        dragging = true; setFromX(e.clientX); e.preventDefault();
    });
    opToolMouseMove = e => { if (dragging) setFromX(e.clientX); };
    opToolMouseUp = () => { dragging = false; };
    window.addEventListener("mousemove", opToolMouseMove);
    window.addEventListener("mouseup", opToolMouseUp);

    updateVisual();
    pop.appendChild(title);
    pop.appendChild(slider);
    pop.appendChild(valEl);
}

// --- Add tool: 2D vector pad ---
// Pad maps pixel offset to complex offset. Range: +/-2 in each axis.
const PAD_RANGE = 2;

function buildAddTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Translate";
    const valEl = document.createElement("div");
    valEl.className = "pop-row";

    const pad = document.createElement("div");
    pad.className = "vec-pad";
    const axH = document.createElement("div");
    axH.className = "pad-axis h";
    const axV = document.createElement("div");
    axV.className = "pad-axis v";
    const dot = document.createElement("div");
    dot.className = "pad-dot";
    pad.appendChild(axH);
    pad.appendChild(axV);
    pad.appendChild(dot);

    let ux = 0.5, uy = 0.5; // center = (0,0)
    function updateVisual() {
        dot.style.left = (ux * 100) + "%";
        dot.style.top = (uy * 100) + "%";
        const dx = (ux - 0.5) * 2 * PAD_RANGE;
        const dy = -(uy - 0.5) * 2 * PAD_RANGE; // screen Y is inverted
        const signRe = dx >= 0 ? "+" : "";
        const signIm = dy >= 0 ? "+" : "";
        valEl.textContent = signRe + dx.toFixed(2) + " " + signIm + dy.toFixed(2) + "i";
        applyPreview(snap, (re, im) => ({ re: re + dx, im: im + dy }));
    }

    function setFromXY(clientX, clientY) {
        const rect = pad.getBoundingClientRect();
        ux = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        uy = Math.max(0, Math.min(1, (clientY - rect.top) / rect.height));
        updateVisual();
    }

    let dragging = false;
    pad.addEventListener("mousedown", e => {
        dragging = true; setFromXY(e.clientX, e.clientY); e.preventDefault();
    });
    opToolMouseMove = e => { if (dragging) setFromXY(e.clientX, e.clientY); };
    opToolMouseUp = () => { dragging = false; };
    window.addEventListener("mousemove", opToolMouseMove);
    window.addEventListener("mouseup", opToolMouseUp);

    updateVisual();
    pop.appendChild(title);
    pop.appendChild(pad);
    pop.appendChild(valEl);
}

// Wire up buttons
document.getElementById("scale-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildScaleTool);
});
document.getElementById("rotate-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildRotateTool);
});
document.getElementById("add-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildAddTool);
});

// Close popover on click outside
document.addEventListener("mousedown", e => {
    // Close ops popover
    if (activeToolBtn) {
        if (!opsPop.contains(e.target) && !(e.target.id && e.target.id.endsWith("-tool-btn"))) {
            closeOpTool();
        }
    }
    // Close audio popover
    if (activeAudioBtn) {
        if (!audioPop.contains(e.target) && !(e.target.id && e.target.id.endsWith("-toggle-btn"))) {
            closeAudioPop();
        }
    }
    // Close color popover
    if (colorPopOpen) {
        if (!colorPop.contains(e.target) && e.target.id !== "root-color-btn") {
            closeColorPop();
        }
    }
    // Close coeff picker popover
    if (coeffPickOpen) {
        if (!coeffPickPop.contains(e.target) && e.target.id !== "coeff-picker-btn") {
            closeCoeffPick();
        }
    }
    // Close coefficient context menu (revert on outside click)
    if (ctxCoeffIdx >= 0) {
        const ctxEl = document.getElementById("coeff-ctx");
        if (!ctxEl.contains(e.target)) {
            closeCoeffCtx(true);
        }
    }
    // Close snap popup
    if (typeof snapPopOpen !== "undefined" && snapPopOpen) {
        const sp = document.getElementById("snap-pop");
        if (sp && !sp.contains(e.target) && e.target.id !== "snap-btn") {
            if (typeof closeSnapPop === "function") closeSnapPop();
        }
    }
    // Close bitmap bg popup
    if (typeof bitmapBgPopOpen !== "undefined" && bitmapBgPopOpen) {
        const bp = document.getElementById("bitmap-bg-pop");
        if (bp && !bp.contains(e.target) && e.target.id !== "bitmap-bg-btn") {
            if (typeof closeBitmapBgPop === "function") closeBitmapBgPop();
        }
    }
    // Close jiggle popup
    if (typeof jigglePopOpen !== "undefined" && jigglePopOpen) {
        const jp = document.getElementById("jiggle-pop");
        if (jp && !jp.contains(e.target) && e.target.id !== "jiggle-btn") {
            if (typeof closeJigglePop === "function") closeJigglePop();
        }
    }
    // Close fastmode popup
    if (typeof fastmodePopOpen !== "undefined" && fastmodePopOpen) {
        const fp = document.getElementById("fastmode-pop");
        if (fp && !fp.contains(e.target) && e.target.id !== "bitmap-fast-btn") {
            if (typeof closeFastmodePop === "function") closeFastmodePop();
        }
    }
    // Close path picker popup (revert on outside click)
    if (typeof pathPickOpen !== "undefined" && pathPickOpen) {
        const pp = document.getElementById("path-pick-pop");
        if (pp && !pp.contains(e.target) && !e.target.classList.contains("cpick-path-btn")) {
            if (typeof closePathPickPop === "function") closePathPickPop(true);
        }
    }
});

// --- Video recording (MediaRecorder ‚Üí WebM) ---

let vidRec = {
    recording: false,
    mode: "roots",   // "roots" | "coeffs" | "both"
    canvas: null,
    ctx: null,
    stream: null,
    mr: null,
    chunks: []
};

// --- Panel drawing helpers for recording ---

function drawPanelGrid(ctx, x0, y0, pW, pH, range) {
    const xs = v => MARGIN + (v + range) / (2 * range) * (pW - 2 * MARGIN) + x0;
    const ys = v => (pH - MARGIN) - (v + range) / (2 * range) * (pH - 2 * MARGIN) + y0;

    // Grid
    ctx.strokeStyle = "#1f3354"; ctx.lineWidth = 0.5;
    const intMax = Math.floor(range);
    for (let v = -intMax; v <= intMax; v++) {
        ctx.beginPath(); ctx.moveTo(xs(v), ys(-range)); ctx.lineTo(xs(v), ys(range)); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(xs(-range), ys(v)); ctx.lineTo(xs(range), ys(v)); ctx.stroke();
    }
    // Axes
    ctx.strokeStyle = "#2a4a6b"; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(xs(-range), ys(0)); ctx.lineTo(xs(range), ys(0)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(xs(0), ys(-range)); ctx.lineTo(xs(0), ys(range)); ctx.stroke();
    // Unit circle
    ctx.setLineDash([4, 3]);
    ctx.beginPath(); ctx.arc(xs(0), ys(0), Math.abs(xs(1) - xs(0)), 0, 2 * Math.PI); ctx.stroke();
    ctx.setLineDash([]);

    return { xs, ys };
}

function drawRootsToCtx(ctx, x0, y0, pW, pH) {
    const range = panels.roots.range;

    // Background + domain coloring
    if (domainColoringEnabled) {
        ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);
        ctx.drawImage(domainCanvas, x0 + MARGIN, y0 + MARGIN, pW - 2 * MARGIN, pH - 2 * MARGIN);
    } else {
        ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);
    }

    const { xs, ys } = drawPanelGrid(ctx, x0, y0, pW, pH, range);

    // Trails
    if (trailData.length > 0) {
        const jumpThresh = range * 0.3;
        ctx.lineWidth = 1.5; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.globalAlpha = 0.6;
        for (let i = 0; i < trailData.length; i++) {
            const pts = trailData[i];
            if (pts.length < 2) continue;
            ctx.strokeStyle = rootColor(i, trailData.length);
            ctx.beginPath(); ctx.moveTo(xs(pts[0].re), ys(pts[0].im));
            for (let j = 1; j < pts.length; j++) {
                const dist = Math.hypot(pts[j].re - pts[j-1].re, pts[j].im - pts[j-1].im);
                if (dist > jumpThresh) { ctx.stroke(); ctx.beginPath(); ctx.moveTo(xs(pts[j].re), ys(pts[j].im)); }
                else ctx.lineTo(xs(pts[j].re), ys(pts[j].im));
            }
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
    }

    // Root dots
    const nRoots = currentRoots.length;
    for (let i = 0; i < nRoots; i++) {
        const r = currentRoots[i];
        ctx.beginPath(); ctx.arc(xs(r.re), ys(r.im), 7, 0, 2 * Math.PI);
        ctx.fillStyle = rootColor(i, nRoots); ctx.fill();
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.stroke();
    }
}

function drawCoeffsToCtx(ctx, x0, y0, pW, pH) {
    const range = panels.coeff.range;

    ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);

    const { xs, ys } = drawPanelGrid(ctx, x0, y0, pW, pH, range);

    // Coefficient curve paths
    const nC = coefficients.length;
    ctx.lineWidth = 1.5; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.globalAlpha = 0.6;
    for (let idx = 0; idx < nC; idx++) {
        const c = coefficients[idx];
        if (c.pathType === "none" || !c.curve) continue;
        if (c.curve._isCloud) {
            // Dot cloud rendering
            ctx.fillStyle = coeffColor(idx, nC);
            for (const pt of c.curve) {
                ctx.beginPath(); ctx.arc(xs(pt.re), ys(pt.im), 1.5, 0, 2 * Math.PI); ctx.fill();
            }
        } else {
            const N = c.curve.length;
            ctx.strokeStyle = coeffColor(idx, nC);
            ctx.beginPath();
            for (let k = 0; k <= N; k++) {
                const pt = c.curve[k % N];
                if (k === 0) ctx.moveTo(xs(pt.re), ys(pt.im)); else ctx.lineTo(xs(pt.re), ys(pt.im));
            }
            ctx.closePath(); ctx.stroke();
        }
    }
    ctx.globalAlpha = 1.0;

    // Coefficient dots + labels
    for (let i = 0; i < nC; i++) {
        const c = coefficients[i];
        ctx.beginPath(); ctx.arc(xs(c.re), ys(c.im), 7, 0, 2 * Math.PI);
        ctx.fillStyle = coeffColor(i, nC); ctx.fill();
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.stroke();
        ctx.fillStyle = "#aaa"; ctx.font = "10px sans-serif"; ctx.textAlign = "left";
        ctx.fillText("c" + subscript(nC - 1 - i), xs(c.re) + 10, ys(c.im) + 4);
    }
}

function drawStatsToCtx(ctx, x0, y0, pW, pH) {
    drawAllStatsPlots();
    ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);
    const gapS = 2, cols = 4, rows = 4;
    const cellW = (pW - gapS * (cols - 1)) / cols;
    const cellH = (pH - gapS * (rows - 1)) / rows;
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const i = r * cols + c;
            const cx = x0 + c * (cellW + gapS);
            const cy = y0 + r * (cellH + gapS);
            if (statsState.canvases[i]) {
                ctx.drawImage(statsState.canvases[i], cx, cy, cellW, cellH);
            }
            // Plot label overlay
            const label = PLOT_OPTIONS[statsState.plotConfigs[i]] || "";
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.font = "bold 8px system-ui";
            ctx.textAlign = "left";
            ctx.fillText(label, cx + 3, cy + 10);
        }
    }
}

function drawSoundToCtx(ctx, x0, y0, pW, pH) {
    ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);
    ctx.textAlign = "left";
    const lineH = 16;
    const margin = 12;
    let y = y0 + margin + lineH;

    function drawSection(title, color, routes, config) {
        ctx.fillStyle = color; ctx.font = "bold 12px monospace";
        ctx.fillText(title, x0 + margin, y); y += lineH + 2;
        // Routes
        ctx.font = "11px monospace";
        for (const r of routes) {
            const src = r.source === "‚Äî" ? "(none)" : r.source;
            const line = `${src} ‚Üí ${r.target}  Œ±=${r.alpha.toFixed(2)} ${r.norm}`;
            ctx.fillStyle = r.source === "‚Äî" ? "rgba(255,255,255,0.25)" : "rgba(255,255,255,0.7)";
            ctx.fillText(line, x0 + margin + 8, y); y += lineH;
        }
        // Config params
        if (config) {
            y += 4;
            ctx.fillStyle = "rgba(255,255,255,0.4)"; ctx.font = "10px monospace";
            const entries = Object.entries(config).map(([k, v]) => `${k}=${typeof v === "number" ? (v < 1 ? v.toFixed(3) : v.toFixed(1)) : v}`);
            // Wrap at ~60 chars
            let line = "";
            for (const e of entries) {
                if (line.length + e.length > 55) {
                    ctx.fillText(line, x0 + margin + 8, y); y += lineH - 2;
                    line = e;
                } else {
                    line += (line ? "  " : "") + e;
                }
            }
            if (line) { ctx.fillText(line, x0 + margin + 8, y); y += lineH - 2; }
        }
        y += 8;
    }

    // Encounters config
    ctx.fillStyle = "#aaa"; ctx.font = "bold 11px monospace";
    ctx.fillText("ENCOUNTERS", x0 + margin, y); y += lineH;
    ctx.fillStyle = "rgba(255,255,255,0.5)"; ctx.font = "10px monospace";
    ctx.fillText(`Memory=${voiceConfig.decay.toFixed(4)}  Novelty=${voiceConfig.novelty.toFixed(2)}`, x0 + margin + 8, y);
    y += lineH + 8;

    drawSection("BASE ROUTING", "#5ddb6a", baseRoutes, baseConfig);
    drawSection("VOICE ROUTING", "#e94560", voiceRoutes, voiceConfig);
    drawSection("MELODY ROUTING", "#4ea8de", melodyRoutes, melodyConfig);
}

function drawBitmapToCtx(ctx, x0, y0, pW, pH) {
    const bc = document.getElementById("bitmap-canvas");
    if (bitmapCtx && bitmapActive && bc.width > 0 && bc.height > 0) {
        ctx.drawImage(bc, x0, y0, pW, pH);
    } else {
        ctx.fillStyle = bitmapCanvasColor; ctx.fillRect(x0, y0, pW, pH);
    }
}

function drawRightPanelToCtx(ctx, x0, y0, pW, pH) {
    if (activeTab === "stats") drawStatsToCtx(ctx, x0, y0, pW, pH);
    else if (activeTab === "sound") drawSoundToCtx(ctx, x0, y0, pW, pH);
    else if (activeTab === "bitmap") drawBitmapToCtx(ctx, x0, y0, pW, pH);
    else drawRootsToCtx(ctx, x0, y0, pW, pH);
}

function drawInfoBar(ctx, x0, y0, barW, barH) {
    ctx.fillStyle = "#0a0a1a"; ctx.fillRect(x0, y0, barW, barH);
    ctx.fillStyle = "#888"; ctx.font = "10px sans-serif"; ctx.textAlign = "left";
    const deg = coefficients.length - 1;
    const pat = document.getElementById("pattern").value;
    const animated = coefficients.filter(c => c.pathType !== "none").length;
    const parts = [
        `Degree ${deg}`,
        `Pattern: ${pat}`,
        `Tab: ${activeTab}`,
        `Animated: ${animated}/${coefficients.length}`,
        trailsEnabled ? "Trails: ON" : "Trails: OFF",
    ];
    ctx.fillText(parts.join("   ¬∑   "), x0 + 8, y0 + barH * 0.65);
}

function recordTick() {
    if (!vidRec.recording) return;
    const ctx = vidRec.ctx;
    const mode = vidRec.mode;
    const gap = 8;
    const infoH = 20;

    if (mode === "roots") {
        ctx.clearRect(0, 0, S, S);
        drawRootsToCtx(ctx, 0, 0, S, S);
    } else if (mode === "coeffs") {
        ctx.clearRect(0, 0, S, S);
        drawCoeffsToCtx(ctx, 0, 0, S, S);
    } else if (mode === "stats") {
        ctx.clearRect(0, 0, S, S);
        drawStatsToCtx(ctx, 0, 0, S, S);
    } else if (mode === "sound") {
        ctx.clearRect(0, 0, S, S);
        drawSoundToCtx(ctx, 0, 0, S, S);
    } else if (mode === "bitmap") {
        ctx.clearRect(0, 0, S, S);
        drawBitmapToCtx(ctx, 0, 0, S, S);
    } else if (mode === "full") {
        const totalW = S * 2 + gap;
        ctx.fillStyle = "#0f1026"; ctx.fillRect(0, 0, totalW, S + infoH);
        drawCoeffsToCtx(ctx, 0, 0, S, S);
        drawRightPanelToCtx(ctx, S + gap, 0, S, S);
        drawInfoBar(ctx, 0, S, totalW, infoH);
    } else {
        // "both" ‚Äî tab-aware side by side
        const totalW = S * 2 + gap;
        ctx.fillStyle = "#0f1026"; ctx.fillRect(0, 0, totalW, S);
        drawCoeffsToCtx(ctx, 0, 0, S, S);
        drawRightPanelToCtx(ctx, S + gap, 0, S, S);
    }
}

function startRecording() {
    if (vidRec.recording) return;

    const mode = document.getElementById("rec-mode").value;
    vidRec.mode = mode;

    const dpr = window.devicePixelRatio || 1;
    const gap = 8;
    const infoH = 20;
    const isDual = mode === "both" || mode === "full";
    const logW = isDual ? S * 2 + gap : S;
    const logH = mode === "full" ? S + infoH : S;

    if (!vidRec.canvas) {
        vidRec.canvas = document.createElement("canvas");
        vidRec.ctx = vidRec.canvas.getContext("2d");
    }
    vidRec.canvas.width = Math.floor(logW * dpr);
    vidRec.canvas.height = Math.floor(logH * dpr);
    vidRec.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const stream = vidRec.canvas.captureStream(60);
    // Merge audio track if sound is active
    if (audioNodes && audioNodes.mediaDest) {
        for (const track of audioNodes.mediaDest.stream.getAudioTracks()) {
            stream.addTrack(track);
        }
    }
    vidRec.stream = stream;
    vidRec.chunks = [];

    const candidates = ["video/webm;codecs=vp9", "video/webm;codecs=vp8", "video/webm"];
    let mimeType = "";
    for (const c of candidates) { if (MediaRecorder.isTypeSupported(c)) { mimeType = c; break; } }

    const mr = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
    vidRec.mr = mr;

    mr.ondataavailable = e => { if (e.data && e.data.size) vidRec.chunks.push(e.data); };
    mr.onerror = e => console.warn("MediaRecorder error:", e.error || e);
    mr.onstop = () => {
        if (!vidRec.chunks.length) {
            console.warn("Recording produced no data ‚Äî not saving.");
            return;
        }
        const blob = new Blob(vidRec.chunks, { type: mr.mimeType || "video/webm" });
        const url = URL.createObjectURL(blob);
        const now = new Date();
        const ts = now.toISOString().replace(/[:.]/g, "-").slice(0, 19);
        const suffix = (mode === "both") ? "both-" + activeTab : mode;
        const basename = `polypaint-${suffix}-${ts}`;

        // Download video
        const a = document.createElement("a");
        a.href = url;
        a.download = `${basename}.webm`;
        a.click();
        URL.revokeObjectURL(url);

        // Download JSON metadata (mirrors snap metadata)
        const meta = {
            type: "recording",
            mode: mode,
            activeTab: activeTab,
            timestamp: now.toISOString(),
            degree: coefficients.length - 1,
            pattern: document.getElementById("pattern").value,
            domainColoring: domainColoringEnabled,
            rootColoring: rootColorMode !== "uniform",
            rootColorMode: rootColorMode,
            uniformRootColor: uniformRootColor.slice(),
            bitmapCanvasColor: bitmapCanvasColor,
            trails: trailsEnabled,
            selectedCoeffs: [...selectedCoeffs],
            selectedRoots: [...selectedRoots],
            coefficients: coefficients.map(c => ({
                pos: [c.re, c.im],
                home: c.curve ? [c.curve[0].re, c.curve[0].im] : [c.re, c.im],
                pathType: c.pathType, radius: c.radius, speed: c.speed,
                angle: c.angle, ccw: c.ccw
            })),
            roots: currentRoots.map(r => [r.re, r.im]),
            panels: {
                coeff: { range: panels.coeff.range },
                roots: { range: panels.roots.range }
            }
        };
        const jsonBlob = new Blob([JSON.stringify(meta, null, 2)], { type: "application/json" });
        const a2 = document.createElement("a");
        a2.href = URL.createObjectURL(jsonBlob);
        a2.download = `${basename}.json`;
        a2.click();
        URL.revokeObjectURL(a2.href);
    };

    vidRec.recording = true;
    mr.start(200);
    recordTick();          // draw first frame AFTER recorder starts

    document.getElementById("rec-roots-btn").classList.add("recording");
    document.getElementById("stop-roots-btn").style.display = "";
}

function stopRecording() {
    if (!vidRec.recording) return;
    vidRec.recording = false;
    if (vidRec.mr && vidRec.mr.state !== "inactive") {
        try { vidRec.mr.requestData(); } catch (_) {}  // flush pending data
        vidRec.mr.stop();
    }
    vidRec.mr = null;
    vidRec.stream = null;

    document.getElementById("rec-roots-btn").classList.remove("recording");
    document.getElementById("stop-roots-btn").style.display = "none";
}

document.getElementById("rec-roots-btn").addEventListener("click", startRecording);
document.getElementById("stop-roots-btn").addEventListener("click", stopRecording);

// --- State metadata ---

function buildStateMetadata(timestamp) {
    return {
        timestamp: timestamp || new Date().toISOString(),
        degree: coefficients.length - 1,
        pattern: document.getElementById("pattern").value,
        domainColoring: domainColoringEnabled,
        rootColoring: rootColorMode !== "uniform",
        rootColorMode: rootColorMode,
        uniformRootColor: uniformRootColor.slice(),
        bitmapCanvasColor: bitmapCanvasColor,
        trails: trailsEnabled,
        trailComplete: trailComplete,
        animPlaying: animState.playing,
        activeTab: activeTab,
        selectedCoeffs: [...selectedCoeffs],
        selectedRoots: [...selectedRoots],
        coefficients: coefficients.map(c => ({
            pos: [c.re, c.im],
            home: c.curve ? [c.curve[0].re, c.curve[0].im] : [c.re, c.im],
            pathType: c.pathType, radius: c.radius, speed: c.speed,
            angle: c.angle, ccw: c.ccw, extra: c.extra || {}
        })),
        roots: currentRoots.map(r => [r.re, r.im]),
        panels: {
            coeff: { range: panels.coeff.range },
            roots: { range: panels.roots.range }
        },
        trailData: trailData.map(pts => pts.map(p => [p.re, p.im])),
        jiggle: { mode: jiggleMode, sigma: jiggleSigma, theta: jiggleTheta, scaleStep: jiggleScaleStep }
    };
}

// --- Snap (capture) ---

function snapDownload(canvas, mode) {
    const now = new Date();
    const ts = now.toISOString().replace(/[:.]/g, "-").slice(0, 19);
    let suffix = mode;
    if (mode === "both") suffix = "both-" + activeTab;
    const basename = `polypaint-${suffix}-${ts}`;

    const meta = buildStateMetadata(now.toISOString());
    meta.snapMode = mode;
    meta.activeTab = activeTab;

    canvas.toBlob(function (blob) {
        if (!blob) return;
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `${basename}.png`;
        a.click();
        URL.revokeObjectURL(a.href);
    }, "image/png");

    const jsonBlob = new Blob([JSON.stringify(meta, null, 2)], { type: "application/json" });
    const a2 = document.createElement("a");
    a2.href = URL.createObjectURL(jsonBlob);
    a2.download = `${basename}.json`;
    a2.click();
    URL.revokeObjectURL(a2.href);
}

function snapCapture(mode) {
    if (!mode) mode = "both";

    // "full" mode: capture the entire app UI via html2canvas
    if (mode === "full") {
        if (typeof html2canvas !== "function") {
            console.warn("html2canvas not loaded ‚Äî falling back to 'both' mode");
            mode = "both";
        } else {
            // Close the snap popup first so it doesn't appear in the capture
            closeSnapPop();
            // Small delay to let the popup close render
            requestAnimationFrame(() => {
                html2canvas(document.body, {
                    backgroundColor: "#0f1026",
                    scale: window.devicePixelRatio || 1,
                    useCORS: true,
                    logging: false,
                    onclone: function(clonedDoc) {
                        clonedDoc.querySelectorAll("svg").forEach(svg => {
                            svg.style.overflow = "visible";
                        });
                        // Replace range inputs with visual track+thumb divs
                        const origRanges = document.querySelectorAll('input[type="range"]');
                        const cloneRanges = clonedDoc.querySelectorAll('input[type="range"]');
                        for (let i = cloneRanges.length - 1; i >= 0; i--) {
                            const clone = cloneRanges[i];
                            const orig = origRanges[i];
                            if (!orig || !clone.parentNode) continue;
                            const val = parseFloat(orig.value);
                            const min = parseFloat(orig.min || 0);
                            const max = parseFloat(orig.max || 100);
                            const pct = Math.max(0, Math.min(100, ((val - min) / (max - min)) * 100));
                            const rect = orig.getBoundingClientRect();
                            const w = rect.width || 100;
                            const h = rect.height || 20;
                            const wrap = clonedDoc.createElement("div");
                            wrap.style.cssText = `display:inline-block;width:${w}px;height:${h}px;position:relative;vertical-align:middle;`;
                            const track = clonedDoc.createElement("div");
                            track.style.cssText = "position:absolute;top:50%;left:2px;right:2px;height:4px;margin-top:-2px;border-radius:2px;background:rgba(255,255,255,0.12);";
                            wrap.appendChild(track);
                            const fill = clonedDoc.createElement("div");
                            fill.style.cssText = `position:absolute;top:50%;left:2px;width:${pct * (w - 4) / 100}px;height:4px;margin-top:-2px;border-radius:2px;background:#e94560;`;
                            wrap.appendChild(fill);
                            const thumb = clonedDoc.createElement("div");
                            const thumbX = 2 + pct * (w - 4) / 100;
                            thumb.style.cssText = `position:absolute;top:50%;left:${thumbX}px;width:10px;height:10px;margin-top:-5px;margin-left:-5px;border-radius:50%;background:#fff;box-shadow:0 0 3px rgba(0,0,0,0.5);`;
                            wrap.appendChild(thumb);
                            clone.parentNode.replaceChild(wrap, clone);
                        }
                        // Replace select elements with styled text divs
                        const origSelects = document.querySelectorAll("select");
                        const cloneSelects = clonedDoc.querySelectorAll("select");
                        for (let i = cloneSelects.length - 1; i >= 0; i--) {
                            const clone = cloneSelects[i];
                            const orig = origSelects[i];
                            if (!orig || !clone.parentNode) continue;
                            const text = orig.options[orig.selectedIndex]?.text || "";
                            const rect = orig.getBoundingClientRect();
                            const w = rect.width || 80;
                            const h = rect.height || 24;
                            const cs = window.getComputedStyle(orig);
                            const div = clonedDoc.createElement("div");
                            div.style.cssText = `display:inline-flex;align-items:center;width:${w}px;height:${h}px;` +
                                `background:rgba(255,255,255,0.04);color:${cs.color};` +
                                `border:1px solid rgba(255,255,255,0.08);border-radius:6px;` +
                                `padding:2px 6px;font-size:${cs.fontSize};font-family:${cs.fontFamily};` +
                                `box-sizing:border-box;overflow:hidden;white-space:nowrap;`;
                            div.textContent = text + " ‚ñæ";
                            clone.parentNode.replaceChild(div, clone);
                        }
                    }
                }).then(canvas => {
                    snapDownload(canvas, "full");
                }).catch(err => {
                    console.warn("html2canvas failed:", err);
                });
            });
            return;
        }
    }

    const dpr = window.devicePixelRatio || 1;
    const gap = 16;
    const headerH = 24;

    const TAB_LABELS = { roots: "ROOTS", stats: "STATS", sound: "SOUND", bitmap: "BITMAP" };
    const rightLabel = TAB_LABELS[activeTab] || "ROOTS";

    // Determine canvas dimensions
    let cw, ch;
    const isSingle = mode === "coeffs" || mode === "roots" || mode === "stats" || mode === "sound";
    if (mode === "bitmap") {
        const bc = document.getElementById("bitmap-canvas");
        if (!bitmapCtx || !bitmapActive || bc.width === 0) return; // nothing to export
        cw = bc.width; ch = bc.height;
    } else if (isSingle) {
        cw = S; ch = S + headerH;
    } else {
        // "both" (default)
        cw = 2 * S + gap; ch = S + headerH;
    }

    const canvas = document.createElement("canvas");
    if (mode === "bitmap") {
        canvas.width = cw; canvas.height = ch; // native resolution, no DPR
    } else {
        canvas.width = cw * dpr; canvas.height = ch * dpr;
    }
    const ctx = canvas.getContext("2d");
    if (mode !== "bitmap") ctx.scale(dpr, dpr);

    // Background
    ctx.fillStyle = "#0f0f23";
    ctx.fillRect(0, 0, cw, ch);

    if (mode === "bitmap") {
        // Direct copy at native resolution
        ctx.drawImage(document.getElementById("bitmap-canvas"), 0, 0);
    } else if (isSingle) {
        // Single panel
        const label = mode === "coeffs" ? "COEFFICIENTS" : mode === "roots" ? "ROOTS" : mode === "stats" ? "STATS" : "SOUND";
        ctx.fillStyle = "#666"; ctx.font = "11px sans-serif"; ctx.textAlign = "center";
        ctx.fillText(label, S / 2, 16);

        if (mode === "coeffs") drawCoeffsToCtx(ctx, 0, headerH, S, S);
        else if (mode === "roots") drawRootsToCtx(ctx, 0, headerH, S, S);
        else if (mode === "stats") drawStatsToCtx(ctx, 0, headerH, S, S);
        else if (mode === "sound") drawSoundToCtx(ctx, 0, headerH, S, S);
    } else {
        // "both" ‚Äî two panels, tab-aware
        ctx.fillStyle = "#666"; ctx.font = "11px sans-serif"; ctx.textAlign = "center";
        ctx.fillText("COEFFICIENTS", S / 2, 16);
        ctx.fillText(rightLabel, S + gap + S / 2, 16);

        drawCoeffsToCtx(ctx, 0, headerH, S, S);
        drawRightPanelToCtx(ctx, S + gap, headerH, S, S);
    }

    snapDownload(canvas, mode);
}

// --- Snap popup ---

const snapPop = document.getElementById("snap-pop");
let snapPopOpen = false;

function closeSnapPop() {
    snapPop.classList.remove("open");
    snapPopOpen = false;
}

function openSnapPop() {
    if (snapPopOpen) { closeSnapPop(); return; }
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeColorPop === "function") closeColorPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();
    if (typeof closeAudioPop === "function") closeAudioPop();
    snapPop.innerHTML = "";
    const modes = [
        { value: "both", label: "Both" },
        { value: "coeffs", label: "Coeffs" },
        { value: "roots", label: "Roots" },
        { value: "stats", label: "Stats" },
        { value: "sound", label: "Sound" },
        { value: "bitmap", label: "Bitmap" },
        { value: "full", label: "Full" },
    ];
    const title = document.createElement("div");
    title.className = "pop-title";
    title.textContent = "EXPORT";
    snapPop.appendChild(title);
    for (const m of modes) {
        const btn = document.createElement("button");
        btn.style.cssText = "width:100%;font-size:10px;padding:5px 10px;text-align:left;border:none;background:transparent;color:var(--muted);cursor:pointer;border-radius:6px;";
        btn.onmouseenter = () => { btn.style.background = "rgba(255,255,255,0.08)"; btn.style.color = "var(--text)"; };
        btn.onmouseleave = () => { btn.style.background = "transparent"; btn.style.color = "var(--muted)"; };
        btn.textContent = m.label;
        btn.addEventListener("click", () => { closeSnapPop(); snapCapture(m.value); });
        snapPop.appendChild(btn);
    }
    snapPop.classList.add("open");
    const r = document.getElementById("snap-btn").getBoundingClientRect();
    snapPop.style.left = r.left + "px";
    snapPop.style.top = (r.bottom + 6) + "px";
    snapPopOpen = true;
}

document.getElementById("snap-btn").addEventListener("click", openSnapPop);

// --- Save / Load state ---

async function saveState() {
    const meta = buildStateMetadata();
    const json = JSON.stringify(meta, null, 2);
    const ts = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
    if (window.showSaveFilePicker) {
        try {
            const handle = await window.showSaveFilePicker({
                suggestedName: `polypaint-${ts}.json`,
                types: [{ description: "JSON", accept: { "application/json": [".json"] } }]
            });
            const w = await handle.createWritable();
            await w.write(json);
            await w.close();
            return;
        } catch (e) { if (e.name === "AbortError") return; }
    }
    const blob = new Blob([json], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `polypaint-${ts}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
}

async function loadState() {
    let text;
    if (window.showOpenFilePicker) {
        try {
            const [handle] = await window.showOpenFilePicker({
                types: [{ description: "JSON", accept: { "application/json": [".json"] } }]
            });
            const file = await handle.getFile();
            text = await file.text();
        } catch (e) { if (e.name === "AbortError") return; throw e; }
    } else {
        text = await new Promise((resolve, reject) => {
            const input = document.createElement("input");
            input.type = "file"; input.accept = ".json";
            input.onchange = async () => {
                if (input.files[0]) resolve(await input.files[0].text());
                else reject(new Error("No file selected"));
            };
            input.click();
        });
    }
    applyLoadedState(JSON.parse(text));
}

function applyLoadedState(meta) {
    // 1. Stop animation, clear everything
    stopAnimation();
    playBtn.textContent = "\u25b6 Play";
    lastSelectedCoeff = -1;
    clearAllSelection();
    clearTrails();
    clearStatsData();
    resetAudioState();
    renderCoeffTrails();
    currentRoots = [];
    rootsLayer.selectAll("circle.root").remove();

    // 2. Set degree + pattern (without triggering applyPattern)
    const deg = meta.degree || 5;
    currentDegree = deg;
    degreeNumber.textContent = deg;
    if (meta.pattern) document.getElementById("pattern").value = meta.pattern;

    // 3. Rebuild coefficients array from saved data
    const n = deg + 1;
    coefficients = [];
    for (let i = 0; i < n; i++) {
        const saved = meta.coefficients[i];
        if (!saved) { coefficients.push({ re: 0, im: 0, curve: null, pathType: "none", radius: 25, speed: 1, angle: 0, ccw: false, extra: {} }); continue; }
        const home = saved.home || saved.pos;
        coefficients.push({
            re: home[0], im: home[1],
            curve: null,
            pathType: saved.pathType || "none",
            radius: saved.radius ?? 25,
            speed: saved.speed ?? 1,
            angle: saved.angle ?? 0,
            ccw: saved.ccw ?? false,
            extra: saved.extra || {}
        });
    }

    // 4. Set panel ranges (must happen before computeCurve so coeffExtent works with correct scale)
    if (meta.panels) {
        if (meta.panels.coeff) { panels.coeff.range = meta.panels.coeff.range; initPanelScales(panels.coeff); drawGrid(coeffSvg, panels.coeff); }
        if (meta.panels.roots) { panels.roots.range = meta.panels.roots.range; initPanelScales(panels.roots); drawGrid(rootsSvg, panels.roots); }
    }

    // 5. Regenerate curves for animated coefficients
    for (const c of coefficients) {
        if (c.pathType !== "none") {
            c.curve = computeCurve(c.re, c.im, c.pathType, c.radius / 100 * coeffExtent(), c.angle, c.extra);
        }
    }

    // 6. Restore roots
    if (meta.roots && meta.roots.length) {
        currentRoots = meta.roots.map(r => ({ re: r[0], im: r[1] }));
    } else {
        solveRoots();
    }

    // 7. Restore UI flags + sync buttons
    trailsEnabled = meta.trails || false;
    trailsBtn.classList.toggle("active", trailsEnabled);
    trailComplete = meta.trailComplete || false;

    domainColoringEnabled = meta.domainColoring || false;
    domainToggleBtn.classList.toggle("active", domainColoringEnabled);
    domainCanvas.style.display = domainColoringEnabled ? "block" : "none";
    rootsSvg.classed("domain-active", domainColoringEnabled);

    if (meta.rootColorMode) {
        rootColorMode = meta.rootColorMode;
    } else if (meta.rootColoring !== undefined) {
        rootColorMode = meta.rootColoring ? "rainbow" : "uniform";
    }
    if (meta.uniformRootColor && Array.isArray(meta.uniformRootColor)) {
        uniformRootColor = meta.uniformRootColor.slice();
    }
    if (meta.bitmapCanvasColor) {
        bitmapCanvasColor = meta.bitmapCanvasColor;
        document.getElementById("bitmap-container").style.background = bitmapCanvasColor;
    }
    rootColorBtn.classList.toggle("active", rootColorMode !== "uniform");

    // 8. Restore trail data
    if (meta.trailData && meta.trailData.length) {
        trailData = meta.trailData.map(pts => pts.map(p => ({ re: p[0], im: p[1] })));
    }

    // 9. Restore jiggle settings
    if (meta.jiggle) {
        jiggleMode = meta.jiggle.mode || "random";
        jiggleSigma = meta.jiggle.sigma ?? 10;
        jiggleTheta = meta.jiggle.theta ?? 0.01;
        jiggleScaleStep = meta.jiggle.scaleStep ?? 5;
    }
    jiggleCumulativeAngle = 0;
    jiggleCumulativeScale = 1.0;
    jiggleOffsets = null;

    // 10. Restore selections
    if (meta.selectedCoeffs) for (const idx of meta.selectedCoeffs) selectedCoeffs.add(idx);
    if (meta.selectedRoots) for (const idx of meta.selectedRoots) selectedRoots.add(idx);

    // 10. Re-render everything
    renderCoefficients();
    renderRoots(currentRoots);
    renderCoeffTrails();
    if (trailData.length) renderTrails();
    if (domainColoringEnabled) renderDomainColoring();
    updateCoeffSelectionVisual();
    updateRootSelectionVisual();
}

document.getElementById("save-btn").addEventListener("click", saveState);
document.getElementById("load-btn").addEventListener("click", loadState);

// --- Resize handler ---

// --- Stats tab ---

(function initStatsCanvases() {
    const canvases = document.querySelectorAll(".stats-canvas");
    const selects = document.querySelectorAll(".stats-select");
    canvases.forEach((c, i) => {
        statsState.canvases[i] = c;
        statsState.ctxs[i] = c.getContext("2d");
    });
    selects.forEach((sel, plotIdx) => {
        PLOT_OPTIONS.forEach((name, si) => {
            const opt = document.createElement("option");
            opt.value = si; opt.textContent = name;
            sel.appendChild(opt);
        });
        sel.value = statsState.plotConfigs[plotIdx];
        sel.addEventListener("change", () => {
            statsState.plotConfigs[plotIdx] = parseInt(sel.value);
            drawStatsPlot(plotIdx);
        });
    });
    // Init ring buffers
    for (const name of STAT_TYPES) statsState.buffers[name] = new Float64Array(statsState.maxFrames);
})();

function resizeStatsCanvases() {
    const dpr = window.devicePixelRatio || 1;
    for (let i = 0; i < 16; i++) {
        const c = statsState.canvases[i];
        if (!c) continue;
        const rect = c.getBoundingClientRect();
        c.width = Math.floor(rect.width * dpr);
        c.height = Math.floor(rect.height * dpr);
        statsState.ctxs[i].setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    statsState.dirty = true;
}

function cacheRootForces() {
    // Per-root sensitivity w.r.t. moving coefficients ‚Äî cached for Force/MinForce/MaxForce
    const nRoots = currentRoots.length;
    const nCoeffs = coefficients.length;
    const deg = nCoeffs - 1;
    if (!statsState.rootForces || statsState.rootForces.length !== nRoots) {
        statsState.rootForces = new Float64Array(nRoots);
    }
    if (nRoots === 0 || nCoeffs === 0) { statsState.rootForces.fill(0); return; }

    const movingSet = allAnimatedCoeffs();
    if (movingSet.size === 0) { statsState.rootForces.fill(0); return; }

    const cRe = new Float64Array(nCoeffs);
    const cIm = new Float64Array(nCoeffs);
    for (let i = 0; i < nCoeffs; i++) { cRe[i] = coefficients[i].re; cIm[i] = coefficients[i].im; }

    const invDpMag = new Float64Array(nRoots);
    const rMag = new Float64Array(nRoots);
    for (let j = 0; j < nRoots; j++) {
        const zRe = currentRoots[j].re, zIm = currentRoots[j].im;
        rMag[j] = Math.hypot(zRe, zIm);
        let pRe = cRe[0], pIm = cIm[0], dpRe = 0, dpIm = 0;
        for (let k = 1; k <= deg; k++) {
            const ndRe = dpRe * zRe - dpIm * zIm + pRe;
            const ndIm = dpRe * zIm + dpIm * zRe + pIm;
            dpRe = ndRe; dpIm = ndIm;
            const npRe = pRe * zRe - pIm * zIm + cRe[k];
            const npIm = pRe * zIm + pIm * zRe + cIm[k];
            pRe = npRe; pIm = npIm;
        }
        const dm = Math.hypot(dpRe, dpIm);
        invDpMag[j] = dm < 1e-30 ? 0 : 1 / dm;
    }

    for (let j = 0; j < nRoots; j++) {
        let f = 0;
        for (const k of movingSet) {
            f += Math.pow(rMag[j], deg - k) * invDpMag[j];
        }
        statsState.rootForces[j] = f;
    }
}

function computeForce() {
    const rf = statsState.rootForces;
    if (!rf || rf.length === 0) return 0;
    let total = 0;
    for (let j = 0; j < rf.length; j++) total += rf[j];
    return total;
}

function computeMinForce() {
    const rf = statsState.rootForces;
    if (!rf || rf.length === 0) return 0;
    let m = Infinity;
    for (let j = 0; j < rf.length; j++) if (rf[j] < m) m = rf[j];
    return m === Infinity ? 0 : m;
}

function computeMaxForce() {
    const rf = statsState.rootForces;
    if (!rf || rf.length === 0) return 0;
    let m = 0;
    for (let j = 0; j < rf.length; j++) if (rf[j] > m) m = rf[j];
    return m;
}

function computeSpeed() {
    const n = currentRoots.length;
    if (!statsState.prevRoots || statsState.prevRoots.length !== n) return 0;
    let total = 0;
    for (let i = 0; i < n; i++) {
        const dx = currentRoots[i].re - statsState.prevRoots[i].re;
        const dy = currentRoots[i].im - statsState.prevRoots[i].im;
        total += Math.hypot(dx, dy);
    }
    return total;
}

function computeMinDist() {
    const n = currentRoots.length;
    if (n < 2) return 0;
    let minD = Infinity;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const dx = currentRoots[i].re - currentRoots[j].re;
            const dy = currentRoots[i].im - currentRoots[j].im;
            const d = Math.hypot(dx, dy);
            if (d < minD) minD = d;
        }
    }
    return minD;
}

function computeMaxDist() {
    const n = currentRoots.length;
    if (n < 2) return 0;
    let maxD = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const dx = currentRoots[i].re - currentRoots[j].re;
            const dy = currentRoots[i].im - currentRoots[j].im;
            const d = Math.hypot(dx, dy);
            if (d > maxD) maxD = d;
        }
    }
    return maxD;
}

function computeRecords() {
    // Count per-pair closeness record updates using voiceConfig.novelty & .decay
    const n = currentRoots.length;
    if (n < 2) return 0;
    const nPairs = n * (n - 1) / 2;

    let seeding = false;
    if (!pairRecords || pairRecords.length !== nPairs) {
        pairRecords = new Float64Array(nPairs).fill(Infinity);
        seeding = true;
    }

    let count = 0;
    let idx = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const d = Math.hypot(
                currentRoots[i].re - currentRoots[j].re,
                currentRoots[i].im - currentRoots[j].im
            );
            if (seeding) {
                pairRecords[idx] = d;
            } else if (d < pairRecords[idx]) {
                count++;
                pairRecords[idx] = d * voiceConfig.novelty;
            }
            idx++;
        }
    }

    // Decay all records (memory > 1.0 ‚Üí records grow, becoming beatable again)
    if (!seeding) {
        for (let k = 0; k < nPairs; k++) {
            pairRecords[k] *= voiceConfig.decay;
        }
    }

    return count;
}

function computeMeanDist() {
    const n = currentRoots.length;
    if (n < 2) return 0;
    let total = 0;
    let count = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            total += Math.hypot(
                currentRoots[i].re - currentRoots[j].re,
                currentRoots[i].im - currentRoots[j].im
            );
            count++;
        }
    }
    return total / count;
}

function computeDeltaMeanDist() {
    // Read the just-written MeanDist from the current buffer slot
    const cur = statsState.buffers["MeanDist"][statsState.writeIdx];
    const prev = statsState.prevMeanDist;
    statsState.prevMeanDist = cur;
    if (prev === null) return 0;
    return Math.abs(cur - prev);
}

function computeMinSpeed() {
    const s = statsState.rootSpeeds;
    if (!s || s.length === 0) return 0;
    let m = Infinity;
    for (let i = 0; i < s.length; i++) if (s[i] < m) m = s[i];
    return m === Infinity ? 0 : m;
}

function computeMaxSpeed() {
    const s = statsState.rootSpeeds;
    if (!s || s.length === 0) return 0;
    let m = 0;
    for (let i = 0; i < s.length; i++) if (s[i] > m) m = s[i];
    return m;
}

function computeAngularMom() {
    // Œ£ (r‚±º ‚àí centroid) √ó v‚±º  (2D cross product, signed)
    const n = currentRoots.length;
    if (n === 0 || !statsState.prevRoots || statsState.prevRoots.length !== n) return 0;
    let cx = 0, cy = 0;
    for (let i = 0; i < n; i++) { cx += currentRoots[i].re; cy += currentRoots[i].im; }
    cx /= n; cy /= n;
    let L = 0;
    for (let i = 0; i < n; i++) {
        const rx = currentRoots[i].re - cx;
        const ry = currentRoots[i].im - cy;
        const vx = currentRoots[i].re - statsState.prevRoots[i].re;
        const vy = currentRoots[i].im - statsState.prevRoots[i].im;
        L += rx * vy - ry * vx;
    }
    return L;
}

function computeSigmaSpeed() {
    const s = statsState.rootSpeeds;
    if (!s || s.length === 0) return 0;
    const n = s.length;
    let sum = 0;
    for (let i = 0; i < n; i++) sum += s[i];
    const mean = sum / n;
    let var_ = 0;
    for (let i = 0; i < n; i++) { const d = s[i] - mean; var_ += d * d; }
    return Math.sqrt(var_ / n);
}

function computeEMASpeed() {
    // Read the just-written Speed from the current buffer slot
    const cur = statsState.buffers["Speed"][statsState.writeIdx];
    statsState.emaSpeed += 0.05 * (cur - statsState.emaSpeed);
    return statsState.emaSpeed;
}

function computeSigmaDist() {
    const n = currentRoots.length;
    if (n < 2) return 0;
    // Read the just-written MeanDist
    const mean = statsState.buffers["MeanDist"][statsState.writeIdx];
    let var_ = 0, count = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const d = Math.hypot(
                currentRoots[i].re - currentRoots[j].re,
                currentRoots[i].im - currentRoots[j].im
            ) - mean;
            var_ += d * d;
            count++;
        }
    }
    return Math.sqrt(var_ / count);
}

function computeOdometer() {
    const od = statsState.rootOdometers;
    if (!od) return 0;
    let total = 0;
    for (let i = 0; i < od.length; i++) total += od[i];
    return total;
}
function computeCycleCount() {
    return statsState.odometerCycleCount;
}

function computeMedianR() {
    // Median radius from centroid (same as audio r50), smoothed
    const n = currentRoots.length;
    if (n === 0) return 0;
    let cx = 0, cy = 0;
    for (let i = 0; i < n; i++) { cx += currentRoots[i].re; cy += currentRoots[i].im; }
    cx /= n; cy /= n;
    const radii = new Array(n);
    for (let i = 0; i < n; i++) radii[i] = Math.hypot(currentRoots[i].re - cx, currentRoots[i].im - cy);
    radii.sort((a, b) => a - b);
    const raw = percentileSorted(radii, 0.50);
    statsState.smoothMedianR += AUDIO_ALPHA * (raw - statsState.smoothMedianR);
    return statsState.smoothMedianR;
}

function computeSpread() {
    // r90 - r10 radius spread from centroid, smoothed
    const n = currentRoots.length;
    if (n === 0) return 0;
    let cx = 0, cy = 0;
    for (let i = 0; i < n; i++) { cx += currentRoots[i].re; cy += currentRoots[i].im; }
    cx /= n; cy /= n;
    const radii = new Array(n);
    for (let i = 0; i < n; i++) radii[i] = Math.hypot(currentRoots[i].re - cx, currentRoots[i].im - cy);
    radii.sort((a, b) => a - b);
    const raw = percentileSorted(radii, 0.90) - percentileSorted(radii, 0.10);
    statsState.smoothSpread += AUDIO_ALPHA * (raw - statsState.smoothSpread);
    return statsState.smoothSpread;
}

function computeEMed() {
    // 50th percentile of per-root speeds, smoothed
    const s = statsState.rootSpeeds;
    if (!s || s.length === 0) return 0;
    const sorted = Array.from(s).sort((a, b) => a - b);
    const raw = percentileSorted(sorted, 0.50);
    statsState.smoothEMed += AUDIO_ALPHA * (raw - statsState.smoothEMed);
    return statsState.smoothEMed;
}

function computeEHi() {
    // 85th percentile of per-root speeds, smoothed
    const s = statsState.rootSpeeds;
    if (!s || s.length === 0) return 0;
    const sorted = Array.from(s).sort((a, b) => a - b);
    const raw = percentileSorted(sorted, 0.85);
    statsState.smoothEHi += AUDIO_ALPHA * (raw - statsState.smoothEHi);
    return statsState.smoothEHi;
}

function computeCoherence() {
    // Angular coherence R = |mean(e^{iŒ∏})| around centroid, smoothed
    const n = currentRoots.length;
    if (n === 0) return 0;
    let cx = 0, cy = 0;
    for (let i = 0; i < n; i++) { cx += currentRoots[i].re; cy += currentRoots[i].im; }
    cx /= n; cy /= n;
    let au = 0, av = 0;
    for (let i = 0; i < n; i++) {
        const th = Math.atan2(currentRoots[i].im - cy, currentRoots[i].re - cx);
        au += Math.cos(th); av += Math.sin(th);
    }
    const raw = Math.hypot(au / n, av / n);
    statsState.smoothCoherence += AUDIO_ALPHA * (raw - statsState.smoothCoherence);
    return statsState.smoothCoherence;
}

function computeEncounters() {
    // Per-root top-3 closest distance records (mirrors audio close encounters), smoothed count
    const n = currentRoots.length;
    if (n < 2) return 0;
    const K = 3;

    let seeding = false;
    if (!statsState.statsEncounters || statsState.statsEncounters.length !== n * K) {
        statsState.statsEncounters = new Float64Array(n * K).fill(Infinity);
        seeding = true;
    }

    let count = 0;
    for (let i = 0; i < n; i++) {
        const closest = [Infinity, Infinity, Infinity];
        for (let j = 0; j < n; j++) {
            if (j === i) continue;
            const d = Math.hypot(currentRoots[i].re - currentRoots[j].re,
                                 currentRoots[i].im - currentRoots[j].im);
            if (d < closest[2]) {
                closest[2] = d;
                if (closest[2] < closest[1]) { const t = closest[1]; closest[1] = closest[2]; closest[2] = t; }
                if (closest[1] < closest[0]) { const t = closest[0]; closest[0] = closest[1]; closest[1] = t; }
            }
        }

        const base = i * K;
        if (seeding) {
            for (let k = 0; k < K; k++) statsState.statsEncounters[base + k] = closest[k];
        } else {
            for (let k = 0; k < K; k++) {
                const worstIdx = base + K - 1;
                if (closest[k] < statsState.statsEncounters[worstIdx]) {
                    count++;
                    statsState.statsEncounters[worstIdx] = closest[k] * voiceConfig.novelty;
                    // Bubble sort to maintain order
                    for (let a = K - 1; a > 0; a--) {
                        if (statsState.statsEncounters[base + a] < statsState.statsEncounters[base + a - 1]) {
                            const td = statsState.statsEncounters[base + a];
                            statsState.statsEncounters[base + a] = statsState.statsEncounters[base + a - 1];
                            statsState.statsEncounters[base + a - 1] = td;
                        }
                    }
                }
            }
        }
    }

    // Decay all records
    if (!seeding) {
        for (let k = 0; k < statsState.statsEncounters.length; k++) {
            statsState.statsEncounters[k] *= voiceConfig.decay;
        }
    }

    // Smooth the count with one-pole filter
    statsState.smoothEncounters += AUDIO_ALPHA * (count - statsState.smoothEncounters);
    return statsState.smoothEncounters;
}

const statComputeFns = [computeForce, computeMinForce, computeMaxForce, computeSpeed, computeMinSpeed, computeMaxSpeed, computeMinDist, computeMaxDist, computeRecords, computeMeanDist, computeDeltaMeanDist, computeAngularMom, computeSigmaSpeed, computeEMASpeed, computeSigmaDist, computeOdometer, computeCycleCount, computeMedianR, computeSpread, computeEMed, computeEHi, computeCoherence, computeEncounters];

function collectStatsSnapshot() {
    const n = currentRoots.length;
    if (n === 0) return;

    // Per-root displacement this tick (= speed in ticks-as-time units)
    if (!statsState.rootSpeeds || statsState.rootSpeeds.length !== n) {
        statsState.rootSpeeds = new Float64Array(n);
    }
    if (statsState.prevRoots && statsState.prevRoots.length === n) {
        for (let i = 0; i < n; i++) {
            statsState.rootSpeeds[i] = Math.hypot(
                currentRoots[i].re - statsState.prevRoots[i].re,
                currentRoots[i].im - statsState.prevRoots[i].im
            );
        }
    } else {
        statsState.rootSpeeds.fill(0);
    }

    // Update spectrum peak heights (all-time max per root)
    if (!statsState.spectrumPeaks || statsState.spectrumPeaks.length !== n) {
        statsState.spectrumPeaks = new Float64Array(n);
    }
    for (let i = 0; i < n; i++) {
        statsState.spectrumPeaks[i] = Math.max(statsState.rootSpeeds[i], statsState.spectrumPeaks[i]);
    }

    // Accumulate per-root odometers (cumulative distance)
    if (!statsState.rootOdometers || statsState.rootOdometers.length !== n) {
        statsState.rootOdometers = new Float64Array(n);
    }
    for (let i = 0; i < n; i++) {
        statsState.rootOdometers[i] += statsState.rootSpeeds[i];
    }

    // Accumulate per-root winding number (cumulative signed angle in turns, around origin)
    if (!statsState.rootWindings || statsState.rootWindings.length !== n) {
        statsState.rootWindings = new Float64Array(n);
    }
    if (statsState.prevRoots && statsState.prevRoots.length === n) {
        for (let i = 0; i < n; i++) {
            const x0 = statsState.prevRoots[i].re, y0 = statsState.prevRoots[i].im;
            const x1 = currentRoots[i].re, y1 = currentRoots[i].im;
            // Cross product and dot product of (prev, current) vectors from origin
            const cross = x0 * y1 - y0 * x1;
            const dot = x0 * x1 + y0 * y1;
            statsState.rootWindings[i] += Math.atan2(cross, dot) / (2 * Math.PI);
        }
    }

    // Accumulate per-root tortuosity components (path length + net displacement)
    if (!statsState.rootTortuosityOdo || statsState.rootTortuosityOdo.length !== n) {
        statsState.rootTortuosityOdo = new Float64Array(n);
        statsState.rootTortuosityNetDx = new Float64Array(n);
        statsState.rootTortuosityNetDy = new Float64Array(n);
    }
    if (statsState.prevRoots && statsState.prevRoots.length === n) {
        for (let i = 0; i < n; i++) {
            const dx = currentRoots[i].re - statsState.prevRoots[i].re;
            const dy = currentRoots[i].im - statsState.prevRoots[i].im;
            statsState.rootTortuosityOdo[i] += statsState.rootSpeeds[i];
            statsState.rootTortuosityNetDx[i] += dx;
            statsState.rootTortuosityNetDy[i] += dy;
        }
    }

    // Per-root odometer cycle detection (each root independently detects its own cycle)
    if (animState.playing && n > 0) {
        if (!statsState.odometerStartRoots || statsState.odometerStartRoots.length !== n) {
            statsState.odometerStartRoots = currentRoots.map(r => ({ re: r.re, im: r.im }));
            statsState.odometerFrameCounts = new Int32Array(n);
            statsState.odometerMaxDisps = new Float64Array(n);
            if (!statsState.odometerCycleLengths || statsState.odometerCycleLengths.length !== n) {
                statsState.odometerCycleLengths = new Float64Array(n);
            }
        } else {
            const thresh = panels.roots.range * 0.02;
            for (let i = 0; i < n; i++) {
                statsState.odometerFrameCounts[i]++;
                const d = Math.hypot(
                    currentRoots[i].re - statsState.odometerStartRoots[i].re,
                    currentRoots[i].im - statsState.odometerStartRoots[i].im
                );
                if (d > statsState.odometerMaxDisps[i]) statsState.odometerMaxDisps[i] = d;
                // Check closure: root must have moved significantly and returned near start
                if (statsState.odometerFrameCounts[i] > 5 &&
                    statsState.odometerMaxDisps[i] > thresh * 5 &&
                    d < thresh) {
                    // This root completed a cycle
                    statsState.odometerCycleCount++;
                    statsState.odometerCycleLengths[i] = statsState.rootOdometers[i];
                    statsState.rootOdometers[i] = 0;
                    statsState.odometerFrameCounts[i] = 0;
                    statsState.odometerMaxDisps[i] = 0;
                    statsState.odometerStartRoots[i].re = currentRoots[i].re;
                    statsState.odometerStartRoots[i].im = currentRoots[i].im;
                }
            }
        }
    }

    // Cache per-root forces before stat compute loop (MinForce/MaxForce read from cache)
    cacheRootForces();

    const idx = statsState.writeIdx;
    for (let s = 0; s < STAT_TYPES.length; s++) {
        statsState.buffers[STAT_TYPES[s]][idx] = statComputeFns[s]();
    }

    // Save previous roots for Speed computation next frame
    if (!statsState.prevRoots || statsState.prevRoots.length !== n) {
        statsState.prevRoots = [];
        for (let i = 0; i < n; i++) statsState.prevRoots.push({ re: 0, im: 0 });
    }
    for (let i = 0; i < n; i++) {
        statsState.prevRoots[i].re = currentRoots[i].re;
        statsState.prevRoots[i].im = currentRoots[i].im;
    }

    statsState.writeIdx = (idx + 1) % statsState.maxFrames;
    statsState.frameCount = Math.min(statsState.frameCount + 1, statsState.maxFrames);
    statsState.dirty = true;
}

function clearStatsData() {
    for (const name of STAT_TYPES) statsState.buffers[name].fill(0);
    statsState.frameCount = 0;
    statsState.writeIdx = 0;
    statsState.prevRoots = null;
    statsState.prevMeanDist = null;
    statsState.emaSpeed = 0;
    statsState.spectrumPeaks = null;
    statsState.rootForces = null;
    statsState.rootOdometers = null;
    statsState.odometerCycleLengths = null;
    statsState.odometerStartRoots = null;
    statsState.odometerFrameCounts = null;
    statsState.odometerMaxDisps = null;
    statsState.odometerCycleCount = 0;
    statsState.rootWindings = null;
    statsState.rootTortuosityOdo = null;
    statsState.rootTortuosityNetDx = null;
    statsState.rootTortuosityNetDy = null;
    statsState.smoothMedianR = 0;
    statsState.smoothSpread = 0;
    statsState.smoothEMed = 0;
    statsState.smoothEHi = 0;
    statsState.smoothCoherence = 0;
    statsState.smoothEncounters = 0;
    statsState.statsEncounters = null;
    pairRecords = null;
    statsState.dirty = true;
    if (activeTab === "stats") drawAllStatsPlots();
}

function drawStatsPlot(plotIdx) {
    const ctx = statsState.ctxs[plotIdx];
    if (!ctx) return;
    const c = statsState.canvases[plotIdx];
    const W = c.getBoundingClientRect().width;
    const H = c.getBoundingClientRect().height;
    if (W === 0 || H === 0) return;

    const optIdx = statsState.plotConfigs[plotIdx];
    const nFrames = statsState.frameCount;
    const startIdx = (nFrames < statsState.maxFrames) ? 0 : statsState.writeIdx;
    const ML = 6, MR = 4, MT = 4, MB = 4;
    const plotW = W - ML - MR;
    const plotH = H - MT - MB;

    // Clear
    ctx.fillStyle = "#151a3a";
    ctx.fillRect(0, 0, W, H);

    // Spectrum plot (bar chart)
    const spectrumIdx = optIdx - STAT_TYPES.length - PHASE_PLOTS.length;
    if (spectrumIdx >= 0) {
        const n = currentRoots.length;
        if (n === 0) return;

        // Extra bottom margin for index labels
        const sMB = 10;
        const sPlotH = plotH - sMB + MB;
        const barW = Math.max(1, plotW / n - 1);
        const gap = plotW / n;

        // Shared spectrum helper: grid + axis + index labels
        function drawSpectrumFrame() {
            ctx.strokeStyle = "rgba(255,255,255,0.04)";
            ctx.lineWidth = 0.5;
            for (const frac of [0.25, 0.5, 0.75]) {
                const y = MT + sPlotH * (1 - frac);
                ctx.beginPath(); ctx.moveTo(ML, y); ctx.lineTo(ML + plotW, y); ctx.stroke();
            }
            ctx.strokeStyle = "rgba(255,255,255,0.08)";
            ctx.lineWidth = 0.5;
            ctx.beginPath(); ctx.moveTo(ML, MT + sPlotH); ctx.lineTo(ML + plotW, MT + sPlotH); ctx.stroke();
        }
        function drawSpectrumLabels() {
            ctx.globalAlpha = 0.6;
            ctx.font = `${Math.min(8, gap * 0.8)}px system-ui`;
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            for (let i = 0; i < n; i++) {
                ctx.fillStyle = rootColor(i, n);
                ctx.fillText(i, ML + gap * (i + 0.5), MT + sPlotH + 1);
            }
            ctx.globalAlpha = 1.0;
        }

        if (spectrumIdx === 0) {
            // SpeedSpectrum
            const speeds = statsState.rootSpeeds;
            if (!speeds || speeds.length !== n) return;
            let sMax = 0;
            const peaks = statsState.spectrumPeaks;
            for (let i = 0; i < n; i++) {
                if (speeds[i] > sMax) sMax = speeds[i];
                if (peaks && peaks.length === n && peaks[i] > sMax) sMax = peaks[i];
            }
            if (sMax < 1e-12) sMax = 1;

            drawSpectrumFrame();
            for (let i = 0; i < n; i++) {
                const x = ML + gap * (i + 0.5);
                const h = (speeds[i] / sMax) * sPlotH;
                ctx.strokeStyle = rootColor(i, n);
                ctx.lineWidth = Math.min(barW, 4);
                ctx.lineCap = "butt";
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(x, MT + sPlotH);
                ctx.lineTo(x, MT + sPlotH - h);
                ctx.stroke();
            }
            if (peaks && peaks.length === n) {
                const dotR = Math.min(barW * 0.6, 3);
                for (let i = 0; i < n; i++) {
                    const ph = (peaks[i] / sMax) * sPlotH;
                    const y = MT + sPlotH - ph;
                    ctx.fillStyle = rootColor(i, n);
                    ctx.globalAlpha = 0.95;
                    ctx.beginPath();
                    ctx.arc(ML + gap * (i + 0.5), y, dotR, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            drawSpectrumLabels();

        } else if (spectrumIdx === 1) {
            // OdometerSpectrum
            const od = statsState.rootOdometers;
            if (!od || od.length !== n) return;
            const cl = statsState.odometerCycleLengths;
            let sMax = 0;
            for (let i = 0; i < n; i++) {
                if (od[i] > sMax) sMax = od[i];
                if (cl && cl.length === n && cl[i] > sMax) sMax = cl[i];
            }
            if (sMax < 1e-12) sMax = 1;

            drawSpectrumFrame();
            for (let i = 0; i < n; i++) {
                const x = ML + gap * (i + 0.5);
                const h = (od[i] / sMax) * sPlotH;
                ctx.strokeStyle = rootColor(i, n);
                ctx.lineWidth = Math.min(barW, 4);
                ctx.lineCap = "butt";
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(x, MT + sPlotH);
                ctx.lineTo(x, MT + sPlotH - h);
                ctx.stroke();
            }
            // Cycle-length dots (max from last completed loop)
            if (cl && cl.length === n) {
                const dotR = Math.min(barW * 0.6, 3);
                for (let i = 0; i < n; i++) {
                    const ch = (cl[i] / sMax) * sPlotH;
                    const y = MT + sPlotH - ch;
                    ctx.fillStyle = rootColor(i, n);
                    ctx.globalAlpha = 0.95;
                    ctx.beginPath();
                    ctx.arc(ML + gap * (i + 0.5), y, dotR, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            drawSpectrumLabels();

        } else if (spectrumIdx === 2) {
            // WindingSpectrum ‚Äî cumulative winding number per root (signed, in turns)
            const w = statsState.rootWindings;
            if (!w || w.length !== n) return;
            // Find max absolute winding for symmetric scale
            let wMax = 0;
            for (let i = 0; i < n; i++) {
                const a = Math.abs(w[i]);
                if (a > wMax) wMax = a;
            }
            if (wMax < 1e-6) wMax = 1;
            const halfH = sPlotH / 2;

            drawSpectrumFrame();
            // Draw zero line at center
            ctx.strokeStyle = "rgba(255,255,255,0.12)";
            ctx.lineWidth = 0.5;
            ctx.beginPath(); ctx.moveTo(ML, MT + halfH); ctx.lineTo(ML + plotW, MT + halfH); ctx.stroke();
            // Draw bars (positive = up from center, negative = down from center)
            for (let i = 0; i < n; i++) {
                const x = ML + gap * (i + 0.5);
                const h = (w[i] / wMax) * halfH;
                ctx.strokeStyle = rootColor(i, n);
                ctx.lineWidth = Math.min(barW, 4);
                ctx.lineCap = "butt";
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(x, MT + halfH);
                ctx.lineTo(x, MT + halfH - h);
                ctx.stroke();
            }
            // Y-axis labels: show max winding value
            ctx.fillStyle = "rgba(255,255,255,0.35)";
            ctx.font = "8px system-ui";
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            ctx.globalAlpha = 1.0;
            ctx.fillText("+" + wMax.toFixed(1), ML - 2, MT + 4);
            ctx.fillText("-" + wMax.toFixed(1), ML - 2, MT + sPlotH - 4);
            ctx.fillText("0", ML - 2, MT + halfH);
            drawSpectrumLabels();

        } else if (spectrumIdx === 3) {
            // TortuositySpectrum ‚Äî net displacement / path length (directness)
            // Auto-scaled y-axis to largest value so differences are visible
            const odo = statsState.rootTortuosityOdo;
            const ndx = statsState.rootTortuosityNetDx;
            const ndy = statsState.rootTortuosityNetDy;
            if (!odo || odo.length !== n) return;
            const dir = new Float64Array(n);
            let dMax = 0;
            for (let i = 0; i < n; i++) {
                const netD = Math.hypot(ndx[i], ndy[i]);
                dir[i] = odo[i] > 1e-8 ? netD / odo[i] : 1;
                if (dir[i] > dMax) dMax = dir[i];
            }
            if (dMax < 1e-12) dMax = 1;

            drawSpectrumFrame();
            for (let i = 0; i < n; i++) {
                const x = ML + gap * (i + 0.5);
                const h = (dir[i] / dMax) * sPlotH;
                ctx.strokeStyle = rootColor(i, n);
                ctx.lineWidth = Math.min(barW, 4);
                ctx.lineCap = "butt";
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(x, MT + sPlotH);
                ctx.lineTo(x, MT + sPlotH - h);
                ctx.stroke();
            }
            drawSpectrumLabels();
        }

        return;
    }

    // Phase-space plot
    const phaseIdx = optIdx - STAT_TYPES.length;
    if (phaseIdx >= 0) {
        const phase = PHASE_PLOTS[phaseIdx];
        const bufX = statsState.buffers[phase.xStat];
        const bufY = statsState.buffers[phase.yStat];
        const color = phase.color;

        // Find tight bounding box then add 10% padding
        let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity;
        for (let f = 0; f < nFrames; f++) {
            const bi = (startIdx + f) % statsState.maxFrames;
            const vx = bufX[bi], vy = bufY[bi];
            if (vx < xMin) xMin = vx; if (vx > xMax) xMax = vx;
            if (vy < yMin) yMin = vy; if (vy > yMax) yMax = vy;
        }
        if (xMin === Infinity) { xMin = 0; xMax = 1; }
        if (yMin === Infinity) { yMin = 0; yMax = 1; }
        let xSpan = xMax - xMin, ySpan = yMax - yMin;
        if (xSpan < 1e-12) { xMin -= 0.5; xMax += 0.5; xSpan = 1; }
        if (ySpan < 1e-12) { yMin -= 0.5; yMax += 0.5; ySpan = 1; }
        const pad = 0.1;
        xMin -= xSpan * pad; xMax += xSpan * pad;
        yMin -= ySpan * pad; yMax += ySpan * pad;
        // Clamp lower bound to 0 when data is non-negative (these stats are all ‚â• 0)
        if (xMin < 0 && xMin + xSpan * pad >= 0) xMin = 0;
        if (yMin < 0 && yMin + ySpan * pad >= 0) yMin = 0;

        const pxOf = (v) => ML + ((v - xMin) / (xMax - xMin)) * plotW;
        const pyOf = (v) => MT + plotH - ((v - yMin) / (yMax - yMin)) * plotH;

        // Grid
        ctx.strokeStyle = "rgba(255,255,255,0.04)";
        ctx.lineWidth = 0.5;
        for (const frac of [0.25, 0.5, 0.75]) {
            const y = MT + plotH * (1 - frac);
            ctx.beginPath(); ctx.moveTo(ML, y); ctx.lineTo(ML + plotW, y); ctx.stroke();
            const x = ML + plotW * frac;
            ctx.beginPath(); ctx.moveTo(x, MT); ctx.lineTo(x, MT + plotH); ctx.stroke();
        }

        // Axes
        ctx.strokeStyle = "rgba(255,255,255,0.08)";
        ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(ML, MT + plotH); ctx.lineTo(ML + plotW, MT + plotH); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ML, MT); ctx.lineTo(ML, MT + plotH); ctx.stroke();

        if (nFrames < 2) return;

        // Draw phase path with age-based opacity (old=dim, new=bright)
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = 1.5;
        for (let f = 1; f < nFrames; f++) {
            const bi0 = (startIdx + f - 1) % statsState.maxFrames;
            const bi1 = (startIdx + f) % statsState.maxFrames;
            const alpha = 0.15 + 0.75 * (f / (nFrames - 1));
            ctx.strokeStyle = color;
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.moveTo(pxOf(bufX[bi0]), pyOf(bufY[bi0]));
            ctx.lineTo(pxOf(bufX[bi1]), pyOf(bufY[bi1]));
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;

        // Current position dot
        const lastBi = (startIdx + nFrames - 1) % statsState.maxFrames;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(pxOf(bufX[lastBi]), pyOf(bufY[lastBi]), 3, 0, Math.PI * 2);
        ctx.fill();

        // Axis labels (inside plot area)
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.font = "8px system-ui";
        ctx.textAlign = "center";
        ctx.fillText(phase.xStat, ML + plotW / 2, MT + plotH - 3);
        ctx.save();
        ctx.translate(ML + 10, MT + plotH / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(phase.yStat, 0, 0);
        ctx.restore();
        return;
    }

    // Time-series plot (optIdx < STAT_TYPES.length)
    const statName = STAT_TYPES[optIdx];
    const buf = statsState.buffers[statName];
    const color = STAT_COLORS[statName];

    // Find min/max value in visible buffer
    let yMin = 0, yMax = 0;
    for (let f = 0; f < nFrames; f++) {
        const bufIdx = (startIdx + f) % statsState.maxFrames;
        const v = buf[bufIdx];
        if (v > yMax) yMax = v;
        if (v < yMin) yMin = v;
    }
    const signed = yMin < -1e-12;
    if (signed) {
        // Symmetric axis around zero
        const absMax = Math.max(Math.abs(yMin), Math.abs(yMax));
        yMin = -absMax || -1; yMax = absMax || 1;
    } else {
        yMin = 0;
        if (yMax < 1e-12) yMax = 1;
    }

    const xOf = (f) => ML + (nFrames > 1 ? (f / (nFrames - 1)) * plotW : 0);
    const yOf = (v) => MT + plotH - ((v - yMin) / (yMax - yMin)) * plotH;

    // Subtle horizontal gridlines at 0.25, 0.5, 0.75
    ctx.strokeStyle = "rgba(255,255,255,0.04)";
    ctx.lineWidth = 0.5;
    for (const frac of [0.25, 0.5, 0.75]) {
        const y = MT + plotH * (1 - frac);
        ctx.beginPath(); ctx.moveTo(ML, y); ctx.lineTo(ML + plotW, y); ctx.stroke();
    }

    // Bottom axis (or zero line for signed stats)
    ctx.strokeStyle = signed ? "rgba(255,255,255,0.15)" : "rgba(255,255,255,0.08)";
    ctx.lineWidth = 0.5;
    if (signed) {
        // Draw zero line in the middle
        const zeroY = yOf(0);
        ctx.beginPath(); ctx.moveTo(ML, zeroY); ctx.lineTo(ML + plotW, zeroY); ctx.stroke();
    } else {
        ctx.beginPath(); ctx.moveTo(ML, MT + plotH); ctx.lineTo(ML + plotW, MT + plotH); ctx.stroke();
    }

    if (nFrames < 2) return;

    // Draw stat line
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    for (let f = 0; f < nFrames; f++) {
        const bufIdx = (startIdx + f) % statsState.maxFrames;
        const x = xOf(f);
        const y = yOf(buf[bufIdx]);
        if (f === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1.0;

    // Current value label (top-right)
    const lastIdx = (startIdx + nFrames - 1) % statsState.maxFrames;
    const curVal = buf[lastIdx];
    ctx.fillStyle = color;
    ctx.font = "bold 7px system-ui";
    ctx.textAlign = "right";
    ctx.fillText(curVal < 100 ? curVal.toFixed(3) : curVal.toFixed(1), W - MR - 2, MT + 10);
}

function drawAllStatsPlots() {
    statsState.dirty = false;
    for (let i = 0; i < 16; i++) drawStatsPlot(i);
}

// --- Bitmap trail canvas ---

function initBitmapCanvas() {
    const canvas = document.getElementById("bitmap-canvas");
    const res = parseInt(document.getElementById("bitmap-res-select").value, 10) || 2000;
    canvas.width = res;
    canvas.height = res;
    bitmapCtx = canvas.getContext("2d");
    bitmapCtx.fillStyle = bitmapCanvasColor;
    bitmapCtx.fillRect(0, 0, canvas.width, canvas.height);
    bitmapRange = panels.roots.range;
    bitmapFrameCount = 0;
    fastModeElapsedOffset = 0;
    bitmapActive = true;
}

function paintBitmapFrame() {
    if (!bitmapCtx || !bitmapRange) return;
    const w = bitmapCtx.canvas.width, h = bitmapCtx.canvas.height;
    const range = bitmapRange;
    const n = currentRoots.length;
    for (let i = 0; i < n; i++) {
        const r = currentRoots[i];
        const px = (r.re / range + 1) * 0.5 * w;
        const py = (1 - r.im / range) * 0.5 * h;
        if (px < -2 || px > w + 2 || py < -2 || py > h + 2) continue;
        bitmapCtx.fillStyle = rootColor(i, n);
        bitmapCtx.beginPath();
        bitmapCtx.arc(px, py, 1.5, 0, 2 * Math.PI);
        bitmapCtx.fill();
    }
    bitmapFrameCount++;
}

// --- Fast mode: high-res bitmap rendering ---

function paintBitmapFrameFast() {
    if (!bitmapCtx || !bitmapRange) return;
    const w = bitmapCtx.canvas.width, h = bitmapCtx.canvas.height;
    const range = bitmapRange;
    const n = currentRoots.length;
    const colors = fastModeRootColors;
    for (let i = 0; i < n; i++) {
        const r = currentRoots[i];
        const px = (r.re / range + 1) * 0.5 * w;
        const py = (1 - r.im / range) * 0.5 * h;
        if (px < 0 || px >= w || py < 0 || py >= h) continue;
        bitmapCtx.fillStyle = colors[i];
        bitmapCtx.fillRect(px | 0, py | 0, 1, 1);
    }
    bitmapFrameCount++;
}

function setCurrentRootsInPlace(newRoots) {
    while (currentRoots.length < newRoots.length) currentRoots.push({ re: 0, im: 0 });
    currentRoots.length = newRoots.length;
    for (let i = 0; i < newRoots.length; i++) {
        currentRoots[i].re = newRoots[i].re;
        currentRoots[i].im = newRoots[i].im;
    }
}

// --- Web Worker fast mode ---

function createFastModeWorkerBlob() {
    const code = `'use strict';

// Flat-array Ehrlich-Aberth solver (same algorithm as main thread)
function solveEA(cRe, cIm, nCoeffs, warmRe, warmIm, nRoots) {
    // Strip leading near-zero coefficients
    var start = 0;
    while (start < nCoeffs - 1 && Math.hypot(cRe[start], cIm[start]) < 1e-15) start++;
    var degree = nCoeffs - 1 - start;
    if (degree <= 0) return;

    // Degree 1: direct
    if (degree === 1) {
        var aR = cRe[start], aI = cIm[start], bR = cRe[start+1], bI = cIm[start+1];
        var d = aR*aR + aI*aI;
        if (d < 1e-30) return;
        warmRe[0] = -(bR*aR + bI*aI) / d;
        warmIm[0] = -(bI*aR - bR*aI) / d;
        return;
    }

    // Build coefficient sub-array (from start)
    var n = nCoeffs - start;
    var cr = new Float64Array(n), ci = new Float64Array(n);
    for (var k = 0; k < n; k++) { cr[k] = cRe[start+k]; ci[k] = cIm[start+k]; }

    // Init roots from warm start
    var rRe = new Float64Array(degree), rIm = new Float64Array(degree);
    for (var i = 0; i < degree; i++) { rRe[i] = warmRe[i]; rIm[i] = warmIm[i]; }

    // Iterate
    for (var iter = 0; iter < 100; iter++) {
        var maxCorr = 0;
        for (var i = 0; i < degree; i++) {
            var zR = rRe[i], zI = rIm[i];
            // Horner: p(z) and p'(z)
            var pR = cr[0], pI = ci[0], dpR = 0, dpI = 0;
            for (var k = 1; k < n; k++) {
                var ndR = dpR*zR - dpI*zI + pR, ndI = dpR*zI + dpI*zR + pI;
                dpR = ndR; dpI = ndI;
                var npR = pR*zR - pI*zI + cr[k], npI = pR*zI + pI*zR + ci[k];
                pR = npR; pI = npI;
            }
            // Newton step w = p/p'
            var dpM = dpR*dpR + dpI*dpI;
            if (dpM < 1e-60) continue;
            var wR = (pR*dpR + pI*dpI)/dpM, wI = (pI*dpR - pR*dpI)/dpM;
            // Aberth sum
            var sR = 0, sI = 0;
            for (var j = 0; j < degree; j++) {
                if (j === i) continue;
                var dR = zR - rRe[j], dI = zI - rIm[j];
                var dM = dR*dR + dI*dI;
                if (dM < 1e-60) continue;
                sR += dR/dM; sI += -dI/dM;
            }
            // Correction
            var wsR = wR*sR - wI*sI, wsI = wR*sI + wI*sR;
            var dnR = 1 - wsR, dnI = -wsI;
            var dnM = dnR*dnR + dnI*dnI;
            if (dnM < 1e-60) continue;
            var crrR = (wR*dnR + wI*dnI)/dnM, crrI = (wI*dnR - wR*dnI)/dnM;
            rRe[i] -= crrR; rIm[i] -= crrI;
            var h = Math.hypot(crrR, crrI);
            if (h > maxCorr) maxCorr = h;
        }
        if (maxCorr < 1e-12) break;
    }
    // Write back (filter NaN/Inf ‚Äî keep warm-start value)
    for (var i = 0; i < degree; i++) {
        if (isFinite(rRe[i]) && isFinite(rIm[i])) {
            warmRe[i] = rRe[i]; warmIm[i] = rIm[i];
        }
    }
}

// Greedy nearest-neighbor root matching (flat arrays, in-place reorder of new into old order)
function matchRoots(newRe, newIm, oldRe, oldIm, n) {
    var used = new Uint8Array(n);
    var tmpRe = new Float64Array(n), tmpIm = new Float64Array(n);
    for (var i = 0; i < n; i++) {
        var bestJ = 0, bestD = Infinity;
        for (var j = 0; j < n; j++) {
            if (used[j]) continue;
            var d = (newRe[j]-oldRe[i])*(newRe[j]-oldRe[i]) + (newIm[j]-oldIm[i])*(newIm[j]-oldIm[i]);
            if (d < bestD) { bestD = d; bestJ = j; }
        }
        tmpRe[i] = newRe[bestJ]; tmpIm[i] = newIm[bestJ];
        used[bestJ] = 1;
    }
    for (var i = 0; i < n; i++) { newRe[i] = tmpRe[i]; newIm[i] = tmpIm[i]; }
}

// Paint single pixels directly into ImageData buffer
function paintPixels(px, w, h, rRe, rIm, nR, range, cR, cG, cB) {
    for (var i = 0; i < nR; i++) {
        var ix = ((rRe[i] / range + 1) * 0.5 * w) | 0;
        var iy = ((1 - rIm[i] / range) * 0.5 * h) | 0;
        if (ix < 0 || ix >= w || iy < 0 || iy >= h) continue;
        var off = (iy * w + ix) * 4;
        px[off] = cR[i]; px[off+1] = cG[i]; px[off+2] = cB[i]; px[off+3] = 255;
    }
}
function paintUniform(px, w, h, rRe, rIm, nR, range, uR, uG, uB) {
    for (var i = 0; i < nR; i++) {
        var ix = ((rRe[i] / range + 1) * 0.5 * w) | 0;
        var iy = ((1 - rIm[i] / range) * 0.5 * h) | 0;
        if (ix < 0 || ix >= w || iy < 0 || iy >= h) continue;
        var off = (iy * w + ix) * 4;
        px[off] = uR; px[off+1] = uG; px[off+2] = uB; px[off+3] = 255;
    }
}

self.onmessage = function(e) {
    var d = e.data;
    var coeffsRe = new Float64Array(d.coeffsRe);
    var coeffsIm = new Float64Array(d.coeffsIm);
    var nCoeffs = d.nCoeffs, degree = d.degree, nRoots = d.nRoots;
    var rootsRe = new Float64Array(d.rootsRe);
    var rootsIm = new Float64Array(d.rootsIm);
    var colorsR = new Uint8Array(d.colorsR);
    var colorsG = new Uint8Array(d.colorsG);
    var colorsB = new Uint8Array(d.colorsB);
    var pixels = new Uint8ClampedArray(d.pixels);
    var W = d.canvasW, H = d.canvasH, range = d.bitmapRange;
    var total = d.totalSteps, FPS = d.FAST_PASS_SECONDS;
    var elapsedOff = d.elapsedOffset || 0;
    var frameMs = d.frameIntervalMs || 2000;
    var noColor = !!d.noColor;
    var uniformR = d.uniformR || 255, uniformG = d.uniformG || 255, uniformB = d.uniformB || 255;
    var curvesFlat = new Float64Array(d.curvesFlat);
    var entries = d.animEntries;
    var offsets = d.curveOffsets;
    var lengths = d.curveLengths;
    var isCloud = d.curveIsCloud;

    // Temp arrays for solver output
    var tmpRe = new Float64Array(nRoots), tmpIm = new Float64Array(nRoots);

    var lastFrame = performance.now();
    var passNum = 0;

    // Loop forever ‚Äî main thread terminates Worker via imode
    while (true) {
        for (var step = 0; step < total; step++) {
            var elapsed = elapsedOff + (step / total) * FPS;

            // Interpolate animated coefficients
            for (var a = 0; a < entries.length; a++) {
                var idx = entries[a].idx;
                var dir = entries[a].ccw ? -1 : 1;
                var t = elapsed * entries[a].speed * dir;
                var u = ((t % 1) + 1) % 1;
                var N = lengths[a];
                var rawIdx = u * N;
                var base = offsets[a] * 2;

                if (isCloud[a]) {
                    var k = (rawIdx | 0) % N;
                    coeffsRe[idx] = curvesFlat[base + k*2];
                    coeffsIm[idx] = curvesFlat[base + k*2 + 1];
                } else {
                    var lo = (rawIdx | 0) % N;
                    var hi = (lo + 1) % N;
                    var frac = rawIdx - (rawIdx | 0);
                    coeffsRe[idx] = curvesFlat[base+lo*2]*(1-frac) + curvesFlat[base+hi*2]*frac;
                    coeffsIm[idx] = curvesFlat[base+lo*2+1]*(1-frac) + curvesFlat[base+hi*2+1]*frac;
                }
            }

            // Copy warm start
            tmpRe.set(rootsRe); tmpIm.set(rootsIm);
            // Solve
            solveEA(coeffsRe, coeffsIm, nCoeffs, tmpRe, tmpIm, nRoots);
            if (noColor) {
                // Uniform color ‚Äî skip O(n¬≤) matching
                rootsRe.set(tmpRe); rootsIm.set(tmpIm);
                paintUniform(pixels, W, H, rootsRe, rootsIm, nRoots, range, uniformR, uniformG, uniformB);
            } else {
                // Match root order for per-root coloring
                matchRoots(tmpRe, tmpIm, rootsRe, rootsIm, nRoots);
                rootsRe.set(tmpRe); rootsIm.set(tmpIm);
                paintPixels(pixels, W, H, rootsRe, rootsIm, nRoots, range, colorsR, colorsG, colorsB);
            }

            // Progress every 500 steps
            if (step % 500 === 0) {
                self.postMessage({type: 'progress', step: step, pass: passNum});
            }

            // Frame snapshot periodically
            var now = performance.now();
            if (now - lastFrame >= frameMs) {
                lastFrame = now;
                self.postMessage({
                    type: 'frame', step: step+1, pass: passNum,
                    pixels: pixels.buffer.slice(0),
                    rootsRe: new Float64Array(rootsRe).buffer,
                    rootsIm: new Float64Array(rootsIm).buffer
                });
            }
        }

        // Pass complete ‚Äî advance offset, send snapshot, continue
        elapsedOff += FPS;
        passNum++;
        self.postMessage({
            type: 'pass', pass: passNum,
            pixels: pixels.buffer.slice(0),
            rootsRe: new Float64Array(rootsRe).buffer,
            rootsIm: new Float64Array(rootsIm).buffer
        });
    }
};`;
    return URL.createObjectURL(new Blob([code], { type: "application/javascript" }));
}

// Compute passes needed for all animated coefficients to return home simultaneously.
// Speed slider step = 0.01, so speed_i = s_i/100 (integer s_i).
// Period_i = 100/s_i seconds. Full cycle = LCM of all periods = 100/GCD(s_1,...,s_k).
// Each pass covers FAST_PASS_SECONDS (1.0s), so passes = 100/GCD(s_1,...,s_k).
function computeFullCyclePasses() {
    const animated = allAnimatedCoeffs();
    if (animated.size === 0) return 0;
    function gcd(a, b) { while (b) { [a, b] = [b, a % b]; } return a; }
    let g = 0;
    for (const idx of animated) {
        const s = Math.round(coefficients[idx].speed * 100);
        if (s <= 0) continue;
        g = g === 0 ? s : gcd(g, s);
    }
    return g > 0 ? 100 / g : 0;
}

// Find nearest integer speed (1‚Äì100) that is coprime with all other animated coefficients' speeds
// and also different from all of them. excludeSet = indices to skip (the coefficient(s) being edited).
function findPrimeSpeed(currentIntSpeed, excludeSet) {
    function gcd(a, b) { while (b) { [a, b] = [b, a % b]; } return a; }
    const otherSpeeds = [];
    for (let i = 0; i < coefficients.length; i++) {
        if (excludeSet.has(i)) continue;
        if (coefficients[i].pathType === "none") continue;
        const s = Math.round(coefficients[i].speed * 100);
        if (s > 0) otherSpeeds.push(s);
    }
    if (otherSpeeds.length === 0) return currentIntSpeed; // no others ‚Äî keep current
    function isValid(s) {
        for (const o of otherSpeeds) {
            if (s === o || gcd(s, o) > 1) return false;
        }
        return true;
    }
    // Search outward from current speed
    for (let d = 0; d <= 100; d++) {
        if (currentIntSpeed + d <= 100 && isValid(currentIntSpeed + d)) return currentIntSpeed + d;
        if (d > 0 && currentIntSpeed - d >= 1 && isValid(currentIntSpeed - d)) return currentIntSpeed - d;
    }
    return currentIntSpeed; // fallback (1 is coprime with everything, so this shouldn't happen)
}

function enterFastMode() {
    if (fastModeActive) return;

    // Stop interactive animation
    stopAnimation();
    playBtn.textContent = "\u25b6 Play";

    // Ensure bitmap canvas exists + range frozen, and resolution matches dropdown
    const wantRes = parseInt(document.getElementById("bitmap-res-select").value, 10) || 2000;
    const canvas = document.getElementById("bitmap-canvas");
    if (!bitmapCtx || !bitmapActive || canvas.width !== wantRes) {
        initBitmapCanvas();
        document.getElementById("bitmap-save-btn").disabled = false;
        document.getElementById("bitmap-clear-btn").disabled = false;
        document.getElementById("bitmap-start-btn").textContent = "restart";
        document.getElementById("jiggle-btn").disabled = false;
    }

    // Read steps from dropdown
    const stepsVal = parseInt(document.getElementById("bitmap-steps-select").value, 10) || 10000;

    // Precompute hi-res curves for all animated coefficients
    fastModeCurves = new Map();
    const animated = allAnimatedCoeffs();

    // Snap animated coefficients to home so coeffExtent() matches interactive mode
    const savedPos = [];
    for (const idx of animated) {
        const c = coefficients[idx];
        savedPos.push({ idx, re: c.re, im: c.im });
        if (c.curve) { c.re = c.curve[0].re; c.im = c.curve[0].im; }
    }
    const extentAtHome = coeffExtent();
    for (const s of savedPos) { coefficients[s.idx].re = s.re; coefficients[s.idx].im = s.im; }

    for (const idx of animated) {
        const c = coefficients[idx];
        const absR = (c.radius / 100) * extentAtHome;
        // Use home position (curve[0]), not current animated position (c.re/c.im)
        let homeRe = c.curve ? c.curve[0].re : c.re;
        let homeIm = c.curve ? c.curve[0].im : c.im;
        if (jiggleOffsets && jiggleOffsets.has(idx)) {
            homeRe += jiggleOffsets.get(idx).re;
            homeIm += jiggleOffsets.get(idx).im;
        }
        const curve = computeCurveN(homeRe, homeIm, c.pathType, absR, c.angle, c.extra, stepsVal);
        fastModeCurves.set(idx, curve);
    }

    // Precompute root colors as RGB byte arrays
    const nRoots = currentRoots.length;
    const colorsR = new Uint8Array(nRoots);
    const colorsG = new Uint8Array(nRoots);
    const colorsB = new Uint8Array(nRoots);
    for (let i = 0; i < nRoots; i++) {
        const [r, g, b] = rootColorRGB(i, nRoots);
        colorsR[i] = r; colorsG[i] = g; colorsB[i] = b;
    }
    // Keep CSS colors for legacy fallback
    fastModeRootColors = new Array(nRoots);
    for (let i = 0; i < nRoots; i++) fastModeRootColors[i] = rootColor(i, nRoots);

    fastModeActive = true;
    fastModeStepIndex = 0;
    fastModeTotalSteps = stepsVal;
    fastModePassCount = 0;
    fastModeTargetPasses = computeFullCyclePasses();

    document.body.classList.add("fast-mode");
    document.getElementById("bitmap-fast-btn").textContent = "imode";
    if (fastModeShowProgress) {
        const prog = document.getElementById("bitmap-progress");
        if (prog) { prog.style.display = ""; document.getElementById("bitmap-progress-bar").style.width = "0%"; }
        const passEl = document.getElementById("bitmap-pass-count");
        if (passEl) {
            passEl.style.display = "";
            const tgt = fastModeTargetPasses > 0 ? "/" + String(fastModeTargetPasses).padStart(4, "0") : "";
            passEl.textContent = "0000" + tgt;
        }
    }

    // Legacy fallback for browsers without Worker
    if (typeof Worker === "undefined") {
        fastModeTimerId = setTimeout(fastModeChunkLegacy, 0);
        return;
    }

    // Serialize coefficients into flat Float64Arrays
    const nCoeffs = coefficients.length;
    const degree = nCoeffs - 1;
    const coeffsRe = new Float64Array(nCoeffs);
    const coeffsIm = new Float64Array(nCoeffs);
    for (let i = 0; i < nCoeffs; i++) {
        coeffsRe[i] = coefficients[i].re;
        coeffsIm[i] = coefficients[i].im;
    }

    // Serialize curves into one flat Float64Array + metadata
    const animEntries = [];
    const curveOffsets = [];
    const curveLengths = [];
    const curveIsCloud = [];
    let totalPts = 0;
    for (const [idx, curve] of fastModeCurves.entries()) {
        const c = coefficients[idx];
        animEntries.push({ idx, ccw: !!c.ccw, speed: c.speed });
        curveOffsets.push(totalPts);
        curveLengths.push(curve.length);
        curveIsCloud.push(!!curve._isCloud);
        totalPts += curve.length;
    }
    const curvesFlat = new Float64Array(totalPts * 2);
    let off = 0;
    for (const [, curve] of fastModeCurves.entries()) {
        for (let k = 0; k < curve.length; k++) {
            curvesFlat[off++] = curve[k].re;
            curvesFlat[off++] = curve[k].im;
        }
    }

    // Serialize current roots
    const rootsRe = new Float64Array(nRoots);
    const rootsIm = new Float64Array(nRoots);
    for (let i = 0; i < nRoots; i++) {
        rootsRe[i] = currentRoots[i].re;
        rootsIm[i] = currentRoots[i].im;
    }

    // Get existing canvas pixels for multi-pass accumulation
    const w = bitmapCtx.canvas.width, h = bitmapCtx.canvas.height;
    const existingData = bitmapCtx.getImageData(0, 0, w, h);
    const pixelBuf = existingData.data.buffer.slice(0); // detachable copy

    // Safety net: cache current pixels for early exit
    fastModeLastPixels = pixelBuf.slice(0);
    fastModeLastRoots = null;
    fastModeLastStep = 0;

    // Create and launch Worker
    const blobUrl = createFastModeWorkerBlob();
    fastModeWorker = new Worker(blobUrl);
    URL.revokeObjectURL(blobUrl);

    fastModeWorker.onmessage = handleFastModeWorkerMessage;
    fastModeWorker.onerror = function(err) {
        console.error("Fast mode worker error:", err);
        exitFastMode();
    };

    fastModeWorker.postMessage({
        coeffsRe: coeffsRe.buffer, coeffsIm: coeffsIm.buffer,
        nCoeffs, degree, nRoots,
        animEntries, curvesFlat: curvesFlat.buffer,
        curveOffsets, curveLengths, curveIsCloud,
        rootsRe: rootsRe.buffer, rootsIm: rootsIm.buffer,
        colorsR: colorsR.buffer, colorsG: colorsG.buffer, colorsB: colorsB.buffer,
        pixels: pixelBuf,
        canvasW: w, canvasH: h, bitmapRange,
        noColor: rootColorMode === "uniform",
        uniformR: uniformRootColor[0], uniformG: uniformRootColor[1], uniformB: uniformRootColor[2],
        totalSteps: stepsVal, FAST_PASS_SECONDS,
        elapsedOffset: fastModeElapsedOffset,
        frameIntervalMs: 2000
    }, [
        coeffsRe.buffer, coeffsIm.buffer, curvesFlat.buffer,
        rootsRe.buffer, rootsIm.buffer,
        colorsR.buffer, colorsG.buffer, colorsB.buffer, pixelBuf
    ]);
}

function applyPixelSnapshot(arrayBuffer) {
    if (!bitmapCtx) return;
    const w = bitmapCtx.canvas.width, h = bitmapCtx.canvas.height;
    if (arrayBuffer.byteLength !== w * h * 4) return;
    const imgData = new ImageData(new Uint8ClampedArray(arrayBuffer), w, h);
    bitmapCtx.putImageData(imgData, 0, 0);
}

function handleFastModeWorkerMessage(e) {
    const msg = e.data;
    if (!fastModeActive) return;

    if (msg.type === "progress") {
        fastModeStepIndex = msg.step;
        fastModeLastStep = msg.step;
        if (fastModeShowProgress) {
            const bar = document.getElementById("bitmap-progress-bar");
            if (bar) bar.style.width = (msg.step / fastModeTotalSteps * 100) + "%";
        }
    }
    else if (msg.type === "frame") {
        fastModeStepIndex = msg.step;
        fastModeLastStep = msg.step;
        fastModeLastPixels = msg.pixels;
        if (msg.rootsRe) fastModeLastRoots = { re: msg.rootsRe, im: msg.rootsIm };
        applyPixelSnapshot(msg.pixels);
        if (fastModeShowProgress) {
            const bar = document.getElementById("bitmap-progress-bar");
            if (bar) bar.style.width = (msg.step / fastModeTotalSteps * 100) + "%";
        }
    }
    else if (msg.type === "pass") {
        // One pass complete ‚Äî update state, Worker auto-continues
        fastModeElapsedOffset += FAST_PASS_SECONDS;
        fastModeLastStep = 0;  // reset so exitFastMode doesn't double-count
        fastModeLastPixels = msg.pixels;
        if (msg.rootsRe) fastModeLastRoots = { re: msg.rootsRe, im: msg.rootsIm };
        applyPixelSnapshot(msg.pixels);
        if (fastModeShowProgress) {
            // Reset progress bar for next pass, update pass counter
            const bar = document.getElementById("bitmap-progress-bar");
            if (bar) bar.style.width = "0%";
            const passEl = document.getElementById("bitmap-pass-count");
            if (passEl) {
                const tgt = fastModeTargetPasses > 0 ? "/" + String(fastModeTargetPasses).padStart(4, "0") : "";
                passEl.textContent = String(msg.pass).padStart(4, "0") + tgt;
            }
        }
        // Auto-stop when full cycle complete
        if (fastModeTargetPasses > 0 && msg.pass >= fastModeTargetPasses) {
            if (jiggleOnTarget && jiggleOffsets) {
                exitFastMode();
                fastModeElapsedOffset = 0;
                generateJiggleOffsets();
                enterFastMode();
            } else {
                exitFastMode();
            }
        }
    }
}

function exitFastMode() {
    if (!fastModeActive) return;

    // Advance elapsed offset so next pass continues where this one left off
    if (fastModeLastStep > 0 && fastModeTotalSteps > 0) {
        fastModeElapsedOffset += (fastModeLastStep / fastModeTotalSteps) * FAST_PASS_SECONDS;
    }

    // Terminate Worker if running
    if (fastModeWorker) { fastModeWorker.terminate(); fastModeWorker = null; }
    // Legacy fallback cleanup
    if (fastModeTimerId) { clearTimeout(fastModeTimerId); fastModeTimerId = null; }

    // Apply last received pixel snapshot (covers early "imode" exit)
    if (fastModeLastPixels && bitmapCtx) {
        applyPixelSnapshot(fastModeLastPixels);
    }

    // Restore root state from last snapshot
    if (fastModeLastRoots) {
        const rRe = new Float64Array(fastModeLastRoots.re);
        const rIm = new Float64Array(fastModeLastRoots.im);
        for (let i = 0; i < currentRoots.length && i < rRe.length; i++) {
            currentRoots[i].re = rRe[i];
            currentRoots[i].im = rIm[i];
        }
    }

    fastModeActive = false;
    fastModeCurves = null;
    fastModeRootColors = null;
    fastModeLastPixels = null;
    fastModeLastRoots = null;
    fastModeLastStep = 0;

    document.body.classList.remove("fast-mode");
    document.getElementById("bitmap-fast-btn").textContent = "fastmode";
    const prog = document.getElementById("bitmap-progress");
    if (prog) prog.style.display = "none";
    const passEl = document.getElementById("bitmap-pass-count");
    if (passEl) passEl.style.display = "none";

    // Bring interactive UI back in sync
    renderCoefficients();
    renderCoeffTrails();
    solveRoots();
}

function fastModeChunkLegacy() {
    if (!fastModeActive) return;

    const deg = coefficients.length - 1;
    const chunkSize = Math.max(10, Math.floor(200 / Math.max(3, deg)));

    const animated = fastModeCurves;
    const total = fastModeTotalSteps;
    let step = fastModeStepIndex;

    for (let s = 0; s < chunkSize && step < total; s++, step++) {
        // Virtual elapsed seconds for this step (offset for multi-pass)
        const elapsed = fastModeElapsedOffset + (step / total) * FAST_PASS_SECONDS;

        // Step coefficients on their hi-res curves
        if (animated && animated.size) {
            for (const [idx, curve] of animated.entries()) {
                const c = coefficients[idx];
                const N = curve.length;
                const dir = c.ccw ? -1 : 1;
                const t = elapsed * c.speed * dir;
                const u = ((t % 1) + 1) % 1;
                const rawIdx = u * N;

                if (curve._isCloud) {
                    const k = (rawIdx | 0) % N;
                    c.re = curve[k].re;
                    c.im = curve[k].im;
                } else {
                    const lo = (rawIdx | 0) % N;
                    const hi = (lo + 1) % N;
                    const frac = rawIdx - (rawIdx | 0);
                    c.re = curve[lo].re * (1 - frac) + curve[hi].re * frac;
                    c.im = curve[lo].im * (1 - frac) + curve[hi].im * frac;
                }
            }
        }

        // Solve roots (warm-start), preserve identity, update in-place
        let roots = solveRootsEA(coefficients, currentRoots);
        if (rootColorMode !== "uniform") roots = matchRootOrder(roots, currentRoots);
        setCurrentRootsInPlace(roots);

        // Paint
        paintBitmapFrameFast();
    }

    fastModeStepIndex = step;

    // Update progress bar (cheap DOM update once per chunk)
    if (fastModeShowProgress) {
        const bar = document.getElementById("bitmap-progress-bar");
        if (bar) bar.style.width = (fastModeStepIndex / fastModeTotalSteps * 100) + "%";
    }

    if (fastModeStepIndex >= fastModeTotalSteps) {
        // Pass complete ‚Äî advance offset, reset step counter, continue
        fastModeElapsedOffset += FAST_PASS_SECONDS;
        fastModePassCount++;
        fastModeStepIndex = 0;
        fastModeLastStep = 0;
        const pbar = document.getElementById("bitmap-progress-bar");
        if (fastModeShowProgress && pbar) pbar.style.width = "0%";
        if (fastModeShowProgress) {
            const passEl = document.getElementById("bitmap-pass-count");
            if (passEl) {
                const tgt = fastModeTargetPasses > 0 ? "/" + String(fastModeTargetPasses).padStart(4, "0") : "";
                passEl.textContent = String(fastModePassCount).padStart(4, "0") + tgt;
            }
        }
        // Auto-stop when full cycle complete
        if (fastModeTargetPasses > 0 && fastModePassCount >= fastModeTargetPasses) {
            exitFastMode();
            return;
        }
    }

    fastModeTimerId = setTimeout(fastModeChunkLegacy, 0);
}

function resetBitmap() {
    if (fastModeActive) exitFastMode();
    bitmapActive = false;
    bitmapCtx = null;
    bitmapRange = null;
    bitmapFrameCount = 0;
    fastModeElapsedOffset = 0;
    const startBtn = document.getElementById("bitmap-start-btn");
    const saveBtn = document.getElementById("bitmap-save-btn");
    const clearBtn = document.getElementById("bitmap-clear-btn");
    const fastBtn = document.getElementById("bitmap-fast-btn");
    const prog = document.getElementById("bitmap-progress");
    if (startBtn) startBtn.textContent = "start";
    if (saveBtn) saveBtn.disabled = true;
    if (clearBtn) clearBtn.disabled = true;
    if (fastBtn) { fastBtn.disabled = true; fastBtn.textContent = "fastmode"; }
    if (prog) prog.style.display = "none";
}

// Tab switching
// --- Right panel tabs ---
const tabButtons = [...document.querySelectorAll(".tab-bar [data-tab]")];
const tabContents = {
    roots: document.getElementById("roots-content"),
    stats: document.getElementById("stats-content"),
    sound: document.getElementById("sound-content"),
    bitmap: document.getElementById("bitmap-content")
};

function switchTab(tabName) {
    if (tabName === activeTab) return;
    const prevTab = activeTab;
    activeTab = tabName;
    tabButtons.forEach(btn => btn.classList.toggle("active", btn.dataset.tab === tabName));
    for (const [key, el] of Object.entries(tabContents)) el.classList.toggle("active", key === tabName);
    if (tabName === "stats") { resizeStatsCanvases(); drawAllStatsPlots(); }
    // Re-render SVG roots when switching back from bitmap (they were skipped)
    if (prevTab === "bitmap" && tabName === "roots") {
        renderDomainColoring();
        solveRoots();
    }
}
tabButtons.forEach(btn => btn.addEventListener("click", () => switchTab(btn.dataset.tab)));

// --- Left panel tabs ---
let leftTab = "coeffs";
const leftTabButtons = [...document.querySelectorAll("#left-tab-bar [data-ltab]")];
const leftTabContents = {
    coeffs: document.getElementById("coeffs-content"),
    list: document.getElementById("list-content")
};

function switchLeftTab(tabName) {
    if (tabName === leftTab) return;
    leftTab = tabName;
    leftTabButtons.forEach(btn => btn.classList.toggle("active", btn.dataset.ltab === tabName));
    for (const [key, el] of Object.entries(leftTabContents)) el.classList.toggle("active", key === tabName);
    if (tabName === "list") { refreshCoeffList(); refreshListCurveEditor(); }
}
leftTabButtons.forEach(btn => btn.addEventListener("click", () => switchLeftTab(btn.dataset.ltab)));

// --- Path display name helper ---
function pathDisplayName(t) {
    if (t === "none") return "\u2014";
    if (t === "figure8") return "Fig-8";
    if (t === "epitrochoid") return "Spiro";
    if (t === "hypotrochoid") return "Hypo";
    if (t === "rose") return "Rose";
    if (t === "hilbert") return "Hilbert";
    if (t === "peano") return "Peano";
    if (t === "sierpinski") return "Sierpinski";
    return t.charAt(0).toUpperCase() + t.slice(1);
}

// --- Path picker popup (full trajectory editor, mirrors right-click context menu) ---

const pathPickPop = document.getElementById("path-pick-pop");
let pathPickOpen = false;
let pathPickCoeffIdx = -1;
let pathPickSnapshot = null;

function closePathPickPop(revert) {
    pathPickPop.classList.remove("open");
    if (revert && pathPickSnapshot && pathPickCoeffIdx >= 0) {
        const c = coefficients[pathPickCoeffIdx];
        c.pathType = pathPickSnapshot.pathType;
        c.radius = pathPickSnapshot.radius;
        c.speed = pathPickSnapshot.speed;
        c.angle = pathPickSnapshot.angle;
        c.ccw = pathPickSnapshot.ccw;
        c.extra = pathPickSnapshot.extra || {};
        c.curve = pathPickSnapshot.curve;
        renderCoeffTrails();
    }
    pathPickOpen = false;
    pathPickCoeffIdx = -1;
    pathPickSnapshot = null;
    if (typeof leftTab !== "undefined" && leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
}

function openPathPickPop(coeffIdx, anchorEl) {
    if (pathPickOpen && pathPickCoeffIdx === coeffIdx) { closePathPickPop(true); return; }
    if (pathPickOpen) closePathPickPop(true);
    pathPickCoeffIdx = coeffIdx;

    // Snapshot for cancel/revert
    const cc = coefficients[coeffIdx];
    pathPickSnapshot = {
        pathType: cc.pathType, radius: cc.radius, speed: cc.speed,
        angle: cc.angle, ccw: cc.ccw, extra: cc.extra ? { ...cc.extra } : {},
        curve: cc.curve ? cc.curve.map(pt => ({ ...pt })) : null,
    };

    pathPickPop.innerHTML = "";
    const n = coefficients.length;
    const subIdx = n - 1 - coeffIdx;

    // Title
    const title = document.createElement("div");
    title.className = "ctx-title";
    title.textContent = "c" + subscript(subIdx) + " trajectory";
    pathPickPop.appendChild(title);

    // Path type select (clone from #anim-path)
    const pathSel = document.createElement("select");
    pathSel.innerHTML = document.getElementById("anim-path").innerHTML;
    pathSel.value = cc.pathType;
    const pathRow = document.createElement("label");
    pathRow.textContent = "Path ";
    pathRow.appendChild(pathSel);
    pathPickPop.appendChild(pathRow);

    // Dynamic controls container
    const dynContainer = document.createElement("div");
    pathPickPop.appendChild(dynContainer);
    const ppInputs = {};

    function buildPPControls(pathType) {
        dynContainer.innerHTML = "";
        for (const k in ppInputs) delete ppInputs[k];
        const schema = PATH_PARAMS[pathType] || [];
        const c = coefficients[coeffIdx];
        for (const p of schema) {
            const val = getCoeffParam(c, p.key, p);
            if (p.type === "toggle") {
                const dirRow = document.createElement("div");
                dirRow.className = "ctx-row";
                const btn = document.createElement("button");
                btn.className = "ctx-dir" + (val ? " active" : "");
                btn.textContent = val ? p.labels[1] : p.labels[0];
                btn.addEventListener("click", () => {
                    const isActive = !btn.classList.contains("active");
                    btn.classList.toggle("active", isActive);
                    btn.textContent = isActive ? p.labels[1] : p.labels[0];
                    previewPP();
                });
                dirRow.appendChild(btn);
                dynContainer.appendChild(dirRow);
                ppInputs[p.key] = btn;
            } else {
                const row = document.createElement("label");
                const ppUiVal = p.toUI ? p.toUI(val) : val;
                const valSpan = document.createElement("span");
                valSpan.className = "ctx-val";
                valSpan.textContent = p.fmt(ppUiVal);
                const inp = document.createElement("input");
                inp.type = "range"; inp.min = p.min; inp.max = p.max; inp.step = p.step; inp.value = ppUiVal;
                inp.addEventListener("input", () => {
                    valSpan.textContent = p.fmt(parseFloat(inp.value));
                    previewPP();
                });
                row.textContent = p.label + " ";
                row.appendChild(inp);
                row.appendChild(valSpan);
                dynContainer.appendChild(row);
                ppInputs[p.key] = inp;
            }
        }
    }

    buildPPControls(cc.pathType);

    pathSel.addEventListener("change", () => {
        buildPPControls(pathSel.value);
        previewPP();
    });

    // PS + Accept buttons row
    const ppBtnRow = document.createElement("div");
    ppBtnRow.style.cssText = "display:flex;gap:6px;align-items:center;justify-content:center;margin-top:4px;";
    const ppPsBtn = document.createElement("button");
    ppPsBtn.className = "ctx-accept";
    ppPsBtn.textContent = "PS";
    ppPsBtn.title = "Prime Speed ‚Äî set to nearest speed coprime with all others";
    ppPsBtn.style.cssText = "padding:4px 8px;background:transparent;border:1px solid var(--stroke);color:var(--muted);";
    ppPsBtn.addEventListener("click", () => {
        const sInp = ppInputs["speed"];
        if (!sInp) return;
        const cur = parseInt(sInp.value, 10);
        const ps = findPrimeSpeed(cur, new Set([coeffIdx]));
        if (ps !== cur) {
            sInp.value = ps;
            const vs = sInp.parentElement.querySelector(".ctx-val");
            if (vs) vs.textContent = _P.speed.fmt(ps);
            previewPP();
            uiPing(1320, 0.06);
        } else { uiBuzz(); }
    });
    ppBtnRow.appendChild(ppPsBtn);
    const acceptBtn = document.createElement("button");
    acceptBtn.className = "ctx-accept";
    acceptBtn.textContent = "Accept";
    acceptBtn.addEventListener("click", () => {
        pathPickSnapshot = null; // discard snapshot ‚Äî keep current state
        closePathPickPop(false);
    });
    ppBtnRow.appendChild(acceptBtn);
    pathPickPop.appendChild(ppBtnRow);

    // Live preview ‚Äî applies current settings immediately
    function previewPP() {
        const c = coefficients[coeffIdx];
        c.pathType = pathSel.value;
        const schema = PATH_PARAMS[c.pathType] || [];
        for (const p of schema) {
            if (p.type === "toggle") {
                setCoeffParam(c, p.key, ppInputs[p.key] ? ppInputs[p.key].classList.contains("active") : p.default);
            } else {
                const ppRaw = ppInputs[p.key] ? parseFloat(ppInputs[p.key].value) : null;
                setCoeffParam(c, p.key, ppRaw !== null ? (p.fromUI ? p.fromUI(ppRaw) : ppRaw) : p.default);
            }
        }
        if (c.pathType === "none") {
            c.curve = null;
        } else {
            const absRadius = c.radius / 100 * coeffExtent();
            c.curve = computeCurve(c.re, c.im, c.pathType, absRadius, c.angle, c.extra);
        }
        animState.elapsedAtPause = null;
        renderCoeffTrails();
    }

    // Show and position
    pathPickPop.classList.add("open");
    const r = anchorEl.getBoundingClientRect();
    const popRect = pathPickPop.getBoundingClientRect();
    let left = r.right + 6;
    let top = r.top;
    // Keep within viewport
    if (left + popRect.width > window.innerWidth - 4) left = r.left - popRect.width - 6;
    top = Math.max(4, Math.min(top, window.innerHeight - popRect.height - 4));
    pathPickPop.style.left = left + "px";
    pathPickPop.style.top = top + "px";
    pathPickOpen = true;
}

// --- Coefficient list helpers ---
function nearestCurveIndex(c) {
    if (!c.curve || c.curve.length === 0) return -1;
    let bestD = Infinity, bestK = 0;
    for (let k = 0; k < c.curve.length; k++) {
        const dx = c.re - c.curve[k].re, dy = c.im - c.curve[k].im;
        const d = dx * dx + dy * dy;
        if (d < bestD) { bestD = d; bestK = k; }
    }
    return bestK;
}

// --- Coefficient list tab ---
function refreshCoeffList() {
    buildCurveCycleTypes();
    updateCurveCycleLabel();
    const container = document.getElementById("coeff-list-scroll");
    container.innerHTML = "";
    const deg = coefficients.length - 1;
    const n = coefficients.length;
    const coeffSens = computeCoeffSensitivities();
    document.getElementById("list-count").textContent = n + " coefficients";
    for (let i = 0; i < n; i++) {
        const row = document.createElement("div");
        row.className = "cpick-row";

        const cb = document.createElement("span");
        cb.className = "cpick-cb" + (selectedCoeffs.has(i) ? " checked" : "");

        const dot = document.createElement("span");
        dot.className = "cpick-dot";
        dot.style.background = coeffColor(i, n);

        const sensDot = document.createElement("span");
        sensDot.className = "cpick-dot";
        sensDot.style.background = coeffSens ? sensitivityColor(coeffSens[i]) : "#555";

        const label = document.createElement("span");
        label.className = "cpick-label";
        label.textContent = "c" + (deg - i);

        const power = document.createElement("span");
        power.className = "cpick-power";
        const exp = deg - i;
        power.textContent = exp === 0 ? "1" : exp === 1 ? "z" : "z" + superscript(exp);

        const pathBtn = document.createElement("button");
        pathBtn.className = "cpick-path-btn";
        const ci = coefficients[i];
        if (ci.pathType !== "none") {
            pathBtn.textContent = pathDisplayName(ci.pathType);
        } else {
            pathBtn.textContent = "\u2014";
        }

        const speedSpan = document.createElement("span");
        speedSpan.className = "cpick-speed";
        speedSpan.textContent = ci.pathType !== "none" ? String(Math.round(ci.speed * 100)) : "\u2014";

        const plenSpan = document.createElement("span");
        plenSpan.className = "cpick-plen";
        plenSpan.textContent = ci.curve ? String(ci.curve.length) : "\u2014";

        const posSpan = document.createElement("span");
        posSpan.className = "cpick-pos";
        const curIdx = nearestCurveIndex(ci);
        posSpan.textContent = curIdx >= 0 ? String(curIdx) : "\u2014";

        const coords = document.createElement("span");
        coords.className = "cpick-coords";
        const c = coefficients[i];
        const sign = c.im >= 0 ? "+" : "";
        coords.textContent = c.re.toFixed(2) + sign + c.im.toFixed(2) + "i";

        row.appendChild(cb);
        row.appendChild(dot);
        row.appendChild(sensDot);
        row.appendChild(label);
        row.appendChild(power);
        row.appendChild(pathBtn);
        row.appendChild(speedSpan);
        row.appendChild(plenSpan);
        row.appendChild(posSpan);
        row.appendChild(coords);

        const idx = i;
        cb.addEventListener("click", (e) => {
            e.stopPropagation();
            clearRootSelection();
            if (selectedCoeffs.has(idx)) {
                selectedCoeffs.delete(idx);
                cb.classList.remove("checked");
            } else {
                selectedCoeffs.add(idx);
                cb.classList.add("checked");
                lastSelectedCoeff = idx;
            }
            updateCoeffSelectionVisual();
            updateAnimBar();
            refreshListCurveEditor();
        });
        pathBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            openPathPickPop(idx, pathBtn);
        });

        container.appendChild(row);
    }
}

// Lightweight update: refresh coordinate text + pos in existing list rows (called every frame during anim/drag)
function updateListCoords() {
    if (typeof leftTab === "undefined" || leftTab !== "list") return;
    const rows = document.querySelectorAll("#coeff-list-scroll .cpick-row");
    const n = coefficients.length;
    if (rows.length !== n) { refreshCoeffList(); return; } // size mismatch ‚Äî full rebuild
    for (let i = 0; i < n; i++) {
        const c = coefficients[i];
        const coordsEl = rows[i].querySelector(".cpick-coords");
        if (coordsEl) {
            const sign = c.im >= 0 ? "+" : "";
            coordsEl.textContent = c.re.toFixed(2) + sign + c.im.toFixed(2) + "i";
        }
        const posEl = rows[i].querySelector(".cpick-pos");
        if (posEl) {
            const idx = nearestCurveIndex(c);
            posEl.textContent = idx >= 0 ? String(idx) : "\u2014";
        }
    }
}

// Full column update: refresh path, speed, pts columns (called after trajectory changes)
function updateListPathCols() {
    if (typeof leftTab === "undefined" || leftTab !== "list") return;
    const rows = document.querySelectorAll("#coeff-list-scroll .cpick-row");
    const n = coefficients.length;
    if (rows.length !== n) { refreshCoeffList(); return; }
    for (let i = 0; i < n; i++) {
        const c = coefficients[i];
        const pathBtn = rows[i].querySelector(".cpick-path-btn");
        if (pathBtn) {
            pathBtn.textContent = c.pathType !== "none" ? pathDisplayName(c.pathType) : "\u2014";
        }
        const speedEl = rows[i].querySelector(".cpick-speed");
        if (speedEl) {
            speedEl.textContent = c.pathType !== "none" ? String(Math.round(c.speed * 100)) : "\u2014";
        }
        const plenEl = rows[i].querySelector(".cpick-plen");
        if (plenEl) {
            plenEl.textContent = c.curve ? String(c.curve.length) : "\u2014";
        }
    }
}

document.getElementById("list-select-all-btn").addEventListener("click", () => {
    clearRootSelection();
    for (let i = 0; i < coefficients.length; i++) selectedCoeffs.add(i);
    updateCoeffSelectionVisual();
    updateAnimBar();
    if (leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
});
document.getElementById("list-deselect-all-btn").addEventListener("click", () => {
    selectedCoeffs.clear();
    lastSelectedCoeff = -1;
    updateCoeffSelectionVisual();
    updateAnimBar();
    if (leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
});
// --- Curve type cycler ---
let curveCycleTypes = [];  // sorted list of all unique path types across all coefficients
let curveCycleIdx = 0;

function buildCurveCycleTypes() {
    const types = new Set();
    for (const c of coefficients) types.add(c.pathType);
    curveCycleTypes = [...types].sort();
    if (curveCycleTypes.length === 0) curveCycleTypes = ["none"];
}

function updateCurveCycleLabel() {
    const label = document.getElementById("list-curve-cycle");
    if (curveCycleTypes.length === 0) { label.textContent = "\u2014"; return; }
    if (curveCycleIdx >= curveCycleTypes.length) curveCycleIdx = 0;
    if (curveCycleIdx < 0) curveCycleIdx = curveCycleTypes.length - 1;
    label.textContent = pathDisplayName(curveCycleTypes[curveCycleIdx]);
}

function selectByCurveType(type) {
    clearRootSelection();
    selectedCoeffs.clear();
    for (let i = 0; i < coefficients.length; i++) {
        if (coefficients[i].pathType === type) selectedCoeffs.add(i);
    }
    updateCoeffSelectionVisual();
    updateAnimBar();
    if (leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
}

// "Same Curve" button: select all coefficients with the currently displayed curve type
document.getElementById("list-all-curves-btn").addEventListener("click", () => {
    if (curveCycleTypes.length === 0) return;
    selectByCurveType(curveCycleTypes[curveCycleIdx]);
});

document.getElementById("list-curve-prev").addEventListener("click", () => {
    buildCurveCycleTypes();
    if (curveCycleTypes.length === 0) return;
    curveCycleIdx = (curveCycleIdx - 1 + curveCycleTypes.length) % curveCycleTypes.length;
    updateCurveCycleLabel();
    selectByCurveType(curveCycleTypes[curveCycleIdx]);
});

document.getElementById("list-curve-next").addEventListener("click", () => {
    buildCurveCycleTypes();
    if (curveCycleTypes.length === 0) return;
    curveCycleIdx = (curveCycleIdx + 1) % curveCycleTypes.length;
    updateCurveCycleLabel();
    selectByCurveType(curveCycleTypes[curveCycleIdx]);
});

// --- List curve editor ---
const lcePanel = document.getElementById("list-curve-editor");
const lcePathSel = document.getElementById("lce-path-sel");
const lceCoeffName = document.getElementById("lce-coeff-name");
const lceControls = document.getElementById("lce-controls");
let lceInputs = {};       // { key: <input or button element> }
let lceCurrentPath = "";  // path type currently shown in dropdown
let lceCycleIdx = 0;      // index into selected coefficients list
let lceCycleList = [];     // all selected coefficient indices

function refreshListCurveEditor() {
    if (selectedCoeffs.size === 0) {
        lcePanel.style.opacity = "0.3";
        lcePanel.style.pointerEvents = "none";
        return;
    }
    lcePanel.style.opacity = "1";
    lcePanel.style.pointerEvents = "";

    // Build cycle list: ALL selected coefficients
    lceCycleList = [...selectedCoeffs].sort((a, b) => a - b);

    // Clamp cycle index
    if (lceCycleIdx >= lceCycleList.length) lceCycleIdx = 0;
    if (lceCycleIdx < 0) lceCycleIdx = lceCycleList.length - 1;

    // Load current coefficient's path type into dropdown and build controls
    const ci = lceCycleList[lceCycleIdx];
    const c = coefficients[ci];
    lcePathSel.value = c.pathType || "none";
    lceCurrentPath = lcePathSel.value;

    updateLceCyclerLabel();
    buildLceControls(lceCurrentPath);
}

// When dropdown changes, rebuild controls with defaults for the new path type
lcePathSel.addEventListener("change", () => {
    lceCurrentPath = lcePathSel.value;
    buildLceControls(lceCurrentPath);
});

function updateLceCyclerLabel() {
    const updateOneBtn = document.getElementById("lce-update-one");
    if (lceCycleList.length === 0) {
        lceCoeffName.textContent = "‚Äî";
        updateOneBtn.textContent = "Update ‚Äî";
        return;
    }
    const ci = lceCycleList[lceCycleIdx];
    const n = coefficients.length;
    const sub = n - 1 - ci;
    const color = coeffColor(ci, n);
    lceCoeffName.textContent = "c" + sub;
    lceCoeffName.style.color = color;
    updateOneBtn.textContent = "Update c" + sub;
}

function buildLceControls(pathType) {
    lceControls.innerHTML = "";
    lceInputs = {};
    const schema = PATH_PARAMS[pathType] || [];
    if (schema.length === 0) return;
    const ci = lceCycleList[lceCycleIdx];
    const c = coefficients[ci];
    for (const p of schema) {
        const val = getCoeffParam(c, p.key, p);
        if (p.type === "toggle") {
            const btn = document.createElement("button");
            btn.className = "ctx-dir" + (val ? " active" : "");
            btn.textContent = val ? p.labels[1] : p.labels[0];
            btn.addEventListener("click", () => {
                const isActive = !btn.classList.contains("active");
                btn.classList.toggle("active", isActive);
                btn.textContent = isActive ? p.labels[1] : p.labels[0];
            });
            lceControls.appendChild(btn);
            lceInputs[p.key] = btn;
        } else {
            const row = document.createElement("label");
            const lceUiVal = p.toUI ? p.toUI(val) : val;
            const valSpan = document.createElement("span");
            valSpan.className = "ctx-val";
            valSpan.textContent = p.fmt(lceUiVal);
            const inp = document.createElement("input");
            inp.type = "range"; inp.min = p.min; inp.max = p.max; inp.step = p.step; inp.value = lceUiVal;
            inp.addEventListener("input", () => {
                valSpan.textContent = p.fmt(parseFloat(inp.value));
            });
            row.textContent = p.label + " ";
            row.appendChild(inp);
            row.appendChild(valSpan);
            lceControls.appendChild(row);
            lceInputs[p.key] = inp;
        }
    }
}

function lceReadParams() {
    // Read current slider/toggle values into an object
    const schema = PATH_PARAMS[lceCurrentPath] || [];
    const params = {};
    for (const p of schema) {
        if (p.type === "toggle") {
            params[p.key] = lceInputs[p.key] ? lceInputs[p.key].classList.contains("active") : p.default;
        } else {
            const lceRaw = lceInputs[p.key] ? parseFloat(lceInputs[p.key].value) : null;
            params[p.key] = lceRaw !== null ? (p.fromUI ? p.fromUI(lceRaw) : lceRaw) : p.default;
        }
    }
    return params;
}

function lceApplyToCoeff(ci, params) {
    const c = coefficients[ci];
    // Set path type from dropdown
    c.pathType = lceCurrentPath;
    const schema = PATH_PARAMS[lceCurrentPath] || [];
    for (const p of schema) {
        setCoeffParam(c, p.key, params[p.key]);
    }
    if (c.pathType === "none") {
        c.curve = null;
    } else {
        const absRadius = c.radius / 100 * coeffExtent();
        c.curve = computeCurve(c.re, c.im, c.pathType, absRadius, c.angle, c.extra);
    }
}

function lceSyncToCurrentCoeff() {
    const ci = lceCycleList[lceCycleIdx];
    const c = coefficients[ci];
    lcePathSel.value = c.pathType || "none";
    lceCurrentPath = lcePathSel.value;
    updateLceCyclerLabel();
    buildLceControls(lceCurrentPath);
}
document.getElementById("lce-prev").addEventListener("click", () => {
    if (lceCycleList.length === 0) return;
    lceCycleIdx = (lceCycleIdx - 1 + lceCycleList.length) % lceCycleList.length;
    lceSyncToCurrentCoeff();
});
document.getElementById("lce-next").addEventListener("click", () => {
    if (lceCycleList.length === 0) return;
    lceCycleIdx = (lceCycleIdx + 1) % lceCycleList.length;
    lceSyncToCurrentCoeff();
});
document.getElementById("lce-update-sel").addEventListener("click", () => {
    if (lceCycleList.length === 0) return;
    const params = lceReadParams();
    for (const ci of lceCycleList) {
        lceApplyToCoeff(ci, params);
    }
    animState.elapsedAtPause = null;
    renderCoeffTrails();
    buildCurveCycleTypes(); updateCurveCycleLabel();
    if (leftTab === "list") { updateListPathCols(); updateListCoords(); }
});
document.getElementById("lce-update-one").addEventListener("click", () => {
    if (lceCycleList.length === 0) return;
    const params = lceReadParams();
    lceApplyToCoeff(lceCycleList[lceCycleIdx], params);
    animState.elapsedAtPause = null;
    renderCoeffTrails();
    buildCurveCycleTypes(); updateCurveCycleLabel();
    if (leftTab === "list") { updateListPathCols(); updateListCoords(); }
});
document.getElementById("lce-ps-btn").addEventListener("click", () => {
    if (lceCycleList.length === 0) return;
    const sInp = lceInputs["speed"];
    if (!sInp) return;
    const ci = lceCycleList[lceCycleIdx];
    const cur = parseInt(sInp.value, 10);
    const ps = findPrimeSpeed(cur, new Set([ci]));
    if (ps !== cur) {
        sInp.value = ps;
        const vs = sInp.parentElement.querySelector(".ctx-val");
        if (vs) vs.textContent = _P.speed.fmt(ps);
        uiPing(1320, 0.06);
    } else { uiBuzz(); }
});

// Bitmap tab buttons
document.getElementById("bitmap-start-btn").addEventListener("click", function () {
    initBitmapCanvas();
    document.getElementById("bitmap-save-btn").disabled = false;
    document.getElementById("bitmap-clear-btn").disabled = false;
    document.getElementById("bitmap-fast-btn").disabled = false;
    document.getElementById("jiggle-btn").disabled = false;
    this.textContent = "restart";
});

document.getElementById("bitmap-save-btn").addEventListener("click", function () {
    const canvas = document.getElementById("bitmap-canvas");
    canvas.toBlob(function (blob) {
        const ts = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "polypaint-bitmap-" + ts + ".png";
        a.click();
        URL.revokeObjectURL(a.href);
    }, "image/png");
});

document.getElementById("bitmap-clear-btn").addEventListener("click", function () {
    if (bitmapCtx) {
        bitmapCtx.fillStyle = bitmapCanvasColor;
        bitmapCtx.fillRect(0, 0, bitmapCtx.canvas.width, bitmapCtx.canvas.height);
        bitmapFrameCount = 0;
        fastModeElapsedOffset = 0;
    }
});

// --- Fastmode popup ---
const fastmodePop = document.getElementById("fastmode-pop");
let fastmodePopOpen = false;

function closeFastmodePop() {
    fastmodePop.classList.remove("open");
    fastmodePopOpen = false;
}

function openFastmodePop() {
    if (fastmodePopOpen) { closeFastmodePop(); return; }
    fastmodePop.innerHTML = "";

    const title = document.createElement("div");
    title.className = "pop-title";
    title.textContent = "FASTMODE";
    fastmodePop.appendChild(title);

    // Progress checkbox
    const cbRow = document.createElement("div");
    cbRow.style.cssText = "display:flex;align-items:center;gap:4px;margin:4px 0;";
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.id = "fastmode-progress-cb";
    cb.checked = fastModeShowProgress;
    cb.style.cssText = "margin:0;";
    cb.addEventListener("change", () => { fastModeShowProgress = cb.checked; });
    const cbLabel = document.createElement("label");
    cbLabel.htmlFor = "fastmode-progress-cb";
    cbLabel.style.cssText = "font-size:10px;color:var(--fg);cursor:pointer;";
    cbLabel.textContent = "Progress bar";
    cbRow.appendChild(cb);
    cbRow.appendChild(cbLabel);
    fastmodePop.appendChild(cbRow);

    // Go button
    const goBtn = document.createElement("button");
    goBtn.textContent = "Go!";
    goBtn.style.cssText = "font-size:10px;padding:3px 10px;background:var(--accent);color:#000;border:none;border-radius:3px;cursor:pointer;margin-top:4px;width:100%;";
    goBtn.addEventListener("click", () => {
        closeFastmodePop();
        enterFastMode();
    });
    fastmodePop.appendChild(goBtn);

    fastmodePop.classList.add("open");
    const r = document.getElementById("bitmap-fast-btn").getBoundingClientRect();
    fastmodePop.style.left = r.left + "px";
    fastmodePop.style.top = (r.bottom + 6) + "px";
    fastmodePopOpen = true;
}

document.getElementById("bitmap-fast-btn").addEventListener("click", function () {
    if (fastModeActive) exitFastMode();
    else openFastmodePop();
});

// --- Bitmap canvas background color popup ---
const bitmapBgPop = document.getElementById("bitmap-bg-pop");
let bitmapBgPopOpen = false;

const CANVAS_BG_COLORS = [
    { hex: "#000000", label: "Black" },
    { hex: "#ffffff", label: "White" },
    { hex: "#0a0a0a", label: "Near Black" },
    { hex: "#1a1a2e", label: "Midnight" },
    { hex: "#16213e", label: "Deep Navy" },
    { hex: "#0f3460", label: "Dark Sapphire" },
    { hex: "#1b1b2f", label: "Space" },
    { hex: "#2d132c", label: "Aubergine" },
    { hex: "#1a0a2e", label: "Deep Violet" },
    { hex: "#0d1b2a", label: "Dark Teal" },
    { hex: "#1b2a1b", label: "Forest Night" },
    { hex: "#2a1b1b", label: "Dark Ember" },
    { hex: "#f5f0e8", label: "Warm White" },
    { hex: "#faf3e0", label: "Parchment" },
    { hex: "#eee8d5", label: "Antique Linen" },
    { hex: "#e8e0d0", label: "Ivory Sand" },
    { hex: "#d4c5a9", label: "Pale Khaki" },
    { hex: "#c4b7a6", label: "Warm Stone" },
    { hex: "#2b2b2b", label: "Charcoal" },
    { hex: "#3c3c3c", label: "Graphite" },
    { hex: "#4a4a4a", label: "Slate" },
    { hex: "#6b6b6b", label: "Ash" },
    { hex: "#8b8b8b", label: "Silver" },
    { hex: "#b0b0b0", label: "Mist" },
];

function closeBitmapBgPop() {
    bitmapBgPop.classList.remove("open");
    bitmapBgPopOpen = false;
}

function openBitmapBgPop() {
    if (bitmapBgPopOpen) { closeBitmapBgPop(); return; }
    bitmapBgPop.innerHTML = "";
    const title = document.createElement("div");
    title.className = "pop-title";
    title.textContent = "CANVAS BG";
    bitmapBgPop.appendChild(title);

    const grid = document.createElement("div");
    grid.style.cssText = "display:flex;flex-wrap:wrap;gap:3px;padding:4px 0;";
    for (const c of CANVAS_BG_COLORS) {
        const sw = document.createElement("div");
        const isActive = bitmapCanvasColor.toLowerCase() === c.hex.toLowerCase();
        const isDark = parseInt(c.hex.slice(1, 3), 16) * 0.299 +
                       parseInt(c.hex.slice(3, 5), 16) * 0.587 +
                       parseInt(c.hex.slice(5, 7), 16) * 0.114 < 128;
        sw.style.cssText = `width:20px;height:20px;border-radius:50%;cursor:pointer;` +
            `background:${c.hex};border:2px solid ${isActive ? "#fff" : (isDark ? "rgba(255,255,255,0.15)" : "rgba(0,0,0,0.15)")};` +
            `flex-shrink:0;`;
        sw.title = c.label;
        sw.addEventListener("click", () => {
            bitmapCanvasColor = c.hex;
            closeBitmapBgPop();
            // Update container CSS background to match
            document.getElementById("bitmap-container").style.background = c.hex;
        });
        grid.appendChild(sw);
    }
    bitmapBgPop.appendChild(grid);

    bitmapBgPop.classList.add("open");
    const r = document.getElementById("bitmap-bg-btn").getBoundingClientRect();
    bitmapBgPop.style.left = r.left + "px";
    bitmapBgPop.style.top = (r.bottom + 6) + "px";
    bitmapBgPopOpen = true;
}

document.getElementById("bitmap-bg-btn").addEventListener("click", openBitmapBgPop);

// --- Jiggle popup ---
const jigglePop = document.getElementById("jiggle-pop");
let jigglePopOpen = false;

function gaussRand() {
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
}

function computeAnimatedCentroid() {
    const animated = allAnimatedCoeffs();
    if (animated.size === 0) return { re: 0, im: 0 };
    let sre = 0, sim = 0;
    for (const idx of animated) {
        const c = coefficients[idx];
        sre += c.curve ? c.curve[0].re : c.re;
        sim += c.curve ? c.curve[0].im : c.im;
    }
    return { re: sre / animated.size, im: sim / animated.size };
}

function generateJiggleOffsets() {
    const animated = allAnimatedCoeffs();
    if (animated.size === 0 || jiggleMode === "none") { jiggleOffsets = null; updateJiggleStatus(); return; }

    if (jiggleMode === "random") {
        const sigma = (jiggleSigma / 100) * coeffExtent();
        if (sigma <= 0) { jiggleOffsets = null; updateJiggleStatus(); return; }
        jiggleOffsets = new Map();
        for (const idx of animated) {
            jiggleOffsets.set(idx, { re: gaussRand() * sigma, im: gaussRand() * sigma });
        }
    } else if (jiggleMode === "rotate") {
        jiggleCumulativeAngle += jiggleTheta * 2 * Math.PI;
        const cen = computeAnimatedCentroid();
        const cos_a = Math.cos(jiggleCumulativeAngle);
        const sin_a = Math.sin(jiggleCumulativeAngle);
        jiggleOffsets = new Map();
        for (const idx of animated) {
            const c = coefficients[idx];
            const hre = c.curve ? c.curve[0].re : c.re;
            const him = c.curve ? c.curve[0].im : c.im;
            const dx = hre - cen.re, dy = him - cen.im;
            jiggleOffsets.set(idx, {
                re: dx * cos_a - dy * sin_a - dx,
                im: dx * sin_a + dy * cos_a - dy
            });
        }
    } else if (jiggleMode === "walk") {
        const sigma = (jiggleSigma / 100) * coeffExtent();
        if (sigma <= 0) { jiggleOffsets = null; updateJiggleStatus(); return; }
        if (!jiggleOffsets) jiggleOffsets = new Map();
        for (const idx of animated) {
            const prev = jiggleOffsets.get(idx) || { re: 0, im: 0 };
            jiggleOffsets.set(idx, {
                re: prev.re + gaussRand() * sigma,
                im: prev.im + gaussRand() * sigma
            });
        }
    } else if (jiggleMode === "scale") {
        jiggleCumulativeScale *= (1 + jiggleScaleStep / 100);
        const cen = computeAnimatedCentroid();
        jiggleOffsets = new Map();
        for (const idx of animated) {
            const c = coefficients[idx];
            const hre = c.curve ? c.curve[0].re : c.re;
            const him = c.curve ? c.curve[0].im : c.im;
            const dx = hre - cen.re, dy = him - cen.im;
            jiggleOffsets.set(idx, {
                re: dx * (jiggleCumulativeScale - 1),
                im: dy * (jiggleCumulativeScale - 1)
            });
        }
    }
    updateJiggleStatus();
}

function updateJiggleStatus() {
    const el = document.getElementById("jiggle-status");
    if (!el) return;
    if (jiggleOffsets && jiggleOffsets.size > 0) {
        el.textContent = jiggleOffsets.size + " offsets active";
        el.style.color = "var(--accent)";
    } else {
        el.textContent = "no offsets";
        el.style.color = "var(--muted)";
    }
}

function closeJigglePop() {
    jigglePop.classList.remove("open");
    jigglePopOpen = false;
}

function openJigglePop() {
    if (jigglePopOpen) { closeJigglePop(); return; }
    jigglePop.innerHTML = "";
    const inpStyle = "width:50px;background:var(--bg);color:var(--fg);border:1px solid var(--stroke);border-radius:3px;padding:2px 4px;font-size:10px;";
    const lblStyle = "font-size:10px;color:var(--fg);";
    const hintStyle = "font-size:9px;color:var(--muted);";
    const rowStyle = "display:flex;align-items:center;gap:6px;margin:4px 0;";

    // Title
    const title = document.createElement("div");
    title.className = "pop-title";
    title.textContent = "JIGGLE";
    jigglePop.appendChild(title);

    // Mode dropdown row
    const modeRow = document.createElement("div");
    modeRow.style.cssText = rowStyle;
    const modeLbl = document.createElement("span");
    modeLbl.style.cssText = lblStyle;
    modeLbl.textContent = "Mode";
    const modeSel = document.createElement("select");
    modeSel.style.cssText = "background:var(--bg);color:var(--fg);border:1px solid var(--stroke);border-radius:3px;padding:2px 4px;font-size:10px;";
    for (const m of ["none", "random", "rotate", "walk", "scale"]) {
        const opt = document.createElement("option");
        opt.value = m;
        opt.textContent = m.charAt(0).toUpperCase() + m.slice(1);
        if (m === jiggleMode) opt.selected = true;
        modeSel.appendChild(opt);
    }
    modeRow.appendChild(modeLbl);
    modeRow.appendChild(modeSel);
    jigglePop.appendChild(modeRow);

    // Controls container ‚Äî rebuilt when mode changes
    const controlsDiv = document.createElement("div");
    jigglePop.appendChild(controlsDiv);

    function buildModeControls() {
        controlsDiv.innerHTML = "";
        if (jiggleMode === "random" || jiggleMode === "walk") {
            // œÉ row
            const row = document.createElement("div");
            row.style.cssText = rowStyle;
            const lbl = document.createElement("span");
            lbl.style.cssText = lblStyle;
            lbl.textContent = "œÉ";
            const inp = document.createElement("input");
            inp.type = "number"; inp.step = "1"; inp.min = "0"; inp.max = "100";
            inp.value = jiggleSigma;
            inp.style.cssText = inpStyle;
            inp.addEventListener("input", () => {
                jiggleSigma = Math.max(0, Math.min(100, parseInt(inp.value, 10) || 0));
            });
            const hint = document.createElement("span");
            hint.style.cssText = hintStyle;
            hint.textContent = "/ 100";
            row.appendChild(lbl); row.appendChild(inp); row.appendChild(hint);
            controlsDiv.appendChild(row);
        } else if (jiggleMode === "rotate") {
            // Œ∏ row
            const row = document.createElement("div");
            row.style.cssText = rowStyle;
            const lbl = document.createElement("span");
            lbl.style.cssText = lblStyle;
            lbl.textContent = "Œ∏";
            const inp = document.createElement("input");
            inp.type = "number"; inp.step = "0.001"; inp.min = "0.001"; inp.max = "0.500";
            inp.value = jiggleTheta;
            inp.style.cssText = inpStyle;
            const hint = document.createElement("span");
            hint.style.cssText = hintStyle;
            hint.textContent = "= " + (jiggleTheta * 360).toFixed(1) + "¬∞";
            inp.addEventListener("input", () => {
                jiggleTheta = Math.max(0.001, Math.min(0.500, parseFloat(inp.value) || 0.01));
                hint.textContent = "= " + (jiggleTheta * 360).toFixed(1) + "¬∞";
            });
            row.appendChild(lbl); row.appendChild(inp); row.appendChild(hint);
            controlsDiv.appendChild(row);
        } else if (jiggleMode === "scale") {
            // step row
            const row = document.createElement("div");
            row.style.cssText = rowStyle;
            const lbl = document.createElement("span");
            lbl.style.cssText = lblStyle;
            lbl.textContent = "step";
            const inp = document.createElement("input");
            inp.type = "number"; inp.step = "1"; inp.min = "1"; inp.max = "50";
            inp.value = jiggleScaleStep;
            inp.style.cssText = inpStyle;
            inp.addEventListener("input", () => {
                jiggleScaleStep = Math.max(1, Math.min(50, parseInt(inp.value, 10) || 5));
            });
            const hint = document.createElement("span");
            hint.style.cssText = hintStyle;
            hint.textContent = "%";
            row.appendChild(lbl); row.appendChild(inp); row.appendChild(hint);
            controlsDiv.appendChild(row);
        }
    }
    buildModeControls();

    modeSel.addEventListener("change", () => {
        jiggleMode = modeSel.value;
        buildModeControls();
    });

    // Buttons row
    const btnRow = document.createElement("div");
    btnRow.style.cssText = "display:flex;gap:4px;margin:4px 0;";
    const genBtn = document.createElement("button");
    genBtn.textContent = "Generate";
    genBtn.style.cssText = "font-size:9px;padding:2px 6px;background:var(--accent);color:#000;border:none;border-radius:3px;cursor:pointer;";
    genBtn.addEventListener("click", () => {
        generateJiggleOffsets();
        (jiggleOffsets && jiggleOffsets.size > 0) ? uiPing(880, 0.08) : uiBuzz();
    });
    const clrBtn = document.createElement("button");
    clrBtn.textContent = "Clear";
    clrBtn.style.cssText = "font-size:9px;padding:2px 6px;background:transparent;color:var(--muted);border:1px solid var(--stroke);border-radius:3px;cursor:pointer;";
    clrBtn.addEventListener("click", () => {
        jiggleOffsets = null;
        jiggleCumulativeAngle = 0;
        jiggleCumulativeScale = 1.0;
        updateJiggleStatus();
    });
    btnRow.appendChild(genBtn);
    btnRow.appendChild(clrBtn);
    jigglePop.appendChild(btnRow);

    // OnTarget checkbox
    const otRow = document.createElement("div");
    otRow.style.cssText = "display:flex;align-items:center;gap:4px;margin:4px 0;";
    const otCb = document.createElement("input");
    otCb.type = "checkbox";
    otCb.id = "jiggle-ontarget";
    otCb.checked = jiggleOnTarget;
    otCb.style.cssText = "margin:0;";
    otCb.addEventListener("change", () => { jiggleOnTarget = otCb.checked; });
    const otLabel = document.createElement("label");
    otLabel.htmlFor = "jiggle-ontarget";
    otLabel.style.cssText = "font-size:10px;color:var(--fg);cursor:pointer;";
    otLabel.textContent = "OnTarget";
    otRow.appendChild(otCb);
    otRow.appendChild(otLabel);
    jigglePop.appendChild(otRow);

    // Status
    const status = document.createElement("div");
    status.id = "jiggle-status";
    status.style.cssText = "font-size:9px;margin-top:2px;";
    jigglePop.appendChild(status);
    updateJiggleStatus();

    jigglePop.classList.add("open");
    const r = document.getElementById("jiggle-btn").getBoundingClientRect();
    jigglePop.style.left = r.left + "px";
    jigglePop.style.top = (r.bottom + 6) + "px";
    jigglePopOpen = true;
}

document.getElementById("jiggle-btn").addEventListener("click", openJigglePop);

function rebuild() {
    S = getPanelSize();
    initPanelScales(panels.coeff);
    initPanelScales(panels.roots);

    // Clear and rebuild both SVGs
    coeffSvg.selectAll("*").remove();
    rootsSvg.selectAll("*").remove();
    setupPanel(coeffSvg, panels.coeff);
    setupPanel(rootsSvg, panels.roots);

    // Recreate layers
    coeffTrailLayer = coeffSvg.append("g").attr("class", "trail-layer");
    coeffLayer = coeffSvg.append("g");
    coeffChainLine = coeffLayer.append("polyline")
        .attr("class", "coeff-chain")
        .attr("fill", "none")
        .attr("stroke", "rgba(255,255,255,0.35)")
        .attr("stroke-width", 1.5)
        .attr("stroke-dasharray", "4,3")
        .style("display", "none");
    trailLayer = rootsSvg.append("g").attr("class", "trail-layer");
    rootsLayer = rootsSvg.append("g");

    renderCoefficients();
    updateCoeffSelectionVisual();

    // Re-solve roots and re-render domain coloring at new size
    solveRoots();
    rootsSvg.classed("domain-active", domainColoringEnabled);
    renderDomainColoring();
    if (trailData.length > 0) renderTrails();
    renderCoeffTrails();
    resizeStatsCanvases();
    if (activeTab === "stats") drawAllStatsPlots();
}

let resizeTimer;
window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(rebuild, 150);
});

// --- Init ---

rootsSvg.classed("domain-active", domainColoringEnabled);
domainCanvas.style.display = domainColoringEnabled ? "block" : "none";
initCoefficients(currentDegree);
renderCoefficients();
solveRoots();
renderDomainColoring();

// Install marquee selection (once ‚Äî survives rebuild since SVG element persists)
installMarqueeSelection(coeffSvg, () => coeffLayer.selectAll("circle.coeff"), "coeff");
installMarqueeSelection(rootsSvg, () => rootsLayer.selectAll("circle.root"), "roots");

// Default trajectory: C3 (index 2) ‚Äî circle, R50%, S0.5, A0.33, CW
{
    const c = coefficients[2];
    c.pathType = "circle"; c.radius = 50; c.speed = 0.5; c.angle = 0.33; c.ccw = false; c.extra = {};
    c.curve = computeCurve(c.re, c.im, "circle", 50 / 100 * coeffExtent(), 0.33, c.extra);
    selectedCoeffs.add(2);
    lastSelectedCoeff = 2;
}
// Default trajectory: C0 (index 5) ‚Äî circle, R15%, S0.85, A0.85, CW
{
    const c2 = coefficients[5];
    c2.pathType = "circle"; c2.radius = 15; c2.speed = 0.85; c2.angle = 0.85; c2.ccw = false; c2.extra = {};
    c2.curve = computeCurve(c2.re, c2.im, "circle", 15 / 100 * coeffExtent(), 0.85, c2.extra);
}
updateCoeffSelectionVisual();
updateAnimBar();
renderCoeffTrails();
</script>
</body>
</html>
