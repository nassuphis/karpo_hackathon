<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>PolyPaint</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; }
body { font-family: 'Segoe UI', system-ui, sans-serif; background: #1a1a2e; color: #eee; display: flex; flex-direction: column; }
/* --- Header --- */
#header {
    padding: 4px 16px; border-bottom: 1px solid #2a2a4a; flex-shrink: 0;
}
#header .app-title { font-size: 14px; font-weight: 600; color: #8888aa; letter-spacing: 0.5px; }
#domain-toggle-btn {
    background: transparent; color: #666; border: 1px solid #444; border-radius: 12px;
    padding: 3px 10px; font-size: 11px; cursor: pointer; transition: all 0.15s;
}
#domain-toggle-btn.active { background: #e94560; color: #fff; border-color: #e94560; }
#domain-toggle-btn:hover:not(.active) { color: #aaa; border-color: #666; }
#root-color-btn {
    background: transparent; color: #666; border: 1px solid #444; border-radius: 12px;
    padding: 3px 10px; font-size: 11px; cursor: pointer; transition: all 0.15s;
}
#root-color-btn.active { background: #e94560; color: #fff; border-color: #e94560; }
#root-color-btn:hover:not(.active) { color: #aaa; border-color: #666; }
#deselect-btn {
    background: transparent; color: #666; border: 1px solid #444; border-radius: 12px;
    padding: 3px 10px; font-size: 11px; cursor: pointer; transition: all 0.15s;
}
#deselect-btn:hover { color: #eee; border-color: #888; }
#select-all-coeffs-btn {
    background: transparent; color: #666; border: 1px solid #444; border-radius: 12px;
    padding: 3px 10px; font-size: 11px; cursor: pointer; transition: all 0.15s;
}
#select-all-coeffs-btn:hover { color: #eee; border-color: #888; }
/* --- Toolbar --- */
#controls {
    display: flex; align-items: center; justify-content: flex-start;
    padding: 6px 16px; border-bottom: 1px solid #2a2a4a; flex-shrink: 0; gap: 0;
}
.control-group {
    display: flex; align-items: center; gap: 8px; padding: 0 20px;
}
.control-group + .control-group { border-left: 1px solid #2a2a4a; }
.control-label {
    font-size: 11px; color: #777; text-transform: uppercase;
    letter-spacing: 0.5px; font-weight: 500;
}
#degree-number {
    width: 32px; background: transparent; color: #e94560; border: none;
    border-bottom: 1px solid #444; font-size: 14px; font-weight: 600;
    text-align: center; outline: none; font-family: inherit;
}
#degree-number:focus { border-bottom-color: #e94560; }
/* Hide spin buttons on number input */
#degree-number::-webkit-outer-spin-button,
#degree-number::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
#degree-number { -moz-appearance: textfield; }
#pattern { background: #16213e; color: #eee; border: 1px solid #444; border-radius: 4px; padding: 4px 8px; font-size: 12px; }
.action-btn {
    background: #e94560; color: #fff; border: none; border-radius: 4px;
    padding: 3px 8px; font-size: 11px; cursor: pointer; font-weight: 500;
}
.action-btn:hover { background: #c73550; }
.param-input {
    width: 48px; background: #16213e; color: #eee; border: 1px solid #444;
    border-radius: 4px; padding: 3px 4px; font-size: 11px; text-align: center;
    font-family: inherit; outline: none;
}
.param-input:focus { border-color: #e94560; }
.param-input::-webkit-outer-spin-button,
.param-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
.param-input { -moz-appearance: textfield; }
.param-label { font-size: 11px; color: #777; }
#transform-group { gap: 5px; }
/* --- Panels --- */
#panels { display: flex; justify-content: center; gap: 16px; padding: 8px 12px 12px; flex: 1; min-height: 0; }
.panel { text-align: center; display: flex; flex-direction: column; flex: 1; min-width: 0; min-height: 0; }
.panel h3 { margin-bottom: 4px; font-weight: 500; font-size: 11px; text-transform: uppercase; letter-spacing: 0.8px; color: #666; flex-shrink: 0; }
svg { background: #16213e; border: 1px solid #2a2a4a; border-radius: 8px; flex: 1; position: relative; }
.grid line { stroke: #1f3354; stroke-width: 0.5; }
.axis line { stroke: #2a4a6b; stroke-width: 1; }
.unit-circle { fill: none; stroke: #2a4a6b; stroke-width: 1; stroke-dasharray: 4 3; }
circle.coeff { cursor: grab; stroke-width: 1.5; }
circle.coeff.dragging { cursor: grabbing; stroke: #fff; stroke-width: 2.5; }
circle.root { cursor: grab; stroke-width: 1.5; }
circle.root.dragging { cursor: grabbing; stroke: #fff; stroke-width: 2.5; }
.coeff-label { font-size: 10px; fill: #aaa; pointer-events: none; }
#roots-container { position: relative; flex: 1; min-height: 0; }
#domain-canvas { position: absolute; top: 0; left: 0; border-radius: 8px; }
#roots-panel.domain-active { background: transparent !important; }
circle.coeff.selected { filter: drop-shadow(0 0 4px #fff) drop-shadow(0 0 8px #e94560) drop-shadow(0 0 16px #e94560); stroke: #fff; stroke-width: 2.5; }
circle.root.selected { filter: drop-shadow(0 0 4px #fff) drop-shadow(0 0 8px #e94560) drop-shadow(0 0 16px #e94560); stroke: #fff; stroke-width: 2.5; }
#coeff-container { position: relative; flex: 1; min-height: 0; }
#anim-bar {
    position: absolute; top: 8px; left: 8px; right: 8px; z-index: 10;
    display: none; padding: 8px 12px;
    background: rgba(22, 33, 62, 0.88);
    backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 8px;
    flex-wrap: wrap; align-items: center; justify-content: center; gap: 8px 14px;
}
#anim-bar.active { display: flex; }
#anim-bar .bar-title { font-weight: bold; color: #e94560; font-size: 14px; }
#anim-bar label { font-size: 12px; display: flex; align-items: center; gap: 5px; cursor: pointer; }
#anim-bar select { background: #16213e; color: #eee; border: 1px solid #444; border-radius: 4px; padding: 2px 6px; font-size: 11px; }
#anim-bar input[type="range"] { width: 70px; accent-color: #e94560; }
#anim-bar .bar-val { color: #e94560; min-width: 24px; text-align: right; font-size: 11px; }
#play-btn {
    background: #e94560; color: #fff; border: none; border-radius: 4px;
    padding: 4px 12px; font-size: 12px; cursor: pointer;
}
#play-btn:hover { background: #c73550; }
#trails-btn {
    background: transparent; color: #888; border: 1px solid #555; border-radius: 4px;
    padding: 4px 12px; font-size: 12px; cursor: pointer; transition: all 0.15s;
}
#trails-btn.active { background: #e94560; color: #fff; border-color: #e94560; }
#trails-btn:hover:not(.active) { color: #ccc; border-color: #888; }
.trail-path { fill: none; stroke-width: 1.5; opacity: 0.6; stroke-linecap: round; stroke-linejoin: round; }
.tooltip {
    position: absolute; background: rgba(0,0,0,0.85); color: #fff;
    padding: 4px 8px; border-radius: 4px; font-size: 12px; pointer-events: none;
    display: none; white-space: nowrap;
}
</style>
</head>
<body>

<div id="header">
    <span class="app-title">PolyPaint</span>
</div>
<div id="controls">
    <div class="control-group">
        <button id="domain-toggle-btn">Domain coloring</button>
        <button id="root-color-btn" class="active">Color roots</button>
        <button id="deselect-btn">Deselect all</button>
        <button id="select-all-coeffs-btn">Select all coeffs</button>
        <span class="control-label">Degree</span>
        <input type="number" id="degree-number" min="3" max="30" value="5">
    </div>
    <div class="control-group">
        <span class="control-label">Pattern</span>
        <select id="pattern">
            <optgroup label="Basic">
                <option value="circle">Circle</option>
                <option value="real">Real axis</option>
                <option value="imag">Imaginary axis</option>
                <option value="grid">Grid</option>
                <option value="random">Random</option>
            </optgroup>
            <optgroup label="Coeff patterns">
                <option value="spiral">Spiral</option>
                <option value="star">Star</option>
                <option value="lemniscate">Figure-8</option>
                <option value="conjugate">Conjugate pairs</option>
                <option value="two-clusters">Two clusters</option>
                <option value="geometric">Geometric decay</option>
                <option value="rose">Rose curve</option>
                <option value="cardioid">Cardioid</option>
            </optgroup>
            <optgroup label="Roots shapes">
                <option value="r-heart">Heart</option>
                <option value="r-circle">Circle</option>
                <option value="r-star">Star</option>
                <option value="r-spiral">Spiral</option>
                <option value="r-cross">Cross</option>
                <option value="r-diamond">Diamond</option>
                <option value="r-grid">Chessboard</option>
                <option value="r-smiley">Smiley</option>
                <option value="r-figure8">Figure-8</option>
                <option value="r-butterfly">Butterfly</option>
                <option value="r-trefoil">Trefoil</option>
                <option value="r-polygon">Polygon</option>
                <option value="r-infinity">Infinity</option>
            </optgroup>
        </select>
    </div>
    <div class="control-group" id="transform-group">
        <button class="action-btn" id="scale-btn">Scale</button>
        <input type="number" id="scale-val" value="2" step="0.1" class="param-input">
        <button class="action-btn" id="add-btn">Add</button>
        <input type="number" id="add-re" value="0" step="0.1" class="param-input"> + <input type="number" id="add-im" value="1" step="0.1" class="param-input"><span class="param-label">i</span>
        <button class="action-btn" id="rotate-btn">Rotate</button>
        <input type="number" id="rotate-val" value="0.25" step="0.01" class="param-input"><span class="param-label">rev</span>
    </div>
</div>

<div id="panels">
    <div class="panel">
        <h3>Coefficients (drag to edit)</h3>
        <div id="coeff-container">
            <svg id="coeff-panel"></svg>
            <div id="anim-bar">
                <span class="bar-title" id="bar-title">c₀</span>
                <label>Path:
                    <select id="anim-path">
                        <optgroup label="Basic">
                            <option value="circle">Circle</option>
                            <option value="horizontal">Horizontal</option>
                            <option value="vertical">Vertical</option>
                            <option value="spiral">Spiral</option>
                            <option value="random">Random walk</option>
                        </optgroup>
                        <optgroup label="Curves">
                            <option value="lissajous">Lissajous (3:2)</option>
                            <option value="figure8">Figure-8</option>
                            <option value="cardioid">Cardioid</option>
                            <option value="astroid">Astroid</option>
                            <option value="deltoid">Deltoid</option>
                            <option value="rose">Rose (3-petal)</option>
                            <option value="epitrochoid">Spirograph</option>
                            <option value="hypotrochoid">Hypotrochoid</option>
                            <option value="butterfly">Butterfly</option>
                            <option value="star">Star (pentagram)</option>
                            <option value="square">Square</option>
                        </optgroup>
                    </select>
                </label>
                <label>Radius: <input type="range" id="anim-radius" min="0.05" max="2.0" step="0.05" value="0.5"> <span class="bar-val" id="anim-radius-val">0.5</span></label>
                <label>Speed: <input type="range" id="anim-speed" min="0.1" max="5.0" step="0.1" value="1.0"> <span class="bar-val" id="anim-speed-val">1.0</span></label>
                <button id="play-btn">▶ Play</button>
                <button id="trails-btn">Trails</button>
            </div>
        </div>
    </div>
    <div class="panel">
        <h3>Roots (drag to edit)</h3>
        <div id="roots-container">
            <canvas id="domain-canvas"></canvas>
            <svg id="roots-panel"></svg>
        </div>
    </div>
</div>

<div class="tooltip" id="tooltip"></div>

<script>
const MIN_RANGE = 1.5;
const MARGIN = 30;
const RANGE_PAD = 1.3; // 30% padding around data

// Compute panel size from available space
function getPanelSize() {
    const header = document.getElementById("header");
    const controls = document.getElementById("controls");
    const availH = window.innerHeight - header.offsetHeight - controls.offsetHeight - 50;
    const availW = (window.innerWidth - 16 * 3) / 2;
    return Math.max(200, Math.floor(Math.min(availW, availH)));
}

let S = getPanelSize();

// Per-panel state
const panels = {
    coeff: { range: 3, xScale: null, yScale: null, gridG: null, axisG: null, labelRe: null, labelIm: null, unitCircle: null },
    roots: { range: 3, xScale: null, yScale: null, gridG: null, axisG: null, labelRe: null, labelIm: null, unitCircle: null }
};

function makeScales(range) {
    return {
        x: d3.scaleLinear().domain([-range, range]).range([MARGIN, S - MARGIN]),
        y: d3.scaleLinear().domain([-range, range]).range([S - MARGIN, MARGIN])
    };
}

function initPanelScales(p) {
    const s = makeScales(p.range);
    p.xScale = s.x;
    p.yScale = s.y;
}
initPanelScales(panels.coeff);
initPanelScales(panels.roots);

// Convenience aliases (updated when range changes)
function cxs() { return panels.coeff.xScale; }
function cys() { return panels.coeff.yScale; }
function rxs() { return panels.roots.xScale; }
function rys() { return panels.roots.yScale; }

let coefficients = [];
let currentRoots = []; // persistent root data for dragging
let pendingSolve = false;

// Selection & animation state
const selectedCoeffs = new Set(); // indices into coefficients[]
const selectedRoots = new Set();  // indices into currentRoots[]
const animState = { playing: false, center: null, offsets: null, startTime: 0, rafId: null };
// Trail state
let trailsEnabled = false;
let trailData = []; // array of arrays: trailData[i] = [{re, im}, ...] for root i
let trailComplete = false; // true once one full loop is detected
const MAX_TRAIL_POINTS = 4000;
const TRAIL_MIN_POINTS = 30; // minimum points before checking for loop closure
// Domain coloring state
let domainColoringEnabled = false;
let rootColorEnabled = true;
let domainCanvas = document.getElementById("domain-canvas");
let domainCtx = domainCanvas.getContext("2d");
let domainPendingRender = false;
const DOMAIN_RES_SCALE = 0.5; // render at half resolution for performance

// --- Compute range needed to fit data ---

function computeRange(points) {
    // points: array of {re, im} or [re, im]
    let maxAbs = MIN_RANGE;
    for (const p of points) {
        const re = Array.isArray(p) ? p[0] : p.re;
        const im = Array.isArray(p) ? p[1] : p.im;
        if (isFinite(re)) maxAbs = Math.max(maxAbs, Math.abs(re));
        if (isFinite(im)) maxAbs = Math.max(maxAbs, Math.abs(im));
    }
    // Round up to a nice number and add padding
    return Math.ceil(maxAbs * RANGE_PAD * 2) / 2;
}

// --- SVG setup / grid redraw ---

function drawGrid(svgSel, p) {
    const xs = p.xScale, ys = p.yScale, range = p.range;

    // Clear old grid elements
    if (p.gridG) p.gridG.remove();
    if (p.axisG) p.axisG.remove();
    if (p.labelRe) p.labelRe.remove();
    if (p.labelIm) p.labelIm.remove();
    if (p.unitCircle) p.unitCircle.remove();

    // Grid lines at integers
    p.gridG = svgSel.insert("g", ":first-child").attr("class", "grid");
    const intMax = Math.floor(range);
    for (let v = -intMax; v <= intMax; v++) {
        p.gridG.append("line")
            .attr("x1", xs(v)).attr("y1", ys(-range))
            .attr("x2", xs(v)).attr("y2", ys(range));
        p.gridG.append("line")
            .attr("x1", xs(-range)).attr("y1", ys(v))
            .attr("x2", xs(range)).attr("y2", ys(v));
    }

    // Axes
    p.axisG = svgSel.insert("g", ":first-child").attr("class", "axis");
    p.axisG.append("line")
        .attr("x1", xs(-range)).attr("y1", ys(0))
        .attr("x2", xs(range)).attr("y2", ys(0));
    p.axisG.append("line")
        .attr("x1", xs(0)).attr("y1", ys(-range))
        .attr("x2", xs(0)).attr("y2", ys(range));

    // Axis labels
    p.labelRe = svgSel.append("text").attr("x", S - MARGIN + 4).attr("y", ys(0) + 4)
        .attr("fill", "#556").attr("font-size", 11).text("Re");
    p.labelIm = svgSel.append("text").attr("x", xs(0) + 6).attr("y", MARGIN - 4)
        .attr("fill", "#556").attr("font-size", 11).text("Im");

    // Unit circle
    const r = Math.abs(xs(1) - xs(0));
    p.unitCircle = svgSel.append("circle").attr("class", "unit-circle")
        .attr("cx", xs(0)).attr("cy", ys(0)).attr("r", r);
}

function setupPanel(svgSel, p) {
    svgSel.attr("width", S).attr("height", S).attr("viewBox", `0 0 ${S} ${S}`);
    drawGrid(svgSel, p);
}

function updatePanelRange(svgSel, p, newRange) {
    if (Math.abs(p.range - newRange) < 0.01) return; // no change
    p.range = newRange;
    initPanelScales(p);
    drawGrid(svgSel, p);
}

const coeffSvg = d3.select("#coeff-panel");
const rootsSvg = d3.select("#roots-panel");
setupPanel(coeffSvg, panels.coeff);
setupPanel(rootsSvg, panels.roots);

let coeffLayer = coeffSvg.append("g");
let trailLayer = rootsSvg.append("g").attr("class", "trail-layer");
let rootsLayer = rootsSvg.append("g");

// --- Tooltip ---

const tooltip = document.getElementById("tooltip");

function showTooltip(event, re, im) {
    const sign = im >= 0 ? "+" : "−";
    const absIm = Math.abs(im);
    tooltip.textContent = `${re.toFixed(3)} ${sign} ${absIm.toFixed(3)}i`;
    tooltip.style.display = "block";
    tooltip.style.left = (event.pageX + 12) + "px";
    tooltip.style.top = (event.pageY - 12) + "px";
}

function hideTooltip() {
    tooltip.style.display = "none";
}

// --- Coefficient color ---

function coeffColor(i, n) {
    return d3.interpolateRainbow(i / n);
}

function rootColor(i, n) {
    return rootColorEnabled ? d3.interpolateRainbow(i / n) : "#e94560";
}

// --- Init coefficients with pattern ---

function getPattern() { return document.getElementById("pattern").value; }
function getSpread() { return 1.0; }

function initCoefficients(degree) {
    const n = degree + 1;
    const spread = getSpread();
    const pattern = getPattern();
    coefficients = [];

    if (pattern === "circle") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            coefficients.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
    } else if (pattern === "real") {
        for (let i = 0; i < n; i++) {
            const t = n === 1 ? 0 : -spread + (2 * spread * i) / (n - 1);
            coefficients.push({ re: t, im: 0 });
        }
    } else if (pattern === "imag") {
        for (let i = 0; i < n; i++) {
            const t = n === 1 ? 0 : -spread + (2 * spread * i) / (n - 1);
            coefficients.push({ re: 0, im: t });
        }
    } else if (pattern === "grid") {
        const cols = Math.ceil(Math.sqrt(n));
        const rows = Math.ceil(n / cols);
        for (let i = 0; i < n; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            const re = cols === 1 ? 0 : -spread + (2 * spread * col) / (cols - 1);
            const im = rows === 1 ? 0 : -spread + (2 * spread * row) / (rows - 1);
            coefficients.push({ re, im });
        }
    } else if (pattern === "random") {
        for (let i = 0; i < n; i++) {
            coefficients.push({
                re: (Math.random() * 2 - 1) * spread,
                im: (Math.random() * 2 - 1) * spread
            });
        }
    } else if (pattern === "spiral") {
        // Archimedean spiral — roots trace beautiful curves when perturbed
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const r = spread * t;
            const angle = 4 * Math.PI * t;
            coefficients.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "star") {
        // Alternating inner/outer radii — gives spiky root patterns
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            const r = (i % 2 === 0) ? spread : spread * 0.4;
            coefficients.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "lemniscate") {
        // Figure-8 (Bernoulli lemniscate) — rich root sensitivity
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const cos2t = Math.cos(2 * t);
            const r = spread * Math.sqrt(Math.abs(cos2t));
            const sign = cos2t >= 0 ? 1 : -1;
            coefficients.push({ re: sign * r * Math.cos(t), im: sign * r * Math.sin(t) });
        }
    } else if (pattern === "conjugate") {
        // Conjugate pairs straddling real axis — roots tend to stay near real axis then bifurcate
        for (let i = 0; i < n; i++) {
            const pairIdx = Math.floor(i / 2);
            const re = n <= 2 ? 0 : -spread + (2 * spread * pairIdx) / (Math.ceil(n / 2) - 1 || 1);
            const im = (i % 2 === 0) ? spread * 0.5 : -spread * 0.5;
            coefficients.push({ re, im });
        }
    } else if (pattern === "two-clusters") {
        // Two clusters — see roots jump between clusters as you drag
        const half = Math.ceil(n / 2);
        for (let i = 0; i < n; i++) {
            const cluster = i < half ? -1 : 1;
            const idx = i < half ? i : i - half;
            const count = i < half ? half : n - half;
            const angle = (2 * Math.PI * idx) / Math.max(count, 1);
            const r = spread * 0.35;
            coefficients.push({
                re: cluster * spread * 0.7 + r * Math.cos(angle),
                im: r * Math.sin(angle)
            });
        }
    } else if (pattern === "geometric") {
        // Geometric decay along real axis — classic for ill-conditioned polynomials
        for (let i = 0; i < n; i++) {
            const val = spread * Math.pow(0.7, i);
            const sign = (i % 2 === 0) ? 1 : -1;
            coefficients.push({ re: sign * val, im: 0 });
        }
    } else if (pattern === "rose") {
        // Rose curve r = cos(kθ) — petals create interesting symmetry breaking
        const k = 3; // 3-petal rose
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * Math.cos(k * t);
            coefficients.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "cardioid") {
        // Cardioid — heart-shaped curve, roots respond dramatically near the cusp
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * 0.5 * (1 + Math.cos(t));
            coefficients.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern.startsWith("r-")) {
        // Root-shape patterns: define roots, compute coefficients
        const roots = generateRootShape(pattern, degree, spread);
        const cs = rootsToCoefficients(roots);
        for (const c of cs) coefficients.push(c);
    }
}

// --- Roots → Coefficients ---
// Expand (z - r₀)(z - r₁)...(z - r_{n-1}) into coefficient array
function rootsToCoefficients(roots) {
    // Start with polynomial = [1] (just the leading coefficient)
    let re = [1], im = [0];
    for (const root of roots) {
        const newRe = new Array(re.length + 1).fill(0);
        const newIm = new Array(im.length + 1).fill(0);
        for (let j = 0; j < re.length; j++) {
            // Multiply by z: shift coefficients up
            newRe[j] += re[j];
            newIm[j] += im[j];
            // Multiply by -root: (a+bi)(-c-di) = (-ac+bd) + (-ad-bc)i
            newRe[j + 1] += -re[j] * root.re + im[j] * root.im;
            newIm[j + 1] += -re[j] * root.im - im[j] * root.re;
        }
        re = newRe;
        im = newIm;
    }
    return re.map((r, i) => ({ re: r, im: im[i] }));
}

// --- Root shape generators ---
function generateRootShape(pattern, degree, spread) {
    const n = degree; // number of roots = degree
    const roots = [];

    if (pattern === "r-heart") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const x = spread * 0.8 * 16 * Math.pow(Math.sin(t), 3) / 16;
            const y = spread * 0.8 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 16;
            roots.push({ re: x, im: y });
        }
    } else if (pattern === "r-circle") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            roots.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
    } else if (pattern === "r-star") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            const r = (i % 2 === 0) ? spread : spread * 0.4;
            roots.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "r-spiral") {
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const r = spread * (0.2 + 0.8 * t);
            const angle = 4 * Math.PI * t;
            roots.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "r-cross") {
        // + shape: half on horizontal, half on vertical
        const hCount = Math.ceil(n / 2);
        const vCount = n - hCount;
        for (let i = 0; i < hCount; i++) {
            const t = hCount === 1 ? 0 : -spread + (2 * spread * i) / (hCount - 1);
            roots.push({ re: t, im: 0 });
        }
        for (let i = 0; i < vCount; i++) {
            const t = vCount === 1 ? 0 : -spread + (2 * spread * i) / (vCount - 1);
            if (Math.abs(t) < 1e-10) continue; // skip origin (already in horizontal)
            roots.push({ re: 0, im: t });
        }
        // Fill up if we skipped the origin duplicate
        while (roots.length < n) {
            roots.push({ re: 0, im: spread * 0.1 * roots.length });
        }
    } else if (pattern === "r-diamond") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            // Diamond: |x| + |y| = spread, parametrically
            const x = spread * Math.cos(t);
            const y = spread * Math.sin(t);
            const scale = 1 / (Math.abs(Math.cos(t)) + Math.abs(Math.sin(t)));
            roots.push({ re: x * scale, im: y * scale });
        }
    } else if (pattern === "r-grid") {
        // Chessboard: only "black squares" of a grid
        const side = Math.ceil(Math.sqrt(n * 2));
        let placed = 0;
        for (let row = 0; row < side && placed < n; row++) {
            for (let col = 0; col < side && placed < n; col++) {
                if ((row + col) % 2 === 0) {
                    const re = -spread + (2 * spread * col) / (side - 1);
                    const im = -spread + (2 * spread * row) / (side - 1);
                    roots.push({ re, im });
                    placed++;
                }
            }
        }
    } else if (pattern === "r-smiley") {
        // Eyes + smile arc
        const eyeCount = Math.max(2, Math.floor(n * 0.2));
        const smileCount = n - eyeCount;
        // Left eye
        const leftEye = Math.ceil(eyeCount / 2);
        for (let i = 0; i < leftEye; i++) {
            const angle = (2 * Math.PI * i) / leftEye;
            roots.push({ re: -spread * 0.35 + spread * 0.12 * Math.cos(angle), im: spread * 0.3 + spread * 0.12 * Math.sin(angle) });
        }
        // Right eye
        const rightEye = eyeCount - leftEye;
        for (let i = 0; i < rightEye; i++) {
            const angle = (2 * Math.PI * i) / Math.max(rightEye, 1);
            roots.push({ re: spread * 0.35 + spread * 0.12 * Math.cos(angle), im: spread * 0.3 + spread * 0.12 * Math.sin(angle) });
        }
        // Smile arc (bottom half of circle)
        for (let i = 0; i < smileCount; i++) {
            const angle = Math.PI + (Math.PI * 0.8) * (i / (smileCount - 1)) - Math.PI * 0.4;
            roots.push({ re: spread * 0.6 * Math.cos(angle), im: spread * 0.6 * Math.sin(angle) - spread * 0.1 });
        }
    } else if (pattern === "r-figure8") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const cos2t = Math.cos(2 * t);
            const r = spread * Math.sqrt(Math.abs(cos2t));
            const sign = cos2t >= 0 ? 1 : -1;
            roots.push({ re: sign * r * Math.cos(t), im: sign * r * Math.sin(t) });
        }
    } else if (pattern === "r-butterfly") {
        // Butterfly curve (polar)
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * 0.4 * (Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) + Math.pow(Math.sin(t / 12), 5));
            roots.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "r-trefoil") {
        // 3-leaf clover
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * Math.cos(3 * t);
            roots.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "r-polygon") {
        // Regular polygon outline (not just vertices)
        const sides = Math.min(Math.max(3, Math.floor(degree / 2)), 8);
        const vertices = [];
        for (let s = 0; s < sides; s++) {
            const angle = (2 * Math.PI * s) / sides - Math.PI / 2;
            vertices.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
        // Distribute roots along edges
        for (let i = 0; i < n; i++) {
            const t = (i / n) * sides;
            const edgeIdx = Math.floor(t) % sides;
            const frac = t - Math.floor(t);
            const v1 = vertices[edgeIdx];
            const v2 = vertices[(edgeIdx + 1) % sides];
            roots.push({ re: v1.re + frac * (v2.re - v1.re), im: v1.im + frac * (v2.im - v1.im) });
        }
    } else if (pattern === "r-infinity") {
        // Infinity / lemniscate of Bernoulli: two lobes
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const denom = 1 + Math.sin(t) * Math.sin(t);
            roots.push({
                re: spread * Math.cos(t) / denom,
                im: spread * Math.sin(t) * Math.cos(t) / denom
            });
        }
    }
    return roots;
}

// --- Drag behavior ---

let dragMoved = false;
const drag = d3.drag()
    .on("start", function () {
        dragMoved = false;
        d3.select(this).raise().classed("dragging", true);
    })
    .on("drag", function (event, d) {
        dragMoved = true;
        const idx = d._idx;
        // Skip if this group is being animated
        if (selectedCoeffs.has(idx) && animState.playing) return;

        const newRe = cxs().invert(event.x);
        const newIm = cys().invert(event.y);

        if (selectedCoeffs.has(idx) && selectedCoeffs.size > 1) {
            // Group drag: apply delta to all selected
            const deltaRe = newRe - d.re;
            const deltaIm = newIm - d.im;
            for (const si of selectedCoeffs) {
                coefficients[si].re += deltaRe;
                coefficients[si].im += deltaIm;
            }
            coeffLayer.selectAll("circle.coeff")
                .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
            coeffLayer.selectAll(".coeff-label")
                .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);
        } else {
            // Single drag
            d.re = newRe;
            d.im = newIm;
            d3.select(this).attr("cx", cxs()(d.re)).attr("cy", cys()(d.im));
            coeffLayer.selectAll(".coeff-label")
                .filter(ld => ld === d)
                .attr("x", cxs()(d.re) + 12).attr("y", cys()(d.im) + 4);
        }
        showTooltip(event.sourceEvent, d.re, d.im);
        autoScaleCoeffPanel();
        solveRootsThrottled();
        renderDomainColoringThrottled();
    })
    .on("end", function (event, d) {
        d3.select(this).classed("dragging", false);
        hideTooltip();
        // Click detection: if mouse didn't move, toggle selection
        if (!dragMoved) {
            const idx = d._idx;
            clearRootSelection();
            toggleCoeffSelect(idx);
        }
    });

function autoScaleCoeffPanel() {
    let needed = computeRange(coefficients);
    // During animation, only zoom out — never shrink back
    if (animState.playing) needed = Math.max(needed, panels.coeff.range);
    if (needed !== panels.coeff.range) {
        updatePanelRange(coeffSvg, panels.coeff, needed);
        coeffLayer.selectAll("circle.coeff")
            .attr("cx", d => cxs()(d.re)).attr("cy", d => cys()(d.im));
        coeffLayer.selectAll(".coeff-label")
            .attr("x", d => cxs()(d.re) + 12).attr("y", d => cys()(d.im) + 4);
    }
}

// --- Coefficient selection & animation ---

const animBar = document.getElementById("anim-bar");
const barTitle = document.getElementById("bar-title");
const animPathSel = document.getElementById("anim-path");
const animRadiusInput = document.getElementById("anim-radius");
const animSpeedInput = document.getElementById("anim-speed");
const animRadiusVal = document.getElementById("anim-radius-val");
const animSpeedVal = document.getElementById("anim-speed-val");
const playBtn = document.getElementById("play-btn");
const trailsBtn = document.getElementById("trails-btn");

function toggleCoeffSelect(idx) {
    stopAnimation();
    playBtn.textContent = "▶ Play";

    if (selectedCoeffs.has(idx)) {
        selectedCoeffs.delete(idx);
    } else {
        selectedCoeffs.add(idx);
    }
    updateCoeffSelectionVisual();
    updateAnimBar();
}

function clearCoeffSelection() {
    stopAnimation();
    selectedCoeffs.clear();
    playBtn.textContent = "▶ Play";
    updateCoeffSelectionVisual();
    animBar.classList.remove("active");
}

function clearRootSelection() {
    selectedRoots.clear();
    updateRootSelectionVisual();
}

function clearAllSelection() {
    clearCoeffSelection();
    clearRootSelection();
}

function updateCoeffSelectionVisual() {
    coeffLayer.selectAll("circle.coeff")
        .classed("selected", d => selectedCoeffs.has(d._idx));
}

function updateRootSelectionVisual() {
    rootsLayer.selectAll("circle.root")
        .classed("selected", d => selectedRoots.has(d._idx));
}

function updateAnimBar() {
    if (selectedCoeffs.size === 0) {
        animBar.classList.remove("active");
        return;
    }
    const sorted = [...selectedCoeffs].sort((a, b) => a - b);
    if (sorted.length <= 3) {
        barTitle.textContent = sorted.map(i => `c${subscript(i)}`).join(' ');
    } else {
        barTitle.textContent = `${sorted.length} coefficients`;
    }
    animBar.classList.add("active");
}

// Slider value displays
animRadiusInput.addEventListener("input", function () { animRadiusVal.textContent = parseFloat(this.value).toFixed(2); });
animSpeedInput.addEventListener("input", function () { animSpeedVal.textContent = parseFloat(this.value).toFixed(1); });

// Play/Pause button
playBtn.addEventListener("click", function () {
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "▶ Play";
    } else {
        if (trailsEnabled) clearTrails(); // new cycle, fresh trails
        startAnimation();
        playBtn.textContent = "⏸ Pause";
    }
});

// Trails toggle button
trailsBtn.addEventListener("click", function () {
    trailsEnabled = !trailsEnabled;
    this.classList.toggle("active", trailsEnabled);
    if (trailsEnabled) {
        clearTrails(); // fresh start
    } else {
        clearTrails();
    }
});

// --- Path functions ---

function animPathFn(name, t, center, radius) {
    const w = 2 * Math.PI; // one full cycle per second (scaled by speed)
    const wt = w * t;
    switch (name) {
        case "circle":
            return { re: center.re + radius * Math.cos(wt), im: center.im + radius * Math.sin(wt) };
        case "horizontal":
            return { re: center.re + radius * Math.cos(wt), im: center.im };
        case "vertical":
            return { re: center.re, im: center.im + radius * Math.cos(wt) };
        case "spiral": {
            const r = radius * (0.5 + 0.5 * Math.sin(wt / 4));
            return { re: center.re + r * Math.cos(wt), im: center.im + r * Math.sin(wt) };
        }
        case "figure8": {
            const d = 1 + Math.sin(wt) * Math.sin(wt);
            return {
                re: center.re + radius * Math.cos(wt) / d,
                im: center.im + radius * Math.sin(wt) * Math.cos(wt) / d
            };
        }
        case "lissajous":
            // 3:2 Lissajous with phase offset
            return {
                re: center.re + radius * Math.sin(3 * wt + Math.PI / 4),
                im: center.im + radius * Math.sin(2 * wt)
            };
        case "cardioid": {
            // r_polar = 0.5*(1 + cos(θ)), parametric
            const s = 0.5 * (1 + Math.cos(wt));
            return {
                re: center.re + radius * s * Math.cos(wt),
                im: center.im + radius * s * Math.sin(wt)
            };
        }
        case "astroid":
            // Hypocycloid with 4 cusps: cos³, sin³
            return {
                re: center.re + radius * Math.cos(wt) * Math.cos(wt) * Math.cos(wt),
                im: center.im + radius * Math.sin(wt) * Math.sin(wt) * Math.sin(wt)
            };
        case "deltoid":
            // Hypocycloid with 3 cusps
            return {
                re: center.re + radius * (2 * Math.cos(wt) + Math.cos(2 * wt)) / 3,
                im: center.im + radius * (2 * Math.sin(wt) - Math.sin(2 * wt)) / 3
            };
        case "rose": {
            // 3-petal rose r = cos(3θ)
            const rr = radius * Math.cos(3 * wt);
            return {
                re: center.re + rr * Math.cos(wt),
                im: center.im + rr * Math.sin(wt)
            };
        }
        case "epitrochoid":
            // Spirograph: R=3, r=1, d=1 → 3-lobed, scaled to fit radius
            return {
                re: center.re + radius * (4 * Math.cos(wt) - Math.cos(4 * wt)) / 5,
                im: center.im + radius * (4 * Math.sin(wt) - Math.sin(4 * wt)) / 5
            };
        case "hypotrochoid":
            // Spirograph inner: R=5, r=2, d=1 → 5-lobed
            return {
                re: center.re + radius * (3 * Math.cos(wt) + Math.cos(1.5 * wt)) / 4,
                im: center.im + radius * (3 * Math.sin(wt) - Math.sin(1.5 * wt)) / 4
            };
        case "butterfly": {
            // Butterfly curve (polar)
            const rb = Math.exp(Math.cos(wt)) - 2 * Math.cos(4 * wt) + Math.pow(Math.sin(wt / 12), 5);
            const scale = radius / 3.5; // normalize to roughly fit radius
            return {
                re: center.re + scale * rb * Math.cos(wt),
                im: center.im + scale * rb * Math.sin(wt)
            };
        }
        case "star": {
            // 5-pointed star (pentagram) via inner/outer radius alternation
            // 10 vertices: 5 outer, 5 inner, linearly interpolated
            const period = wt / (2 * Math.PI); // 0..1 per cycle
            const seg = ((period % 1) + 1) % 1; // normalized 0..1
            const idx = seg * 10;
            const vi = Math.floor(idx) % 10;
            const frac = idx - Math.floor(idx);
            const angle1 = (vi / 10) * 2 * Math.PI - Math.PI / 2;
            const angle2 = ((vi + 1) / 10) * 2 * Math.PI - Math.PI / 2;
            const r1 = (vi % 2 === 0) ? radius : radius * 0.38;
            const r2 = ((vi + 1) % 2 === 0) ? radius : radius * 0.38;
            return {
                re: center.re + r1 * Math.cos(angle1) * (1 - frac) + r2 * Math.cos(angle2) * frac,
                im: center.im + r1 * Math.sin(angle1) * (1 - frac) + r2 * Math.sin(angle2) * frac
            };
        }
        case "square": {
            // Square path, one full cycle
            const period = wt / (2 * Math.PI);
            const seg = ((period % 1) + 1) % 1; // 0..1
            let x, y;
            if (seg < 0.25)      { const f = seg / 0.25;       x =  1 - 2*f; y =  1; }
            else if (seg < 0.5)  { const f = (seg-0.25) / 0.25; x = -1;       y =  1 - 2*f; }
            else if (seg < 0.75) { const f = (seg-0.5) / 0.25;  x = -1 + 2*f; y = -1; }
            else                 { const f = (seg-0.75) / 0.25;  x =  1;       y = -1 + 2*f; }
            return { re: center.re + radius * x, im: center.im + radius * y };
        }
        case "random": {
            const step = radius * 0.02;
            return {
                re: center.re + (Math.random() - 0.5) * step,
                im: center.im + (Math.random() - 0.5) * step
            };
        }
        default:
            return center;
    }
}

// --- Animation engine ---

function startAnimation() {
    if (selectedCoeffs.size === 0) return;

    // Compute centroid of selected group
    let centerRe = 0, centerIm = 0;
    for (const idx of selectedCoeffs) {
        centerRe += coefficients[idx].re;
        centerIm += coefficients[idx].im;
    }
    centerRe /= selectedCoeffs.size;
    centerIm /= selectedCoeffs.size;

    // Store each coefficient's offset from centroid
    const offsets = new Map();
    for (const idx of selectedCoeffs) {
        offsets.set(idx, {
            re: coefficients[idx].re - centerRe,
            im: coefficients[idx].im - centerIm
        });
    }

    animState.center = { re: centerRe, im: centerIm };
    animState.offsets = offsets;
    animState.playing = true;
    animState.startTime = performance.now();
    animState.rafId = requestAnimationFrame(animLoop);
}

function animLoop(now) {
    if (!animState.playing || selectedCoeffs.size === 0) return;
    const elapsed = (now - animState.startTime) / 1000;
    const speed = parseFloat(animSpeedInput.value);
    const radius = parseFloat(animRadiusInput.value);
    const pathName = animPathSel.value;
    const t = elapsed * speed;

    let newCenter;
    if (pathName === "random") {
        newCenter = animPathFn("random", t, animState.center, radius);
        animState.center = newCenter;
    } else {
        newCenter = animPathFn(pathName, t, animState.center, radius);
    }

    // Move all selected coefficients maintaining their offsets from centroid
    for (const [idx, offset] of animState.offsets) {
        coefficients[idx].re = newCenter.re + offset.re;
        coefficients[idx].im = newCenter.im + offset.im;
    }

    // Update visuals for all selected coefficients
    coeffLayer.selectAll("circle.coeff")
        .filter(cd => selectedCoeffs.has(coefficients.indexOf(cd)))
        .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
    coeffLayer.selectAll(".coeff-label")
        .filter(ld => selectedCoeffs.has(coefficients.indexOf(ld)))
        .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);

    autoScaleCoeffPanel();
    solveRootsThrottled();
    renderDomainColoringThrottled();

    animState.rafId = requestAnimationFrame(animLoop);
}

function stopAnimation() {
    animState.playing = false;
    if (animState.rafId) {
        cancelAnimationFrame(animState.rafId);
        animState.rafId = null;
    }
}

// --- Render coefficients ---

function renderCoefficients() {
    // Auto-scale coeff panel to fit all coefficients
    const needed = computeRange(coefficients);
    updatePanelRange(coeffSvg, panels.coeff, needed);

    const n = coefficients.length;
    for (let i = 0; i < n; i++) coefficients[i]._idx = i;

    const circles = coeffLayer.selectAll("circle.coeff").data(coefficients, d => d._idx);

    circles.enter()
        .append("circle")
        .attr("class", "coeff")
        .attr("r", 10)
        .attr("stroke", "#fff")
        .call(drag)
        .on("mouseover", function (event, d) { showTooltip(event, d.re, d.im); })
        .on("mouseout", hideTooltip)
      .merge(circles)
        .attr("cx", d => cxs()(d.re))
        .attr("cy", d => cys()(d.im))
        .attr("fill", (_, i) => coeffColor(i, n));

    circles.exit().remove();

    const labels = coeffLayer.selectAll(".coeff-label").data(coefficients, d => d._idx);

    labels.enter()
        .append("text")
        .attr("class", "coeff-label")
      .merge(labels)
        .attr("x", d => cxs()(d.re) + 12)
        .attr("y", d => cys()(d.im) + 4)
        .text((_, i) => `c${subscript(i)}`);

    labels.exit().remove();
}

function subscript(n) {
    const digits = "₀₁₂₃₄₅₆₇₈₉";
    return String(n).split("").map(d => digits[+d]).join("");
}

// --- Root drag behavior (roots → coefficients) ---

let rootDragMoved = false;
const rootDrag = d3.drag()
    .on("start", function () {
        rootDragMoved = false;
        d3.select(this).raise().classed("dragging", true);
    })
    .on("drag", function (event, d) {
        rootDragMoved = true;
        const newRe = rxs().invert(event.x);
        const newIm = rys().invert(event.y);
        const idx = d._idx;

        if (selectedRoots.has(idx) && selectedRoots.size > 1) {
            // Group drag: apply delta to all selected roots
            const deltaRe = newRe - d.re;
            const deltaIm = newIm - d.im;
            for (const si of selectedRoots) {
                currentRoots[si].re += deltaRe;
                currentRoots[si].im += deltaIm;
            }
            rootsLayer.selectAll("circle.root")
                .attr("cx", rd => rxs()(rd.re)).attr("cy", rd => rys()(rd.im));
        } else {
            d.re = newRe;
            d.im = newIm;
            d3.select(this).attr("cx", rxs()(d.re)).attr("cy", rys()(d.im));
        }
        showTooltip(event.sourceEvent, d.re, d.im);
        autoScaleRootsPanel();
        // Recompute coefficients from current roots (all client-side)
        const rootsForCoeffs = currentRoots.map(r => ({ re: r.re, im: r.im }));
        coefficients = rootsToCoefficients(rootsForCoeffs);
        renderCoefficients();
        renderDomainColoringThrottled();
    })
    .on("end", function (event, d) {
        d3.select(this).classed("dragging", false);
        hideTooltip();
        // Click detection: if mouse didn't move, toggle root selection
        if (!rootDragMoved) {
            const idx = d._idx;
            clearCoeffSelection();
            if (selectedRoots.has(idx)) {
                selectedRoots.delete(idx);
            } else {
                selectedRoots.add(idx);
            }
            updateRootSelectionVisual();
        }
    });

function autoScaleRootsPanel() {
    let needed = computeRange(currentRoots);
    if (animState.playing) needed = Math.max(needed, panels.roots.range);
    if (needed !== panels.roots.range) {
        updatePanelRange(rootsSvg, panels.roots, needed);
        rootsLayer.selectAll("circle.root")
            .attr("cx", d => rxs()(d.re)).attr("cy", d => rys()(d.im));
    }
}

// --- Render roots ---

function renderRoots(newRoots) {
    // Update persistent root data
    while (currentRoots.length < newRoots.length) currentRoots.push({ re: 0, im: 0 });
    currentRoots.length = newRoots.length;
    for (let i = 0; i < newRoots.length; i++) {
        currentRoots[i].re = newRoots[i].re;
        currentRoots[i].im = newRoots[i].im;
    }

    // Auto-scale roots panel (zoom-out only during animation)
    let needed = computeRange(currentRoots);
    if (animState.playing) needed = Math.max(needed, panels.roots.range);
    updatePanelRange(rootsSvg, panels.roots, needed);
    renderDomainColoringThrottled();

    const n = currentRoots.length;
    for (let i = 0; i < n; i++) currentRoots[i]._idx = i;

    const circles = rootsLayer.selectAll("circle.root").data(currentRoots, d => d._idx);
    circles.enter()
        .append("circle")
        .attr("class", "root")
        .attr("r", 7)
        .attr("stroke", "#fff")
        .attr("stroke-width", 1)
        .call(rootDrag)
        .on("mouseover", function (event, d) { showTooltip(event, d.re, d.im); })
        .on("mouseout", hideTooltip)
      .merge(circles)
        .attr("cx", d => rxs()(d.re))
        .attr("cy", d => rys()(d.im))
        .attr("fill", (_, i) => rootColor(i, n));

    circles.exit().remove();

    // Record trail points during animation
    if (trailsEnabled && animState.playing && !trailComplete) {
        // Initialize trail arrays if needed
        while (trailData.length < n) trailData.push([]);
        trailData.length = n;
        for (let i = 0; i < n; i++) {
            trailData[i].push({ re: currentRoots[i].re, im: currentRoots[i].im });
            if (trailData[i].length > MAX_TRAIL_POINTS) trailData[i].shift();
        }
        // Check for loop closure: all roots back near their starting positions
        const len = trailData[0].length;
        if (len > TRAIL_MIN_POINTS) {
            let closed = true;
            for (let i = 0; i < n; i++) {
                const start = trailData[i][0];
                const cur = trailData[i][len - 1];
                const dist = Math.hypot(cur.re - start.re, cur.im - start.im);
                if (dist > panels.roots.range * 0.01) { closed = false; break; }
            }
            if (closed) trailComplete = true;
        }
        renderTrails();
    }
}

function renderTrails() {
    const xScale = rxs(), yScale = rys();
    const n = trailData.length;
    const jumpThresh = panels.roots.range * 0.3; // 30% of visible range = likely a root swap
    const paths = trailLayer.selectAll("path.trail-path").data(trailData);
    paths.enter()
        .append("path")
        .attr("class", "trail-path")
      .merge(paths)
        .attr("d", pts => {
            if (pts.length < 2) return "";
            let d = `M${xScale(pts[0].re)},${yScale(pts[0].im)}`;
            for (let j = 1; j < pts.length; j++) {
                const dist = Math.hypot(pts[j].re - pts[j-1].re, pts[j].im - pts[j-1].im);
                const cmd = dist > jumpThresh ? "M" : "L";
                d += `${cmd}${xScale(pts[j].re)},${yScale(pts[j].im)}`;
            }
            return d;
        })
        .attr("stroke", (_, i) => rootColor(i, n));
    paths.exit().remove();
}

function clearTrails() {
    trailData = [];
    trailComplete = false;
    trailLayer.selectAll("path.trail-path").remove();
}


// --- Domain coloring ---

function hueToChannel(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1/6) return p + (q - p) * 6 * t;
    if (t < 1/2) return q;
    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
    return p;
}

function hslToRgb(h, s, l) {
    if (s === 0) return [Math.round(l * 255), Math.round(l * 255), Math.round(l * 255)];
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return [
        Math.round(hueToChannel(p, q, h + 1/3) * 255),
        Math.round(hueToChannel(p, q, h) * 255),
        Math.round(hueToChannel(p, q, h - 1/3) * 255)
    ];
}

function renderDomainColoring() {
    if (!domainColoringEnabled) return;

    const range = panels.roots.range;
    // Measure actual SVG position to align canvas precisely
    // (SVG may be centered by text-align:center, shifted by border, etc.)
    const svgEl = document.getElementById("roots-panel");
    const container = document.getElementById("roots-container");
    const svgRect = svgEl.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    const borderW = parseFloat(getComputedStyle(svgEl).borderLeftWidth) || 0;
    const contentW = svgRect.width - 2 * borderW;
    const vbScale = contentW / S; // viewBox units → CSS pixels
    const plotSize = (S - 2 * MARGIN) * vbScale;
    const plotLeft = (svgRect.left - containerRect.left) + borderW + MARGIN * vbScale;
    const plotTop = (svgRect.top - containerRect.top) + borderW + MARGIN * vbScale;
    const dpr = window.devicePixelRatio || 1;
    const canvasW = Math.max(1, Math.floor(plotSize * DOMAIN_RES_SCALE * dpr));
    const canvasH = canvasW;

    domainCanvas.width = canvasW;
    domainCanvas.height = canvasH;
    domainCanvas.style.width = plotSize + "px";
    domainCanvas.style.height = plotSize + "px";
    domainCanvas.style.left = plotLeft + "px";
    domainCanvas.style.top = plotTop + "px";

    const imageData = domainCtx.createImageData(canvasW, canvasH);
    const data = imageData.data;

    const n = coefficients.length;
    if (n === 0) { domainCtx.putImageData(imageData, 0, 0); return; }

    // Precompute coefficient arrays for Horner's method
    const cRe = new Float64Array(n);
    const cIm = new Float64Array(n);
    for (let k = 0; k < n; k++) {
        cRe[k] = coefficients[k].re;
        cIm[k] = coefficients[k].im;
    }

    const TWO_PI = 2 * Math.PI;
    const INV_PI_180 = 180 / Math.PI;

    for (let py = 0; py < canvasH; py++) {
        const im = range - (2 * range * (py + 0.5)) / canvasH;
        for (let px = 0; px < canvasW; px++) {
            const re = -range + (2 * range * (px + 0.5)) / canvasW;

            // Horner's method: p(z) = c[0]*z^(n-1) + c[1]*z^(n-2) + ... + c[n-1]
            let pRe = cRe[0], pIm = cIm[0];
            for (let k = 1; k < n; k++) {
                const newRe = pRe * re - pIm * im + cRe[k];
                const newIm = pRe * im + pIm * re + cIm[k];
                pRe = newRe;
                pIm = newIm;
            }

            // Hue from argument
            let hue = Math.atan2(pIm, pRe) * INV_PI_180;
            if (hue < 0) hue += 360;

            // Lightness with log-modulus contour lines
            const mod2 = pRe * pRe + pIm * pIm;
            let lightness;
            if (mod2 < 1e-600) {
                lightness = 0;
            } else {
                const logMod = 0.5 * Math.log2(mod2); // = log2(|p(z)|)
                const frac = logMod - Math.floor(logMod);
                lightness = 0.5 + 0.4 * Math.cos(TWO_PI * frac);
            }

            const [r, g, b] = hslToRgb(hue / 360, 0.8, lightness);
            const idx = (py * canvasW + px) * 4;
            data[idx] = r;
            data[idx + 1] = g;
            data[idx + 2] = b;
            data[idx + 3] = 255;
        }
    }
    domainCtx.putImageData(imageData, 0, 0);
}

function renderDomainColoringThrottled() {
    if (!domainPendingRender) {
        domainPendingRender = true;
        requestAnimationFrame(() => {
            renderDomainColoring();
            domainPendingRender = false;
        });
    }
}

// --- Ehrlich-Aberth client-side root solver ---

function solveRootsEA(coeffs, warmStart) {
    // coeffs: array of {re, im} in descending degree order
    // warmStart: array of {re, im} initial guesses (or null)
    // Returns: array of {re, im} roots

    // Strip leading near-zero coefficients
    let start = 0;
    while (start < coeffs.length - 1 && Math.hypot(coeffs[start].re, coeffs[start].im) < 1e-15) {
        start++;
    }
    const c = coeffs.slice(start);
    const degree = c.length - 1;
    if (degree <= 0) return [];

    // Degree 1: linear case c[0]*z + c[1] = 0
    if (degree === 1) {
        const aRe = c[0].re, aIm = c[0].im;
        const bRe = c[1].re, bIm = c[1].im;
        const denom = aRe * aRe + aIm * aIm;
        if (denom < 1e-30) return [];
        return [{ re: -(bRe * aRe + bIm * aIm) / denom, im: -(bIm * aRe - bRe * aIm) / denom }];
    }

    const MAX_ITER = 100;
    const TOL = 1e-12;

    // Initialize root guesses
    const roots = new Array(degree);
    if (warmStart && warmStart.length === degree) {
        for (let i = 0; i < degree; i++) {
            roots[i] = [warmStart[i].re, warmStart[i].im];
        }
    } else {
        // Spread initial guesses on a circle with radius from coefficient ratio
        const leadMod = Math.hypot(c[0].re, c[0].im);
        const trailMod = Math.hypot(c[degree].re, c[degree].im);
        const radius = leadMod > 1e-30
            ? Math.max(0.1, Math.min(Math.pow(trailMod / leadMod, 1 / degree), 10))
            : 1;
        for (let i = 0; i < degree; i++) {
            const angle = (2 * Math.PI * i) / degree + 0.37; // offset to break symmetry
            roots[i] = [radius * Math.cos(angle), radius * Math.sin(angle)];
        }
    }

    // Precompute coefficient arrays for Horner's method
    const n = c.length;
    const cRe = new Float64Array(n);
    const cIm = new Float64Array(n);
    for (let k = 0; k < n; k++) {
        cRe[k] = c[k].re;
        cIm[k] = c[k].im;
    }

    // Iterate
    for (let iter = 0; iter < MAX_ITER; iter++) {
        let maxCorr = 0;

        for (let i = 0; i < degree; i++) {
            const zRe = roots[i][0], zIm = roots[i][1];

            // Evaluate p(z) and p'(z) simultaneously via Horner
            let pRe = cRe[0], pIm = cIm[0];
            let dpRe = 0, dpIm = 0;
            for (let k = 1; k < n; k++) {
                // dp = dp * z + p
                const ndRe = dpRe * zRe - dpIm * zIm + pRe;
                const ndIm = dpRe * zIm + dpIm * zRe + pIm;
                dpRe = ndRe;
                dpIm = ndIm;
                // p = p * z + c[k]
                const npRe = pRe * zRe - pIm * zIm + cRe[k];
                const npIm = pRe * zIm + pIm * zRe + cIm[k];
                pRe = npRe;
                pIm = npIm;
            }

            // Newton step: w = p(z) / p'(z)
            const dpMod2 = dpRe * dpRe + dpIm * dpIm;
            if (dpMod2 < 1e-60) continue;
            const wRe = (pRe * dpRe + pIm * dpIm) / dpMod2;
            const wIm = (pIm * dpRe - pRe * dpIm) / dpMod2;

            // Aberth sum: S = Σ_{j≠i} 1/(z_i - z_j)
            let sRe = 0, sIm = 0;
            for (let j = 0; j < degree; j++) {
                if (j === i) continue;
                const dRe = zRe - roots[j][0];
                const dIm = zIm - roots[j][1];
                const dMod2 = dRe * dRe + dIm * dIm;
                if (dMod2 < 1e-60) continue;
                sRe += dRe / dMod2;
                sIm += -dIm / dMod2;
            }

            // Aberth correction: correction = w / (1 - w * S)
            const wsRe = wRe * sRe - wIm * sIm;
            const wsIm = wRe * sIm + wIm * sRe;
            const denomRe = 1 - wsRe;
            const denomIm = -wsIm;
            const denomMod2 = denomRe * denomRe + denomIm * denomIm;
            if (denomMod2 < 1e-60) continue;

            const corrRe = (wRe * denomRe + wIm * denomIm) / denomMod2;
            const corrIm = (wIm * denomRe - wRe * denomIm) / denomMod2;

            roots[i][0] -= corrRe;
            roots[i][1] -= corrIm;

            maxCorr = Math.max(maxCorr, Math.hypot(corrRe, corrIm));
        }

        if (maxCorr < TOL) break;
    }

    // Filter NaN/Inf and return
    const result = [];
    for (let i = 0; i < degree; i++) {
        if (isFinite(roots[i][0]) && isFinite(roots[i][1])) {
            result.push({ re: roots[i][0], im: roots[i][1] });
        }
    }
    return result;
}

function solveRoots() {
    const roots = solveRootsEA(coefficients, currentRoots);
    renderRoots(roots);
}

function solveRootsThrottled() {
    if (!pendingSolve) {
        pendingSolve = true;
        requestAnimationFrame(() => {
            solveRoots();
            pendingSolve = false;
        });
    }
}

// --- Degree input ---

const degreeNumber = document.getElementById("degree-number");

function applyPattern() {
    clearAllSelection();
    clearTrails();
    currentRoots = [];
    rootsLayer.selectAll("circle.root").remove();
    updatePanelRange(rootsSvg, panels.roots, MIN_RANGE);
    initCoefficients(parseInt(degreeNumber.value));
    renderCoefficients();
    solveRoots();
    renderDomainColoring();
}

degreeNumber.addEventListener("change", function () {
    let v = parseInt(this.value);
    if (isNaN(v)) v = 5;
    v = Math.max(3, Math.min(30, v));
    this.value = v;
    applyPattern();
});

document.getElementById("pattern").addEventListener("change", applyPattern);

document.getElementById("deselect-btn").addEventListener("click", clearAllSelection);

document.getElementById("select-all-coeffs-btn").addEventListener("click", function () {
    clearRootSelection();
    for (let i = 0; i < coefficients.length; i++) selectedCoeffs.add(i);
    updateCoeffSelectionVisual();
    updateAnimBar();
});

const domainToggleBtn = document.getElementById("domain-toggle-btn");
domainToggleBtn.addEventListener("click", function () {
    domainColoringEnabled = !domainColoringEnabled;
    this.classList.toggle("active", domainColoringEnabled);
    domainCanvas.style.display = domainColoringEnabled ? "block" : "none";
    rootsSvg.classed("domain-active", domainColoringEnabled);
    if (domainColoringEnabled) renderDomainColoring();
});

const rootColorBtn = document.getElementById("root-color-btn");
rootColorBtn.addEventListener("click", function () {
    rootColorEnabled = !rootColorEnabled;
    this.classList.toggle("active", rootColorEnabled);
    rootsLayer.selectAll("circle.root")
        .attr("fill", (_, i) => rootColor(i, currentRoots.length));
});

document.addEventListener("keydown", function (e) {
    if (e.key === "Escape") clearAllSelection();
});

// --- Transform actions ---

function applyTransformToSelection(fn) {
    if (selectedCoeffs.size > 0) {
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            const r = fn(c.re, c.im);
            c.re = r.re; c.im = r.im;
        }
        autoScaleCoeffPanel();
        renderCoefficients();
        updateCoeffSelectionVisual();
        solveRootsThrottled();
    } else if (selectedRoots.size > 0) {
        for (const idx of selectedRoots) {
            const r = currentRoots[idx];
            const res = fn(r.re, r.im);
            r.re = res.re; r.im = res.im;
        }
        autoScaleRootsPanel();
        coefficients = rootsToCoefficients(currentRoots.map(r => ({ re: r.re, im: r.im })));
        renderCoefficients();
        renderRoots(currentRoots);
        updateRootSelectionVisual();
    }
}

document.getElementById("scale-btn").addEventListener("click", function () {
    const s = parseFloat(document.getElementById("scale-val").value) || 1;
    applyTransformToSelection((re, im) => ({ re: re * s, im: im * s }));
});

document.getElementById("add-btn").addEventListener("click", function () {
    const addRe = parseFloat(document.getElementById("add-re").value) || 0;
    const addIm = parseFloat(document.getElementById("add-im").value) || 0;
    applyTransformToSelection((re, im) => ({ re: re + addRe, im: im + addIm }));
});

document.getElementById("rotate-btn").addEventListener("click", function () {
    const rev = parseFloat(document.getElementById("rotate-val").value) || 0;
    const angle = 2 * Math.PI * rev;
    const cosA = Math.cos(angle), sinA = Math.sin(angle);
    applyTransformToSelection((re, im) => ({ re: re * cosA - im * sinA, im: re * sinA + im * cosA }));
});

// --- Resize handler ---

function rebuild() {
    S = getPanelSize();
    initPanelScales(panels.coeff);
    initPanelScales(panels.roots);

    // Clear and rebuild both SVGs
    coeffSvg.selectAll("*").remove();
    rootsSvg.selectAll("*").remove();
    setupPanel(coeffSvg, panels.coeff);
    setupPanel(rootsSvg, panels.roots);

    // Recreate layers
    coeffLayer = coeffSvg.append("g");
    trailLayer = rootsSvg.append("g").attr("class", "trail-layer");
    rootsLayer = rootsSvg.append("g");

    renderCoefficients();
    updateCoeffSelectionVisual();

    // Re-solve roots and re-render domain coloring at new size
    solveRoots();
    rootsSvg.classed("domain-active", domainColoringEnabled);
    renderDomainColoring();
    if (trailData.length > 0) renderTrails();
}

let resizeTimer;
window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(rebuild, 150);
});

// --- Init ---

rootsSvg.classed("domain-active", domainColoringEnabled);
domainCanvas.style.display = domainColoringEnabled ? "block" : "none";
initCoefficients(parseInt(degreeNumber.value));
renderCoefficients();
solveRoots();
renderDomainColoring();
</script>
</body>
</html>
