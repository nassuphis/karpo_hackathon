\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}

\geometry{margin=2.5cm}

\hypersetup{
    colorlinks=true,
    linkcolor=blue!60!black,
    urlcolor=blue!60!black,
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small\textit{PolyPaint -- Coefficient Path Calculation}}
\fancyhead[R]{\small\thepage}
\renewcommand{\headrulewidth}{0.4pt}

\titleformat{\section}{\Large\bfseries}{}{0em}{}[\vspace{-0.5em}\rule{\textwidth}{0.4pt}]

\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\N}{\mathcal{N}}
\newcommand{\re}{\mathrm{Re}}
\newcommand{\im}{\mathrm{Im}}
\newcommand{\home}{\mathrm{H}}

\title{\vspace{-1cm}\textbf{Coefficient Path Calculation}\\[0.3em]
\large The F-Node Formula in PolyPaint}
\author{PolyPaint Technical Documentation}
\date{}

\begin{document}
\maketitle
\thispagestyle{fancy}

\begin{abstract}
\noindent This document gives the exact formula for the \textbf{final coefficient vector} $\mathbf{F}(t) \in \C^n$ ---
the complex polynomial coefficients fed to the Ehrlich--Aberth solver at each time step.
Every root trajectory the application produces is determined entirely by this vector.
A degree-$d$ polynomial has $n = d+1$ coefficients indexed $i = 0, \ldots, n{-}1$.
\end{abstract}

%──────────────────────────────────────────────────────────────────────
\section{Master Formula}

\begin{equation}
\boxed{\;
F_i(t) \;=\; M\!\bigl(\,C_i(t),\; D_i(t),\; \theta(t)\bigr) \;+\; J_i(s)\;\cdot\;\mathbf{1}_{[i \in S]}
\;}
\label{eq:master}
\end{equation}

\medskip

\begin{center}
\begin{tabular}{@{}cl@{}}
\toprule
\textbf{Symbol} & \textbf{Meaning} \\
\midrule
$F_i(t) \in \C$          & Final coefficient $i$ at time $t$. This is what the solver sees. \\
$C_i(t) \in \C$          & C-node $i$ position at time $t$, sampled from its precomputed curve. \\
$D_i(t) \in \C$          & D-node $i$ position at time $t$, sampled from its precomputed curve. \\
$M(c,d,\theta)$          & Morph interpolation function (identity when morph disabled). \\
$\theta(t)$              & Morph phase angle $= 2\pi \cdot r_{\mathrm{morph}} \cdot t$. \\
$J_i(s) \in \C$          & Jiggle offset for coefficient $i$ at jiggle step $s$ (additive). \\
$s$                       & Jiggle step $= \lfloor t / \Delta t_{\mathrm{jiggle}} \rfloor$. \\
$S \subseteq \{0,\ldots,n{-}1\}$ & Set of selected coefficient indices (jiggle targets). \\
$\mathbf{1}_{[i \in S]}$ & Iverson bracket: $1$ if $i \in S$, $0$ otherwise. \\
\bottomrule
\end{tabular}
\end{center}

\bigskip

The order of operations is:
\[
\text{animate } C \;\longrightarrow\;
\text{animate } D \;\longrightarrow\;
\text{morph blend} \;\longrightarrow\;
\text{add jiggle} \;\longrightarrow\;
\text{solve}
\]
Jiggle is never applied to $C$ or $D$ individually---it is applied to the already-blended result.
When morph is disabled, $M$ is the identity on $C$: $M(c,d,\theta) = c$.
When jiggle is off, the jiggle term is zero.


%──────────────────────────────────────────────────────────────────────
\section{Node Parameters}

The formula~\eqref{eq:master} involves two sets of animated nodes, each of length $n = d{+}1$:

\begin{itemize}[nosep]
\item \textbf{C-nodes} (\texttt{coefficients[]}): primary coefficients. Always active.
\item \textbf{D-nodes} (\texttt{morphTargetCoeffs[]}): morph targets.
      Active only when morph is enabled.
\end{itemize}

\noindent Both node types carry the \emph{same} set of per-node animation parameters.
D-nodes additionally support $\tau_i = \texttt{"follow-c"}$ (see D-Node Animation below).

\subsection*{Per-node parameters}

\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{@{}clccl@{}}
\toprule
\textbf{Symbol} & \textbf{Meaning} & \textbf{Range} & \textbf{Default} & \textbf{Unit} \\
\midrule
$\home_i$         & Home position ($= \gamma_i[0]$)        & $\C$             & (from pattern)  & complex \\
$\gamma_i$        & Precomputed closed curve                & ---              & $[\home_i]$     & $N$ points in $\C$ \\
$\tau_i$          & Path type (curve shape)                 & see below        & \texttt{"none"} & --- \\
$R_i$             & Path radius                             & $[1,\, 100]$     & $25$            & \% of $E$ \\
$v_i$             & Traversal speed                         & $[0.001,\, 1.0]$ & $1.0$           & cycles/s \\
$\alpha_i$        & Rotation of path shape                  & $[0,\, 1)$       & $0$             & turns \\
$\delta_i$        & Direction: $-1$ if CCW, $+1$ if CW     & $\{-1,\,+1\}$    & $+1$            & --- \\
$\varepsilon_i$   & Extra parameters (path-specific)        & varies           & $\{\}$          & --- \\
$N$               & Curve sample count                      & $\{200,\, 1500\}$ & $200$          & points \\
\bottomrule
\end{tabular}
\end{center}

\medskip
\noindent Here $E = \texttt{coeffExtent}$: the maximum pairwise distance among all coefficient
home positions. The absolute radius used for curve generation is
$R_{\mathrm{abs}} = (R_i / 100) \cdot E$.

The curve $\gamma_i$ is generated once from $(\home_i,\, \tau_i,\, R_{\mathrm{abs}},\, \alpha_i,\, \varepsilon_i)$
and recomputed whenever any parameter changes.
When $\tau_i = \texttt{"none"}$, the curve is the single point $[\home_i]$ (no animation).

\subsection*{Path types}

There are 22 base path shapes in three groups. Each animated type also has a
\textbf{dithered variant} (suffix \texttt{-dither}) that adds per-frame Gaussian noise.

\begin{center}
\renewcommand{\arraystretch}{1.15}
\begin{tabular}{@{}lp{10cm}@{}}
\toprule
\textbf{Group} & \textbf{Types} \\
\midrule
Non-animated   & \texttt{none},\; \texttt{follow-c}\,$^{\dagger}$ \\[2pt]
Basic          & circle, horizontal, vertical, spiral\,$^{*}$, random\,$^{\ddagger}$ \\[2pt]
Curves         & lissajous, figure-8, cardioid, astroid, deltoid, rose, spirograph,
                 hypotrochoid, butterfly, star, square, c-ellipse\,$^{*}$ \\[2pt]
Space-filling  & hilbert, peano, sierpinski \\
\bottomrule
\end{tabular}
\end{center}

\smallskip
\noindent
$^{\dagger}$D-node only: $D_i(t) = C_i(t)$.\quad
$^{*}$Orbital paths: curve points are absolute positions
(orbiting the origin), not offsets from $\home_i$.\quad
$^{\ddagger}$Cloud: pre-generated Gaussian point cloud; no interpolation between samples.

\medskip
\noindent Curve sample count: $N = 200$ for most paths; $N = 1500$ for space-filling paths
and \texttt{spiral} (Hilbert, Peano, Sierpi\'{n}ski, spiral).

\paragraph{Notable extra parameters ($\varepsilon_i$).}
\texttt{spiral}: multiplier $m \in [0,2]$ (default 1.5), turns $T \in [0.5, 5]$ (default 2).
\texttt{lissajous}: frequencies $a \in [1,8]$ (default 3), $b \in [1,8]$ (default 2).
\texttt{c-ellipse}: minor-axis width $w \in [1,100]\%$ (default 50).
\texttt{random}: sigma $\in [0,10]$ (default 2).
Dithered variants: $\sigma_{\%} \in [0,1]$ (default 0.2).


%──────────────────────────────────────────────────────────────────────
\section{$C_i(t)$: C-Node Animation}

Each C-node $i$ carries a precomputed curve $\gamma_i$ generated from the parameters
in the preceding table. At each time step, $C_i(t)$ is obtained by sampling this curve
at a phase determined by the speed $v_i$ and direction $\delta_i$.

\subsection*{Curve Sampling}

Define the \textbf{phase} of coefficient $i$ at time $t$:
\[
\varphi_i(t) \;=\; t \cdot v_i \cdot \delta_i
\qquad\text{where}\quad
\delta_i = \begin{cases} -1 & \text{if CCW} \\ +1 & \text{if CW} \end{cases}
\]
and $v_i$ is the speed parameter. Then the normalized phase:
\[
u_i \;=\; \bigl((\varphi_i \bmod 1) + 1\bigr) \bmod 1 \;\in\; [0,1)
\]
and the raw index into the curve array:
\[
\rho \;=\; u_i \cdot N
\]

\paragraph{Smooth curves.}
Linear interpolation between adjacent samples (wrapping at $N$):
\begin{align}
\ell &= \lfloor \rho \rfloor \bmod N, \qquad
h = (\ell + 1) \bmod N, \qquad
f = \rho - \lfloor \rho \rfloor \\[4pt]
C_i(t) &= \gamma_i[\ell]\,(1-f) \;+\; \gamma_i[h]\,f
\end{align}

\paragraph{Cloud curves} (random path, \texttt{\_isCloud} flag):
no interpolation---snap to the nearest point:
\[
C_i(t) = \gamma_i\bigl[\lfloor \rho \rfloor \bmod N\bigr]
\]

\paragraph{Dither.} If the curve carries a dither parameter $\sigma_{\%} > 0$:
\[
C_i(t) \;\leftarrow\; C_i(t) \;+\; \sigma_{\mathrm{abs}}\,\bigl(\N(0,1) + i\,\N(0,1)\bigr),
\qquad
\sigma_{\mathrm{abs}} = \frac{\sigma_{\%}}{100}\cdot E
\]
where $\N(0,1)$ is a standard Gaussian (Box--Muller) and $E = \texttt{coeffExtent}$
is the maximum pairwise distance between any two coefficients.

\paragraph{Static case.} When $\text{pathType} = \texttt{"none"}$: $C_i(t) = \home_i$ for all $t$.


%──────────────────────────────────────────────────────────────────────
\section{$D_i(t)$: D-Node Animation}

D-nodes use the \textbf{identical curve-sampling formula} as C-nodes, with their own independent
pathType, speed, radius, angle, direction, and precomputed curve.

\paragraph{Follow~C.} When $D_i.\text{pathType} = \texttt{"follow-c"}$:
\[
D_i(t) = C_i(t)
\]
The D-node copies the already-animated C-node position.
This is evaluated \emph{after} C-node advancement.

\paragraph{Static case.} When pathType $=$ \texttt{"none"}: $D_i(t)$ stays at the D-node's
home position (which may differ from $\home_i$ if the user has dragged it).


%──────────────────────────────────────────────────────────────────────
\section{$M(c, d, \theta)$: Morph Interpolation}

When morph is \textbf{disabled}: $M(c,d,\theta) = c$ \,(D-nodes are ignored).

When morph is \textbf{enabled}, the behaviour depends on the \textbf{C--D path type}.
All paths share a local coordinate frame.

\subsection*{Setup}

Given $c, d \in \C$ (the animated C- and D-node positions):
\begin{align}
\boldsymbol{\delta} &= d - c &
L &= |\boldsymbol{\delta}| \\
\mathbf{u} &= \boldsymbol{\delta} / L &
\mathbf{v} &= i\,\mathbf{u} \quad\text{(90\textdegree{} CCW rotation)} \\
\mathbf{m} &= \tfrac{1}{2}(c + d) &
a &= L/2 \quad\text{(semi-major)}
\end{align}
Let $\sigma = +1$ if CCW, $-1$ if CW. When $L < 10^{-15}$, all paths return $c$.

The morph phase angle:
\begin{equation}
\theta(t) = 2\pi \cdot r_{\mathrm{morph}} \cdot t
\end{equation}
where $r_{\mathrm{morph}}$ is the morph rate in Hz (default $0.01$, range $[0, 0.1]$).

\subsection*{Line (default)}

\begin{equation}
\mu = \frac{1 - \cos\theta}{2}
\qquad\Longrightarrow\qquad
M(c,d,\theta) = c\,(1-\mu) + d\,\mu
\end{equation}

Raised-cosine oscillation. $\mu$ sweeps smoothly from 0 (at $c$) to 1 (at $d$) and back.
Period $= 1/r_{\mathrm{morph}}$ seconds. The path is a straight line segment.

\subsection*{Circle}

The $c$--$d$ segment is the \textbf{diameter} of a circle:
\begin{equation}
M = \mathbf{m} \;+\; \bigl(-a\cos\theta\bigr)\,\mathbf{u}
                \;+\; \bigl(\sigma\, a\sin\theta\bigr)\,\mathbf{v}
\end{equation}

At $\theta=0$: position $= c$.\; At $\theta=\pi$: position $= d$.\; Full revolution $= 2\pi$.

\subsection*{Ellipse}

Same as circle, with a shorter semi-minor axis $b = p \cdot a$
where $p \in [0.1, 1.0]$ is the minor-axis percentage:
\begin{equation}
M = \mathbf{m} \;+\; \bigl(-a\cos\theta\bigr)\,\mathbf{u}
                \;+\; \bigl(\sigma\, b\sin\theta\bigr)\,\mathbf{v}
\end{equation}

When $p = 1$, this reduces to the circle. The major axis lies along $c \to d$.

\subsection*{Figure-8}

A Lissajous $1{:}2$ curve crossing at the midpoint:
\begin{equation}
M = \mathbf{m} \;+\; \bigl(-a\cos\theta\bigr)\,\mathbf{u}
                \;+\; \bigl(\sigma\,\tfrac{a}{2}\,\sin 2\theta\bigr)\,\mathbf{v}
\end{equation}

At $\theta=0$: at $c$.\; At $\theta=\pi/2$: crosses midpoint.\; At $\theta=\pi$: at $d$.\;
At $\theta=3\pi/2$: crosses midpoint again. The two lobes are symmetric about $\mathbf{m}$.

\subsection*{Summary Table}

\begin{center}
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Path} & \textbf{Local-frame displacement} $(l_x, l_y)$ & \textbf{Period} \\
\midrule
Line      & $c + (d{-}c)\,\dfrac{1-\cos\theta}{2}$ & $2\pi$ \\[6pt]
Circle    & $(-a\cos\theta,\; \sigma\,a\sin\theta)$ & $2\pi$ \\[4pt]
Ellipse   & $(-a\cos\theta,\; \sigma\,b\sin\theta)$ & $2\pi$ \\[4pt]
Figure-8  & $\bigl(-a\cos\theta,\; \sigma\,\frac{a}{2}\sin 2\theta\bigr)$ & $2\pi$ \\
\bottomrule
\end{tabular}
\end{center}

\noindent Position in global frame: $M = \mathbf{m} + l_x\,\mathbf{u} + l_y\,\mathbf{v}$
\;(except Line, which is computed directly).


%──────────────────────────────────────────────────────────────────────
\section{$J_i(s)$: Jiggle Offsets}

Jiggle produces per-coefficient \textbf{additive} complex offsets with these properties:
\begin{itemize}[nosep]
\item Computed from \textbf{home positions} $\home_i = \gamma_i[0]$, \emph{not} from
      the current animated position $C_i(t)$.
\item \textbf{Piecewise-constant} in time: offsets change only at step boundaries,
      every $\Delta t_{\mathrm{jiggle}}$ seconds.
\item Applied \textbf{only to selected} coefficients ($i \in S$).
\item Applied \textbf{after} morph blending.
\end{itemize}

\[
s = \bigl\lfloor t \,/\, \Delta t_{\mathrm{jiggle}} \bigr\rfloor,
\qquad
J_i(s) = 0 \;\;\text{if}\;\; i \notin S \;\text{or}\; \text{mode} = \texttt{"none"}
\]

\medskip
\noindent\textbf{Notation} (in addition to the per-node symbols from the Node Parameters table):

\begin{center}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{@{}cll@{}}
\toprule
\textbf{Symbol} & \textbf{Meaning} & \textbf{Used by} \\
\midrule
$\mathbf{c}$           & Centroid $= \frac{1}{|S|}\sum_{i\in S} \home_i$  & rotate, scale-cen., spiral-cen., breathe, wobble \\
$\sigma$               & $(\texttt{jiggleSigma}/10)\cdot E$                & random, walk \\
$g$                    & $(\texttt{scaleStep}/100)\cdot E$                 & scale, spiral \\
$N_{\mathrm{angle}}$   & Angle steps per full rotation                     & rotate, spiral, wobble \\
$N_{\mathrm{circle}}$  & Steps per full rotation (about origin)            & circle \\
$A$                    & Amplitude parameter ($0$--$100$)                  & breathe, lissajous \\
$P$                    & Period in jiggle steps                            & breathe, wobble, lissajous \\
$f_x, f_y$            & Frequency multipliers                             & lissajous \\
$R_\alpha$             & Rotation operator by angle $\alpha$               & all rotation modes \\
\bottomrule
\end{tabular}
\end{center}

\subsection*{Random}
\begin{equation}
J_i(s) = \sigma\,\N_1(0,1) + i\,\sigma\,\N_2(0,1)
\end{equation}
Independent Gaussian noise, freshly sampled each step.

\subsection*{Walk}
\begin{equation}
J_i(s) = J_i(s{-}1) + \sigma\,\N_1(0,1) + i\,\sigma\,\N_2(0,1),
\qquad J_i(0) = 0
\end{equation}
Cumulative random walk. The \emph{only} jiggle mode with memory.

\subsection*{Rotate}
\begin{equation}
\alpha = \frac{2\pi s}{N_{\mathrm{angle}}},
\qquad
J_i(s) = R_\alpha\,(\home_i - \mathbf{c}) - (\home_i - \mathbf{c})
\end{equation}
Rigid rotation of the selected coefficients about their centroid.

\subsection*{Circle (jiggle)}
\begin{equation}
\alpha = \frac{2\pi s}{N_{\mathrm{circle}}},
\qquad
J_i(s) = R_\alpha\,\home_i - \home_i
\end{equation}
Rotation of each coefficient about the origin.

\subsection*{Scale--Center}
\begin{equation}
g = \frac{\texttt{scaleStep}}{100}\cdot E,
\qquad
J_i(s) = \frac{\home_i}{|\home_i|}\cdot g \cdot s
\end{equation}
Radial growth from the origin. Linear in step number.

\subsection*{Scale--Centroid}
\begin{equation}
\mathbf{d}_i = \home_i - \mathbf{c},
\qquad
J_i(s) = \frac{\mathbf{d}_i}{|\mathbf{d}_i|}\cdot g \cdot s
\end{equation}

\subsection*{Spiral--Centroid}
\begin{equation}
\alpha = \frac{2\pi s}{N_{\mathrm{angle}}},
\qquad
r = 1 + \frac{g\,s}{|\mathbf{d}_i|},
\qquad
J_i(s) = r\,R_\alpha\,\mathbf{d}_i - \mathbf{d}_i
\end{equation}
Combined rotation and radial scaling from centroid.

\subsection*{Spiral--Center}
\begin{equation}
r = 1 + \frac{g\,s}{|\home_i|},
\qquad
J_i(s) = r\,R_\alpha\,\home_i - \home_i
\end{equation}

\subsection*{Breathe}
\begin{equation}
\lambda = 1 + \frac{A}{100}\,\sin\!\Bigl(\frac{2\pi s}{P}\Bigr),
\qquad
J_i(s) = (\home_i - \mathbf{c})\,(\lambda - 1)
\end{equation}
Sinusoidal radial pulsation from centroid.

\subsection*{Wobble}
\begin{equation}
\alpha = \frac{2\pi}{N_{\mathrm{angle}}}\,\sin\!\Bigl(\frac{2\pi s}{P}\Bigr),
\qquad
J_i(s) = R_\alpha\,(\home_i - \mathbf{c}) - (\home_i - \mathbf{c})
\end{equation}
Sinusoidal angular oscillation about centroid.

\subsection*{Lissajous}
\begin{equation}
A_{\mathrm{abs}} = \frac{A}{100}\cdot E,
\qquad
J_i(s) = A_{\mathrm{abs}}\,\sin\!\Bigl(\frac{2\pi f_x s}{P} + \frac{\pi}{2}\Bigr)
       + i\,A_{\mathrm{abs}}\,\sin\!\Bigl(\frac{2\pi f_y s}{P}\Bigr)
\end{equation}
Uniform translation of \emph{all} selected coefficients along a Lissajous curve.
Same offset for every coefficient.


%──────────────────────────────────────────────────────────────────────
\section{Complete Pipeline}

\begin{enumerate}[leftmargin=2em]
\item \textbf{Animate C-nodes.}\; For each coefficient $i$:
\[
C_i(t) = \begin{cases}
\text{sample } \gamma_i \text{ at phase } \varphi_i(t) & \text{if pathType} \neq \texttt{"none"} \\
\home_i & \text{otherwise}
\end{cases}
\]
If dither is enabled, add Gaussian noise.

\item \textbf{Animate D-nodes.}\; For each D-node $i$:
\[
D_i(t) = \begin{cases}
C_i(t) & \text{if pathType} = \texttt{"follow-c"} \\
\text{sample D-curve}_i \text{ at phase } \varphi_i^D(t) & \text{if pathType} \neq \texttt{"none"} \\
D_{\home,i} & \text{otherwise}
\end{cases}
\]

\item \textbf{Morph blend.}\;
\[
B_i = \begin{cases}
M\bigl(C_i(t),\, D_i(t),\, \theta(t)\bigr) & \text{if morph enabled} \\
C_i(t) & \text{otherwise}
\end{cases}
\]

\item \textbf{Jiggle.}\; Compute step $s = \lfloor t / \Delta t_{\mathrm{jiggle}} \rfloor$
      and offsets $J_i(s)$ for $i \in S$.

\item \textbf{Assemble F.}
\[
F_i(t) = B_i + J_i(s) \cdot \mathbf{1}_{[i \in S]}
\]

\item \textbf{Solve.}\; Feed $\mathbf{F}(t)$ to the Ehrlich--Aberth root finder $\to$ roots.
\end{enumerate}


%──────────────────────────────────────────────────────────────────────
\section{Key Invariants}

\begin{enumerate}[nosep]
\item \textbf{Jiggle never mutates $C$ or $D$.}\;
      It only affects the final blend $F$.
\item \textbf{Jiggle uses home positions.}\;
      All jiggle offsets (except walk) are deterministic functions of
      $(s,\, \home_i,\, \text{params})$, not the current animated position.
\item \textbf{Morph uses live positions.}\;
      The morph function receives the already-animated $C_i(t)$ and $D_i(t)$,
      not home positions.
\item \textbf{No feedback.}\;
      $F_i(t)$ depends only on the current state of $C_i(t)$, $D_i(t)$,
      and jiggle step $s$. It does not depend on $F$ at any previous time
      (except jiggle walk mode, which accumulates).
\item \textbf{In-place mutation.}\;
      The \texttt{coefficients[i].re/im} fields hold the current animated
      $C_i(t)$ after step~1. \texttt{solveRoots()} copies before modifying.
\end{enumerate}


%──────────────────────────────────────────────────────────────────────
\section{Fast Mode (Bitmap Workers)}

In bitmap rendering, the pipeline from Section~\ref{eq:master} runs in parallel
Web Workers. This section defines the execution model.

\subsection*{Definitions}

\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{@{}cll@{}}
\toprule
\textbf{Symbol} & \textbf{Meaning} & \textbf{Value / range} \\
\midrule
$\Delta T_{\mathrm{pass}}$ & Virtual time per pass           & $1.0$\,s (constant) \\
$K$                        & Total steps per pass             & user-selected: $10$ to $10^6$ \\
$W$                        & Number of workers                & $\min(\text{HW threads}, 16)$ \\
$t_{\mathrm{off}}$         & Elapsed offset (accumulated)     & starts at $0$, $+\Delta T_{\mathrm{pass}}$ each pass \\
\bottomrule
\end{tabular}
\end{center}

\subsection*{What is a pass}

A \textbf{pass} is one complete execution of $K$ solver steps distributed across $W$ workers.
Each pass advances virtual time by exactly $\Delta T_{\mathrm{pass}} = 1.0$\,s.
This is not wall-clock time; it is the simulated elapsed time used to advance
coefficient animations along their curves.

\paragraph{Step distribution.}
Steps are divided evenly across workers.
Let $b = \lfloor K / W \rfloor$ and $r = K \bmod W$.
Worker $w$ ($w = 0, \ldots, W{-}1$) executes steps $[\text{start}_w,\, \text{end}_w)$ where
the first $r$ workers receive $b+1$ steps and the remaining $W{-}r$ workers receive $b$ steps.

\paragraph{Elapsed time per step.}
Within a pass, step $k$ ($0 \le k < K$) runs at virtual time:
\begin{equation}
t(k) \;=\; t_{\mathrm{off}} \;+\; \frac{k}{K}\;\Delta T_{\mathrm{pass}}
\label{eq:elapsed}
\end{equation}
So within a single pass, $t$ ramps linearly from $t_{\mathrm{off}}$ to
$t_{\mathrm{off}} + \Delta T_{\mathrm{pass}}$.

\paragraph{Per-step pipeline.}
Each step executes the full pipeline from the Complete Pipeline section
(animate C, animate D, morph, jiggle, solve), then maps each root to a canvas pixel
and emits it as a sparse $(x, y, r, g, b)$ entry.

\subsection*{Pass lifecycle}

\begin{enumerate}[nosep]
\item \textbf{Init.}\; Main thread serializes all static data
      (curves, colors, morph config, jiggle offsets, WASM binaries)
      and sends it to each worker once.
\item \textbf{Run.}\; Main thread sends a \texttt{"run"} message to each worker
      with its step range $[\text{start}_w, \text{end}_w)$, the current
      $t_{\mathrm{off}}$, and warm-start root positions.
\item \textbf{Compute.}\; Workers execute their steps in parallel.
      Each worker accumulates sparse pixel arrays (no full-canvas buffers).
\item \textbf{Done.}\; Each worker transfers its pixel arrays
      (\texttt{Int32Array} indices + \texttt{Uint8Array} RGB) to the main thread
      via zero-copy buffer transfer.
\item \textbf{Composite.}\; Main thread merges all workers' pixels into
      a persistent \texttt{ImageData} buffer and calls \texttt{putImageData}
      on the dirty rectangle only.
\item \textbf{Advance.}\;
      $t_{\mathrm{off}} \leftarrow t_{\mathrm{off}} + \Delta T_{\mathrm{pass}}$.\;
      Root positions from the highest-step worker become the warm start for the next pass.
      Go to step~2.
\end{enumerate}

Workers are \textbf{persistent}: they are created once at init and reused across
passes (only a new \texttt{"run"} message is sent each pass).

\subsection*{Jiggle boundary}

Jiggle offsets are \textbf{static within a pass}: the main thread computes $J_i(s)$
once and bakes it into the worker init data. Workers apply the same offset for every
step in the pass.

A \textbf{jiggle boundary} occurs every $\Delta t_{\mathrm{jiggle}}$ virtual seconds
(default 4\,s $=$ 4 passes). When the pass counter reaches the jiggle interval:
\begin{enumerate}[nosep]
\item Compute the new jiggle step $s = \lfloor t_{\mathrm{off}} / \Delta t_{\mathrm{jiggle}} \rfloor$.
\item Compute $J_i(s)$ for all $i \in S$.
\item \textbf{Terminate all workers} and recreate them with the updated offsets
      (full reinit, because jiggle offsets are init-time data).
\end{enumerate}

\subsection*{Solver and WASM}

Workers use a 2-tier execution strategy:
\begin{enumerate}[nosep]
\item \textbf{WASM step loop}: entire per-step pipeline compiled to WASM ($\sim$15\,KB).
      Supports all morph C--D path types (line, circle, ellipse, figure-8) natively.
\item \textbf{Pure JS}: fallback when WASM is unavailable.
\end{enumerate}

\noindent Worker solver parameters differ from the main thread:
\begin{center}
\begin{tabular}{@{}lcc@{}}
\toprule
& \textbf{Main thread} & \textbf{Workers} \\
\midrule
MAX\_ITER & 100 & 64 \\
TOL       & $10^{-12}$ (magnitude) & $10^{-16}$ (squared) \\
\bottomrule
\end{tabular}
\end{center}

\noindent The mathematical pipeline is identical to the main-thread path.
The output differs only in solver precision and iteration count.

\end{document}
