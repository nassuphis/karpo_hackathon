<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>PolyPaint v39</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jpeg-js@0.4.4/lib/encoder.js"></script>
<script src="https://cdn.jsdelivr.net/npm/utif@3.1.0/UTIF.js"></script>
<style>
:root {
    --bg: #0f1026;
    --panel: #151a3a;
    --stroke: rgba(255,255,255,0.08);
    --stroke2: rgba(255,255,255,0.14);
    --text: #e9e9f2;
    --muted: #8a90a6;
    --accent: #e94560;
    --accent-hover: #c73550;
    --accent-dim: rgba(233,69,96,0.18);
    --accent-border: rgba(233,69,96,0.45);
    --blue: #5b6abf;
    --radius: 10px;
    --blur: blur(12px);
}
* { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; }
body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: radial-gradient(ellipse 1200px 600px at 20% -10%, rgba(233,69,96,0.12), transparent 60%),
                radial-gradient(ellipse 900px 500px at 90% 0%, rgba(91,106,191,0.10), transparent 60%),
                var(--bg);
    color: var(--text);
    display: grid; grid-template-rows: auto 1fr; height: 100%;
}
/* --- Header --- */
#header {
    padding: 6px 14px; border-bottom: 1px solid var(--stroke);
    display: flex; align-items: center; gap: 10px;
    background: rgba(10,12,30,0.55);
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
}
#header .app-title {
    font-size: 12px; font-weight: 600; color: var(--muted);
    letter-spacing: 0.14em; text-transform: uppercase;
}
.header-sep { width: 1px; height: 18px; background: var(--stroke2); }
/* --- Content + main --- */
#content { display: flex; flex-direction: column; min-height: 0; }
#main { display: flex; flex-direction: column; min-height: 0; flex: 1; }
.icon-btn {
    width: 28px; height: 28px; border-radius: 8px;
    border: 1px solid var(--stroke); background: rgba(255,255,255,0.03);
    color: var(--muted); display: flex; align-items: center; justify-content: center;
    cursor: pointer; font-size: 13px; padding: 0;
    transition: background 0.12s, border-color 0.12s, color 0.12s;
}
.icon-btn:hover { background: rgba(255,255,255,0.06); border-color: var(--stroke2); color: var(--text); }
.icon-btn.active { background: var(--accent-dim); border-color: var(--accent-border); color: #fff; }
.control-label {
    font-size: 10px; color: var(--muted); text-transform: uppercase;
    letter-spacing: 0.5px; font-weight: 500;
}
.degree-val {
    color: var(--accent); font-size: 14px; font-weight: 600;
    cursor: pointer; min-width: 20px; text-align: center;
    border-bottom: 1px solid transparent;
    transition: border-color 0.12s;
}
.degree-val:hover { border-bottom-color: var(--accent); }
.degree-val.tool-active { border-bottom-color: var(--accent); }
#pattern {
    background: rgba(255,255,255,0.04); color: var(--text);
    border: 1px solid var(--stroke); border-radius: 6px;
    padding: 4px 8px; font-size: 11px; outline: none;
}
/* --- Mid-bar (Ops between panels) --- */
.mid-bar {
    display: flex; flex-direction: column; gap: 6px; align-items: center;
    justify-content: center; padding: 0 2px; flex-shrink: 0;
}
.mid-label {
    font-size: 8px; color: var(--muted); letter-spacing: 0.10em;
    text-transform: uppercase; opacity: 0.85; text-align: center; line-height: 1.2;
}
.mid-btn {
    width: 32px; height: 32px; border-radius: 10px;
    border: 1px solid var(--stroke); background: rgba(255,255,255,0.03);
    color: var(--muted); display: flex; align-items: center; justify-content: center;
    cursor: pointer; font-size: 14px; padding: 0;
    transition: background 0.12s, border-color 0.12s, color 0.12s, transform 0.06s;
}
.mid-btn:hover { background: rgba(255,255,255,0.06); border-color: var(--stroke2); color: var(--text); }
.mid-btn:active { transform: translateY(1px); }
#ops-target { opacity: 0.7; font-size: 7px; display: block; }
#ops-group.disabled { opacity: 0.35; pointer-events: none; }
#ops-group:not(.disabled) .mid-btn { color: var(--text); border-color: var(--stroke2); }
#ops-group .mid-btn.tool-active {
    background: var(--accent-dim); border-color: var(--accent-border); color: #fff;
}
/* --- Ops Popover --- */
.ops-pop {
    display: none; position: fixed; z-index: 200;
    background: rgba(15, 16, 38, 0.92);
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
    border: 1px solid var(--stroke2); border-radius: var(--radius);
    box-shadow: 0 12px 40px rgba(0,0,0,0.5);
    padding: 10px; min-width: 52px;
}
.ops-pop.open { display: flex; flex-direction: column; align-items: center; gap: 6px; }
.ops-pop .pop-title {
    font-size: 9px; color: var(--muted); text-transform: uppercase;
    letter-spacing: 0.10em;
}
#bitmap-cfg-pop .pop-title {
    color: #000; background: #fff; padding: 2px 6px; border-radius: 3px;
    margin: 2px -4px; font-weight: 600; align-self: stretch; text-align: left;
}
.ops-pop .pop-val {
    font-size: 11px; color: var(--accent); font-weight: 600; min-width: 40px; text-align: center;
}
/* Scale / Rotate slider track */
.ops-pop .vslider {
    width: 6px; height: 140px; border-radius: 3px;
    background: rgba(255,255,255,0.06); position: relative; cursor: pointer;
    touch-action: none;
}
.ops-pop .vslider .vslider-fill {
    position: absolute; bottom: 0; left: 0; right: 0;
    border-radius: 3px; background: var(--accent-dim);
    pointer-events: none;
}
.ops-pop .vslider .vslider-thumb {
    position: absolute; left: 50%; width: 16px; height: 16px;
    margin-left: -8px; margin-top: -8px;
    border-radius: 50%; background: var(--accent); border: 2px solid #fff;
    box-shadow: 0 0 8px rgba(233,69,96,0.5); pointer-events: none;
}
/* Horizontal slider (rotate) */
.ops-pop .hslider {
    width: 160px; height: 6px; border-radius: 3px;
    background: rgba(255,255,255,0.06); position: relative; cursor: pointer;
    touch-action: none;
}
.ops-pop .hslider .hslider-thumb {
    position: absolute; top: 50%; width: 16px; height: 16px;
    margin-left: -8px; margin-top: -8px;
    border-radius: 50%; background: var(--accent); border: 2px solid #fff;
    box-shadow: 0 0 8px rgba(233,69,96,0.5); pointer-events: none;
}
.ops-pop .hslider .hslider-center {
    position: absolute; left: 50%; top: 0; bottom: 0; width: 1px;
    background: rgba(255,255,255,0.15); pointer-events: none;
}
/* 2D vector pad */
.ops-pop .vec-pad {
    width: 140px; height: 140px; border-radius: 8px;
    background: rgba(255,255,255,0.04); border: 1px solid var(--stroke);
    position: relative; cursor: crosshair; touch-action: none;
}
.ops-pop .vec-pad .pad-axis {
    position: absolute; background: rgba(255,255,255,0.08); pointer-events: none;
}
.ops-pop .vec-pad .pad-axis.h { left: 0; right: 0; top: 50%; height: 1px; }
.ops-pop .vec-pad .pad-axis.v { top: 0; bottom: 0; left: 50%; width: 1px; }
.ops-pop .vec-pad .pad-dot {
    position: absolute; width: 14px; height: 14px;
    margin-left: -7px; margin-top: -7px;
    border-radius: 50%; background: var(--accent); border: 2px solid #fff;
    box-shadow: 0 0 8px rgba(233,69,96,0.5); pointer-events: none;
    left: 50%; top: 50%;
}
.ops-pop .vec-pad .pad-line {
    position: absolute; pointer-events: none;
    left: 50%; top: 50%; width: 0; height: 0;
    transform-origin: 0 0;
}
.ops-pop .pop-row {
    display: flex; gap: 8px; font-size: 10px; color: var(--muted);
}
/* --- Coefficient context menu --- */
#coeff-ctx { min-width: 180px; padding: 10px 12px; gap: 6px; }
#coeff-ctx .ctx-title { font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 2px; display: flex; align-items: center; gap: 6px; width: 100%; }
#coeff-ctx .ctx-title .ctx-move { width: 16px; height: 16px; border-radius: 50%; border: 1px solid var(--stroke); background: rgba(255,255,255,0.08); color: var(--muted); font-size: 9px; cursor: pointer; display: flex; align-items: center; justify-content: center; margin-left: auto; flex-shrink: 0; padding: 0; line-height: 1; }
#coeff-ctx .ctx-title .ctx-move:hover { background: rgba(255,255,255,0.18); color: var(--text); }
#coeff-ctx label { display: flex; align-items: center; gap: 6px; font-size: 9px; color: var(--muted); white-space: nowrap; width: 100%; }
#coeff-ctx select, #coeff-ctx input[type=range] { flex: 1; }
#coeff-ctx select { font-size: 9px; background: var(--panel); color: var(--text); border: 1px solid var(--stroke); border-radius: 3px; padding: 2px 4px; }
#coeff-ctx .ctx-val { font-size: 9px; color: var(--text); min-width: 32px; text-align: right; }
#coeff-ctx .ctx-row { display: flex; align-items: center; gap: 6px; width: 100%; }
#coeff-ctx .ctx-accept { margin-top: 4px; padding: 4px 16px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; background: var(--accent); color: #fff; border: none; border-radius: var(--radius); cursor: pointer; align-self: center; }
#coeff-ctx .ctx-accept:hover { filter: brightness(1.2); }
#coeff-ctx .ctx-dir { font-size: 9px; padding: 2px 8px; background: transparent; border: 1px solid var(--stroke); color: var(--muted); border-radius: 3px; cursor: pointer; }
#coeff-ctx .ctx-dir.active { color: var(--text); border-color: var(--accent-dim); }
/* --- D-node context menu (shares coeff-ctx styles) --- */
#dnode-ctx { min-width: 180px; padding: 10px 12px; gap: 6px; }
#dnode-ctx .ctx-title { font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 2px; display: flex; align-items: center; gap: 6px; width: 100%; }
#dnode-ctx .ctx-title .ctx-move { width: 16px; height: 16px; border-radius: 50%; border: 1px solid var(--stroke); background: rgba(255,255,255,0.08); color: var(--muted); font-size: 9px; cursor: pointer; display: flex; align-items: center; justify-content: center; margin-left: auto; flex-shrink: 0; padding: 0; line-height: 1; }
#dnode-ctx .ctx-title .ctx-move:hover { background: rgba(255,255,255,0.18); color: var(--text); }
#dnode-ctx label { display: flex; align-items: center; gap: 6px; font-size: 9px; color: var(--muted); white-space: nowrap; width: 100%; }
#dnode-ctx select, #dnode-ctx input[type=range] { flex: 1; }
#dnode-ctx select { font-size: 9px; background: var(--panel); color: var(--text); border: 1px solid var(--stroke); border-radius: 3px; padding: 2px 4px; }
#dnode-ctx .ctx-val { font-size: 9px; color: var(--text); min-width: 32px; text-align: right; }
#dnode-ctx .ctx-row { display: flex; align-items: center; gap: 6px; width: 100%; }
#dnode-ctx .ctx-accept { margin-top: 4px; padding: 4px 16px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; background: var(--accent); color: #fff; border: none; border-radius: var(--radius); cursor: pointer; align-self: center; }
#dnode-ctx .ctx-accept:hover { filter: brightness(1.2); }
#dnode-ctx .ctx-dir { font-size: 9px; padding: 2px 8px; background: transparent; border: 1px solid var(--stroke); color: var(--muted); border-radius: 3px; cursor: pointer; }
#dnode-ctx .ctx-dir.active { color: var(--text); border-color: var(--accent-dim); }
/* --- Audio config popover rows --- */
.audio-row {
    display: flex; align-items: center; gap: 8px; width: 100%;
}
.audio-row .row-label {
    font-size: 9px; color: var(--muted); width: 56px;
    text-transform: uppercase; letter-spacing: 0.08em; flex-shrink: 0;
}
.audio-row .hslider { flex: 1; min-width: 80px; }
.audio-row .row-val {
    font-size: 10px; color: var(--accent); width: 52px;
    text-align: right; font-variant-numeric: tabular-nums; flex-shrink: 0;
}
.audio-toggle {
    display: flex; align-items: center; gap: 6px;
    cursor: pointer; padding: 4px 0; user-select: none; width: 100%;
}
.audio-toggle .toggle-dot {
    width: 10px; height: 10px; border-radius: 50%;
    border: 1.5px solid var(--muted); transition: all 0.12s;
}
.audio-toggle.on .toggle-dot {
    background: var(--accent); border-color: var(--accent);
}
.audio-toggle .toggle-label {
    font-size: 10px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em;
}
.audio-toggle.on .toggle-label { color: var(--text); }
/* --- Coeff picker rows --- */
.cpick-row {
    display: flex; align-items: center; gap: 6px; width: 100%;
    padding: 2px 0; cursor: pointer; user-select: none;
}
.cpick-row:hover { background: rgba(255,255,255,0.05); }
.cpick-row .cpick-dot {
    width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0;
}
.cpick-row .cpick-label {
    font-size: 10px; color: var(--muted); width: 28px; flex-shrink: 0;
}
.cpick-row .cpick-power {
    font-size: 9px; color: var(--muted); opacity: 0.6; width: 30px; flex-shrink: 0;
}
.cpick-row .cpick-path {
    font-size: 8px; color: var(--muted); opacity: 0.7; flex-shrink: 0;
    overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.cpick-row .cpick-path .cpick-detail { opacity: 0.6; margin-left: 3px; font-size: 7px; }
.cpick-path-btn {
    font-size: 8px; color: var(--text); background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15);
    border-radius: 3px; padding: 1px 2px; cursor: pointer; flex-shrink: 0;
    white-space: nowrap; width: 58px; text-align: center; transition: all 0.12s;
    overflow: hidden; text-overflow: ellipsis;
}
.cpick-path-btn:hover { background: rgba(255,255,255,0.14); border-color: rgba(255,255,255,0.3); }
#path-pick-pop { min-width: 180px; padding: 10px 12px; gap: 6px; }
#path-pick-pop .ctx-title { font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 2px; display: flex; align-items: center; gap: 6px; width: 100%; }
#path-pick-pop label { display: flex; align-items: center; gap: 6px; font-size: 9px; color: var(--muted); white-space: nowrap; width: 100%; }
#path-pick-pop select, #path-pick-pop input[type=range] { flex: 1; }
#path-pick-pop select { font-size: 9px; background: var(--panel); color: var(--text); border: 1px solid var(--stroke); border-radius: 3px; padding: 2px 4px; }
#path-pick-pop .ctx-val { font-size: 9px; color: var(--text); min-width: 32px; text-align: right; }
#path-pick-pop .ctx-row { display: flex; align-items: center; gap: 6px; width: 100%; }
#path-pick-pop .ctx-accept { margin-top: 4px; padding: 4px 16px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; background: var(--accent); color: #fff; border: none; border-radius: var(--radius); cursor: pointer; align-self: center; }
#path-pick-pop .ctx-accept:hover { filter: brightness(1.2); }
#path-pick-pop .ctx-dir { font-size: 9px; padding: 2px 8px; background: transparent; border: 1px solid var(--stroke); color: var(--muted); border-radius: 3px; cursor: pointer; }
#path-pick-pop .ctx-dir.active { color: var(--text); border-color: var(--accent-dim); }
#dpath-pick-pop { min-width: 180px; padding: 10px 12px; gap: 6px; }
#dpath-pick-pop .ctx-title { font-size: 10px; color: var(--accent); font-weight: 600; margin-bottom: 2px; display: flex; align-items: center; gap: 6px; width: 100%; }
#dpath-pick-pop label { display: flex; align-items: center; gap: 6px; font-size: 9px; color: var(--muted); white-space: nowrap; width: 100%; }
#dpath-pick-pop select, #dpath-pick-pop input[type=range] { flex: 1; }
#dpath-pick-pop select { font-size: 9px; background: var(--panel); color: var(--text); border: 1px solid var(--stroke); border-radius: 3px; padding: 2px 4px; }
#dpath-pick-pop .ctx-val { font-size: 9px; color: var(--text); min-width: 32px; text-align: right; }
#dpath-pick-pop .ctx-row { display: flex; align-items: center; gap: 6px; width: 100%; }
#dpath-pick-pop .ctx-accept { margin-top: 4px; padding: 4px 16px; font-size: 9px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.8px; background: var(--accent); color: #fff; border: none; border-radius: var(--radius); cursor: pointer; align-self: center; }
#dpath-pick-pop .ctx-accept:hover { filter: brightness(1.2); }
#dpath-pick-pop .ctx-dir { font-size: 9px; padding: 2px 8px; background: transparent; border: 1px solid var(--stroke); color: var(--muted); border-radius: 3px; cursor: pointer; }
#dpath-pick-pop .ctx-dir.active { color: var(--text); border-color: var(--accent-dim); }
#lce-controls { display: flex; align-items: center; gap: 4px; }
#lce-controls label { display: flex; align-items: center; gap: 2px; font-size: 9px; color: var(--muted); white-space: nowrap; }
#lce-controls input[type=range] { width: 48px; accent-color: var(--accent); }
#lce-controls .ctx-val { font-size: 9px; color: var(--text); min-width: 20px; text-align: right; }
#lce-controls .ctx-dir { font-size: 9px; padding: 1px 6px; background: transparent; border: 1px solid var(--stroke); color: var(--muted); border-radius: 3px; cursor: pointer; }
#lce-controls .ctx-dir.active { color: var(--text); border-color: var(--accent-dim); }
#dle-controls { display: flex; align-items: center; gap: 4px; }
#dle-controls label { display: flex; align-items: center; gap: 2px; font-size: 9px; color: var(--muted); white-space: nowrap; }
#dle-controls input[type=range] { width: 48px; accent-color: var(--accent); }
#dle-controls .ctx-val { font-size: 9px; color: var(--text); min-width: 20px; text-align: right; }
#dle-controls .ctx-dir { font-size: 9px; padding: 1px 6px; background: transparent; border: 1px solid var(--stroke); color: var(--muted); border-radius: 3px; cursor: pointer; }
#dle-controls .ctx-dir.active { color: var(--text); border-color: var(--accent-dim); }
.cpick-row .cpick-pts {
    font-size: 8px; color: var(--muted); opacity: 0.5; flex-shrink: 0;
    min-width: 28px; text-align: right; font-variant-numeric: tabular-nums;
}
.cpick-row .cpick-speed, .cpick-row .cpick-radius, .cpick-row .cpick-plen, .cpick-row .cpick-pos {
    font-size: 8px; color: var(--muted); opacity: 0.7; flex-shrink: 0;
    min-width: 24px; text-align: right; font-variant-numeric: tabular-nums;
}
.cpick-row .cpick-coords {
    font-size: 9px; color: var(--muted); flex: 1; text-align: right;
    font-variant-numeric: tabular-nums;
}
.cpick-row .cpick-cb {
    width: 12px; height: 12px; border: 1.5px solid var(--muted); border-radius: 2px;
    flex-shrink: 0; display: flex; align-items: center; justify-content: center;
    transition: all 0.12s;
}
.cpick-row .cpick-cb.checked {
    background: var(--accent); border-color: var(--accent);
}
.cpick-row .cpick-cb.checked::after {
    content: "âœ“"; font-size: 8px; color: #fff;
}
/* --- Panels --- */
#panels { display: flex; justify-content: center; gap: 8px; padding: 8px 12px 12px 12px; flex: 1; min-height: 0; }
.panel {
    text-align: center; display: flex; flex-direction: column; flex: 1; min-width: 0; min-height: 0;
    background: rgba(255,255,255,0.02); border: 1px solid var(--stroke);
    border-radius: var(--radius); box-shadow: 0 8px 24px rgba(0,0,0,0.3); overflow: hidden;
}
.panel h3 {
    margin: 0; padding: 8px 12px; flex-shrink: 0;
    font-weight: 500; font-size: 11px; text-transform: uppercase; letter-spacing: 0.8px; color: var(--muted);
    border-bottom: 1px solid var(--stroke); background: rgba(10,12,30,0.45);
    display: flex; align-items: center; justify-content: space-between;
}
.panel h3 .icon-btn { width: 22px; height: 22px; font-size: 11px; border-radius: 6px; }
#rec-roots-btn.recording { color: #e94560; animation: rec-blink 1s ease-in-out infinite alternate; }
@keyframes rec-blink { from { opacity: 1; } to { opacity: 0.4; } }
svg { background: var(--panel); border: 0; border-radius: 0; flex: 1; position: relative; }
.grid line { stroke: #1f3354; stroke-width: 0.5; }
.axis line { stroke: #2a4a6b; stroke-width: 1; }
.unit-circle { fill: none; stroke: #2a4a6b; stroke-width: 1; stroke-dasharray: 4 3; }
circle.coeff { cursor: grab; stroke-width: 1.5; }
circle.coeff.dragging { cursor: grabbing; stroke: #fff; stroke-width: 2.5; }
circle.root { cursor: grab; stroke-width: 1.5; }
circle.root.dragging { cursor: grabbing; stroke: #fff; stroke-width: 2.5; }
.coeff-label { font-size: 10px; fill: #aaa; pointer-events: none; }
circle.morph-ghost { pointer-events: none; opacity: 0.25; }
circle.morph-coeff { cursor: grab; stroke-width: 1.5; }
circle.morph-coeff.dragging { cursor: grabbing; stroke-width: 2.5; }
.morph-label { font-size: 10px; fill: #aaa; pointer-events: none; }
.morph-ghost-label { font-size: 9px; fill: #555; pointer-events: none; }
line.morph-interp-line { pointer-events: none; }
circle.morph-interp-marker { pointer-events: none; }
/* --- Tabs (roots panel) --- */
.tab-bar { display:flex; align-items:stretch; padding:0 8px; gap:0;
           flex-shrink:0; background:rgba(10,12,30,0.45);
           border-bottom:1px solid var(--stroke); }
.tab { padding:7px 14px 8px; font-weight:500; font-size:11px;
       text-transform:uppercase; letter-spacing:0.8px; color:var(--muted);
       background:transparent; border:1px solid transparent; border-bottom:none;
       border-radius:var(--radius) var(--radius) 0 0; cursor:pointer;
       position:relative; top:1px; margin-bottom:-1px; transition:color 0.12s, background 0.12s; }
.tab:not(.active):hover { background:rgba(255,255,255,0.04); color:var(--text); }
.tab.active { background:rgba(255,255,255,0.02); border-color:var(--stroke);
              border-bottom-color:rgba(255,255,255,0.02); color:var(--text); z-index:1; }
.tab-bar .icon-btn { width:22px; height:22px; font-size:11px; border-radius:6px; }
.tab-bar-controls { display:flex; gap:4px; align-items:center; margin-left:auto; padding:0 0 0 8px; }
.tab-panes { flex:1; min-height:0; position:relative; }
.tab-content { position:absolute; top:0; left:0; right:0; bottom:0;
               visibility:hidden; display:flex; flex-direction:column; }
.tab-content.active { visibility:visible; }
.stats-grid { display:grid; grid-template-columns:1fr 1fr 1fr 1fr; grid-template-rows:1fr 1fr 1fr 1fr;
              flex:1; gap:0; min-height:0; }
.stats-cell { display:flex; flex-direction:column; min-height:0; border:1px solid var(--stroke);
              margin:-0.5px; overflow:hidden; }
.stats-cell:first-child { border-radius:0; }
.stats-select { flex-shrink:0; width:100%; padding:1px 3px; font-size:8px;
                background:rgba(10,12,30,0.6); color:var(--muted); border:none;
                border-bottom:1px solid var(--stroke); cursor:pointer;
                font-family:inherit; letter-spacing:0.3px; outline:none; }
.stats-select:focus { color:var(--text); }
.stats-canvas { flex:1; width:100%; min-height:0; background:var(--panel); }
.config-panel { padding:8px 10px; display:flex; flex-direction:column; gap:6px; overflow-y:auto; align-items:flex-start; }
.config-section { font-size:8px; color:var(--muted); text-transform:uppercase; letter-spacing:0.08em; padding:5px 0 2px; border-bottom:1px solid var(--stroke); text-align:left; }
.config-row-stack { display:flex; flex-direction:column; gap:4px; max-width:220px; }
.config-row-stack .audio-row .row-label { width:42px; font-size:8px; }
.config-row-stack .audio-row .row-val { width:40px; font-size:9px; }
.config-row-stack .audio-row .hslider { min-width:60px; }
.config-panel .hslider {
    height:6px; border-radius:3px; background:rgba(255,255,255,0.06);
    position:relative; cursor:pointer; touch-action:none;
}
.config-panel .hslider .hslider-thumb {
    position:absolute; top:50%; width:14px; height:14px;
    margin-left:-7px; margin-top:-7px; border-radius:50%;
    background:var(--accent); border:2px solid #fff;
    box-shadow:0 0 6px rgba(233,69,96,0.4); pointer-events:none;
}
.route-table { border-collapse:collapse; width:auto; }
.route-table th { font-size:7px; color:var(--muted); text-transform:uppercase; letter-spacing:0.08em;
    padding:2px 4px 2px 0; text-align:left; border-bottom:1px solid var(--stroke); font-weight:500; white-space:nowrap; }
.route-table td { padding:2px 4px 2px 0; vertical-align:middle; white-space:nowrap; }
.route-table select { padding:1px 3px; font-size:8px; width:auto;
    background:rgba(10,12,30,0.6); color:var(--text); border:1px solid var(--stroke);
    border-radius:var(--radius); font-family:inherit; cursor:pointer; outline:none; }
.route-table select:focus { border-color:var(--accent); }
.route-table .target-label { font-size:8px; color:var(--muted); white-space:nowrap; }
.route-table .norm-select { font-size:7px; padding:1px 2px; }
.cell-slider-wrap { display:flex; align-items:center; gap:2px; min-width:48px; }
.cell-slider { flex:1; height:3px; border-radius:2px; background:rgba(255,255,255,0.06);
    position:relative; cursor:pointer; touch-action:none; min-width:24px; }
.cell-slider-thumb { position:absolute; top:50%; width:8px; height:8px;
    margin-left:-4px; margin-top:-4px; border-radius:50%;
    background:var(--accent); border:1px solid #fff; pointer-events:none; }
.cell-slider-val { font-size:7px; color:var(--accent); width:22px;
    text-align:right; font-variant-numeric:tabular-nums; flex-shrink:0; }
#roots-container { position: relative; flex: 1; min-height: 0; }
#domain-canvas { position: absolute; top: 0; left: 0; border-radius: 0; }
#roots-panel.domain-active { background: transparent !important; }
circle.coeff.selected, circle.root.selected, circle.morph-coeff.selected {
    stroke: #fff; stroke-width: 3;
    filter: drop-shadow(0 0 4px var(--accent)) drop-shadow(0 0 10px var(--accent)) drop-shadow(0 0 18px rgba(233,69,96,0.4));
    animation: sel-pulse 1.2s ease-in-out infinite alternate;
}
@keyframes sel-pulse {
    from { filter: drop-shadow(0 0 4px var(--accent)) drop-shadow(0 0 10px var(--accent)) drop-shadow(0 0 18px rgba(233,69,96,0.4)); }
    to   { filter: drop-shadow(0 0 6px var(--accent)) drop-shadow(0 0 14px var(--accent)) drop-shadow(0 0 24px rgba(233,69,96,0.5)); }
}
.sel-rect {
    fill: rgba(233,69,96,0.12); stroke: rgba(233,69,96,0.65);
    stroke-width: 1.5; stroke-dasharray: 4 3; pointer-events: none;
}
#coeff-container { position: relative; flex: 1; min-height: 0; }
/* --- Anim bar --- */
#anim-bar {
    display: grid; grid-template-columns: 1fr; gap: 4px;
    padding: 6px 10px; flex-shrink: 0;
    background: rgba(10, 12, 30, 0.45);
    border-bottom: 1px solid var(--stroke);
}
.bar-row { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
#anim-bar .bar-title { font-weight: bold; color: var(--accent); font-size: 11px; }
#anim-bar .bar-title.empty { color: var(--muted); font-weight: normal; font-style: italic; }
#anim-bar label { font-size: 10px; display: flex; align-items: center; gap: 3px; cursor: pointer; color: var(--muted); }
#anim-bar select {
    background: rgba(255,255,255,0.04); color: var(--text);
    border: 1px solid var(--stroke); border-radius: 6px;
    padding: 2px 4px; font-size: 10px;
}
#anim-bar input[type="range"] { width: 52px; accent-color: var(--accent); }
#anim-bar .bar-val { color: var(--accent); min-width: 20px; text-align: right; font-size: 10px; }
#bar-dynamic { display: grid; grid-template-columns: repeat(6, auto); gap: 4px 8px; align-items: center; }
#scrub-slider { width: 80px; accent-color: var(--accent); }
#play-btn {
    background: var(--accent); color: #fff; border: none; border-radius: 6px;
    padding: 2px 8px; font-size: 10px; cursor: pointer; font-weight: 500;
    transition: background 0.12s;
}
#play-btn:hover { background: var(--accent-hover); }
#home-btn {
    background: rgba(255,255,255,0.12); color: #fff; border: 1px solid rgba(255,255,255,0.25); border-radius: 6px;
    padding: 2px 8px; font-size: 10px; cursor: pointer; font-weight: 500;
    transition: all 0.12s;
}
#home-btn:hover { background: rgba(255,255,255,0.22); border-color: rgba(255,255,255,0.4); }
#roots-toolbar {
    position: absolute; top: 6px; left: 6px; z-index: 10;
    display: flex; gap: 4px;
}
#trails-btn, .roots-tool-btn {
    background: rgba(15, 16, 38, 0.75); color: var(--muted); border: 1px solid var(--stroke); border-radius: 6px;
    padding: 3px 8px; font-size: 10px; cursor: pointer; transition: all 0.12s;
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
}
#trails-btn.active, .roots-tool-btn.active { background: var(--accent-dim); color: #fff; border-color: var(--accent-border); }
#trails-btn:hover:not(.active), .roots-tool-btn:hover:not(.active) { color: var(--text); border-color: var(--stroke2); }
#sound-toolbar { display: flex; gap: 6px; padding: 8px 10px; border-bottom: 1px solid var(--stroke); }
.sound-tool-btn {
    background: rgba(255,255,255,0.04); color: var(--muted); border: 1px solid var(--stroke); border-radius: 6px;
    padding: 4px 10px; font-size: 11px; cursor: pointer; font-weight: 500; transition: all 0.12s;
}
.sound-tool-btn:hover { color: var(--text); border-color: var(--stroke2); }
.sound-tool-btn.active { background: var(--accent-dim); color: #fff; border-color: var(--accent-border); }
.bar-sel-btn {
    background: transparent; color: var(--muted); border: 1px solid var(--stroke); border-radius: 5px;
    padding: 2px 7px; font-size: 10px; cursor: pointer; transition: all 0.12s;
}
.bar-sel-btn:hover { color: var(--text); border-color: var(--stroke2); }
#sel2path-btn {
    background: transparent; color: var(--accent); border: 1px solid var(--accent-border); border-radius: 6px;
    padding: 3px 8px; font-size: 10px; cursor: pointer; font-weight: 600; transition: all 0.12s;
}
#sel2path-btn:hover { background: var(--accent); color: #fff; }
#sel2path-btn:disabled { opacity: 0.3; cursor: default; background: transparent; color: var(--accent); }
.bitmap-btn {
    background: transparent; color: var(--accent); border: 1px solid var(--accent-border); border-radius: 6px;
    padding: 3px 8px; font-size: 10px; cursor: pointer; font-weight: 600; transition: all 0.12s;
}
.bitmap-btn:hover { background: var(--accent); color: #fff; }
.bitmap-btn:disabled { opacity: 0.3; cursor: default; background: transparent; color: var(--accent); }
#bitmap-coeff-btn { color: #e94560; font-weight: 700; }
#bitmap-coeff-btn.active { color: #2ecc71; }
.bitmap-select {
    background: var(--bg); color: var(--fg); border: 1px solid var(--accent-border); border-radius: 6px;
    padding: 2px 4px; font-size: 10px; font-weight: 600; cursor: pointer;
}
body.fast-mode #header,
body.fast-mode .mid-bar,
body.fast-mode .tab-bar,
body.fast-mode #roots-content,
body.fast-mode #stats-content,
body.fast-mode #sound-content,
body.fast-mode #anim-bar,
body.fast-mode .panel:first-child {
    opacity: 0.15; pointer-events: none; filter: grayscale(1);
    transition: opacity 0.3s, filter 0.3s;
}
body.fast-mode #bitmap-toolbar .bitmap-btn:not(#bitmap-fast-btn):not(#bitmap-coeff-btn):not(#bitmap-zoom-in-btn):not(#bitmap-zoom-out-btn),
body.fast-mode #bitmap-toolbar .bitmap-select {
    opacity: 0.3; pointer-events: none;
}
body.fast-mode #bitmap-fast-btn {
    background: var(--accent); color: #fff;
}
body.fast-mode #rec-mode,
body.fast-mode #rec-roots-btn,
body.fast-mode #stop-roots-btn {
    opacity: 1; pointer-events: auto; filter: none;
}
#anim-bar .bar-controls { opacity: 1; transition: opacity 0.15s; }
#anim-bar .bar-controls.dimmed { opacity: 0.3; pointer-events: none; }
#path-nav { display: flex; align-items: center; gap: 4px; }
.path-nav-btn {
    background: transparent; color: var(--muted); border: 1px solid var(--stroke); border-radius: 5px;
    width: 22px; height: 22px; font-size: 10px; cursor: pointer; padding: 0;
    display: flex; align-items: center; justify-content: center; transition: all 0.12s;
}
.path-nav-btn:hover { color: #fff; border-color: var(--stroke2); }
#path-label { font-size: 11px; color: var(--muted); min-width: 56px; text-align: center; }
#ccw-btn {
    background: transparent; color: var(--muted); border: 1px solid var(--stroke); border-radius: 6px;
    padding: 3px 8px; font-size: 10px; cursor: pointer; transition: all 0.12s; min-width: 28px;
}
#ccw-btn.active { background: rgba(91,106,191,0.20); color: #fff; border-color: rgba(91,106,191,0.55); }
#del-path-btn {
    background: transparent; color: var(--muted); border: 1px solid var(--stroke); border-radius: 6px;
    width: 22px; height: 22px; font-size: 14px; cursor: pointer; padding: 0;
    display: flex; align-items: center; justify-content: center; transition: all 0.12s;
}
#del-path-btn:hover { color: var(--accent); border-color: var(--accent-border); }
.trail-path { fill: none; stroke-width: 1.5; opacity: 0.6; stroke-linecap: round; stroke-linejoin: round; }
.tooltip {
    position: absolute; background: rgba(10,12,30,0.75); color: var(--text);
    padding: 5px 10px; border-radius: 8px; font-size: 12px; pointer-events: none;
    display: none; white-space: nowrap;
    border: 1px solid var(--stroke);
    backdrop-filter: var(--blur); -webkit-backdrop-filter: var(--blur);
}
</style>
</head>
<body>

<div id="header">
    <span class="app-title">PolyPaint v39</span>
    <div class="header-sep"></div>
    <span class="control-label">Degree</span>
    <span id="degree-number" class="degree-val">5</span>
    <select id="pattern">
            <optgroup label="Basic">
                <option value="circle">Circle</option>
                <option value="real">Real axis</option>
                <option value="imag">Imaginary axis</option>
                <option value="grid">Grid</option>
                <option value="random">Random</option>
            </optgroup>
            <optgroup label="Coeff patterns">
                <option value="spiral">Spiral</option>
                <option value="star">Star</option>
                <option value="lemniscate">Figure-8</option>
                <option value="conjugate">Conjugate pairs</option>
                <option value="two-clusters">Two clusters</option>
                <option value="geometric">Geometric decay</option>
                <option value="rose">Rose curve</option>
                <option value="cardioid">Cardioid</option>
            </optgroup>
            <optgroup label="Roots shapes">
                <option value="r-heart">Heart</option>
                <option value="r-circle">Circle</option>
                <option value="r-star">Star</option>
                <option value="r-spiral">Spiral</option>
                <option value="r-cross">Cross</option>
                <option value="r-diamond">Diamond</option>
                <option value="r-grid">Chessboard</option>
                <option value="r-smiley">Smiley</option>
                <option value="r-figure8">Figure-8</option>
                <option value="r-butterfly">Butterfly</option>
                <option value="r-trefoil">Trefoil</option>
                <option value="r-polygon">Polygon</option>
                <option value="r-infinity">Infinity</option>
            </optgroup>
    </select>
    <div class="header-sep"></div>
    <button id="reset-btn" class="icon-btn" title="Reset to initial state">â†º</button>
    <div class="header-sep"></div>
    <span style="display:flex;gap:4px;align-items:center;">
        <button id="save-btn" class="icon-btn" title="Save state">ðŸ’¾</button>
        <button id="load-btn" class="icon-btn" title="Load state">ðŸ“‚</button>
        <button id="snap-btn" class="icon-btn" title="Export snapshot">â¬‡</button>
    </span>
    <div class="header-sep"></div>
    <button id="timing-btn" class="icon-btn" title="Timing" style="font-size:11px;font-weight:700;">T</button>
    <div class="header-sep"></div>
    <span id="anim-controls" style="display:flex;gap:4px;align-items:center;"><input id="scrub-slider" type="range" min="0" max="5000" value="0" step="1" title="Scrub (adds seconds when paused)"><button id="play-btn">â–¶ Play</button><span id="anim-seconds" style="font-size:10px;color:var(--accent);min-width:36px;text-align:right;font-variant-numeric:tabular-nums;">0.00s</span><button id="home-btn" title="Return to start position">Home</button></span>
</div>
<div id="content">
    <div id="main">
        <div id="panels">
    <div class="panel" id="left-panel">
        <div class="tab-bar" id="left-tab-bar">
            <button class="tab active" data-ltab="coeffs">C-Nodes <span id="coeff-sel-count" style="font-size:9px;color:#5ddb6a;opacity:0.85;"></span></button>
            <button class="tab" data-ltab="list">C-List</button>
            <button class="tab" data-ltab="morph">D-Nodes <span id="morph-sel-count" style="font-size:9px;color:#5ddb6a;opacity:0.85;"></span></button>
            <button class="tab" data-ltab="dlist">D-List</button>
            <button class="tab" data-ltab="jiggle">Jiggle <span id="jiggle-sel-count" style="font-size:9px;color:#5ddb6a;opacity:0.85;"></span></button>
            <button class="tab" data-ltab="final">Final</button>
        </div>
        <div class="tab-panes" id="left-tab-panes">
            <div id="coeffs-content" class="tab-content active">
                <div id="anim-bar">
                    <div class="bar-row">
                        <button id="coeff-picker-btn" class="bar-sel-btn" title="Coefficient picker">â˜°</button>
                        <button id="select-all-coeffs-btn" class="bar-sel-btn" title="Select all coefficients">âŠ• All</button>
                        <button id="deselect-all-btn" class="bar-sel-btn" title="Deselect all (Esc)">âœ• None</button>
                        <span class="bar-title empty" id="bar-title">&lt;no selection&gt;</span>
                        <button id="sel2path-btn">Update Whole Selection</button>
                    </div>
                    <div class="bar-controls dimmed" id="bar-controls">
                        <div class="bar-row">
                            <select id="anim-path"></select>
                            <div id="bar-dynamic"></div>
                        </div>
                    </div>
                </div>
                <div id="coeff-container">
                    <svg id="coeff-panel"></svg>
                </div>
            </div>
            <div id="list-content" class="tab-content">
                <div id="coeff-list-toolbar" style="display:flex;gap:6px;padding:4px 8px;align-items:center;border-bottom:1px solid var(--stroke);background:rgba(10,12,30,0.45);flex-shrink:0;">
                    <button id="list-select-all-btn" class="bar-sel-btn" title="Select all">âŠ• All</button>
                    <button id="list-deselect-all-btn" class="bar-sel-btn" title="Deselect all">âœ• None</button>
                    <button id="list-all-curves-btn" class="bar-sel-btn" title="Select all coefficients with the displayed curve type">Same Curve</button>
                    <button id="list-curve-prev" class="bar-sel-btn" style="padding:0 4px;font-size:10px;line-height:1;">&#9664;</button>
                    <span id="list-curve-cycle" style="font-size:9px;color:var(--accent);min-width:36px;text-align:center;">â€”</span>
                    <button id="list-curve-next" class="bar-sel-btn" style="padding:0 4px;font-size:10px;line-height:1;">&#9654;</button>
                    <span id="list-count" style="font-size:9px;color:var(--muted);"></span>
                    <span style="font-size:7px;color:var(--muted);">Transform</span>
                    <select id="list-transform" style="font-size:8px;background:var(--bg);color:var(--fg);border:1px solid var(--stroke);border-radius:3px;padding:1px 2px;">
                        <option value="none">none</option>
                        <option value="PrimeSpeeds">PrimeSpeeds</option>
                        <option value="SetAllSpeeds">Set All Speeds</option>
                        <option value="RandomSpeed">RandomSpeed</option>
                        <option value="RandomAngle">RandomAngle</option>
                        <option value="RandomRadius">RandomRadius</option>
                        <option value="LerpSpeed">Lerp Speed</option>
                        <option value="LerpRadius">Lerp Radius</option>
                        <option value="LerpAngle">Lerp Angle</option>
                        <option value="RandomDirection">RandomDirection</option>
                        <option value="FlipAllDirections">FlipAllDirections</option>
                        <option value="ShuffleCurves">ShuffleCurves</option>
                        <option value="ShufflePositions">ShufflePositions</option>
                        <option value="CircleLayout">CircleLayout</option>
                        <option value="RotatePositions">RotatePositions</option>
                        <option value="ScalePositions">ScalePositions</option>
                        <option value="JitterPositions">JitterPositions</option>
                        <option value="Conjugate">Conjugate</option>
                        <option value="InvertPositions">InvertPositions</option>
                        <option value="SortByModulus">SortByModulus</option>
                        <option value="SortByArgument">SortByArgument</option>
                    </select>
                    <span style="display:inline-flex;align-items:center;gap:2px;" title="Parameter for transforms">
                        <span style="font-size:7px;color:var(--muted);">Param1</span>
                        <input id="list-sel-speed" type="range" min="1" max="1000" value="500" step="1" style="width:52px;height:10px;accent-color:var(--accent);">
                        <span id="list-sel-speed-val" style="font-size:7px;color:var(--muted);min-width:16px;">500</span>
                    </span>
                    <span style="display:inline-flex;align-items:center;gap:2px;" title="Parameter 2 for transforms">
                        <span style="font-size:7px;color:var(--muted);">Param2</span>
                        <input id="list-sel-param2" type="range" min="1" max="1000" value="1000" step="1" style="width:52px;height:10px;accent-color:var(--accent);">
                        <span id="list-sel-param2-val" style="font-size:7px;color:var(--muted);min-width:16px;">1000</span>
                    </span>
                </div>
                <div id="list-curve-editor" style="padding:4px 8px 6px;border-bottom:1px solid var(--stroke);background:rgba(10,12,30,0.55);flex-shrink:0;opacity:0.3;pointer-events:none;transition:opacity 0.15s;">
                    <div style="display:flex;align-items:center;gap:4px;flex-wrap:wrap;">
                        <select id="lce-path-sel" style="font-size:9px;font-weight:600;color:var(--accent);background:rgba(0,0,0,0.3);border:1px solid var(--stroke);border-radius:3px;padding:1px 2px;"></select>
                        <span style="width:6px;"></span>
                        <div id="lce-controls"></div>
                        <span style="width:4px;"></span>
                        <button id="lce-update-sel" class="bar-sel-btn" style="font-size:8px;">Update Whole Selection</button>
                    </div>
                </div>
                <div id="coeff-list-hdr" class="cpick-row" style="padding:1px 8px 1px;border-bottom:1px solid var(--stroke);flex-shrink:0;cursor:default;opacity:0.5;">
                    <span class="cpick-cb" style="visibility:hidden;"></span>
                    <span class="cpick-dot" style="visibility:hidden;"></span>
                    <span class="cpick-dot" style="visibility:hidden;"></span>
                    <span class="cpick-label" style="font-size:7px;">idx</span>
                    <span class="cpick-power" style="font-size:7px;">term</span>
                    <span style="font-size:7px;color:var(--muted);width:58px;text-align:center;flex-shrink:0;">path</span>
                    <span class="cpick-speed" style="font-size:7px;">spd</span>
                    <span class="cpick-radius" style="font-size:7px;">rad</span>
                    <span class="cpick-plen" style="font-size:7px;">pts</span>
                    <span class="cpick-pos" style="font-size:7px;">pos</span>
                    <span class="cpick-coords" style="font-size:7px;">position</span>
                </div>
                <div id="coeff-list-scroll" style="flex:1;min-height:0;overflow-y:auto;padding:4px 8px;"></div>
            </div>
            <div id="morph-content" class="tab-content">
                <div id="morph-bar" style="padding:4px 8px;display:flex;align-items:center;gap:8px;flex-shrink:0;border-bottom:1px solid var(--stroke);background:rgba(10,12,30,0.45);">
                    <button id="morph-copy-btn" class="bar-sel-btn" style="font-size:8px;">Copy Câ†’D</button>
                    <button id="morph-swap-btn" class="bar-sel-btn" style="font-size:8px;">Swap Câ†”D</button>
                    <button id="morph-cdpath-btn" class="bar-sel-btn" style="font-size:8px;">C-D Path</button>
                </div>
                <div id="morph-container" style="flex:1;min-height:0;position:relative;">
                    <svg id="morph-panel"></svg>
                </div>
            </div>
            <div id="dlist-content" class="tab-content">
                <div id="dcoeff-list-toolbar" style="display:flex;gap:6px;padding:4px 8px;align-items:center;border-bottom:1px solid var(--stroke);background:rgba(10,12,30,0.45);flex-shrink:0;">
                    <button id="dlist-select-all-btn" class="bar-sel-btn" title="Select all">âŠ• All</button>
                    <button id="dlist-deselect-all-btn" class="bar-sel-btn" title="Deselect all">âœ• None</button>
                    <button id="dlist-all-curves-btn" class="bar-sel-btn" title="Select all D-nodes with the displayed curve type">Same Curve</button>
                    <button id="dlist-curve-prev" class="bar-sel-btn" style="padding:0 4px;font-size:10px;line-height:1;">&#9664;</button>
                    <span id="dlist-curve-cycle" style="font-size:9px;color:var(--accent);min-width:36px;text-align:center;">â€”</span>
                    <button id="dlist-curve-next" class="bar-sel-btn" style="padding:0 4px;font-size:10px;line-height:1;">&#9654;</button>
                    <span id="dlist-count" style="font-size:9px;color:var(--muted);"></span>
                    <span style="font-size:7px;color:var(--muted);">Transform</span>
                    <select id="dlist-transform" style="font-size:8px;background:var(--bg);color:var(--fg);border:1px solid var(--stroke);border-radius:3px;padding:1px 2px;">
                        <option value="none">none</option>
                        <option value="PrimeSpeeds">PrimeSpeeds</option>
                        <option value="SetAllSpeeds">Set All Speeds</option>
                        <option value="RandomSpeed">RandomSpeed</option>
                        <option value="RandomAngle">RandomAngle</option>
                        <option value="RandomRadius">RandomRadius</option>
                        <option value="LerpSpeed">Lerp Speed</option>
                        <option value="LerpRadius">Lerp Radius</option>
                        <option value="LerpAngle">Lerp Angle</option>
                        <option value="RandomDirection">RandomDirection</option>
                        <option value="FlipAllDirections">FlipAllDirections</option>
                        <option value="ShuffleCurves">ShuffleCurves</option>
                        <option value="ShufflePositions">ShufflePositions</option>
                        <option value="CircleLayout">CircleLayout</option>
                        <option value="RotatePositions">RotatePositions</option>
                        <option value="ScalePositions">ScalePositions</option>
                        <option value="JitterPositions">JitterPositions</option>
                        <option value="Conjugate">Conjugate</option>
                        <option value="InvertPositions">InvertPositions</option>
                        <option value="SortByModulus">SortByModulus</option>
                        <option value="SortByArgument">SortByArgument</option>
                    </select>
                    <span style="display:inline-flex;align-items:center;gap:2px;" title="Parameter for transforms">
                        <span style="font-size:7px;color:var(--muted);">Param1</span>
                        <input id="dlist-sel-speed" type="range" min="1" max="1000" value="500" step="1" style="width:52px;height:10px;accent-color:var(--accent);">
                        <span id="dlist-sel-speed-val" style="font-size:7px;color:var(--muted);min-width:16px;">500</span>
                    </span>
                    <span style="display:inline-flex;align-items:center;gap:2px;" title="Parameter 2 for transforms">
                        <span style="font-size:7px;color:var(--muted);">Param2</span>
                        <input id="dlist-sel-param2" type="range" min="1" max="1000" value="1000" step="1" style="width:52px;height:10px;accent-color:var(--accent);">
                        <span id="dlist-sel-param2-val" style="font-size:7px;color:var(--muted);min-width:16px;">1000</span>
                    </span>
                </div>
                <div id="dlist-curve-editor" style="padding:4px 8px 6px;border-bottom:1px solid var(--stroke);background:rgba(10,12,30,0.55);flex-shrink:0;opacity:0.3;pointer-events:none;transition:opacity 0.15s;">
                    <div style="display:flex;align-items:center;gap:4px;flex-wrap:wrap;">
                        <select id="dle-path-sel" style="font-size:9px;font-weight:600;color:var(--accent);background:rgba(0,0,0,0.3);border:1px solid var(--stroke);border-radius:3px;padding:1px 2px;"></select>
                        <span style="width:6px;"></span>
                        <div id="dle-controls"></div>
                        <span style="width:4px;"></span>
                        <button id="dle-update-sel" class="bar-sel-btn" style="font-size:8px;">Update Whole Selection</button>
                    </div>
                </div>
                <div id="dcoeff-list-hdr" class="cpick-row" style="padding:1px 8px 1px;border-bottom:1px solid var(--stroke);flex-shrink:0;cursor:default;opacity:0.5;">
                    <span class="cpick-cb" style="visibility:hidden;"></span>
                    <span class="cpick-dot" style="visibility:hidden;"></span>
                    <span class="cpick-dot" style="visibility:hidden;"></span>
                    <span class="cpick-label" style="font-size:7px;">idx</span>
                    <span class="cpick-power" style="font-size:7px;">term</span>
                    <span style="font-size:7px;color:var(--muted);width:58px;text-align:center;flex-shrink:0;">path</span>
                    <span class="cpick-speed" style="font-size:7px;">spd</span>
                    <span class="cpick-radius" style="font-size:7px;">rad</span>
                    <span class="cpick-plen" style="font-size:7px;">pts</span>
                    <span class="cpick-pos" style="font-size:7px;">pos</span>
                    <span class="cpick-coords" style="font-size:7px;">position</span>
                </div>
                <div id="dcoeff-list-scroll" style="flex:1;min-height:0;overflow-y:auto;padding:4px 8px;"></div>
            </div>
            <div id="jiggle-content" class="tab-content" style="display:flex;flex-direction:column;">
                <div id="jiggle-bar" style="padding:4px 8px;display:flex;align-items:center;gap:8px;flex-shrink:0;border-bottom:1px solid var(--stroke);background:rgba(10,12,30,0.45);">
                    <span style="font-size:10px;font-weight:600;color:var(--fg);">JIGGLE</span>
                    <span id="jiggle-status" style="font-size:9px;color:var(--muted);"></span>
                </div>
                <div id="jiggle-controls" style="flex:1;min-height:0;overflow-y:auto;padding:8px;"></div>
            </div>
            <div id="final-content" class="tab-content">
                <div id="final-bar" style="padding:4px 8px;display:flex;align-items:center;gap:8px;flex-shrink:0;border-bottom:1px solid var(--stroke);background:rgba(10,12,30,0.45);">
                    <span id="morph-mu-val" style="font-size:9px;color:var(--accent);min-width:30px;">Î¼=0.50</span>
                </div>
                <div id="final-container" style="flex:1;min-height:0;position:relative;overflow:hidden;">
                    <svg id="final-panel" style="width:100%;height:100%;"></svg>
                </div>
            </div>
        </div>
    </div>
    <div class="mid-bar">
        <div id="ops-group" class="disabled" style="display:flex;flex-direction:column;gap:6px;align-items:center;">
            <div class="mid-label">Ops <span id="ops-target"></span></div>
            <button id="scale-tool-btn" class="mid-btn" title="Scale">â‡•</button>
            <button id="scale-re-tool-btn" class="mid-btn" title="Scale Re" style="font-size:9px;font-weight:bold;">Re</button>
            <button id="scale-im-tool-btn" class="mid-btn" title="Scale Im" style="font-size:9px;font-weight:bold;">Im</button>
            <button id="rotate-tool-btn" class="mid-btn" title="Rotate">âŸ²</button>
            <button id="add-tool-btn" class="mid-btn" title="Translate">âœ›</button>
            <button id="shape-tool-btn" class="mid-btn" title="Shape morph" style="font-size:9px;font-weight:bold;">Shp</button>
            <button id="ptrn-tool-btn" class="mid-btn" title="Pattern arrange" style="font-size:9px;font-weight:bold;">Ptrn</button>
        </div>
        <div style="display:flex;gap:2px;margin-top:4px;">
            <button id="mid-all-btn" class="mid-btn" style="width:auto;height:auto;font-size:8px;padding:1px 4px;border-radius:4px;" title="Select all (roots if any root selected, else coefficients)">âŠ•</button>
            <button id="mid-none-btn" class="mid-btn" style="width:auto;height:auto;font-size:8px;padding:1px 4px;border-radius:4px;" title="Deselect all">âœ•</button>
        </div>
        <button id="inverse-btn" class="mid-btn" style="width:auto;height:auto;font-size:9px;padding:2px 6px;border-radius:6px;margin-top:6px;" title="Reverse coefficient order (reflects roots around unit circle)">Inv</button>
    </div>
    <div class="panel">
        <div class="tab-bar">
            <button class="tab active" data-tab="roots">Roots <span id="roots-sel-count" style="font-size:9px;color:#e94560;opacity:0.85;"></span></button>
            <button class="tab" data-tab="stats">Stats</button>
            <button class="tab" data-tab="sound">Sound</button>
            <button class="tab" data-tab="bitmap">Bitmap</button>
            <span class="tab-bar-controls">
                <select id="rec-mode" title="Recording mode" style="font-size:10px;padding:1px 2px;background:rgba(255,255,255,0.06);color:var(--muted);border:1px solid var(--stroke);border-radius:4px;cursor:pointer;"><option value="roots">Roots</option><option value="coeffs">Coeffs</option><option value="both">Both</option><option value="stats">Stats</option><option value="sound">Sound</option><option value="bitmap">Bitmap</option><option value="full">Full</option></select>
                <button id="rec-roots-btn" class="icon-btn" title="Record (webm)">âº</button>
                <button id="stop-roots-btn" class="icon-btn" title="Stop recording" style="display:none;">â¹</button>
            </span>
        </div>
        <div class="tab-panes">
            <div id="roots-content" class="tab-content active">
                <div id="roots-toolbar">
                    <button id="trails-btn">Trails</button>
                    <button id="root-color-btn" class="roots-tool-btn active" title="Color roots">ðŸŽ¨</button>
                    <button id="domain-toggle-btn" class="roots-tool-btn" title="Domain coloring">â—</button>
                    <button id="roots-fit-btn" class="roots-tool-btn" title="Resize to fit all roots and trails">Fit</button>
                    <button id="roots-zoom-in-btn" class="roots-tool-btn" title="Zoom in 25%">âˆ’25%</button>
                    <button id="roots-zoom-out-btn" class="roots-tool-btn" title="Zoom out 25%">+25%</button>
                    <button id="select-all-roots-btn" class="roots-tool-btn" title="Select all roots">âŠ• All</button>
                    <button id="deselect-all-roots-btn" class="roots-tool-btn" title="Deselect all roots">âœ• None</button>
                </div>
                <div id="roots-container">
                    <canvas id="domain-canvas"></canvas>
                    <svg id="roots-panel"></svg>
                </div>
            </div>
            <div id="stats-content" class="tab-content">
                <div class="stats-grid">
                    <div class="stats-cell"><select class="stats-select" data-plot="0"></select><canvas class="stats-canvas" data-plot="0"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="1"></select><canvas class="stats-canvas" data-plot="1"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="2"></select><canvas class="stats-canvas" data-plot="2"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="3"></select><canvas class="stats-canvas" data-plot="3"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="4"></select><canvas class="stats-canvas" data-plot="4"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="5"></select><canvas class="stats-canvas" data-plot="5"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="6"></select><canvas class="stats-canvas" data-plot="6"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="7"></select><canvas class="stats-canvas" data-plot="7"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="8"></select><canvas class="stats-canvas" data-plot="8"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="9"></select><canvas class="stats-canvas" data-plot="9"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="10"></select><canvas class="stats-canvas" data-plot="10"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="11"></select><canvas class="stats-canvas" data-plot="11"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="12"></select><canvas class="stats-canvas" data-plot="12"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="13"></select><canvas class="stats-canvas" data-plot="13"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="14"></select><canvas class="stats-canvas" data-plot="14"></canvas></div>
                    <div class="stats-cell"><select class="stats-select" data-plot="15"></select><canvas class="stats-canvas" data-plot="15"></canvas></div>
                </div>
            </div>
            <div id="sound-content" class="tab-content">
                <div id="sound-toolbar">
                    <button id="base-toggle-btn" class="sound-tool-btn" title="Base (drone)">B Base</button>
                    <button id="melody-toggle-btn" class="sound-tool-btn" title="Melody (arpeggio)">M Melody</button>
                    <button id="voice-toggle-btn" class="sound-tool-btn" title="Voice (beeps)">V Voice</button>
                </div>
                <div class="config-panel" id="config-sliders"></div>
            </div>
            <div id="bitmap-content" class="tab-content">
                <div id="bitmap-toolbar" style="display:flex;gap:6px;padding:4px 6px;align-items:center;flex-wrap:wrap;">
                    <button id="bitmap-start-btn" class="bitmap-btn">init</button>
                    <button id="bitmap-save-btn" class="bitmap-btn" disabled>save</button>
                    <button id="bitmap-clear-btn" class="bitmap-btn" disabled>clear</button>
                    <select id="bitmap-res-select" class="bitmap-select"><option value="1000">1000px</option><option value="2000" selected>2000px</option><option value="5000">5000px</option><option value="8000">8000px</option><option value="10000">10000px</option><option value="15000">15000px</option><option value="25000">25000px</option></select>
                    <button id="bitmap-fast-btn" class="bitmap-btn" disabled>start</button>
                    <button id="bitmap-coeff-btn" class="bitmap-btn" disabled title="Plot coefficient positions instead of roots">ROOT</button>
                    <select id="bitmap-steps-select" class="bitmap-select"><option value="10">10</option><option value="100">100</option><option value="1000">1K</option><option value="5000">5K</option><option value="10000" selected>10K</option><option value="50000">50K</option><option value="100000">100K</option><option value="1000000">1M</option></select>
                    <button id="bitmap-cfg-btn" class="bitmap-btn" title="Fast mode config">cfg</button>
                    <button id="bitmap-zoom-in-btn" class="bitmap-btn" title="Zoom in 25%">âˆ’25%</button>
                    <button id="bitmap-zoom-out-btn" class="bitmap-btn" title="Zoom out 25%">+25%</button>
                    <span id="bitmap-zoom-label" style="font-family:monospace;font-size:10px;color:var(--muted);white-space:nowrap;">1.00Ã—</span>
                    <span id="bitmap-pass-count" style="display:none;font-family:monospace;font-size:10px;color:var(--muted);margin-left:4px;white-space:nowrap;"></span>
                </div>
                <div id="bitmap-container" style="flex:1;min-height:0;position:relative;background:#000;">
                    <canvas id="bitmap-canvas" style="width:100%;height:100%;"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>
    </div>
</div>

<div class="tooltip" id="tooltip"></div>
<div id="ops-pop" class="ops-pop"></div>
<div id="degree-pop" class="ops-pop"></div>
<div id="audio-pop" class="ops-pop" style="min-width:220px"></div>
<div id="color-pop" class="ops-pop" style="min-width:160px"></div>
<div id="coeff-pick-pop" class="ops-pop" style="min-width:300px"></div>
<div id="coeff-ctx" class="ops-pop"></div>
<div id="dnode-ctx" class="ops-pop"></div>
<div id="snap-pop" class="ops-pop" style="min-width:100px"></div>
<div id="path-pick-pop" class="ops-pop"></div>
<div id="dpath-pick-pop" class="ops-pop"></div>
<div id="timing-pop" class="ops-pop" style="min-width:220px"></div>
<div id="bitmap-cfg-pop" class="ops-pop" style="min-width:160px"></div>
<div id="bitmap-save-pop" class="ops-pop" style="min-width:160px"></div>
<div id="cdpath-pop" class="ops-pop" style="min-width:180px"></div>

<script>
// ============================================================================
// COEFFICIENT INDEXING CONVENTION
//
// The polynomial is p(z) = câ‚™zâ¿ + câ‚™â‚‹â‚zâ¿â»Â¹ + Â·Â·Â· + câ‚z + câ‚€
//
// Subscript = power of z:
//   câ‚™  = leading coefficient (always 1+0i for monic polynomials from roots)
//   câ‚€  = constant term
//
// Internal array storage is in DESCENDING power order:
//   coefficients[0]   = câ‚™   (leading, z^n)
//   coefficients[1]   = câ‚™â‚‹â‚ (z^(n-1))
//   ...
//   coefficients[n]   = câ‚€   (constant, z^0)
//
// So array index i corresponds to câ‚– where k = degree - i.
// All user-facing labels (SVG dots, picker, bar title, recording canvas)
// display the power-based subscript k, NOT the array index i.
// ============================================================================

const MIN_RANGE = 1.5;
const MARGIN = 30;
const RANGE_PAD = 1.3; // 30% padding around data

// Compute panel size from available space
function getPanelSize() {
    const header = document.getElementById("header");
    const opsBar = document.getElementById("ops-group");
    const opsW = opsBar ? opsBar.offsetWidth : 0;
    const availH = window.innerHeight - header.offsetHeight - 50;
    const availW = (window.innerWidth - opsW - 16 * 3) / 2;
    return Math.max(200, Math.floor(Math.min(availW, availH)));
}

let S = getPanelSize();

// Per-panel state
const panels = {
    coeff: { range: 3, xScale: null, yScale: null, gridG: null, axisG: null, labelRe: null, labelIm: null, unitCircle: null },
    roots: { range: 3, xScale: null, yScale: null, gridG: null, axisG: null, labelRe: null, labelIm: null, unitCircle: null }
};

function makeScales(range) {
    return {
        x: d3.scaleLinear().domain([-range, range]).range([MARGIN, S - MARGIN]),
        y: d3.scaleLinear().domain([-range, range]).range([S - MARGIN, MARGIN])
    };
}

function initPanelScales(p) {
    const s = makeScales(p.range);
    p.xScale = s.x;
    p.yScale = s.y;
}
initPanelScales(panels.coeff);
initPanelScales(panels.roots);

// Convenience aliases (updated when range changes)
function cxs() { return panels.coeff.xScale; }
function cys() { return panels.coeff.yScale; }
function rxs() { return panels.roots.xScale; }
function rys() { return panels.roots.yScale; }

let coefficients = [];
let currentRoots = []; // persistent root data for dragging
let pendingSolve = false;

// Selection & animation state
const selectedCoeffs = new Set(); // indices into coefficients[]
const selectedRoots = new Set();  // indices into currentRoots[]
const selectedMorphCoeffs = new Set(); // indices into morphTargetCoeffs[]
const animState = { playing: false, startTime: 0, rafId: null, elapsedAtPause: null };
let lastSelectedCoeff = -1; // index of last coefficient added to selection (for editor display)
// Trail state
let trailsEnabled = false;
let trailData = []; // array of arrays: trailData[i] = [{re, im}, ...] for root i
let finalTrailData = []; // array of arrays: finalTrailData[i] = [{re, im}, ...] for final coeff i
const MAX_TRAIL_POINTS = 4000;
// Domain coloring state
let domainColoringEnabled = false;
let rootColorMode = "rainbow";  // "uniform" | "rainbow" | "derivative" | "proximity"
let uniformRootColor = [255, 255, 255];  // RGB for uniform mode (default white)
let rootSensitivities = null;   // Float64Array for derivative mode
// Bitmap-specific color mode (decoupled from animation rootColorMode)
let bitmapColorMode = "uniform";  // "uniform" | "rainbow" | "derivative" | "proximity" | "idx-prox" | "ratio"
let bitmapUniformColor = [255, 255, 255];
let bitmapMatchStrategy = "assign4"; // "assign4" | "assign1" | "hungarian1"
let bitmapProxPaletteName = "inferno"; // key into PROX_PALETTE_CATALOG
let bitmapDerivPaletteName = "bwr"; // key into DERIV_PALETTE_CATALOG
let bitmapIdxProxGamma = 0.5; // gamma correction for IdxÃ—Prox brightness (0.1=bright, 1.0=linear)
let bitmapRatioGamma = 0.5;   // gamma correction for Min/Max Ratio (0.1=spread low ratios, 1.0=linear)
// Fixed 8-color palette shared by animation and bitmap uniform pickers
const ROOT_COLOR_SWATCHES = [
    { label: "White",  rgb: [255, 255, 255] },
    { label: "Red",    rgb: [233, 69, 96] },
    { label: "Orange", rgb: [255, 165, 0] },
    { label: "Yellow", rgb: [255, 255, 0] },
    { label: "Green",  rgb: [0, 200, 83] },
    { label: "Cyan",   rgb: [0, 210, 211] },
    { label: "Blue",   rgb: [30, 144, 255] },
    { label: "Purple", rgb: [155, 89, 182] },
];
// Proximity palette catalog: name â†’ d3 interpolator
const PROX_PALETTE_CATALOG = [
    { key: "inferno",  label: "Inferno",  fn: d3.interpolateInferno },
    { key: "viridis",  label: "Viridis",  fn: d3.interpolateViridis },
    { key: "magma",    label: "Magma",    fn: d3.interpolateMagma },
    { key: "plasma",   label: "Plasma",   fn: d3.interpolatePlasma },
    { key: "turbo",    label: "Turbo",    fn: d3.interpolateTurbo },
    { key: "cividis",  label: "Cividis",  fn: d3.interpolateCividis },
    { key: "warm",     label: "Warm",     fn: d3.interpolateWarm },
    { key: "cool",     label: "Cool",     fn: d3.interpolateCool },
];
function buildProxPaletteFrom(interpolator) {
    const pal = [];
    for (let k = 0; k < 16; k++) {
        const c = d3.color(interpolator(k / 15));
        pal.push([c.r, c.g, c.b]);
    }
    return pal;
}
// 16-color proximity palette: rebuildable from catalog selection
let PROX_PALETTE = buildProxPaletteFrom(d3.interpolateInferno);
let PROX_PAL_R = new Uint8Array(PROX_PALETTE.map(c => c[0]));
let PROX_PAL_G = new Uint8Array(PROX_PALETTE.map(c => c[1]));
let PROX_PAL_B = new Uint8Array(PROX_PALETTE.map(c => c[2]));
function setProxPalette(key) {
    const entry = PROX_PALETTE_CATALOG.find(p => p.key === key);
    if (!entry) return;
    bitmapProxPaletteName = key;
    PROX_PALETTE = buildProxPaletteFrom(entry.fn);
    PROX_PAL_R = new Uint8Array(PROX_PALETTE.map(c => c[0]));
    PROX_PAL_G = new Uint8Array(PROX_PALETTE.map(c => c[1]));
    PROX_PAL_B = new Uint8Array(PROX_PALETTE.map(c => c[2]));
}
// 16-color derivative palette: rebuildable from catalog selection
function buildDerivBWR() {
    const pal = [];
    for (let k = 0; k < 16; k++) {
        const t = k / 15;
        if (t <= 0.5) { const s = t * 2; pal.push([Math.round(s * 255), Math.round(s * 255), 255]); }
        else { const s = (t - 0.5) * 2; pal.push([255, Math.round((1 - s) * 255), Math.round((1 - s) * 255)]); }
    }
    return pal;
}
const DERIV_PALETTE_CATALOG = [
    { key: "bwr",      label: "Blue-White-Red", fn: null },
    { key: "inferno",   label: "Inferno",   fn: d3.interpolateInferno },
    { key: "viridis",   label: "Viridis",   fn: d3.interpolateViridis },
    { key: "magma",     label: "Magma",     fn: d3.interpolateMagma },
    { key: "plasma",    label: "Plasma",    fn: d3.interpolatePlasma },
    { key: "turbo",     label: "Turbo",     fn: d3.interpolateTurbo },
    { key: "cividis",   label: "Cividis",   fn: d3.interpolateCividis },
    { key: "warm",      label: "Warm",      fn: d3.interpolateWarm },
    { key: "cool",      label: "Cool",      fn: d3.interpolateCool },
];
let DERIV_PALETTE = buildDerivBWR();
let DERIV_PAL_R = new Uint8Array(DERIV_PALETTE.map(c => c[0]));
let DERIV_PAL_G = new Uint8Array(DERIV_PALETTE.map(c => c[1]));
let DERIV_PAL_B = new Uint8Array(DERIV_PALETTE.map(c => c[2]));
function setDerivPalette(key) {
    const entry = DERIV_PALETTE_CATALOG.find(p => p.key === key);
    if (!entry) return;
    bitmapDerivPaletteName = key;
    DERIV_PALETTE = entry.fn ? buildProxPaletteFrom(entry.fn) : buildDerivBWR();
    DERIV_PAL_R = new Uint8Array(DERIV_PALETTE.map(c => c[0]));
    DERIV_PAL_G = new Uint8Array(DERIV_PALETTE.map(c => c[1]));
    DERIV_PAL_B = new Uint8Array(DERIV_PALETTE.map(c => c[2]));
}
let domainCanvas = document.getElementById("domain-canvas");
let domainCtx = domainCanvas.getContext("2d");
let domainPendingRender = false;
const DOMAIN_RES_SCALE = 0.5; // render at half resolution for performance
// Bitmap trail tab state
let bitmapActive = false;
let bitmapCtx = null;
let bitmapRange = null;   // frozen bounding box from roots panel
let bitmapRangeInitial = null; // range at init, for zoom label
let bitmapFrameCount = 0;
let bitmapCanvasColor = "#000000"; // canvas background color
let bitmapPersistentBuffer = null; // persistent ImageData for fast mode compositing (avoids getImageData)
const BITMAP_DISPLAY_CAP = 2000;   // max display canvas resolution (px)
let bitmapComputeRes = 0;          // full computation resolution (from dropdown)
let bitmapDisplayRes = 0;          // display canvas resolution = min(computeRes, DISPLAY_CAP)
let bitmapDisplayBuffer = null;    // ImageData at display resolution (null when no split needed)
let bitmapCoeffView = false;     // when true, fast mode plots coefficient positions instead of roots
// Fast mode state
const FAST_PASS_SECONDS = 1.0; // virtual duration of one fast pass
let fastModeActive = false;
let fastModeCurves = null;      // Map<coeffIndex, hi-res curve>
let fastModeDCurves = null;     // Map<dNodeIndex, hi-res curve> for animated D-nodes
let fastModeStepIndex = 0;
let fastModeTotalSteps = 0;
let fastModeTimerId = null;
let fastModeRootColors = null;  // pre-computed CSS color strings
let fastModeLastPixels = null;  // last received pixel ArrayBuffer snapshot (legacy)
let fastModeLastRoots = null;   // last received root positions (legacy)
let fastModeLastStep = 0;       // last reported step count
let fastModeElapsedOffset = 0;  // accumulated elapsed time across passes
let fastModePassCount = 0;      // completed pass counter (resets each cycle)
let fastModeTargetPasses = 0;   // passes for jiggle cycle (= jiggleInterval since each pass = 1s)
let jiggleInterval = 4;         // seconds between jiggle perturbations (0.1â€“100), shown in cfg popup
let jiggleOffsets = null;       // Map<coeffIdx, {re, im}> or null â€” cached output of computeJiggleForStep
let jiggleSigma = 1;           // Ïƒ as 0â€“10, read as jiggleSigma/10 (fraction of coeffExtent)
let jiggleMode = "none";       // "none" | "random" | "rotate" | "walk" | "scale" | etc.
let jiggleAngleSteps = 100;    // rotate/spiral/wobble: jiggle steps for one full revolution (10â€“5000)
let jiggleScaleStep = 0.1;     // scale: % of extent per step (0.01â€“1.0)
let jigglePeriod = 20;         // breathe/wobble/lissajous: triggers for one oscillation
let jiggleAmplitude = 10;      // breathe/lissajous: amplitude as % (of centroid distance or coeffExtent)
let jiggleLissFreqX = 1;       // lissajous: X frequency multiplier
let jiggleLissFreqY = 2;       // lissajous: Y frequency multiplier
let jiggleCircleSteps = 60;   // circle: number of jiggle steps for a full revolution (10â€“5000)
let jiggleStep = -1;           // current jiggle step = floor(elapsed / interval), -1 = no jiggle yet
let jiggleWalkCache = null;    // Map<coeffIdx, {re,im}> â€” walk mode running totals, keyed by step count
// Morph state: second coefficient set D blends with C via mu
let morphTargetCoeffs = [];   // parallel to coefficients[], same {re,im,curve,...} structure
let morphEnabled = true;
let morphRate = 0.01;         // Hz (oscillation cycles/sec), range 0â€“0.01
let morphMu = 0;              // current blend factor [0,1] â€” 0 when morph disabled
let morphPathType = "line";   // "line" | "circle" | "ellipse" | "figure8"
let morphPathCcw = false;     // CW by default; applies to circle, ellipse, figure8
let morphEllipseMinor = 0.5;  // minor axis as fraction of major (0.1â€“1.0), ellipse only
let morphDitherStartSigma = 0; // 0â€“0.01 (% of coeffExtent), uniform dither at C/start (max(cosÎ¸,0)Â² envelope)
let morphDitherMidSigma = 0;   // 0â€“0.1 (% of coeffExtent), uniform dither at midpoint (sinÂ²Î¸ envelope)
let morphDitherEndSigma = 0;   // 0â€“0.01 (% of coeffExtent), uniform dither at D/end (max(-cosÎ¸,0)Â² envelope)

// Compute interpolated position between C-node and D-node along the configured morph path.
// theta = 2Ï€ * morphRate * elapsed (raw angle in radians)
function morphInterpPoint(cRe, cIm, dRe, dIm, theta, pathType, ccw, minorPct) {
    const dx = dRe - cRe, dy = dIm - cIm;
    const len = Math.sqrt(dx * dx + dy * dy);
    if (len < 1e-15) return { re: cRe, im: cIm };
    if (pathType === "line") {
        const mu = 0.5 - 0.5 * Math.cos(theta);
        return { re: cRe * (1 - mu) + dRe * mu, im: cIm * (1 - mu) + dIm * mu };
    }
    // Local frame: u = unit Câ†’D, v = perpendicular (90Â° CCW)
    const ux = dx / len, uy = dy / len;
    const vx = -uy, vy = ux;
    const midRe = (cRe + dRe) * 0.5, midIm = (cIm + dIm) * 0.5;
    const semi = len * 0.5;
    const sign = ccw ? 1 : -1;
    let lx, ly;
    if (pathType === "circle") {
        lx = -semi * Math.cos(theta);
        ly = sign * semi * Math.sin(theta);
    } else if (pathType === "ellipse") {
        const semi_b = minorPct * semi;
        lx = -semi * Math.cos(theta);
        ly = sign * semi_b * Math.sin(theta);
    } else { // figure8
        lx = -semi * Math.cos(theta);
        ly = sign * (semi * 0.5) * Math.sin(2 * theta);
    }
    return { re: midRe + lx * ux + ly * vx, im: midIm + lx * uy + ly * vy };
}
let morphTheta = 0;  // current morph phase angle = 2Ï€ * morphRate * elapsed

let solverType = "js"; // "js" or "wasm" â€” which solver to use in fast mode workers
const WASM_STEP_LOOP_B64 = "AGFzbQEAAAABGQVgAXwBfGABfwBgAABgAn9/AGADf398AX8CQgUDZW52Bm1lbW9yeQIAAgNlbnYDbG9nAAADZW52A2NvcwAAA2VudgNzaW4AAANlbnYOcmVwb3J0UHJvZ3Jlc3MAAQMEAwIDBAQFAXABAQEGDwJ/AUGAgAQLfwBB0IIECwckAwRpbml0AAULcnVuU3RlcExvb3AABgtfX2hlYXBfYmFzZQMBCAEECsp9Aw4AQYCABEEAQcQC/AsAC/YIAQN/QQAgADYCgICEgABBACAAKAIANgKEgISAAEEAIAAoAiA2AqSAhIAAQQAgACgCHDYCoICEgABBACAAKAIYNgKcgISAAEEAIAAoAhQ2ApiAhIAAQQAgACgCEDYClICEgABBACAAKAIMNgKQgISAAEEAIAAoAgg2AoyAhIAAQQAgACgCBDYCiICEgABBACAAKAIkNgKogISAAEEAIAAoAig2AqyAhIAAQQAgACgCLDYCsICEgABBACAAKAIwNgK0gISAAEEAIAErAwA5A7iAhIAAQQAgASsDEDkDyICEgABBACABKwMIOQPAgISAAEEAIAErAxg5A9CAhIAAQQAgASsDIDkD2ICEgABBACABKwMoOQPggISAAEEAIAErAzA5A+iAhIAAQQAgACgChAI2AvCAhIAAQQAgACgCiAI2AvSAhIAAQQAgACgCQCIBNgKAgYSAAEEAIAAoAkQiAjYChIGEgABBACAAKAJIIgM2AoiBhIAAQQAgACgCTCIENgKMgYSAAAJAIAENACACDQAgAw0AIAQNAEEAQfis0ZEBNgKEgYSAAEEAQe/9tvV9NgKAgYSAAEEAQYHet956NgKIgYSAAEEAQaGGlbt4NgKMgYSAAAtBACAAKAJQNgKQgYSAAEEAIAAoAlQ2ApSBhIAAQQAgACgCWDYCmIGEgABBACAAKAJcNgKcgYSAAEEAIAAoAmA2AqCBhIAAQQAgACgCZDYCpIGEgABBACAAKAJoNgKogYSAAEEAIAAoAnQ2AqyBhIAAQQAgACgCeDYCsIGEgABBACAAKAJ8NgK0gYSAAEEAIAAoAoABNgK4gYSAAEEAIAAoAoQBNgK8gYSAAEEAIAAoAogBNgLAgYSAAEEAIAAoAowBNgLEgYSAAEEAIAAoApABNgLIgYSAAEEAIAAoApQBNgLMgYSAAEEAIAAoApgBNgLQgYSAAEEAIAAoApwBNgLUgYSAAEEAIAAoAqABNgLYgYSAAEEAIAAoAowCNgLcgYSAAEEAIAAoAqQBNgLggYSAAEEAIAAoAqgBNgLkgYSAAEEAIAAoAqwBNgLogYSAAEEAIAAoAswBNgLsgYSAAEEAIAAoArABNgLwgYSAAEEAIAAoArQBNgL0gYSAAEEAIAAoArgBNgL4gYSAAEEAIAAoArwBNgL8gYSAAEEAIAAoApACNgKAgoSAAEEAIAAoAsABNgKEgoSAAEEAIAAoAsQBNgKIgoSAAEEAIAAoAsgBNgKMgoSAAEEAIAAoAtABNgKQgoSAAEEAIAAoAtQBNgKUgoSAAEEAIAAoAtgBNgKYgoSAAEEAIAAoAtwBNgKcgoSAAEEAIAAoAuABNgKggoSAAEEAIAAoAuQBNgKkgoSAAEEAIAAoAugBNgKogoSAAEEAIAAoAuwBNgKsgoSAAEEAQQAoAoCAhIAAIgAoAvABNgKwgoSAAEEAIAAoAvQBNgK0goSAAEEAIAAoAvgBNgK4goSAAEEAIAAoAvwBNgK8goSAAEEAIAAoAoACNgLAgoSAAAvAdBMEfwF8Hn8BfAZ/AXwBfwJ8AX8BfAF/AXwCfwF8An8KfAF/A3wBfyOAgICAAEGg9ABrIgMkgICAgABBACEEQQAoArCChIAAIQVBACgCrIKEgAAhBkEAKwO4gISAACEHAkBBACgCiICEgAAiCEEBSA0AIAhBAXEhCUEAIQpBACgCoIKEgAAhC0EAKAKcgoSAACEMAkAgCEEBRg0AIAhB/v///wdxIQ1BACEOQQAhCgNAIAwgDmoiDyAGIA5qIhArAwA5AwAgCyAOaiIRIAUgDmoiEisDADkDACAPQQhqIBBBCGorAwA5AwAgEUEIaiASQQhqKwMAOQMAIA5BEGohDiANIApBAmoiCkcNAAsLIAlFDQAgDCAKQQN0Ig5qIAYgDmorAwA5AwAgCyAOaiAFIA5qKwMAOQMACwJAIAAgAU4NAEEAKAKEgISAACITQX9qIRQgCEEBcSEVIAhBB3EhFiAIQf7///8HcSEXIAhBA3EhGCAIQfj///8HcSEZIAhB/P///wdxIRogE0EBcSEbIBNB/v///wdxIRwgE0F+aiEdIAhBAWoiDEF4cSEeIAxBB3EhHyAIQX9qIiBBfnEhISAgQQFxISIgCEECdEEEaiEjIAhBA3QiJEEIaiElICC4ISYgA0GQM2pBCHIhJyADQYAyakEEciEoIANBoDRqQRBqISkgA0EIciEqIANBoDRqQQhyIQkgA0GAIGpBCHIhK0EAKAKQgISAACIstyEtQQAoAoyAhIAAIi63IS8gCLchMCAIQSFIITFBACEERAAAAAAAAPA/ITIgACEzA0AgM7dBACgClICEgAC3o0EAKwPAgISAAKIhNAJAQQAoArSAhIAARQ0AIBNBAUgNAEEAIQpBACgCmIKEgAAhC0EAKAKUgYSAACENQQAoApSChIAAITVBACgCkIGEgAAhNgJAIBRFDQBBACEOQQAhCgNAIDUgDmoiDyA2IA5qIhArAwA5AwAgCyAOaiIRIA0gDmoiEisDADkDACAPQQhqIBBBCGorAwA5AwAgEUEIaiASQQhqKwMAOQMAIA5BEGohDiAcIApBAmoiCkcNAAsLIBtFDQAgNSAKQQN0Ig5qIDYgDmorAwA5AwAgCyAOaiANIA5qKwMAOQMACyA0IAKgITcCQEEAKAKkgISAACISQQFIDQBBACE1A0AgN0EAKALQgYSAACA1QQN0IjZqKwMAoiI0miA0QQAoAtSBhIAAIDVBAnQiDWooAgAbIjQgNPwGuaEiNEQAAAAAAADwP6AgNCA0RAAAAAAAAAAAYxtBACgC5IGEgAAgDWooAgAiDreiIjT8AiILIA5vIhBBH3UgDnEhEUEAKALggYSAACANaigCACEPQQAoAsyBhIAAIA1qKAIAIQoCQAJAQQAoAuiBhIAAIA1qKAIARQ0AQQAoApSChIAAIjggCkEDdGpBACgC7IGEgAAgECAPaiARakEEdGoiDisDADkDACAOQQhqKwMAITQMAQtBACgClIKEgAAiOCAKQQN0akEAKALsgYSAACI5IBEgEGoiECAPakEEdGoiESsDAEQAAAAAAADwPyA0IAu3oSI0RAAAAAAAAPA/oCA0IDREAAAAAAAAAABjGyI0oSI6oiA0IDkgEEEBaiAObyAPakEEdGoiDisDAKKgOQMAIBFBCGorAwAgOqIgNCAOQQhqKwMAoqAhNAtBACgCmIKEgAAgCkEDdCI5aiA0OQMAAkBBACgC2IGEgAAiDyA2aisDACI0RAAAAAAAAAAAZEUNAEEAKAKEgYSAACERQQAoAoiBhIAAIQ5BACgCgIGEgAAhEkEAKAKMgYSAACEKAkACQAJAAkBBACgC3IGEgAAgDWooAgBFDQBBACASNgKEgYSAACA4IDlqIgsgEkETdiAKQQt0IApzIgpBCHZzIBJzIApzIhBBAXa4RAAAAAAAAAA+okQAAAAAAADgv6AiOiA6oCA0oiALKwMAoDkDAAwBCwNAIA4hCyARIQ4gCkELdCAKcyEQIBIiDyERIAshCiAQIA9BE3YgEEEIdnMgD3NzIhJBAXa4RAAAAAAAAAA+oiI0RAAAAAAAAAAAYQ0AC0EAIA82AoiBhIAAQQAgDjYCjIGEgABBACASNgKEgYSAAEEAIAtBC3QgC3MiDkEIdiASQRN2cyAOcyAScyIONgKAgYSAACA0EICAgIAAITQgDkEBdrhEAAAAAAAAAD6iRBgtRFT7IRlAohCBgICAACE6QQAoApSChIAAIDlqIg4gOiA0RAAAAAAAAADAop+iQQAoAtiBhIAAIg8gNmorAwCiIA4rAwCgOQMAQQAoAoiBhIAAIRFBACgCgIGEgAAhEEEAKAKMgYSAACEOQQAoAtyBhIAAIA1qKAIARQ0BC0EAIBE2AoyBhIAAQQAoAoSBhIAAIQpBACAQNgKEgYSAAEEAIAo2AoiBhIAAQQAgEEETdiAOQQt0IA5zIg5BCHZzIBBzIA5zIg42AoCBhIAAIA5BAXa4RAAAAAAAAAA+okQAAAAAAADgv6AiNCA0oCE0DAELQQAoAoSBhIAAIQsDQCARIRIgCyERIA5BC3QgDnMhDyAQIgohCyASIQ4gDyAKQRN2IA9BCHZzIApzcyIQQQF2uEQAAAAAAAAAPqIiNEQAAAAAAAAAAGENAAtBACAKNgKIgYSAAEEAIBE2AoyBhIAAQQAgEDYChIGEgABBACASQQt0IBJzIg5BCHYgEEETdnMgDnMgEHMiDjYCgIGEgAAgNBCAgICAACE0IA5BAXa4RAAAAAAAAAA+okQYLURU+yEZQKIQgYCAgAAgNEQAAAAAAAAAwKKfoiE0QQAoAtiBhIAAIQ8LQQAoApiChIAAIDlqIg4gNCAPIDZqKwMAoiAOKwMAoDkDAEEAKAKkgISAACESCyA1QQFqIjUgEkgNAAsLAkBBACgCqICEgAAiEkEBSA0AQQAoApCChIAARQ0AQQAhNQNAIDdBACgC9IGEgAAgNUEDdCI2aisDAKIiNJogNEEAKAL4gYSAACA1QQJ0Ig1qKAIAGyI0IDT8BrmhIjREAAAAAAAA8D+gIDQgNEQAAAAAAAAAAGMbQQAoAoiChIAAIA1qKAIAIg63oiI0/AIiCyAObyIQQR91IA5xIRFBACgChIKEgAAgDWooAgAhD0EAKALwgYSAACANaigCACEKAkACQEEAKAKMgoSAACANaigCAEUNAEEAKAKkgoSAACI4IApBA3RqQQAoApCChIAAIBAgD2ogEWpBBHRqIg4rAwA5AwAgDkEIaisDACE0DAELQQAoAqSChIAAIjggCkEDdGpBACgCkIKEgAAiOSARIBBqIhAgD2pBBHRqIhErAwBEAAAAAAAA8D8gNCALt6EiNEQAAAAAAADwP6AgNCA0RAAAAAAAAAAAYxsiNKEiOqIgNCA5IBBBAWogDm8gD2pBBHRqIg4rAwCioDkDACARQQhqKwMAIDqiIDQgDkEIaisDAKKgITQLQQAoAqiChIAAIApBA3QiOWogNDkDAAJAQQAoAvyBhIAAIg8gNmorAwAiNEQAAAAAAAAAAGRFDQBBACgChIGEgAAhEUEAKAKIgYSAACEOQQAoAoCBhIAAIRJBACgCjIGEgAAhCgJAAkACQAJAQQAoAoCChIAAIA1qKAIARQ0AQQAgEjYChIGEgAAgOCA5aiILIBJBE3YgCkELdCAKcyIKQQh2cyAScyAKcyIQQQF2uEQAAAAAAAAAPqJEAAAAAAAA4L+gIjogOqAgNKIgCysDAKA5AwAMAQsDQCAOIQsgESEOIApBC3QgCnMhECASIg8hESALIQogECAPQRN2IBBBCHZzIA9zcyISQQF2uEQAAAAAAAAAPqIiNEQAAAAAAAAAAGENAAtBACAPNgKIgYSAAEEAIA42AoyBhIAAQQAgEjYChIGEgABBACALQQt0IAtzIg5BCHYgEkETdnMgDnMgEnMiDjYCgIGEgAAgNBCAgICAACE0IA5BAXa4RAAAAAAAAAA+okQYLURU+yEZQKIQgYCAgAAhOkEAKAKkgoSAACA5aiIOIDogNEQAAAAAAAAAwKKfokEAKAL8gYSAACIPIDZqKwMAoiAOKwMAoDkDAEEAKAKIgYSAACERQQAoAoCBhIAAIRBBACgCjIGEgAAhDkEAKAKAgoSAACANaigCAEUNAQtBACARNgKMgYSAAEEAKAKEgYSAACEKQQAgEDYChIGEgABBACAKNgKIgYSAAEEAIBBBE3YgDkELdCAOcyIOQQh2cyAQcyAOcyIONgKAgYSAACAOQQF2uEQAAAAAAAAAPqJEAAAAAAAA4L+gIjQgNKAhNAwBC0EAKAKEgYSAACELA0AgESESIAshESAOQQt0IA5zIQ8gECIKIQsgEiEOIA8gCkETdiAPQQh2cyAKc3MiEEEBdrhEAAAAAAAAAD6iIjREAAAAAAAAAABhDQALQQAgCjYCiIGEgABBACARNgKMgYSAAEEAIBA2AoSBhIAAQQAgEkELdCAScyIOQQh2IBBBE3ZzIA5zIBBzIg42AoCBhIAAIDQQgICAgAAhNCAOQQF2uEQAAAAAAAAAPqJEGC1EVPshGUCiEIGAgIAAIDREAAAAAAAAAMCin6IhNEEAKAL8gYSAACEPC0EAKAKogoSAACA5aiIOIDQgDyA2aisDAKIgDisDAKA5AwBBACgCqICEgAAhEgsgNUEBaiI1IBJIDQALCwJAQQAoAqyAhIAAIg5BAUgNACAOQQFxITVBACEPQQAoAqiChIAAIRBBACgCmIKEgAAhEUEAKAKkgoSAACESQQAoApSChIAAIQtBACgCyIGEgAAhNgJAIA5BAUYNACAOQf7///8HcSENQQAhDyA2IQ4DQCASIA4oAgBBA3QiCmogCyAKaisDADkDACAQIApqIBEgCmorAwA5AwAgEiAOQQRqKAIAQQN0IgpqIAsgCmorAwA5AwAgECAKaiARIApqKwMAOQMAIA5BCGohDiANIA9BAmoiD0cNAAsLIDVFDQAgEiA2IA9BAnRqKAIAQQN0Ig5qIAsgDmorAwA5AwAgECAOaiARIA5qKwMAOQMACwJAAkBBACgCoICEgABFDQAgN0EAKwPIgISAAEQYLURU+yEZQKKiIjQQgYCAgAAhOyA0EIKAgIAAITwCQAJAQQAoAvCAhIAAIhINACATQQFIDQFEAAAAAAAA8D8gO0QAAAAAAADgv6JEAAAAAAAA4D+gIjShITdBACgCqIKEgAAhD0EAKAKYgoSAACEOQQAoAqSChIAAIRBBACgClIKEgAAhCiATIREDQCAKIAorAwAgN6IgNCAQKwMAoqA5AwAgDiAOKwMAIDeiIDQgDysDAKKgOQMAIApBCGohCiAQQQhqIRAgDkEIaiEOIA9BCGohDyARQX9qIhENAAwCCwsgE0EBSA0AIDsgPCA8oKIhPUEAKAL0gISAACELQQArA9CAhIAAIT5BACgCqIKEgAAhD0EAKAKkgoSAACEQQQAoApiChIAAIQ5BACgClIKEgAAhCiATIREDQAJAIBArAwAiOiAKKwMAIj+hIjQgNKIgDysDACJAIA4rAwAiQaEiNyA3oqAiQkSgwuv+S0i0OWMNACBBIECgRAAAAAAAAOA/oiFBID8gOqBEAAAAAAAA4D+iIUMgNCBCnyI6oyE/IDsgOkQAAAAAAADgP6IiNJqiIUAgNyA6oyI6miFCIDwhNwJAAkACQCASQX9qDgICAAELIDQgPqIhNCA8ITcMAQsgNEQAAAAAAADgP6IhNCA9ITcLIAogNyA0IDSaIAsboiI0IEKiIEAgP6IgQ6CgOQMAIA4gNCA/oiBAIDqiIEGgoDkDAAsgCkEIaiEKIA5BCGohDiAQQQhqIRAgD0EIaiEPIBFBf2oiEQ0ACwtBACsD6ICEgAAhN0EAKwPggISAACE0AkBBACsD2ICEgAAiOkQAAAAAAAAAAGQNACA0RAAAAAAAAAAAZA0AIDdEAAAAAAAAAABkRQ0BCyA3IDsgO6IiP0QAAAAAAAAAACA7RAAAAAAAAAAAYxuiIDogP0QAAAAAAAAAACA7RAAAAAAAAAAAZBuiIDwgPCA0oqKgoCI0RAAAAAAAAAAAZEUNACATQQFIDQFBACgCmIKEgAAhCkEAKAKUgoSAACEPQQAoAoyBhIAAIRBBACgCgIGEgAAhC0EAKAKIgYSAACERQQAoAoSBhIAAIQ4gEyENA0AgDiE1IA8gCyISQRN2IBBBC3QgEHMiDkEIdnMgEnMgDnMiDkEBdrhEAAAAAAAAAD6iRAAAAAAAAOC/oCI3IDegIDSiIA8rAwCgOQMAIAogEUELdCARcyIQQQh2IA5BE3ZzIBBzIA5zIgtBAXa4RAAAAAAAAAA+okQAAAAAAADgv6AiNyA3oCA0oiAKKwMAoDkDACAPQQhqIQ8gCkEIaiEKIDUhECASIREgDUF/aiINDQALQQAgEjYCiIGEgABBACA1NgKMgYSAAEEAIA42AoSBhIAAQQAgCzYCgIGEgAALQQAoArSAhIAARQ0AIBNBAUgNAEEAIRBBACgCmIKEgAAhC0EAKAKogYSAACENQQAoApSChIAAITVBACgCpIGEgAAhNgJAIBRFDQBBACEOQQAhEANAIDUgDmoiCiA2IA5qIhErAwAgCisDAKA5AwAgCyAOaiIPIA0gDmoiEisDACAPKwMAoDkDACAKQQhqIgogEUEIaisDACAKKwMAoDkDACAPQQhqIgogEkEIaisDACAKKwMAoDkDACAOQRBqIQ4gHCAQQQJqIhBHDQALCyAbRQ0AIDUgEEEDdCIOaiIKIDYgDmorAwAgCisDAKA5AwAgCyAOaiIKIA0gDmorAwAgCisDAKA5AwALQQAoAqCChIAAITZBACgCnIKEgAAhNQJAIAhBAUgiRA0AAkACQCAgDQBBACEKDAELQQAhDkEAIQoDQCA1IA5qIg8gBiAOaiIQKwMAOQMAIDYgDmoiESAFIA5qIhIrAwA5AwAgD0EIaiAQQQhqKwMAOQMAIBFBCGogEkEIaisDADkDACAOQRBqIQ4gFyAKQQJqIgpHDQALCyAVRQ0AIDUgCkEDdCIOaiAGIA5qKwMAOQMAIDYgDmogBSAOaisDADkDAAtBACE4QQAoApiChIAAIQ9BACgClIKEgAAhEAJAIBNBAkgNAEEAITggECEOIA8hCgNAIA4rAwAiNCA0oiAKKwMAIjQgNKKgRKDC6/5LSLQ5Y0UNASAOQQhqIQ4gCkEIaiEKIBQgOEEBaiI4Rw0ACyAUITgLAkAgFCA4ayIRQQFIDQACQCARQQFHDQAgECA4QQN0Ig5qKwMAIjQgNKIgDyAOaisDACI3IDeioCI6RKDC6/5LSLQ5Yw0BIDUgECAOQQhqIg5qKwMAIj8gNKIgNyAPIA5qKwMAIkCioJogOqM5AwAgNiBAIDSiID8gN6KhmiA6ozkDAAwBCwJAIBMgOGsiDUEBSA0AIDhBA3QhDgJAIA1BA3QiCkUiEg0AIANBoDRqIBAgDmogCvwKAAALAkAgEg0AIANBgCBqIA8gDmogCvwKAAALIAMrA4AgIUUgAysDoDQhRgsCQCARQQN0Ig5FIgoNACADQYAQaiA1IA78CgAACwJAIAoNACADIDYgDvwKAAALQQAhOQNARAAAAAAAAAAAIUdBACEQA0AgAyAQQQN0Ig5qIhIrAwAhQSADQYAQaiAOaiILKwMAITREAAAAAAAAAAAhQkQAAAAAAAAAACE/IEUhPCBGIT4CQCANQQFMDQAgQZohQ0QAAAAAAAAAACE/IAkhDiArIQogESEPIEYhNyBFITpEAAAAAAAAAAAhQANAIDcgQaIhPCAKKwMAITsgDisDACE+IDogPyBBoiA0IECioKAhQiA3ID8gNKIgQCBDoqCgIT8gDkEIaiEOIApBCGohCiA+IDcgNKIgOiBDoqCgIj4hNyA7IDwgNCA6oqCgIjwhOiBCIUAgD0F/aiIPDQALCwJAID8gP6IgQiBCoqAiPUQmpqyqBLZ5M2MNAEQAAAAAAAAAACFDQQAhDiADIQogA0GAEGohD0QAAAAAAAAAACE7A0ACQCAQIA5GDQAgNCAPKwMAoSI3IDeiIEEgCisDAKEiOiA6oqAiQEQmpqyqBLZ5M2MNACBDIDogQKOhIUMgOyA3IECjoCE7CyAPQQhqIQ8gCkEIaiEKIBEgDkEBaiIORw0AC0QAAAAAAADwPyA+ID+iIEIgPKKgID2jIjcgO6IgPCA/oiA+IEKioSA9oyI6IEOioaEiPyA/oiA3IEOiIDogO6KgIkAgQKKgIkJEJqasqgS2eTNjDQAgEiBBIDogP6IgNyBAoqAgQqMiQ6E5AwAgCyA0IDcgP6IgOiBAoqEgQqMiN6E5AwAgNyA3oiBDIEOioCI0IEcgNCBHZBshRwsgEEEBaiIQIBFHDQALAkAgR0S8idiXstKcPGMNACA5QT9JIQ4gOUEBaiE5IA4NAQsLIBFBAXEhEkEAIQoCQCAdIDhGDQAgEUH+////B3EhEEEAIQ5BACEKA0ACQCADQYAQaiAOaiIPKwMAIjQgNGINACADIA5qKwMAIjcgN2INACA1IA5qIDQ5AwAgNiAOaiA3OQMACwJAIA9BCGorAwAiNCA0Yg0AIAMgDmpBCGorAwAiNyA3Yg0AIDUgDmpBCGogNDkDACA2IA5qQQhqIDc5AwALIA5BEGohDiAQIApBAmoiCkcNAAsLIBJFDQAgA0GAEGogCkEDdCIOaisDACI0IDRiDQAgAyAOaisDACI3IDdiDQAgNSAOaiA0OQMAIDYgDmogNzkDAAsCQCBEDQBEAAAAAAAAAAAhNEEAIQ4gCCEKA0ACQAJAIDUgDmorAwAiNyA3Yg0AIDYgDmorAwAiNyA3YQ0BCyA0RBgtRFT7IRlAoiAwo0SuR+F6FK7XP6AiNxCBgICAACE6QQAoApyChIAAIA5qIDo5AwAgNxCCgICAACE3QQAoAqCChIAAIjYgDmogNzkDAEEAKAKcgoSAACE1CyAOQQhqIQ4gNEQAAAAAAADwP6AhNCAKQX9qIgoNAAsLAkACQAJAAkACQAJAAkACQEEAKAKYgISAAA4EAAIEAQILIEQNBiAgDQJBACEKDAULAkAgMyAAa0EDcQ0AIEQNAEEAITkCQCAIRQ0AIANBgBBqQQAgCPwLAAsDQCAFIDlBA3QiDWohEiAGIA1qIQtEnHUAiDzkN34hNEEAIQ4gNSEKIDYhD0EAIRADQAJAIANBgBBqIA5qLQAADQAgCisDACALKwMAoSI3IDeiIA8rAwAgEisDAKEiNyA3oqAiNyA0IDcgNGMiERshNCAOIBAgERshEAsgCkEIaiEKIA9BCGohDyAIIA5BAWoiDkcNAAsgA0GgNGogDWogNSAQQQN0Ig5qKwMAOQMAIDYgDmorAwAhNCADQYAQaiAQakEBOgAAIANBgCBqIA1qIDQ5AwAgOUEBaiI5IAhHDQALAkACQCAgDQBBACEKDAELQQAhDkEAIQoDQCA1IA5qIg8gA0GgNGogDmoiECsDADkDACA2IA5qIhEgA0GAIGogDmoiEisDADkDACAPQQhqIBBBCGorAwA5AwAgEUEIaiASQQhqKwMAOQMAIA5BEGohDiAXIApBAmoiCkcNAAsLIBVFDQAgNSAKQQN0Ig5qIANBoDRqIA5qKwMAOQMAIDYgDmogA0GAIGogDmorAwA5AwALIEQNBQJAIBNBAUoNAEEAIQoCQCAgQQdJDQBBACEKIANBgCBqIQ4DQCAOQpzrgcDIh/mb/gA3AwAgDkE4akKc64HAyIf5m/4ANwMAIA5BMGpCnOuBwMiH+Zv+ADcDACAOQShqQpzrgcDIh/mb/gA3AwAgDkEgakKc64HAyIf5m/4ANwMAIA5BGGpCnOuBwMiH+Zv+ADcDACAOQRBqQpzrgcDIh/mb/gA3AwAgDkEIakKc64HAyIf5m/4ANwMAIA5BwABqIQ4gGSAKQQhqIgpHDQALCyAWRQ0EIANBgCBqIApBA3RqIQ4gFiEKA0AgDkKc64HAyIf5m/4ANwMAIA5BCGohDiAKQX9qIgoNAAwFCwtBACgCsICEgAAhEUEAKALEgYSAACESQQAoApSChIAAIg5BCGohOUEAKAKYgoSAACIKQQhqITggCisDACE9IA4rAwAhRUEAIQsDQCA1IAtBA3QiDWorAwAhNCA2IA1qKwMAIkKaIUNEAAAAAAAAAAAhPyA5IQ4gOCEKIBQhDyBFITcgPSE6RAAAAAAAAAAAIUADQCA3IEKiITwgCisDACE7IA4rAwAhPiA6ID8gQqIgNCBAoqCgIUEgNyA/IDSiIEAgQ6KgoCE/IA5BCGohDiAKQQhqIQogPiA3IDSiIDogQ6KgoCE3IDsgPCA0IDqioKAhOiBBIUAgD0F/aiIPDQALRJx1AIg85Dd+ITcCQCA/ID+iIEEgQaKgIjpEJqasqgS2eTNjDQAgOp8hPwJAAkAgEUEBTg0ARAAAAAAAAAAAIToMAQsgNCA0oiBCIEKioJ8hNEQAAAAAAAAAACE6QQAhDwNAAkACQCATIBIgD0ECdGooAgAiEEF/c2oiCkEBTg0ARAAAAAAAAPA/ITcMAQsgCkEHcSEORAAAAAAAAPA/ITcCQCAdIBBrQQdJDQAgCkH4////B3EhCkQAAAAAAADwPyE3A0AgNCA0IDQgNCA0IDQgNCA0IDeioqKioqKioiE3IApBeGoiCg0ACwsgDkUNAANAIDQgN6IhNyAOQX9qIg4NAAsLIDogN6AhOiAPQQFqIg8gEUcNAAsLIDogP6MhNwsgA0GAIGogDWogNzkDACALQQFqIgsgCEYNBAwACwsCQAJAAkACQAJAQQAoApyAhIAAQX9qDgIBAAILAkAgMQ0AQQAhOQJAIAhFDQAgA0GAEGpBACAI/AsACwNAIAUgOUEDdCINaiESIAYgDWohC0ScdQCIPOQ3fiE0QQAhDiA1IQogNiEPQQAhEANAAkAgA0GAEGogDmotAAANACAKKwMAIAsrAwChIjcgN6IgDysDACASKwMAoSI3IDeioCI3IDQgNyA0YyIRGyE0IA4gECARGyEQCyAKQQhqIQogD0EIaiEPIAggDkEBaiIORw0ACyADQaA0aiANaiA1IBBBA3QiDmorAwA5AwAgNiAOaisDACE0IANBgBBqIBBqQQE6AAAgA0GAIGogDWogNDkDACA5QQFqIjkgCEcNAAsCQAJAICANAEEAIQoMAQtBACEOQQAhCgNAIDUgDmoiDyADQaA0aiAOaiIQKwMAOQMAIDYgDmoiESADQYAgaiAOaiISKwMAOQMAIA9BCGogEEEIaisDADkDACARQQhqIBJBCGorAwA5AwAgDkEQaiEOIBcgCkECaiIKRw0ACwsgFUUNBCA1IApBA3QiDmogA0GgNGogDmorAwA5AwAgNiAOaiADQYAgaiAOaisDADkDAAwECwJAIEQNAEEAIREgA0GgNGohEgNAIAUgEUEDdCIOaisDACE0IAYgDmorAwAhN0EAIRACQCAgRQ0AQQAhECASIQ4gNiEKIDUhDwNAIA4gDysDACA3oSI6IDqiIAorAwAgNKEiOiA6oqA5AwAgDkEIaiAPQQhqKwMAIDehIjogOqIgCkEIaisDACA0oSI6IDqioDkDACAOQRBqIQ4gCkEQaiEKIA9BEGohDyAXIBBBAmoiEEcNAAsLAkAgFUUNACADQaA0aiAQIBEgCGxqQQN0aiA1IBBBA3QiDmorAwAgN6EiNyA3oiA2IA5qKwMAIDShIjQgNKKgOQMACyASICRqIRIgEUEBaiIRIAhHDQALCyAIQQBIDQMCQCAlRSIODQAgA0GAIGpBACAl/AsACwJAIA4NACADQYAQakEAICX8CwALAkAgI0UNACADQZAzakEAICP8CwALIAhFDQNBASE5A0AgAyA5NgKQM0EAIQoCQCAMRQ0AIANBgDBqQQAgDPwLAAsCQCAIQQdJDQBBACEKIAMhDgNAIA5CgJC7utat8NXDADcDACAOQThqQoCQu7rWrfDVwwA3AwAgDkEwakKAkLu61q3w1cMANwMAIA5BKGpCgJC7utat8NXDADcDACAOQSBqQoCQu7rWrfDVwwA3AwAgDkEYakKAkLu61q3w1cMANwMAIA5BEGpCgJC7utat8NXDADcDACAOQQhqQoCQu7rWrfDVwwA3AwAgDkHAAGohDiAeIApBCGoiCkcNAAsLAkAgH0UNACADIApBA3RqIQ4gHyEKA0AgDkKAkLu61q3w1cMANwMAIA5BCGohDiAKQX9qIgoNAAsLQQAhDSA5IQ4DQCADQYAwaiANakEBOgAAIANBgCBqIA5BA3RqIRJBfyERIANBoDRqICQgDkF/amxqIQtEAMhOZ23Bq0MhNEEIIQpBACEPICghEANAIA9BAWohDgJAIANBgDBqIA9qQQFqLQAADQACQCALIApqQXhqKwMAIBIrAwChIANBgBBqIApqKwMAoSI6IAMgCmoiDysDACI3Y0UNACAQIA02AgAgDyA6OQMAIDohNwsgNyA0IDcgNGMiDxshNCAOIBEgDxshEQsgCkEIaiEKIBBBBGohECAOIQ8gCCAORw0AC0EAIQ4gA0GQM2ohD0EAIQoDQAJAAkAgA0GAMGogCmotAAANACADIRAMAQsgA0GAIGogDygCAEEDdGoiECA0IBArAwCgOQMAIANBgBBqIRALIBAgDmoiECAQKwMAIDShOQMAIA9BBGohDyAOQQhqIQ4gDCAKQQFqIgpHDQALIBEhDSADQZAzaiARQQJ0aigCACIODQALA0AgA0GQM2ogEUECdCIOaiADQZAzaiADQYAyaiAOaigCACIRQQJ0aigCADYCACARDQALIDkgCEYhDiA5QQFqITkgDg0DDAALCyBEDQJBACE5AkAgCEUNACADQYAQakEAIAj8CwALA0AgBSA5QQN0Ig1qIRIgBiANaiELRJx1AIg85Dd+ITRBACEOIDUhCiA2IQ9BACEQA0ACQCADQYAQaiAOai0AAA0AIAorAwAgCysDAKEiNyA3oiAPKwMAIBIrAwChIjcgN6KgIjcgNCA3IDRjIhEbITQgDiAQIBEbIRALIApBCGohCiAPQQhqIQ8gCCAOQQFqIg5HDQALIANBoDRqIA1qIDUgEEEDdCIOaisDADkDACA2IA5qKwMAITQgA0GAEGogEGpBAToAACADQYAgaiANaiA0OQMAIDlBAWoiOSAIRw0ACwJAAkAgIA0AQQAhCgwBC0EAIQ5BACEKA0AgNSAOaiIPIANBoDRqIA5qIhArAwA5AwAgNiAOaiIRIANBgCBqIA5qIhIrAwA5AwAgD0EIaiAQQQhqKwMAOQMAIBFBCGogEkEIaisDADkDACAOQRBqIQ4gFyAKQQJqIgpHDQALCyAVRQ0CIDUgCkEDdCIOaiADQaA0aiAOaisDADkDACA2IA5qIANBgCBqIA5qKwMAOQMADAILIDMgAGtBA3ENASBEDQFBACE5AkAgCEUNACADQYAQakEAIAj8CwALA0AgBSA5QQN0Ig1qIRIgBiANaiELRJx1AIg85Dd+ITRBACEOIDUhCiA2IQ9BACEQA0ACQCADQYAQaiAOai0AAA0AIAorAwAgCysDAKEiNyA3oiAPKwMAIBIrAwChIjcgN6KgIjcgNCA3IDRjIhEbITQgDiAQIBEbIRALIApBCGohCiAPQQhqIQ8gCCAOQQFqIg5HDQALIANBoDRqIA1qIDUgEEEDdCIOaisDADkDACA2IA5qKwMAITQgA0GAEGogEGpBAToAACADQYAgaiANaiA0OQMAIDlBAWoiOSAIRw0ACwJAAkAgIA0AQQAhCgwBC0EAIQ5BACEKA0AgNSAOaiIPIANBoDRqIA5qIhArAwA5AwAgNiAOaiIRIANBgCBqIA5qIhIrAwA5AwAgD0EIaiAQQQhqKwMAOQMAIBFBCGogEkEIaisDADkDACAOQRBqIQ4gFyAKQQJqIgpHDQALCyAVRQ0BIDUgCkEDdCIOaiADQaA0aiAOaisDADkDACA2IA5qIANBgCBqIA5qKwMAOQMADAELAkACQCAgDQBBASEODAELQQAhDiAnIQpBACEPA0AgAyAKQXxqKAIAQQN0QXhqIhBqIDUgDmoiESsDADkDACADQYAwaiAQaiA2IA5qIhArAwA5AwAgAyAKKAIAQQN0QXhqIhJqIBFBCGorAwA5AwAgA0GAMGogEmogEEEIaisDADkDACAKQQhqIQogDkEQaiEOIBcgD0ECaiIPRw0ACyAPQQFqIQ4LAkAgFUUNACADIANBkDNqIA5BAnRqKAIAQQN0QXhqIgpqIDUgDkEDdEF4aiIOaisDADkDACADQYAwaiAKaiA2IA5qKwMAOQMACyBEDQACQAJAICANAEEAIQoMAQtBACEOQQAhCgNAIDUgDmoiDyADIA5qIhArAwA5AwAgNiAOaiIRIANBgDBqIA5qIhIrAwA5AwAgD0EIaiAQQQhqKwMAOQMAIBFBCGogEkEIaisDADkDACAOQRBqIQ4gFyAKQQJqIgpHDQALCyAVRQ0AIDUgCkEDdCIOaiADIA5qKwMAOQMAIDYgDmogA0GAMGogDmorAwA5AwALIEQNBAJAAkAgIA0AQQAhCgwBC0EAIQ5BACEKA0AgBiAOaiIPIDUgDmoiECsDADkDACAFIA5qIhEgNiAOaiISKwMAOQMAIA9BCGogEEEIaisDADkDACARQQhqIBJBCGorAwA5AwAgDkEQaiEOIBcgCkECaiIKRw0ACwsCQCAVRQ0AIAYgCkEDdCIOaiA1IA5qKwMAOQMAIAUgDmogNiAOaisDADkDAAtBACgCwIKEgAAhNUEAKAKggYSAACEPQQAoAryChIAAITZBACgCnIGEgAAhEEEAKAK4goSAACE5QQAoApiBhIAAIRFBACgCtIKEgAAhOCAGIQ4gBSEKIAghEgNAAkAgDisDACAHo0QAAAAAAADwP6BEAAAAAAAA4D+iIC+i/AIiC0EASA0AIC4gC0wNAEQAAAAAAADwPyAKKwMAIAejoUQAAAAAAADgP6IgLaL8AiINQQBIDQAgLCANTA0AIDggBEECdGogLiANbCALajYCACA5IARqIBEtAAA6AAAgNiAEaiAQLQAAOgAAIDUgBGogDy0AADoAACAEQQFqIQQLIA5BCGohDiAKQQhqIQogEUEBaiERIBBBAWohECAPQQFqIQ8gEkF/aiISRQ0FDAALC0EAIQ5BACEKA0AgBiAOaiIPIDUgDmoiECsDADkDACAFIA5qIhEgNiAOaiISKwMAOQMAIA9BCGogEEEIaisDADkDACARQQhqIBJBCGorAwA5AwAgDkEQaiEOIBcgCkECaiIKRw0ADAMLCwJAAkAgRA0AQQAhEANAIDYgEEEDdCILaiERIDUgC2ohEkScdQCIPOQ3fiE0IDUhCiA2IQ9BACEOA0ACQCAQIA5GDQAgEisDACAKKwMAoSI3IDeiIBErAwAgDysDAKEiNyA3oqAiNyA0IDcgNGMbITQLIApBCGohCiAPQQhqIQ8gCCAOQQFqIg5HDQALIANBoDRqIAtqIDSfOQMAIBBBAWoiECAIRw0AC0EAIQoCQCAgQQNJDQBBACEKIANBoDRqIQ4DQCAOQRhqKwMAIjQgDkEQaisDACI3IA5BCGorAwAiOiAOKwMAIj8gMiA/IDJkGyI/IDogP2QbIjogNyA6ZBsiNyA0IDdkGyEyIA5BIGohDiAaIApBBGoiCkcNAAsLAkAgGEUNACADQaA0aiAKQQN0aiEOIBghCgNAIA4rAwAiNCAyIDQgMmQbITIgDkEIaiEOIApBf2oiCg0ACwsCQCAgDQBBACEKDAILQQAhDkEAIQoDQCAGIA5qIg8gNSAOaiIQKwMAOQMAIAUgDmoiESA2IA5qIhIrAwA5AwAgD0EIaiAQQQhqKwMAOQMAIBFBCGogEkEIaisDADkDACAOQRBqIQ4gFyAKQQJqIgpHDQAMAgsLIDJEK4cW2c737z+iITIMAwsCQCAVRQ0AIAYgCkEDdCIOaiA1IA5qKwMAOQMAIAUgDmogNiAOaisDADkDAAsgMkQrhxbZzvfvP6IhMkEAKALAgoSAACENQQAoArSBhIAAITVBACgCvIKEgAAhNkEAKAKwgYSAACE5QQAoAriChIAAIThBACgCrIGEgAAhREEAKAK0goSAACFIIANBoDRqIQ8gBiEOIAUhCiAIIRADQAJAIA4rAwAgB6NEAAAAAAAA8D+gRAAAAAAAAOA/oiAvovwCIhFBAEgNACAuIBFMDQBEAAAAAAAA8D8gCisDACAHo6FEAAAAAAAA4D+iIC2i/AIiEkEASA0AICwgEkwNAEEPIQsCQCAyRAAAAAAAAAAAZEUNAEQAAAAAAADwP0QAAAAAAADwPyAPKwMAIDKjIjQgNEQAAAAAAADwP2QboUQAAAAAAAAuQKL8AiELCyBIIARBAnRqIC4gEmwgEWo2AgAgOCAEaiBEIAtBDyALQQ9IGyIRai0AADoAACA2IARqIDkgEWotAAA6AAAgDSAEaiA1IBFqLQAAOgAAIARBAWohBAsgDkEIaiEOIApBCGohCiAPQQhqIQ8gEEF/aiIQRQ0DDAALC0EAIQpEnHUAiDzkN/4hNAJAICBBA0kNACADQYAgaiEOA0AgDkEYaisDACI3IA5BEGorAwAiOiAOQQhqKwMAIj8gDisDACJAIDQgQCA0ZBsgNCBARJx1AIg85Dd+YxsiNCA/IDRkGyA0ID9EnHUAiDzkN35jGyI0IDogNGQbIDQgOkScdQCIPOQ3fmMbIjQgNyA0ZBsgNCA3RJx1AIg85Dd+YxshNCAOQSBqIQ4gGiAKQQRqIgpHDQALCwJAIBhFDQAgA0GAIGogCkEDdGohDiAYIQoDQCAOKwMAIjcgNCA3IDRkGyA0IDdEnHUAiDzkN35jGyE0IA5BCGohDiAKQX9qIgoNAAsLAkACQCA0RJx1AIg85Df+ZUUNAEEAIQoCQCAgQQdJDQBBACEKIANBgBBqIQ4DQCAOQoCAgICAgIDwPzcDACAOQThqQoCAgICAgIDwPzcDACAOQTBqQoCAgICAgIDwPzcDACAOQShqQoCAgICAgIDwPzcDACAOQSBqQoCAgICAgIDwPzcDACAOQRhqQoCAgICAgIDwPzcDACAOQRBqQoCAgICAgIDwPzcDACAOQQhqQoCAgICAgIDwPzcDACAOQcAAaiEOIBkgCkEIaiIKRw0ACwsgFkUNASADQYAQaiAKQQN0aiEOIBYhCgNAIA5CgICAgICAgPA/NwMAIA5BCGohDiAKQX9qIgoNAAwCCwtBACEOAkAgIEUNACADQYAgaiEKIANBoDRqIQ8gAyEQA0AgECAONgIAIBBBBGogDkEBajYCACAPIAorAwAiNyA0IDdEnHUAiDzkN35jGzkDACAPQQhqIApBCGorAwAiNyA0IDdEnHUAiDzkN35jGzkDACAQQQhqIRAgD0EQaiEPIApBEGohCiAOQQJqIg4gF0cNAAsLAkAgFUUNACADIA5BAnRqIA42AgAgA0GgNGogDkEDdCIOaiADQYAgaiAOaisDACI3IDQgN0ScdQCIPOQ3fmMbOQMACwJAAkACQAJAIAhBAUYNAEEBIREgAyESQQAhCwNAIAMgEUECdGooAgAhDSADQaA0aiARQQN0aisDACE3IAshCiASIQ4gESEPAkADQCADQaA0aiAKaiIQKwMAIjQgN2RFDQEgDkEEaiAOKAIANgIAIBBBCGogNDkDACAKQXhqIQogDkF8aiEOIA9Bf2oiD0EBakEBSg0AC0EAIQ8LIAMgD0ECdGogDTYCACADQaA0aiAPQQN0aiA3OQMAIAtBCGohCyASQQRqIRIgEUEBaiIRIAhHDQALIANBgBBqIAMoAgBBA3RqQgA3AwAgAysDoDQhNEEAIRBBASEOIAhBAkcNAQwCCyADQYAQaiADKAIAQQN0akIANwMADAILICkhCiAqIQ8DQCADQYAQaiAPQXxqKAIAQQN0aiAOIBAgCkF4aisDACI3IDRiGyIQuDkDACADQYAQaiAPKAIAQQN0aiAOQQFqIhEgECA3IAorAwAiNGIbIhC4OQMAIA5BAmohDiAKQRBqIQogD0EIaiEPIBEgIUcNAAsLAkAgIkUNACADQYAQaiADIA5BAnRqKAIAQQN0aiAOIBAgA0GgNGogDkEDdGorAwAgNGIbuDkDAAsgIEUNAEEAIQoCQCAgRQ0AIANBgBBqIQ4DQCAOIA4rAwAgJqM5AwAgDkEIaiIPIA8rAwAgJqM5AwAgDkEQaiEOIBcgCkECaiIKRw0ACwsgFUUNASADQYAQaiAKQQN0aiIOIA4rAwAgJqM5AwAMAQtBACEKAkAgIEEHSQ0AQQAhCiADQYAQaiEOA0AgDkKAgICAgICA8D83AwAgDkE4akKAgICAgICA8D83AwAgDkEwakKAgICAgICA8D83AwAgDkEoakKAgICAgICA8D83AwAgDkEgakKAgICAgICA8D83AwAgDkEYakKAgICAgICA8D83AwAgDkEQakKAgICAgICA8D83AwAgDkEIakKAgICAgICA8D83AwAgDkHAAGohDiAZIApBCGoiCkcNAAsLIBZFDQAgA0GAEGogCkEDdGohDiAWIQoDQCAOQoCAgICAgIDwPzcDACAOQQhqIQ4gCkF/aiIKDQALCwJAAkAgIA0AQQAhCgwBC0EAIQ5BACEKA0AgBiAOaiIPIDUgDmoiECsDADkDACAFIA5qIhEgNiAOaiISKwMAOQMAIA9BCGogEEEIaisDADkDACARQQhqIBJBCGorAwA5AwAgDkEQaiEOIBcgCkECaiIKRw0ACwsCQCAVRQ0AIAYgCkEDdCIOaiA1IA5qKwMAOQMAIAUgDmogNiAOaisDADkDAAtBACgCwIKEgAAhC0EAKALAgYSAACENQQAoAryChIAAITVBACgCvIGEgAAhNkEAKAK4goSAACE5QQAoAriBhIAAIThBACgCtIKEgAAhRCADQYAQaiEPIAYhDiAFIQogCCEQA0ACQCAOKwMAIAejRAAAAAAAAPA/oEQAAAAAAADgP6IgL6L8AiIRQQBIDQAgLiARTA0ARAAAAAAAAPA/IAorAwAgB6OhRAAAAAAAAOA/oiAtovwCIhJBAEgNACAsIBJMDQAgRCAEQQJ0aiAuIBJsIBFqNgIAIDkgBGogOCAPKwMARAAAAAAAAC5AokQAAAAAAADgP6D8AiIRQQ8gEUEPSBsiEWotAAA6AAAgNSAEaiA2IBFqLQAAOgAAIAsgBGogDSARai0AADoAACAEQQFqIQQLIA5BCGohDiAKQQhqIQogD0EIaiEPIBBBf2oiEA0ADAILCwJAIBVFDQAgBiAKQQN0Ig5qIDUgDmorAwA5AwAgBSAOaiA2IA5qKwMAOQMAC0EAKALAgoSAACESQQAoAryChIAAIQtBACgCuIKEgAAhDUEAKAK0goSAACE1QQAoAoCAhIAAIg4oAjQhNiAOKAI4ITkgDigCPCE4IAYhDiAFIQogCCEPA0ACQCAOKwMAIAejRAAAAAAAAPA/oEQAAAAAAADgP6IgL6L8AiIQQQBIDQAgLiAQTA0ARAAAAAAAAPA/IAorAwAgB6OhRAAAAAAAAOA/oiAtovwCIhFBAEgNACAsIBFMDQAgNSAEQQJ0aiAuIBFsIBBqNgIAIA0gBGogNjoAACALIARqIDk6AAAgEiAEaiA4OgAAIARBAWohBAsgDkEIaiEOIApBCGohCiAPQX9qIg8NAAsLAkAgMyAAayIOQdAPbw0AIA4Qg4CAgAALIDNBAWoiMyABRw0ACwsgA0Gg9ABqJICAgIAAIAQLAH8EbmFtZQAPDnN0ZXBfbG9vcC53YXNtAVMHAAZqc19sb2cBBmpzX2NvcwIGanNfc2luAxFqc19yZXBvcnRQcm9ncmVzcwQSX193YXNtX2luaXRfbWVtb3J5BQRpbml0BgtydW5TdGVwTG9vcAcSAQAPX19zdGFja19wb2ludGVyAC8JcHJvZHVjZXJzAQxwcm9jZXNzZWQtYnkBDkhvbWVicmV3IGNsYW5nBjIxLjEuOACUAQ90YXJnZXRfZmVhdHVyZXMIKwtidWxrLW1lbW9yeSsPYnVsay1tZW1vcnktb3B0KxZjYWxsLWluZGlyZWN0LW92ZXJsb25nKwptdWx0aXZhbHVlKw9tdXRhYmxlLWdsb2JhbHMrE25vbnRyYXBwaW5nLWZwdG9pbnQrD3JlZmVyZW5jZS10eXBlcysIc2lnbi1leHQ=";
// WASM_SOLVER_B64 removed â€” solver-only WASM tier eliminated
// Multi-worker state
let numWorkers = Math.min(navigator.hardwareConcurrency || 4, 16);
let fastModeWorkers = [];           // Array of Worker instances
let fastModeWorkersComplete = 0;    // Count of workers that reported "done" for current pass
let fastModeWorkerPixels = [];      // Collected pixel buffers from workers
let fastModeWorkerRoots = null;     // Root positions from the last-range worker
let fastModeWorkerProgress = [];    // Per-worker step counts for progress aggregation
let fastModePassStartTime = 0;      // performance.now() when current pass started
let fastModeCompositeBreakdown = null; // Timing breakdown of compositeWorkerPixels phases
let fastModeCycleStartTime = 0;     // performance.now() when current cycle started
let fastModeTimingHistory = [];     // Array of {passMs, stepsPerSec, workers, steps}
// Stats tab state
let activeTab = "roots";
const STAT_TYPES = ["Force", "MinForce", "MaxForce", "Speed", "MinSpeed", "MaxSpeed", "MinDist", "MaxDist", "Records", "MeanDist", "\u0394MeanDist", "AngularMom", "\u03c3Speed", "EMASpeed", "\u03c3Dist", "Odometer", "CycleCount", "MedianR", "Spread", "EMed", "EHi", "Coherence", "Encounters"];
const STAT_COLORS = { Force: "#e94560", MinForce: "#f7a1b5", MaxForce: "#c0392b", Speed: "#5b6abf", MinSpeed: "#7eb8da", MaxSpeed: "#ff7b54", MinDist: "#2ecc71", MaxDist: "#f39c12", Records: "#ff6b9d", MeanDist: "#4ecdc4", "\u0394MeanDist": "#a8e6cf", AngularMom: "#e0aaff", "\u03c3Speed": "#48bfe3", EMASpeed: "#64dfdf", "\u03c3Dist": "#f4a261", Odometer: "#d4a373", CycleCount: "#80ed99", MedianR: "#f0a6ca", Spread: "#b8c0ff", EMed: "#a7c957", EHi: "#f77f00", Coherence: "#7209b7", Encounters: "#ff85a1" };
// Phase-space (XY) plot definitions: { label, xStat, yStat, color }
const PHASE_PLOTS = [
    { label: "Force v Speed", xStat: "Force", yStat: "Speed", color: "#c77dff" },
    { label: "MinDist v MaxDist", xStat: "MinDist", yStat: "MaxDist", color: "#ffd166" },
    { label: "MinSpeed v MaxSpeed", xStat: "MinSpeed", yStat: "MaxSpeed", color: "#72efdd" },
    { label: "MeanDist v \u03c3Dist", xStat: "MeanDist", yStat: "\u03c3Dist", color: "#f4845f" },
    { label: "MaxForce v MaxSpeed", xStat: "MaxForce", yStat: "MaxSpeed", color: "#e76f51" }
];
// Spectrum plots: special bar-chart visualizations (not time-series)
const SPECTRUM_PLOTS = [
    { label: "SpeedSpectrum" },
    { label: "OdometerSpectrum" },
    { label: "WindingSpectrum" },
    { label: "TortuositySpectrum" }
];
// Total dropdown options: time-series, then phase-space, then spectrum
const PLOT_OPTIONS = [...STAT_TYPES, ...PHASE_PLOTS.map(p => p.label), ...SPECTRUM_PLOTS.map(p => p.label)];
let pairRecords = null; // Float64Array(n*(n-1)/2): per-pair closest distance records for Records stat
const statsState = {
    buffers: {},        // { statName: Float64Array ring buffer }
    frameCount: 0,
    writeIdx: 0,
    maxFrames: 4000,
    prevRoots: null,    // for Speed computation
    prevMeanDist: null, // for Î”MeanDist computation
    emaSpeed: 0,        // exponential moving average of Speed
    rootSpeeds: null,   // Float64Array: cached per-root speeds (displacement per tick)
    rootForces: null,   // Float64Array: cached per-root force (sensitivity) for MinForce/MaxForce
    spectrumPeaks: null, // Float64Array: all-time max per-root speed for SpeedSpectrum dots
    rootOdometers: null, // Float64Array: cumulative per-root distance traveled
    odometerCycleLengths: null, // Float64Array: snapshot of odometers at loop completion (cycle arc lengths)
    odometerStartRoots: null, // [{re,im}]: per-root start positions for cycle detection
    odometerFrameCounts: null, // Int32Array: per-root frame count since last reset
    odometerMaxDisps: null, // Float64Array: per-root max displacement from start
    odometerCycleCount: 0, // cumulative number of cycle detections triggered
    rootWindings: null,    // Float64Array: cumulative winding angle per root (in turns, signed)
    rootTortuosityOdo: null, // Float64Array: per-root path length for tortuosity (resets on cycle)
    rootTortuosityNetDx: null, // Float64Array: per-root cumulative signed dx for tortuosity
    rootTortuosityNetDy: null, // Float64Array: per-root cumulative signed dy for tortuosity
    // Sonification feature smoothing (one-pole EMA, same Î± as audio)
    smoothMedianR: 0,
    smoothSpread: 0,
    smoothEMed: 0,
    smoothEHi: 0,
    smoothCoherence: 0,
    smoothEncounters: 0,
    // Per-root encounter records for Encounters stat (mirrors audio close encounters)
    statsEncounters: null,    // Float64Array(n * 3): per-root top-3 closest distances
    plotConfigs: [0, 3, 6, 8, 17, 18, 19, 20, 21, 22, 11, 9, 28, 29, 30, 31], // index into PLOT_OPTIONS for each of the 16 plots
    canvases: [],       // 4 canvas elements
    ctxs: [],           // 4 canvas 2D contexts
    dirty: true
};
// Audio sonification state
let baseEnabled = false;
let melodyEnabled = false;
let voiceEnabled = false;
function anySoundEnabled() { return baseEnabled || melodyEnabled || voiceEnabled; }
let audioCtx = null;
let audioNodes = null;
let prevRootsAudio = null;
let prevAnglesAudio = null; // per-root angles from centroid (for angular momentum)
let lastBeepTime = 0;
let lastAudioUpdateTime = 0;
let audioWatchdogId = null;
let closeEncounters = null;  // Float64Array(n * TOP_K): per-root closest distances seen
let encounterAge = null;     // Float64Array(n * TOP_K): frames since each record was set
let arpPhase = 0;
let arpSmoothVel = 0;
const AUDIO_ALPHA = 0.1;
const ARP_SCALE = [0, 2, 4, 7, 9]; // pentatonic
const ENCOUNTER_TOP_K = 3;         // track top 3 records per root (non-tunable)

// Tunable config objects (sliders modify these in real time)
const baseConfig = {
    freq: 85, octaves: 1.8,
    modRatio: 2.0, modDepth: 300,
    filterLo: 250, filterHi: 3500,
    gainFloor: 0.03, gainRange: 0.22,
    vibDepth: 10, vibRate: 6.0,
};
const ROUTE_SOURCES = ["â€”",
    "MedianR", "Spread", "EMed", "EHi", "Coherence",
    "Speed", "MinSpeed", "MaxSpeed", "ÏƒSpeed", "EMASpeed",
    "MeanDist", "MinDist", "MaxDist", "ÏƒDist", "Î”MeanDist",
    "AngularMom", "Force", "MinForce", "MaxForce",
    "Records", "Encounters", "Odometer", "CycleCount",
    "Const0", "Const1"];
const NORM_MODES = ["fixed", "runmax"];
const RUNMAX_DECAY = 0.9995;
const BIPOLAR_SRC = new Set(["AngularMom"]);
const baseRoutes = [
    { source: "MedianR",   alpha: 0.10, norm: "runmax", target: "Carrier pitch",  smoothed: 0, runMax: 0.001 },
    { source: "EHi",       alpha: 0.10, norm: "runmax", target: "FM mod depth",   smoothed: 0, runMax: 0.001 },
    { source: "Spread",    alpha: 0.10, norm: "runmax", target: "Filter cutoff",  smoothed: 0, runMax: 0.001 },
    { source: "EHi",       alpha: 0.10, norm: "runmax", target: "Gain",           smoothed: 0, runMax: 0.001 },
    { source: "Coherence", alpha: 0.10, norm: "runmax", target: "Vibrato depth",  smoothed: 0, runMax: 0.001 },
    { source: "EMed",      alpha: 0.10, norm: "runmax", target: "Vibrato rate",   smoothed: 0, runMax: 0.001 },
];
const voiceRoutes = [
    { source: "â€”",  alpha: 0.10, norm: "runmax", target: "Pitch bias",  smoothed: 0.5, runMax: 0.001 },
    { source: "â€”",  alpha: 0.10, norm: "runmax", target: "Volume",      smoothed: 0.5, runMax: 0.001 },
    { source: "â€”",  alpha: 0.10, norm: "runmax", target: "Ringdown",    smoothed: 0.5, runMax: 0.001 },
    { source: "â€”",  alpha: 0.10, norm: "runmax", target: "Cooldown",    smoothed: 0.5, runMax: 0.001 },
];
const melodyRoutes = [
    { source: "â€”",  alpha: 0.10, norm: "runmax", target: "Rate",        smoothed: 0.5, runMax: 0.001 },
    { source: "â€”",  alpha: 0.10, norm: "runmax", target: "Brightness",  smoothed: 0.5, runMax: 0.001 },
    { source: "â€”",  alpha: 0.10, norm: "runmax", target: "Volume",      smoothed: 0.5, runMax: 0.001 },
    { source: "â€”",  alpha: 0.10, norm: "runmax", target: "Decay",       smoothed: 0.5, runMax: 0.001 },
];
const melodyConfig = {
    rate: 5, peak: 0.12, cutoff: 5,
    attack: 0.004, decay: 0.064,
    filterLo: 1200, filterHi: 3800,
};
const voiceConfig = {
    decay: 1.001, novelty: 0.85, cooldown: 0.01,
    peak: 0.12, attack: 0.005, ringdown: 0.08,
};

function audioClamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
function frac01(x) { x = x % 1; return x < 0 ? x + 1 : x; }
function quantizeToScale(semi) {
    const oct = Math.floor(semi / 12);
    const inOct = semi - 12 * oct;
    let best = ARP_SCALE[0], bestD = 1e9;
    for (const s of ARP_SCALE) {
        const d = Math.abs(inOct - s);
        if (d < bestD) { bestD = d; best = s; }
    }
    return 12 * oct + best;
}
function midiToHz(m) { return 440 * Math.pow(2, (m - 69) / 12); }
function percentileSorted(sorted, q) {
    const n = sorted.length;
    if (n === 0) return 0;
    const idx = (n - 1) * q;
    const lo = Math.floor(idx), hi = Math.ceil(idx);
    return sorted[lo] * (1 - (idx - lo)) + sorted[hi] * (idx - lo);
}

// --- Audio config popover helpers ---
let activeAudioBtn = null;
let audioDragMove = null;
let audioDragUp = null;

function buildAudioSlider(parent, label, min, max, value, logScale, fmt, onChange) {
    const row = document.createElement("div");
    row.className = "audio-row";
    const lbl = document.createElement("span");
    lbl.className = "row-label"; lbl.textContent = label;
    const slider = document.createElement("div");
    slider.className = "hslider";
    const thumb = document.createElement("div");
    thumb.className = "hslider-thumb";
    slider.appendChild(thumb);
    const val = document.createElement("span");
    val.className = "row-val";

    function valToU(v) {
        if (logScale) return (Math.log(v) - Math.log(min)) / (Math.log(max) - Math.log(min));
        return (v - min) / (max - min);
    }
    function uToVal(u) {
        if (logScale) return Math.exp(Math.log(min) + u * (Math.log(max) - Math.log(min)));
        return min + u * (max - min);
    }

    let u = Math.max(0, Math.min(1, valToU(value)));
    function update() {
        thumb.style.left = (u * 100) + "%";
        const v = uToVal(u);
        val.textContent = fmt(v);
        onChange(v);
    }
    function setFromX(clientX) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        update();
    }
    let dragging = false;
    slider.addEventListener("mousedown", e => { dragging = true; setFromX(e.clientX); e.preventDefault(); });
    const moveFn = e => { if (dragging) setFromX(e.clientX); };
    const upFn = () => { dragging = false; };
    slider.addEventListener("mousemove", moveFn);
    window.addEventListener("mousemove", moveFn);
    window.addEventListener("mouseup", upFn);

    update();
    row.appendChild(lbl);
    row.appendChild(slider);
    row.appendChild(val);
    parent.appendChild(row);
    return { row, setU: newU => { u = newU; update(); } };
}

function buildAudioToggle(parent, label, isOn, onChange) {
    const row = document.createElement("div");
    row.className = "audio-toggle" + (isOn ? " on" : "");
    const dot = document.createElement("span");
    dot.className = "toggle-dot";
    const lbl = document.createElement("span");
    lbl.className = "toggle-label"; lbl.textContent = label;
    row.appendChild(dot);
    row.appendChild(lbl);
    row.addEventListener("click", () => {
        const nowOn = !row.classList.contains("on");
        row.classList.toggle("on", nowOn);
        onChange(nowOn);
    });
    parent.appendChild(row);
    return row;
}

// Lightweight UI feedback sounds â€” independent of the sonification audio graph
let _uiSoundActive = false; // prevents global click from doubling with specific ping/buzz
function uiPing(freq = 880, dur = 0.08) {
    _uiSoundActive = true;
    try {
        const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        if (!audioCtx) audioCtx = ctx;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "sine";
        o.frequency.value = freq;
        g.gain.setValueAtTime(0.12, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
        o.connect(g);
        g.connect(ctx.destination);
        o.start();
        o.stop(ctx.currentTime + dur + 0.01);
    } catch (e) { /* audio not available */ }
}
// "Unhappy" buzz â€” short descending tone for "nothing to do"
function uiBuzz() {
    _uiSoundActive = true;
    try {
        const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        if (!audioCtx) audioCtx = ctx;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "sawtooth";
        o.frequency.setValueAtTime(340, ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(160, ctx.currentTime + 0.15);
        g.gain.setValueAtTime(0.07, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
        o.connect(g);
        g.connect(ctx.destination);
        o.start();
        o.stop(ctx.currentTime + 0.16);
    } catch (e) { /* audio not available */ }
}
// Subtle click â€” global fallback for buttons without specific ping/buzz
function uiClick() {
    try {
        const ctx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        if (!audioCtx) audioCtx = ctx;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "sine";
        o.frequency.value = 1600;
        g.gain.setValueAtTime(0.06, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.025);
        o.connect(g);
        g.connect(ctx.destination);
        o.start();
        o.stop(ctx.currentTime + 0.035);
    } catch (e) { /* audio not available */ }
}
// Global button click audio â€” plays uiClick for any button unless handler already played ping/buzz
document.addEventListener("click", function(e) {
    const btn = e.target.closest("button, .swatch, .cpick-label, .chip");
    if (!btn) return;
    // Let the handler run first (sync), then check if it already made a sound
    requestAnimationFrame(function() {
        if (_uiSoundActive) { _uiSoundActive = false; return; }
        uiClick();
    });
}, true);

function initAudio() {
    if (audioNodes) return;
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0;
    masterGain.connect(audioCtx.destination);
    // Tap audio graph for recording (MediaStreamDestination)
    const mediaDest = audioCtx.createMediaStreamDestination();
    masterGain.connect(mediaDest);
    // FM synthesis: carrier (osc1) + modulator (osc2) â†’ modGain â†’ carrier.frequency
    const osc1 = audioCtx.createOscillator();   // carrier
    osc1.type = "sine";
    osc1.frequency.value = 110;
    const osc2 = audioCtx.createOscillator();   // FM modulator
    osc2.type = "sine";
    osc2.frequency.value = 220;
    const modGain = audioCtx.createGain();       // FM depth (Hz)
    modGain.gain.value = 0;
    osc2.connect(modGain);
    modGain.connect(osc1.frequency);
    const filter = audioCtx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 800;
    filter.Q.value = 2;
    const gainNode = audioCtx.createGain();
    gainNode.gain.value = 0.06;
    const lfo = audioCtx.createOscillator();
    lfo.type = "sine";
    lfo.frequency.value = 5;
    const lfoGain = audioCtx.createGain();
    lfoGain.gain.value = 0;
    lfo.connect(lfoGain);
    lfoGain.connect(osc1.frequency);
    const beepOsc = audioCtx.createOscillator();
    beepOsc.type = "sine";
    beepOsc.frequency.value = 800;
    const beepGain = audioCtx.createGain();
    beepGain.gain.value = 0;
    osc1.connect(gainNode);  // carrier â†’ gain â†’ filter (osc2 routes to osc1.frequency via modGain)
    gainNode.connect(filter);
    filter.connect(masterGain);
    beepOsc.connect(beepGain);
    beepGain.connect(masterGain);
    // Arpeggiator oscillator
    const arpOsc = audioCtx.createOscillator();
    arpOsc.type = "triangle";
    arpOsc.frequency.value = 440;
    const arpGain = audioCtx.createGain();
    arpGain.gain.value = 0;
    const arpFilter = audioCtx.createBiquadFilter();
    arpFilter.type = "lowpass";
    arpFilter.frequency.value = 2500;
    arpFilter.Q.value = 0.7;
    arpOsc.connect(arpGain);
    arpGain.connect(arpFilter);
    arpFilter.connect(masterGain);
    osc1.start();
    osc2.start();
    lfo.start();
    beepOsc.start();
    arpOsc.start();
    audioNodes = { osc1, osc2, modGain, lfo, lfoGain, filter, gainNode, masterGain, beepOsc, beepGain, arpOsc, arpGain, arpFilter, mediaDest };
}

function updateAudio() {
    if (!anySoundEnabled() || !audioCtx || !audioNodes) return;
    const n = currentRoots.length;
    if (n === 0) return;
    const range = panels.roots.range;
    const now = audioCtx.currentTime;
    audioNodes.masterGain.gain.setTargetAtTime(1, now, 0.05);

    // --- Centroid ---
    let cx = 0, cy = 0;
    for (const r of currentRoots) { cx += r.re; cy += r.im; }
    cx /= n; cy /= n;

    // --- Dual energy: E_med (stability) and E_hi (excitement) ---
    let eMed = 0, eHi = 0, meanSpeed = 0, maxSpeed = 0;
    if (prevRootsAudio && prevRootsAudio.length === n) {
        const v = new Array(n);
        for (let i = 0; i < n; i++) {
            v[i] = Math.hypot(
                currentRoots[i].re - prevRootsAudio[i].re,
                currentRoots[i].im - prevRootsAudio[i].im
            );
        }
        v.sort((a, b) => a - b);
        eMed = percentileSorted(v, 0.50);
        eHi  = percentileSorted(v, 0.85);
        maxSpeed = v[n - 1];
        for (let i = 0; i < n; i++) meanSpeed += v[i];
        meanSpeed /= n;
    }

    // --- Radius distribution around centroid ---
    const radii = new Array(n);
    const angles = new Array(n);
    for (let i = 0; i < n; i++) {
        const dx = currentRoots[i].re - cx, dy = currentRoots[i].im - cy;
        radii[i] = Math.hypot(dx, dy);
        angles[i] = Math.atan2(dy, dx);
    }
    radii.sort((a, b) => a - b);
    const r50 = percentileSorted(radii, 0.50);
    const r10 = percentileSorted(radii, 0.10);
    const r90 = percentileSorted(radii, 0.90);
    const spread = r90 - r10;

    // --- Angular coherence R in [0,1] ---
    let au = 0, av = 0;
    for (let i = 0; i < n; i++) { au += Math.cos(angles[i]); av += Math.sin(angles[i]); }
    au /= n; av /= n;
    const coherence = Math.hypot(au, av); // 1 = clustered, 0 = uniform ring

    // --- Pairwise distances: MeanDist & ÏƒDist ---
    let pairSum = 0, pairSqSum = 0, pairCount = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const d = Math.hypot(currentRoots[i].re - currentRoots[j].re,
                                 currentRoots[i].im - currentRoots[j].im);
            pairSum += d; pairSqSum += d * d; pairCount++;
        }
    }
    const meanPairDist = pairCount > 0 ? pairSum / pairCount : 0;
    const sigmaPairDist = pairCount > 0 ? Math.sqrt(Math.max(0, pairSqSum / pairCount - meanPairDist * meanPairDist)) : 0;

    // --- Angular momentum: signed rotational velocity ---
    let angMomRaw = 0;
    if (prevAnglesAudio && prevAnglesAudio.length === n) {
        for (let i = 0; i < n; i++) {
            let dth = angles[i] - prevAnglesAudio[i];
            if (dth > Math.PI) dth -= 2 * Math.PI;
            if (dth < -Math.PI) dth += 2 * Math.PI;
            angMomRaw += dth;
        }
        angMomRaw /= n;
    }
    prevAnglesAudio = angles.slice();

    // --- Raw normalized features (unsmoothed) ---
    const eNormMed = audioClamp(eMed / (range * 0.05), 0, 1);
    const eNormHi  = audioClamp(eHi  / (range * 0.05), 0, 1);
    const speedRef = range * 0.05;

    // Read latest stats buffer value (collectStatsSnapshot runs before updateAudio)
    const _si = statsState.frameCount > 0 ? (statsState.writeIdx - 1 + statsState.maxFrames) % statsState.maxFrames : 0;
    const _hs = statsState.frameCount > 0;
    const sv = name => _hs ? (statsState.buffers[name]?.[_si] ?? 0) : 0;

    const rawF = {
        MedianR:    audioClamp(r50 / range, 0, 1),
        Spread:     audioClamp(spread / range, 0, 1),
        EMed:       eNormMed,
        EHi:        eNormHi,
        Coherence:  coherence,
        Speed:      audioClamp(meanSpeed / speedRef, 0, 1),
        MinSpeed:   audioClamp(sv("MinSpeed") / speedRef, 0, 1),
        MaxSpeed:   audioClamp(maxSpeed / speedRef, 0, 1),
        "ÏƒSpeed":   audioClamp(sv("\u03c3Speed") / speedRef, 0, 1),
        EMASpeed:   audioClamp(sv("EMASpeed") / (speedRef * Math.max(n, 1)), 0, 1),
        MeanDist:   audioClamp(meanPairDist / range, 0, 1),
        MinDist:    audioClamp(sv("MinDist") / range, 0, 1),
        MaxDist:    audioClamp(sv("MaxDist") / (range * 2), 0, 1),
        "ÏƒDist":    audioClamp(sigmaPairDist / range, 0, 1),
        "Î”MeanDist": audioClamp(sv("\u0394MeanDist") / (range * 0.02), 0, 1),
        AngularMom: audioClamp(angMomRaw / 0.15 * 0.5 + 0.5, 0, 1),
        Force:      audioClamp(sv("Force") / Math.max(n, 1), 0, 1),
        MinForce:   audioClamp(sv("MinForce") * 5, 0, 1),
        MaxForce:   audioClamp(sv("MaxForce"), 0, 1),
        Records:    audioClamp(sv("Records") / 3, 0, 1),
        Encounters: audioClamp(sv("Encounters") / 3, 0, 1),
        Odometer:   audioClamp(sv("Odometer") / (range * Math.max(n, 1) * 100), 0, 1),
        CycleCount: audioClamp(sv("CycleCount") / (Math.max(n, 1) * 5), 0, 1),
        Const0: 0,
        Const1: 1,
    };
    const rawUnorm = {
        MedianR: r50, Spread: spread, EMed: eMed, EHi: eHi,
        Coherence: coherence, Speed: meanSpeed, MaxSpeed: maxSpeed,
        MeanDist: meanPairDist, "ÏƒDist": sigmaPairDist, AngularMom: angMomRaw,
        MinSpeed: sv("MinSpeed"), "ÏƒSpeed": sv("\u03c3Speed"), EMASpeed: sv("EMASpeed"),
        MinDist: sv("MinDist"), MaxDist: sv("MaxDist"), "Î”MeanDist": sv("\u0394MeanDist"),
        Force: sv("Force"), MinForce: sv("MinForce"), MaxForce: sv("MaxForce"),
        Records: sv("Records"), Encounters: sv("Encounters"),
        Odometer: sv("Odometer"), CycleCount: sv("CycleCount"),
        Const0: 0, Const1: 1,
    };

    // --- Per-route EMA smoothing (base + voice + melody) with normalization ---
    for (const route of baseRoutes.concat(voiceRoutes, melodyRoutes)) {
        if (route.source === "â€”") continue;
        let raw;
        if (route.norm === "runmax") {
            const rv = rawUnorm[route.source] ?? 0;
            route.runMax = Math.max(route.runMax * RUNMAX_DECAY, Math.abs(rv));
            if (BIPOLAR_SRC.has(route.source)) {
                raw = route.runMax > 1e-12 ? audioClamp(rv / route.runMax * 0.5 + 0.5, 0, 1) : 0.5;
            } else {
                raw = route.runMax > 1e-12 ? audioClamp(rv / route.runMax, 0, 1) : 0;
            }
        } else {
            raw = rawF[route.source] ?? 0;
        }
        route.smoothed += route.alpha * (raw - route.smoothed);
    }

    // --- Base (FM drone): all 6 params driven by routed + smoothed features ---
    if (baseEnabled) {
        const pitch = baseConfig.freq * Math.pow(2, (baseRoutes[0].smoothed - 0.5) * baseConfig.octaves);
        audioNodes.osc1.frequency.setTargetAtTime(pitch, now, 0.05);
        audioNodes.osc2.frequency.setTargetAtTime(pitch * baseConfig.modRatio, now, 0.05);
        audioNodes.modGain.gain.setTargetAtTime(baseConfig.modDepth * baseRoutes[1].smoothed, now, 0.05);
        const cutoff = baseConfig.filterLo + baseConfig.filterHi * baseRoutes[2].smoothed;
        audioNodes.filter.frequency.setTargetAtTime(audioClamp(cutoff, 150, 8000), now, 0.05);
        audioNodes.gainNode.gain.setTargetAtTime(baseConfig.gainFloor + baseConfig.gainRange * baseRoutes[3].smoothed, now, 0.05);
        audioNodes.lfoGain.gain.setTargetAtTime(2 + baseConfig.vibDepth * baseRoutes[4].smoothed, now, 0.05);
        audioNodes.lfo.frequency.setTargetAtTime(1.5 + baseConfig.vibRate * baseRoutes[5].smoothed, now, 0.05);
    } else {
        audioNodes.gainNode.gain.setTargetAtTime(0, now, 0.05);
        audioNodes.lfoGain.gain.setTargetAtTime(0, now, 0.05);
        audioNodes.modGain.gain.setTargetAtTime(0, now, 0.05);
    }

    // --- Voice (beeps): close encounters per-root record tracking ---
    if (voiceEnabled) {
        let seeding = false;
        if (!closeEncounters || closeEncounters.length !== n * ENCOUNTER_TOP_K) {
            closeEncounters = new Float64Array(n * ENCOUNTER_TOP_K).fill(Infinity);
            encounterAge = new Float64Array(n * ENCOUNTER_TOP_K).fill(0);
            seeding = true;
        }

        let bestImprovement = 0;
        let bestRoot = -1;

        for (let i = 0; i < n; i++) {
            const closest = [Infinity, Infinity, Infinity];
            for (let j = 0; j < n; j++) {
                if (j === i) continue;
                const d = Math.hypot(currentRoots[i].re - currentRoots[j].re,
                                     currentRoots[i].im - currentRoots[j].im);
                if (d < closest[2]) {
                    closest[2] = d;
                    if (closest[2] < closest[1]) { const t = closest[1]; closest[1] = closest[2]; closest[2] = t; }
                    if (closest[1] < closest[0]) { const t = closest[0]; closest[0] = closest[1]; closest[1] = t; }
                }
            }

            const base = i * ENCOUNTER_TOP_K;
            if (seeding) {
                for (let k = 0; k < ENCOUNTER_TOP_K; k++) {
                    closeEncounters[base + k] = closest[k];
                    encounterAge[base + k] = 0;
                }
            } else {
                for (let k = 0; k < ENCOUNTER_TOP_K; k++) {
                    const worstIdx = base + ENCOUNTER_TOP_K - 1;
                    if (closest[k] < closeEncounters[worstIdx]) {
                        const improvement = closeEncounters[worstIdx] - closest[k];
                        closeEncounters[worstIdx] = closest[k] * voiceConfig.novelty;
                        encounterAge[worstIdx] = 0;
                        for (let a = ENCOUNTER_TOP_K - 1; a > 0; a--) {
                            if (closeEncounters[base + a] < closeEncounters[base + a - 1]) {
                                const td = closeEncounters[base + a]; closeEncounters[base + a] = closeEncounters[base + a - 1]; closeEncounters[base + a - 1] = td;
                                const ta = encounterAge[base + a]; encounterAge[base + a] = encounterAge[base + a - 1]; encounterAge[base + a - 1] = ta;
                            }
                        }
                        if (improvement > bestImprovement) {
                            bestImprovement = improvement;
                            bestRoot = i;
                        }
                    }
                }
            }
        }

        if (bestRoot >= 0 && now - lastBeepTime > voiceConfig.cooldown * voiceRoutes[3].smoothed * 2) {
            lastBeepTime = now;
            const midi = 60 + ARP_SCALE[bestRoot % 5] + 12 * Math.floor(bestRoot / 5);
            const pitchBias = (voiceRoutes[0].smoothed - 0.5) * 24;
            const freq = midiToHz(Math.min(Math.max(midi + pitchBias, 36), 108));
            const improvNorm = audioClamp(bestImprovement / (range * 0.05), 0, 1);
            const volScale = voiceRoutes[1].smoothed * 2;
            const peak = audioClamp((0.05 + voiceConfig.peak * improvNorm) * volScale, 0.0001, 0.5);
            const ringdown = Math.max(0.01, voiceConfig.ringdown * voiceRoutes[2].smoothed * 2);

            audioNodes.beepOsc.frequency.setTargetAtTime(freq, now, 0.01);
            audioNodes.beepGain.gain.cancelScheduledValues(now);
            audioNodes.beepGain.gain.setValueAtTime(0.0001, now);
            audioNodes.beepGain.gain.exponentialRampToValueAtTime(peak, now + voiceConfig.attack);
            audioNodes.beepGain.gain.exponentialRampToValueAtTime(0.0001, now + voiceConfig.attack + ringdown);
        }

        if (!seeding) {
            for (let k = 0; k < closeEncounters.length; k++) {
                closeEncounters[k] *= voiceConfig.decay;
                encounterAge[k]++;
            }
        }
    }

    // --- Melody (arpeggiator): one note per step, cycling through top-N fastest roots ---
    if (melodyEnabled && audioNodes.arpOsc && audioNodes.arpGain) {
        const tNow = performance.now();
        const dt = lastAudioUpdateTime ? Math.max(0.001, Math.min((tNow - lastAudioUpdateTime) / 1000, 0.05)) : 1 / 60;

        // Build per-root velocity array and sort indices by speed (descending)
        const vels = new Array(n);
        for (let i = 0; i < n; i++) {
            if (prevRootsAudio && prevRootsAudio.length === n) {
                vels[i] = Math.hypot(currentRoots[i].re - prevRootsAudio[i].re,
                                     currentRoots[i].im - prevRootsAudio[i].im);
            } else {
                vels[i] = 0;
            }
        }
        const indices = Array.from({ length: n }, (_, i) => i);
        indices.sort((a, b) => vels[b] - vels[a]);

        // cutoff: top N fastest roots to arpeggio (clamped to [2, n])
        const N = Math.min(Math.max(Math.round(melodyConfig.cutoff), 2), n);

        const prevArpStep = Math.floor(arpPhase);
        arpPhase += melodyConfig.rate * melodyRoutes[0].smoothed * 2 * dt;
        const rank = Math.floor(arpPhase) % N;
        const rootIdx = indices[rank];
        const rk = currentRoots[rootIdx];

        // angle â†’ scale degree (pentatonic)
        const theta = Math.atan2(rk.im - cy, rk.re - cx);
        const u = frac01((theta + Math.PI) / (2 * Math.PI));
        const degree = Math.floor(u * 12);
        const qSemi = quantizeToScale(degree);

        // radius â†’ octave (0â€“2, 3 octaves)
        const rad = Math.hypot(rk.re - cx, rk.im - cy);
        const radNorm = audioClamp(rad / (range * 1.2), 0, 1);
        const octave = Math.floor(radNorm * 3);

        const baseMidi = 48; // C3
        const hz = midiToHz(baseMidi + qSemi + 12 * octave);

        // velocity of this root â†’ filter brightness
        const velNorm = audioClamp(vels[rootIdx] / (range * 0.03), 0, 1);
        arpSmoothVel = arpSmoothVel * 0.85 + velNorm * 0.15;

        audioNodes.arpOsc.frequency.setTargetAtTime(hz, now, 0.01);
        audioNodes.arpFilter.frequency.setTargetAtTime((melodyConfig.filterLo + melodyConfig.filterHi * arpSmoothVel) * melodyRoutes[1].smoothed * 2, now, 0.02);

        // pluck envelope on new step â€” volume scales with rank (fastest = loudest)
        const curArpStep = Math.floor(arpPhase);
        if (curArpStep !== prevArpStep) {
            const rankScale = 1 - rank / N;  // 1.0 for rank 0 (fastest), ~0 for rank N-1
            const melVolScale = melodyRoutes[2].smoothed * 2;
            const peak = (0.02 + melodyConfig.peak * arpSmoothVel) * rankScale * melVolScale;
            const g = audioNodes.arpGain.gain;
            g.cancelScheduledValues(now);
            g.setValueAtTime(0.0001, now);
            const melDecay = Math.max(0.005, melodyConfig.decay * melodyRoutes[3].smoothed * 2);
            g.exponentialRampToValueAtTime(Math.max(peak, 0.0001), now + melodyConfig.attack);
            g.exponentialRampToValueAtTime(0.0001, now + melodyConfig.attack + melDecay);
        }
    }
    // Save state for next frame
    prevRootsAudio = currentRoots.map(r => ({ re: r.re, im: r.im }));
    lastAudioUpdateTime = performance.now();
}

function audioWatchdog() {
    if (!anySoundEnabled() || !audioNodes || !audioCtx) return;
    if (performance.now() - lastAudioUpdateTime > 150) {
        audioNodes.masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.15);
    }
}

function resetAudioState() {
    prevRootsAudio = null;
    closeEncounters = null;
    encounterAge = null;
    arpPhase = 0;
    arpSmoothVel = 0;
    for (const route of baseRoutes) { route.smoothed = 0; route.runMax = 0.001; }
    for (const route of voiceRoutes) { route.smoothed = 0.5; route.runMax = 0.001; }
    for (const route of melodyRoutes) { route.smoothed = 0.5; route.runMax = 0.001; }
    prevAnglesAudio = null;
    if (audioNodes && audioCtx) {
        audioNodes.masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.08);
    }
}

// --- Compute range needed to fit data ---

function computeRange(points) {
    // points: array of {re, im} or [re, im]
    let maxAbs = MIN_RANGE;
    for (const p of points) {
        const re = Array.isArray(p) ? p[0] : p.re;
        const im = Array.isArray(p) ? p[1] : p.im;
        if (isFinite(re)) maxAbs = Math.max(maxAbs, Math.abs(re));
        if (isFinite(im)) maxAbs = Math.max(maxAbs, Math.abs(im));
    }
    // Round up to a nice number and add padding; cap to prevent Infinity
    const raw = maxAbs * RANGE_PAD * 2;
    return isFinite(raw) ? Math.ceil(raw) / 2 : 1e6;
}

// --- SVG setup / grid redraw ---

function drawGrid(svgSel, p) {
    const xs = p.xScale, ys = p.yScale, range = p.range;

    // Clear old grid elements
    if (p.gridG) p.gridG.remove();
    if (p.axisG) p.axisG.remove();
    if (p.labelRe) p.labelRe.remove();
    if (p.labelIm) p.labelIm.remove();
    if (p.unitCircle) p.unitCircle.remove();

    if (!isFinite(range) || range <= 0) return; // bail on bad range

    // Grid lines â€” pick a 1-2-5 step that keeps â‰¤ ~20 lines per axis
    p.gridG = svgSel.insert("g", ":first-child").attr("class", "grid");
    let step = 1;
    if (isFinite(range) && range > 0) {
        const raw = range / 10;
        const mag = Math.pow(10, Math.floor(Math.log10(raw)));
        const norm = raw / mag;
        step = (norm <= 1 ? 1 : norm <= 2 ? 2 : norm <= 5 ? 5 : 10) * mag;
    }
    const gridMax = Math.floor(range / step) * step;
    for (let v = -gridMax; v <= gridMax; v += step) {
        p.gridG.append("line")
            .attr("x1", xs(v)).attr("y1", ys(-range))
            .attr("x2", xs(v)).attr("y2", ys(range));
        p.gridG.append("line")
            .attr("x1", xs(-range)).attr("y1", ys(v))
            .attr("x2", xs(range)).attr("y2", ys(v));
    }

    // Axes
    p.axisG = svgSel.insert("g", ":first-child").attr("class", "axis");
    p.axisG.append("line")
        .attr("x1", xs(-range)).attr("y1", ys(0))
        .attr("x2", xs(range)).attr("y2", ys(0));
    p.axisG.append("line")
        .attr("x1", xs(0)).attr("y1", ys(-range))
        .attr("x2", xs(0)).attr("y2", ys(range));

    // Axis labels
    p.labelRe = svgSel.append("text").attr("x", S - MARGIN + 4).attr("y", ys(0) + 4)
        .attr("fill", "#556").attr("font-size", 11).text("Re");
    p.labelIm = svgSel.append("text").attr("x", xs(0) + 6).attr("y", MARGIN - 4)
        .attr("fill", "#556").attr("font-size", 11).text("Im");

    // Unit circle
    const r = Math.abs(xs(1) - xs(0));
    p.unitCircle = svgSel.append("circle").attr("class", "unit-circle")
        .attr("cx", xs(0)).attr("cy", ys(0)).attr("r", r);
}

function setupPanel(svgSel, p) {
    svgSel.attr("width", S).attr("height", S).attr("viewBox", `0 0 ${S} ${S}`);
    drawGrid(svgSel, p);
}

function updatePanelRange(svgSel, p, newRange) {
    if (Math.abs(p.range - newRange) < 0.01) return; // no change
    p.range = newRange;
    initPanelScales(p);
    drawGrid(svgSel, p);
}

const coeffSvg = d3.select("#coeff-panel");
const rootsSvg = d3.select("#roots-panel");
setupPanel(coeffSvg, panels.coeff);
setupPanel(rootsSvg, panels.roots);

let coeffTrailLayer = coeffSvg.append("g").attr("class", "trail-layer");
let coeffLayer = coeffSvg.append("g");
let coeffChainLine = coeffLayer.append("polyline")
    .attr("class", "coeff-chain")
    .attr("fill", "none")
    .attr("stroke", "rgba(255,255,255,0.35)")
    .attr("stroke-width", 1.5)
    .attr("stroke-dasharray", "4,3")
    .style("display", "none");
let trailLayer = rootsSvg.append("g").attr("class", "trail-layer");
let rootsLayer = rootsSvg.append("g");

// Morph panel (lazy-initialized on first Morph tab switch)
let morphSvg = null;
let morphGhostLayer = null;
let morphInterpLayer = null;
let morphLayer = null;
let morphPanelInited = false;

function initMorphPanel() {
    morphSvg = d3.select("#morph-panel");
    setupPanel(morphSvg, panels.coeff);
    morphGhostLayer = morphSvg.append("g");
    morphInterpLayer = morphSvg.append("g");
    morphLayer = morphSvg.append("g");
    morphPanelInited = true;
}

// Right-click on empty canvas space â†’ add new coefficient
coeffSvg.on("contextmenu", function(event) {
    if (event.target.classList && event.target.classList.contains("coeff")) return;
    event.preventDefault();
    const [mx, my] = d3.pointer(event);
    const re = cxs().invert(mx);
    const im = cys().invert(my);
    addCoefficientAt(re, im, event);
});

// --- Tooltip ---

const tooltip = document.getElementById("tooltip");

function showTooltip(event, re, im) {
    const sign = im >= 0 ? "+" : "âˆ’";
    const absIm = Math.abs(im);
    tooltip.textContent = `${re.toFixed(3)} ${sign} ${absIm.toFixed(3)}i`;
    tooltip.style.display = "block";
    tooltip.style.left = (event.pageX + 12) + "px";
    tooltip.style.top = (event.pageY - 12) + "px";
}

function hideTooltip() {
    tooltip.style.display = "none";
}

// --- Coefficient color ---

function coeffColor(i, n) {
    return d3.interpolateRainbow(i / n);
}

function rootColor(i, n) {
    if (rootColorMode === "rainbow") return d3.interpolateRainbow(i / n);
    if (rootColorMode === "proximity") return d3.interpolateRainbow(i / n); // fallback for SVG (bitmap does real proximity)
    if (rootColorMode === "derivative" && rootSensitivities && i < rootSensitivities.length) {
        return sensitivityColor(rootSensitivities[i]);
    }
    if (rootColorMode === "uniform") {
        return `rgb(${uniformRootColor[0]},${uniformRootColor[1]},${uniformRootColor[2]})`;
    }
    return "#e94560";
}

function rootColorRGB(i, n) {
    const css = rootColor(i, n);
    // Handle hex format (#rrggbb)
    if (css[0] === "#") {
        const hex = css.length === 4
            ? css[1]+css[1]+css[2]+css[2]+css[3]+css[3]
            : css.slice(1);
        return [parseInt(hex.slice(0,2),16), parseInt(hex.slice(2,4),16), parseInt(hex.slice(4,6),16)];
    }
    // Handle rgb() format from d3
    const m = css.match(/(\d+)/g);
    if (m && m.length >= 3) return [+m[0], +m[1], +m[2]];
    return [233, 69, 96];
}

function sensitivityColor(normVal) {
    if (normVal <= 0.5) {
        const t = normVal * 2;
        const r = Math.round(t * 255);
        const g = Math.round(t * 255);
        return `rgb(${r},${g},255)`;
    } else {
        const t = (normVal - 0.5) * 2;
        const g = Math.round((1 - t) * 255);
        const b = Math.round((1 - t) * 255);
        return `rgb(255,${g},${b})`;
    }
}

// Rank-based normalization: sort values, assign integer ranks (ties get same rank),
// map linearly to [0,1]. 0=blue, 0.5=white, 1=red in sensitivityColor.
function rankNormalize(raw) {
    const n = raw.length;
    if (n === 0) return null;
    // Build (value, index) pairs, replacing non-finite with largest finite
    let maxFinite = -Infinity;
    for (let i = 0; i < n; i++) if (isFinite(raw[i]) && raw[i] > maxFinite) maxFinite = raw[i];
    if (maxFinite === -Infinity) return null;
    const pairs = [];
    for (let i = 0; i < n; i++) pairs.push({ v: isFinite(raw[i]) ? raw[i] : maxFinite, i });
    pairs.sort((a, b) => a.v - b.v);
    // Assign integer ranks; ties get the same rank
    const result = new Float64Array(n);
    let rank = 0;
    for (let p = 0; p < n; p++) {
        if (p > 0 && pairs[p].v !== pairs[p - 1].v) rank = p;
        result[pairs[p].i] = rank;
    }
    const maxRank = n - 1;
    if (maxRank === 0) { result.fill(0.5); return result; }
    for (let i = 0; i < n; i++) result[i] /= maxRank;
    return result;
}

function computeCoeffSensitivities() {
    const nRoots = currentRoots.length;
    const nCoeffs = coefficients.length;
    const deg = nCoeffs - 1;
    if (nRoots === 0) return null;

    const cRe = new Float64Array(nCoeffs);
    const cIm = new Float64Array(nCoeffs);
    for (let i = 0; i < nCoeffs; i++) { cRe[i] = coefficients[i].re; cIm[i] = coefficients[i].im; }

    // Precompute 1/|p'(rj)| and |rj| for each root
    const invDpMag = new Float64Array(nRoots);
    const rMag = new Float64Array(nRoots);
    for (let j = 0; j < nRoots; j++) {
        const zRe = currentRoots[j].re, zIm = currentRoots[j].im;
        rMag[j] = Math.hypot(zRe, zIm);
        let pRe = cRe[0], pIm = cIm[0], dpRe = 0, dpIm = 0;
        for (let k = 1; k <= deg; k++) {
            const ndRe = dpRe * zRe - dpIm * zIm + pRe;
            const ndIm = dpRe * zIm + dpIm * zRe + pIm;
            dpRe = ndRe; dpIm = ndIm;
            const npRe = pRe * zRe - pIm * zIm + cRe[k];
            const npIm = pRe * zIm + pIm * zRe + cIm[k];
            pRe = npRe; pIm = npIm;
        }
        const dm = Math.hypot(dpRe, dpIm);
        invDpMag[j] = dm < 1e-30 ? 0 : 1 / dm;
    }

    // For each coefficient k: sensitivity_k = Î£â±¼ |râ±¼^(deg-k)| / |p'(râ±¼)|
    const raw = new Float64Array(nCoeffs);
    for (let k = 0; k < nCoeffs; k++) {
        const power = deg - k;
        let sum = 0;
        for (let j = 0; j < nRoots; j++) {
            sum += Math.pow(rMag[j], power) * invDpMag[j];
        }
        raw[k] = sum;
    }

    return rankNormalize(raw);
}

function computeRootSensitivities() {
    const n = currentRoots.length;
    const deg = coefficients.length - 1;
    if (n === 0 || selectedCoeffs.size === 0) { rootSensitivities = null; return; }

    // Build coefficient arrays for Horner evaluation of p'(z)
    const cRe = new Float64Array(coefficients.length);
    const cIm = new Float64Array(coefficients.length);
    for (let i = 0; i < coefficients.length; i++) {
        cRe[i] = coefficients[i].re;
        cIm[i] = coefficients[i].im;
    }

    const raw = new Float64Array(n);
    for (let j = 0; j < n; j++) {
        const zRe = currentRoots[j].re, zIm = currentRoots[j].im;
        // Horner: simultaneous p(z) and p'(z)
        let pRe = cRe[0], pIm = cIm[0];
        let dpRe = 0, dpIm = 0;
        for (let k = 1; k <= deg; k++) {
            const ndRe = dpRe * zRe - dpIm * zIm + pRe;
            const ndIm = dpRe * zIm + dpIm * zRe + pIm;
            dpRe = ndRe; dpIm = ndIm;
            const npRe = pRe * zRe - pIm * zIm + cRe[k];
            const npIm = pRe * zIm + pIm * zRe + cIm[k];
            pRe = npRe; pIm = npIm;
        }
        const dpMag = Math.hypot(dpRe, dpIm);
        if (dpMag < 1e-30) { raw[j] = Infinity; continue; }

        // Sum |rj^(deg-k)| for each selected coefficient k
        const rMag = Math.hypot(zRe, zIm);
        let sum = 0;
        for (const k of selectedCoeffs) {
            sum += Math.pow(rMag, deg - k);
        }
        raw[j] = sum / dpMag;
    }

    rootSensitivities = rankNormalize(raw);
}

// --- Init coefficients with pattern ---

function getPattern() { return document.getElementById("pattern").value; }
function getSpread() { return 1.0; }

function initCoefficients(degree) {
    const n = degree + 1;
    const spread = getSpread();
    const pattern = getPattern();
    coefficients = [];

    if (pattern === "circle") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            coefficients.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
    } else if (pattern === "real") {
        for (let i = 0; i < n; i++) {
            const t = n === 1 ? 0 : -spread + (2 * spread * i) / (n - 1);
            coefficients.push({ re: t, im: 0 });
        }
    } else if (pattern === "imag") {
        for (let i = 0; i < n; i++) {
            const t = n === 1 ? 0 : -spread + (2 * spread * i) / (n - 1);
            coefficients.push({ re: 0, im: t });
        }
    } else if (pattern === "grid") {
        const cols = Math.ceil(Math.sqrt(n));
        const rows = Math.ceil(n / cols);
        for (let i = 0; i < n; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            const re = cols === 1 ? 0 : -spread + (2 * spread * col) / (cols - 1);
            const im = rows === 1 ? 0 : -spread + (2 * spread * row) / (rows - 1);
            coefficients.push({ re, im });
        }
    } else if (pattern === "random") {
        for (let i = 0; i < n; i++) {
            coefficients.push({
                re: (Math.random() * 2 - 1) * spread,
                im: (Math.random() * 2 - 1) * spread
            });
        }
    } else if (pattern === "spiral") {
        // Archimedean spiral â€” roots trace beautiful curves when perturbed
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const r = spread * t;
            const angle = 4 * Math.PI * t;
            coefficients.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "star") {
        // Alternating inner/outer radii â€” gives spiky root patterns
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            const r = (i % 2 === 0) ? spread : spread * 0.4;
            coefficients.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "lemniscate") {
        // Figure-8 (Bernoulli lemniscate) â€” rich root sensitivity
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const cos2t = Math.cos(2 * t);
            const r = spread * Math.sqrt(Math.abs(cos2t));
            const sign = cos2t >= 0 ? 1 : -1;
            coefficients.push({ re: sign * r * Math.cos(t), im: sign * r * Math.sin(t) });
        }
    } else if (pattern === "conjugate") {
        // Conjugate pairs straddling real axis â€” roots tend to stay near real axis then bifurcate
        for (let i = 0; i < n; i++) {
            const pairIdx = Math.floor(i / 2);
            const re = n <= 2 ? 0 : -spread + (2 * spread * pairIdx) / (Math.ceil(n / 2) - 1 || 1);
            const im = (i % 2 === 0) ? spread * 0.5 : -spread * 0.5;
            coefficients.push({ re, im });
        }
    } else if (pattern === "two-clusters") {
        // Two clusters â€” see roots jump between clusters as you drag
        const half = Math.ceil(n / 2);
        for (let i = 0; i < n; i++) {
            const cluster = i < half ? -1 : 1;
            const idx = i < half ? i : i - half;
            const count = i < half ? half : n - half;
            const angle = (2 * Math.PI * idx) / Math.max(count, 1);
            const r = spread * 0.35;
            coefficients.push({
                re: cluster * spread * 0.7 + r * Math.cos(angle),
                im: r * Math.sin(angle)
            });
        }
    } else if (pattern === "geometric") {
        // Geometric decay along real axis â€” classic for ill-conditioned polynomials
        for (let i = 0; i < n; i++) {
            const val = spread * Math.pow(0.7, i);
            const sign = (i % 2 === 0) ? 1 : -1;
            coefficients.push({ re: sign * val, im: 0 });
        }
    } else if (pattern === "rose") {
        // Rose curve r = cos(kÎ¸) â€” petals create interesting symmetry breaking
        const k = 3; // 3-petal rose
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * Math.cos(k * t);
            coefficients.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "cardioid") {
        // Cardioid â€” heart-shaped curve, roots respond dramatically near the cusp
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * 0.5 * (1 + Math.cos(t));
            coefficients.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern.startsWith("r-")) {
        // Root-shape patterns: define roots, compute coefficients
        const roots = generateRootShape(pattern, degree, spread);
        const cs = rootsToCoefficients(roots);
        for (const c of cs) coefficients.push(c);
    }

    // Initialize trajectory defaults (no path assigned yet)
    for (const c of coefficients) {
        c.curve = [{ re: c.re, im: c.im }];
        c.curveIndex = 0;
        c.pathType = "none";
        c.radius = 25;
        c.speed = 1.0;
        c.angle = 0;
        c.ccw = false;
        c.extra = {};
    }
}

// --- Roots â†’ Coefficients ---
// Expand (z - râ‚€)(z - râ‚)...(z - r_{n-1}) into coefficient array
function rootsToCoefficients(roots) {
    // Start with polynomial = [1] (just the leading coefficient)
    let re = [1], im = [0];
    for (const root of roots) {
        const newRe = new Array(re.length + 1).fill(0);
        const newIm = new Array(im.length + 1).fill(0);
        for (let j = 0; j < re.length; j++) {
            // Multiply by z: shift coefficients up
            newRe[j] += re[j];
            newIm[j] += im[j];
            // Multiply by -root: (a+bi)(-c-di) = (-ac+bd) + (-ad-bc)i
            newRe[j + 1] += -re[j] * root.re + im[j] * root.im;
            newIm[j + 1] += -re[j] * root.im - im[j] * root.re;
        }
        re = newRe;
        im = newIm;
    }
    return re.map((r, i) => ({ re: r, im: im[i] }));
}

// --- Root shape generators ---
function generateRootShape(pattern, degree, spread) {
    const n = degree; // number of roots = degree
    const roots = [];

    if (pattern === "r-heart") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const x = spread * 0.8 * 16 * Math.pow(Math.sin(t), 3) / 16;
            const y = spread * 0.8 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 16;
            roots.push({ re: x, im: y });
        }
    } else if (pattern === "r-circle") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            roots.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
    } else if (pattern === "r-star") {
        for (let i = 0; i < n; i++) {
            const angle = (2 * Math.PI * i) / n;
            const r = (i % 2 === 0) ? spread : spread * 0.4;
            roots.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "r-spiral") {
        for (let i = 0; i < n; i++) {
            const t = i / (n - 1);
            const r = spread * (0.2 + 0.8 * t);
            const angle = 4 * Math.PI * t;
            roots.push({ re: r * Math.cos(angle), im: r * Math.sin(angle) });
        }
    } else if (pattern === "r-cross") {
        // + shape: half on horizontal, half on vertical
        const hCount = Math.ceil(n / 2);
        const vCount = n - hCount;
        for (let i = 0; i < hCount; i++) {
            const t = hCount === 1 ? 0 : -spread + (2 * spread * i) / (hCount - 1);
            roots.push({ re: t, im: 0 });
        }
        for (let i = 0; i < vCount; i++) {
            const t = vCount === 1 ? 0 : -spread + (2 * spread * i) / (vCount - 1);
            if (Math.abs(t) < 1e-10) continue; // skip origin (already in horizontal)
            roots.push({ re: 0, im: t });
        }
        // Fill up if we skipped the origin duplicate
        while (roots.length < n) {
            roots.push({ re: 0, im: spread * 0.1 * roots.length });
        }
    } else if (pattern === "r-diamond") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            // Diamond: |x| + |y| = spread, parametrically
            const x = spread * Math.cos(t);
            const y = spread * Math.sin(t);
            const scale = 1 / (Math.abs(Math.cos(t)) + Math.abs(Math.sin(t)));
            roots.push({ re: x * scale, im: y * scale });
        }
    } else if (pattern === "r-grid") {
        // Chessboard: only "black squares" of a grid
        const side = Math.ceil(Math.sqrt(n * 2));
        let placed = 0;
        for (let row = 0; row < side && placed < n; row++) {
            for (let col = 0; col < side && placed < n; col++) {
                if ((row + col) % 2 === 0) {
                    const re = -spread + (2 * spread * col) / (side - 1);
                    const im = -spread + (2 * spread * row) / (side - 1);
                    roots.push({ re, im });
                    placed++;
                }
            }
        }
    } else if (pattern === "r-smiley") {
        // Eyes + smile arc
        const eyeCount = Math.max(2, Math.floor(n * 0.2));
        const smileCount = n - eyeCount;
        // Left eye
        const leftEye = Math.ceil(eyeCount / 2);
        for (let i = 0; i < leftEye; i++) {
            const angle = (2 * Math.PI * i) / leftEye;
            roots.push({ re: -spread * 0.35 + spread * 0.12 * Math.cos(angle), im: spread * 0.3 + spread * 0.12 * Math.sin(angle) });
        }
        // Right eye
        const rightEye = eyeCount - leftEye;
        for (let i = 0; i < rightEye; i++) {
            const angle = (2 * Math.PI * i) / Math.max(rightEye, 1);
            roots.push({ re: spread * 0.35 + spread * 0.12 * Math.cos(angle), im: spread * 0.3 + spread * 0.12 * Math.sin(angle) });
        }
        // Smile arc (bottom half of circle)
        for (let i = 0; i < smileCount; i++) {
            const angle = Math.PI + (Math.PI * 0.8) * (i / (smileCount - 1)) - Math.PI * 0.4;
            roots.push({ re: spread * 0.6 * Math.cos(angle), im: spread * 0.6 * Math.sin(angle) - spread * 0.1 });
        }
    } else if (pattern === "r-figure8") {
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const cos2t = Math.cos(2 * t);
            const r = spread * Math.sqrt(Math.abs(cos2t));
            const sign = cos2t >= 0 ? 1 : -1;
            roots.push({ re: sign * r * Math.cos(t), im: sign * r * Math.sin(t) });
        }
    } else if (pattern === "r-butterfly") {
        // Butterfly curve (polar)
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * 0.4 * (Math.exp(Math.cos(t)) - 2 * Math.cos(4 * t) + Math.pow(Math.sin(t / 12), 5));
            roots.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "r-trefoil") {
        // 3-leaf clover
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const r = spread * Math.cos(3 * t);
            roots.push({ re: r * Math.cos(t), im: r * Math.sin(t) });
        }
    } else if (pattern === "r-polygon") {
        // Regular polygon outline (not just vertices)
        const sides = Math.min(Math.max(3, Math.floor(degree / 2)), 8);
        const vertices = [];
        for (let s = 0; s < sides; s++) {
            const angle = (2 * Math.PI * s) / sides - Math.PI / 2;
            vertices.push({ re: spread * Math.cos(angle), im: spread * Math.sin(angle) });
        }
        // Distribute roots along edges
        for (let i = 0; i < n; i++) {
            const t = (i / n) * sides;
            const edgeIdx = Math.floor(t) % sides;
            const frac = t - Math.floor(t);
            const v1 = vertices[edgeIdx];
            const v2 = vertices[(edgeIdx + 1) % sides];
            roots.push({ re: v1.re + frac * (v2.re - v1.re), im: v1.im + frac * (v2.im - v1.im) });
        }
    } else if (pattern === "r-infinity") {
        // Infinity / lemniscate of Bernoulli: two lobes
        for (let i = 0; i < n; i++) {
            const t = (2 * Math.PI * i) / n;
            const denom = 1 + Math.sin(t) * Math.sin(t);
            roots.push({
                re: spread * Math.cos(t) / denom,
                im: spread * Math.sin(t) * Math.cos(t) / denom
            });
        }
    }
    return roots;
}

// --- Drag behavior ---

let dragMoved = false;
let dragStartX = 0, dragStartY = 0;
const CLICK_DEAD_ZONE = 3; // px threshold: smaller moves count as clicks, not drags
const drag = d3.drag()
    .on("start", function (event) {
        dragMoved = false;
        dragStartX = event.x;
        dragStartY = event.y;
        d3.select(this).raise().classed("dragging", true);
    })
    .on("drag", function (event, d) {
        if (!dragMoved && Math.hypot(event.x - dragStartX, event.y - dragStartY) < CLICK_DEAD_ZONE) return;
        dragMoved = true;
        const idx = d._idx;
        // Skip if this coefficient is being animated
        if (animState.playing && allAnimatedCoeffs().has(idx)) return;

        const newRe = cxs().invert(event.x);
        const newIm = cys().invert(event.y);

        if (selectedCoeffs.has(idx) && selectedCoeffs.size > 1) {
            // Group drag: apply delta to all selected
            const deltaRe = newRe - d.re;
            const deltaIm = newIm - d.im;
            for (const si of selectedCoeffs) {
                coefficients[si].re += deltaRe;
                coefficients[si].im += deltaIm;
                for (const pt of coefficients[si].curve) { pt.re += deltaRe; pt.im += deltaIm; }
            }
            coeffLayer.selectAll("circle.coeff")
                .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
            coeffLayer.selectAll(".coeff-label")
                .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);
        } else {
            // Single drag: shift position and all curve points by delta
            const deltaRe = newRe - d.re;
            const deltaIm = newIm - d.im;
            d.re = newRe;
            d.im = newIm;
            for (const pt of d.curve) { pt.re += deltaRe; pt.im += deltaIm; }
            d3.select(this).attr("cx", cxs()(d.re)).attr("cy", cys()(d.im));
            coeffLayer.selectAll(".coeff-label")
                .filter(ld => ld === d)
                .attr("x", cxs()(d.re) + 12).attr("y", cys()(d.im) + 4);
        }
        showTooltip(event.sourceEvent, d.re, d.im);
        autoScaleCoeffPanel();
        solveRootsThrottled();
        renderDomainColoringThrottled();
        // Update analytical coefficient path curves (they follow the coefficient)
        renderCoeffTrails();
        updateListCoords();
    })
    .on("end", function (event, d) {
        d3.select(this).classed("dragging", false);
        hideTooltip();
        // Click detection: if mouse didn't move, toggle selection
        if (!dragMoved) {
            const idx = d._idx;
            clearRootSelection();
            toggleCoeffSelect(idx);
        }
    });

function autoScaleCoeffPanel() {
    let needed = computeRange(coefficients);
    // Include jiggle-offset positions so the Final tab doesn't clip
    if (jiggleOffsets && jiggleOffsets.size > 0) {
        for (const [idx, off] of jiggleOffsets) {
            if (idx < coefficients.length) {
                const c = coefficients[idx];
                const absRe = Math.abs(c.re + off.re);
                const absIm = Math.abs(c.im + off.im);
                const raw = Math.max(absRe, absIm) * RANGE_PAD * 2;
                if (isFinite(raw)) needed = Math.max(needed, Math.ceil(raw) / 2);
            }
        }
    }
    // During animation, only zoom out â€” never shrink back
    if (animState.playing) needed = Math.max(needed, panels.coeff.range);
    if (needed !== panels.coeff.range) {
        updatePanelRange(coeffSvg, panels.coeff, needed);
        coeffLayer.selectAll("circle.coeff")
            .attr("cx", d => cxs()(d.re)).attr("cy", d => cys()(d.im));
        coeffLayer.selectAll(".coeff-label")
            .attr("x", d => cxs()(d.re) + 12).attr("y", d => cys()(d.im) + 4);
        // Trail SVG paths contain absolute screen coordinates â€” must re-render
        // when the scale changes so trails stay aligned with coefficient dots
        renderCoeffTrails();
        // Sync morph panel grid + dot positions when coeff scale changes
        if (morphPanelInited) {
            drawGrid(morphSvg, panels.coeff);
            renderMorphPanel();
        }
    }
}

// --- Coefficient selection & animation ---

function coeffExtent() {
    const n = coefficients.length;
    let maxDist = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const d = Math.hypot(coefficients[i].re - coefficients[j].re,
                                 coefficients[i].im - coefficients[j].im);
            if (d > maxDist) maxDist = d;
        }
    }
    return maxDist || 1;
}

const animBar = document.getElementById("anim-bar");
const barTitle = document.getElementById("bar-title");
const animPathSel = document.getElementById("anim-path");
const playBtn = document.getElementById("play-btn");
const trailsBtn = document.getElementById("trails-btn");
const sel2pathBtn = document.getElementById("sel2path-btn");
const barControls = document.getElementById("bar-controls");
const barDynamic = document.getElementById("bar-dynamic");

// --- Path parameter schemas ---

const _P = {
    radius: { key: "radius", label: "R", min: 1, max: 100, step: 1, default: 25, fmt: v => Math.round(v) + "%" },
    speed:  { key: "speed",  label: "S", min: 1, max: 1000, step: 1, default: 1.0, fmt: v => String(Math.round(v)), toUI: v => Math.round(v * 1000), fromUI: v => v / 1000 },
    angle:  { key: "angle",  label: "A", min: 0, max: 1.0, step: 0.01, default: 0, fmt: v => v.toFixed(2) },
    ccw:    { key: "ccw", type: "toggle", labels: ["CW", "CCW"], default: false },
};
const _RSAD = [_P.speed, _P.radius, _P.angle, _P.ccw];
const _RSD  = [_P.speed, _P.radius, _P.ccw];
const _STD_KEYS = new Set(["radius", "speed", "angle", "ccw"]);
const _SIGMA_PARAM = { key: "sigma", label: "\u03C3", min: 0, max: 1, step: 0.01, default: 0.2, fmt: v => v.toFixed(2) + "%" };
const _DIST_PARAM = { key: "ditherDist", type: "select", label: "Dist", options: [{ value: "normal", label: "Normal" }, { value: "uniform", label: "Uniform" }], default: "normal" };

const PATH_PARAMS = {
    none:          [],
    "follow-c":    [],
    circle:        _RSAD,
    horizontal:    _RSD,
    vertical:      _RSD,
    spiral:        [_P.speed,
        { key: "mult", label: "R", min: 0, max: 2.0, step: 0.05, default: 1.5, fmt: v => v.toFixed(2) + "Ã—" },
        { key: "turns", label: "T", min: 0.5, max: 5, step: 0.5, default: 2, fmt: v => v.toFixed(1) },
        _P.ccw],
    random:        [_P.speed,
        { key: "radius", label: "Ïƒ", min: 0, max: 10, step: 0.5, default: 2, fmt: v => v.toFixed(1) + "%" }],
    lissajous:     [..._RSAD,
        { key: "freqA", label: "a", min: 1, max: 8, step: 1, default: 3, fmt: v => String(Math.round(v)) },
        { key: "freqB", label: "b", min: 1, max: 8, step: 1, default: 2, fmt: v => String(Math.round(v)) },
    ],
    figure8:       _RSAD,
    cardioid:      _RSAD,
    astroid:       _RSAD,
    deltoid:       _RSAD,
    rose:          _RSAD,
    epitrochoid:   _RSAD,
    hypotrochoid:  _RSAD,
    butterfly:     _RSAD,
    star:          _RSAD,
    square:        _RSAD,
    hilbert:       _RSAD,
    peano:         _RSAD,
    sierpinski:    _RSAD,
    "c-ellipse":   [_P.speed,
        { key: "width", label: "W", min: 1, max: 100, step: 1, default: 50, fmt: v => Math.round(v) + "%" },
        _P.ccw],
};
// Auto-generate dithered variants for all animated paths
for (const key of Object.keys(PATH_PARAMS)) {
    if (key !== "none" && key !== "follow-c" && key !== "random" && !key.endsWith("-dither")) {
        PATH_PARAMS[key + "-dither"] = [...PATH_PARAMS[key], _SIGMA_PARAM, _DIST_PARAM];
    }
}

// Single source of truth for all path <select> elements.
// Order here = display order.  Groups become <optgroup> labels.
const PATH_CATALOG = [
    { value: "none", label: "None" },
    { value: "follow-c", label: "Follow C", dOnly: true },
    { group: "Basic", items: [
        { value: "circle",     label: "Circle" },
        { value: "horizontal", label: "Horizontal" },
        { value: "vertical",   label: "Vertical" },
        { value: "spiral",     label: "Spiral" },
        { value: "random",     label: "Gaussian cloud" },
    ]},
    { group: "Curves", items: [
        { value: "lissajous",    label: "Lissajous" },
        { value: "figure8",      label: "Figure-8" },
        { value: "cardioid",     label: "Cardioid" },
        { value: "astroid",      label: "Astroid" },
        { value: "deltoid",      label: "Deltoid" },
        { value: "rose",         label: "Rose (3-petal)" },
        { value: "epitrochoid",  label: "Spirograph" },
        { value: "hypotrochoid", label: "Hypotrochoid" },
        { value: "butterfly",    label: "Butterfly" },
        { value: "star",         label: "Star (pentagram)" },
        { value: "square",       label: "Square" },
        { value: "c-ellipse",   label: "C-Ellipse" },
    ]},
    { group: "Space-filling", items: [
        { value: "hilbert",    label: "Hilbert (Moore)" },
        { value: "peano",      label: "Peano" },
        { value: "sierpinski", label: "Sierpinski" },
    ]},
];
// Auto-insert dithered variants after each base path in catalog groups
for (const entry of PATH_CATALOG) {
    if (entry.items) {
        const expanded = [];
        for (const item of entry.items) {
            expanded.push(item);
            if (item.value !== "random") {
                expanded.push({ value: item.value + "-dither", label: item.label + " (dither)" });
            }
        }
        entry.items = expanded;
    }
}

/** Populate a <select> element from PATH_CATALOG. noneLabel overrides the "None" text. dNode includes D-only options. */
function buildPathSelect(sel, noneLabel, dNode) {
    sel.innerHTML = "";
    for (const entry of PATH_CATALOG) {
        if (entry.dOnly && !dNode) continue;
        if (entry.value !== undefined) {
            // Top-level option (e.g. "none")
            const opt = document.createElement("option");
            opt.value = entry.value;
            opt.textContent = noneLabel && entry.value === "none" ? noneLabel : entry.label;
            sel.appendChild(opt);
        } else {
            const grp = document.createElement("optgroup");
            grp.label = entry.group;
            for (const item of entry.items) {
                const opt = document.createElement("option");
                opt.value = item.value;
                opt.textContent = item.label;
                grp.appendChild(opt);
            }
            sel.appendChild(grp);
        }
    }
}

// Build both path selectors from the single catalog
buildPathSelect(document.getElementById("anim-path"));
buildPathSelect(document.getElementById("lce-path-sel"), "\u2014");
buildPathSelect(document.getElementById("dle-path-sel"), "\u2014", true);

function getCoeffParam(c, key, schema) {
    if (_STD_KEYS.has(key)) return c[key];
    if (c.extra && c.extra[key] !== undefined) return c.extra[key];
    if (schema) return schema.default;
    return 0;
}

function setCoeffParam(c, key, value) {
    if (_STD_KEYS.has(key)) { c[key] = value; return; }
    if (!c.extra) c.extra = {};
    c.extra[key] = value;
}

// Dynamic bar controls â€” rebuilt when path type changes
let barInputs = {};       // { key: <input element>, ... }
let barCurrentPath = "";  // track which path type is currently shown
let barSnapshots = null;  // preview/revert: { idx: {pathType,radius,...}, ... } or null

function rebuildBarControls(pathType) {
    if (pathType === barCurrentPath) return;
    barCurrentPath = pathType;
    barDynamic.innerHTML = "";
    barInputs = {};
    const schema = PATH_PARAMS[pathType] || [];
    // Render sliders first, selects next, toggles last (CW/CCW always at end)
    const sliders = schema.filter(p => p.type !== "toggle" && p.type !== "select");
    const selects = schema.filter(p => p.type === "select");
    const toggles = schema.filter(p => p.type === "toggle");
    for (const p of sliders) {
        const lbl = document.createElement("label");
        const inp = document.createElement("input");
        const uiDef = p.toUI ? p.toUI(p.default) : p.default;
        inp.type = "range"; inp.min = p.min; inp.max = p.max; inp.step = p.step; inp.value = uiDef;
        const valSpan = document.createElement("span");
        valSpan.className = "bar-val";
        valSpan.textContent = p.fmt(uiDef);
        inp.addEventListener("input", function () {
            valSpan.textContent = p.fmt(parseFloat(this.value));
            previewBarToSelection();
        });
        lbl.textContent = p.label + " ";
        lbl.appendChild(inp);
        lbl.appendChild(valSpan);
        barDynamic.appendChild(lbl);
        barInputs[p.key] = inp;
        barInputs[p.key + "_val"] = valSpan;
        barInputs[p.key + "_fmt"] = p.fmt;
    }
    for (const p of selects) {
        const lbl = document.createElement("label");
        lbl.textContent = p.label + " ";
        const sel = document.createElement("select");
        for (const opt of p.options) {
            const o = document.createElement("option");
            o.value = opt.value; o.textContent = opt.label;
            sel.appendChild(o);
        }
        sel.value = p.default;
        sel.addEventListener("change", () => previewBarToSelection());
        lbl.appendChild(sel);
        barDynamic.appendChild(lbl);
        barInputs[p.key] = sel;
    }
    for (const p of toggles) {
        const btn = document.createElement("button");
        btn.id = "ccw-btn";
        btn.textContent = p.labels[0];
        btn.addEventListener("click", function () {
            if (selectedCoeffs.size === 0) return;
            const isActive = !this.classList.contains("active");
            this.textContent = isActive ? p.labels[1] : p.labels[0];
            this.classList.toggle("active", isActive);
            previewBarToSelection();
        });
        barDynamic.appendChild(btn);
        barInputs[p.key] = btn;
    }
}

// Initialize with "none" (empty)
rebuildBarControls("none");

function toggleCoeffSelect(idx) {
    // If animation is playing and user clicks a coefficient, stop animation
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "â–¶ Resume";
    }
    // Mutually exclusive: clear D-nodes and roots
    clearRootSelection();
    clearMorphSelection();

    if (selectedCoeffs.has(idx)) {
        selectedCoeffs.delete(idx);
    } else {
        selectedCoeffs.add(idx);
        lastSelectedCoeff = idx;
    }
    updateCoeffSelectionVisual();
    updateAnimBar();
}

function clearCoeffSelection() {
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "â–¶ Resume";
    }
    selectedCoeffs.clear();
    updateCoeffSelectionVisual();
    updateAnimBar();
}

function clearRootSelection() {
    selectedRoots.clear();
    updateRootSelectionVisual();
}

function clearMorphSelection() {
    selectedMorphCoeffs.clear();
    updateMorphSelectionVisual();
}

function clearAllSelection() {
    clearCoeffSelection();
    clearRootSelection();
    clearMorphSelection();
}

function updateTransformGroupVisibility() {
    const hasCoeff = selectedCoeffs.size > 0;
    const hasRoot = selectedRoots.size > 0;
    const hasMorph = selectedMorphCoeffs.size > 0;
    const hasSel = hasCoeff || hasRoot || hasMorph;
    document.getElementById("ops-group").classList.toggle("disabled", !hasSel);
    const t = document.getElementById("ops-target");
    if (!hasSel) {
        t.textContent = "Â· none"; t.style.color = "#888";
        if (typeof closeOpTool === "function") closeOpTool();
    }
    else if (hasCoeff) { t.textContent = "Â· C"; t.style.color = "#5ddb6a"; }
    else if (hasMorph) { t.textContent = "Â· D"; t.style.color = "#4ea8de"; }
    else { t.textContent = "Â· roots"; t.style.color = "#e94560"; }
}

function updateCoeffSelectionVisual() {
    coeffLayer.selectAll("circle.coeff")
        .classed("selected", d => selectedCoeffs.has(d._idx));
    const cc = document.getElementById("coeff-sel-count");
    cc.textContent = selectedCoeffs.size > 0 ? `(${selectedCoeffs.size})` : "";
    const jc = document.getElementById("jiggle-sel-count");
    if (jc) jc.textContent = selectedCoeffs.size > 0 ? `(${selectedCoeffs.size})` : "";
    updateTransformGroupVisibility();
    if (rootColorMode === "derivative") {
        computeRootSensitivities();
        refreshRootColors();
    }
    // Sync list tab checkboxes and curve editor
    if (typeof leftTab !== "undefined" && leftTab === "list") {
        const rows = document.querySelectorAll("#coeff-list-scroll .cpick-row");
        rows.forEach((row, i) => {
            const cb = row.querySelector(".cpick-cb");
            if (cb) cb.classList.toggle("checked", selectedCoeffs.has(i));
        });
        if (typeof refreshListCurveEditor === "function") refreshListCurveEditor();
    }
}

function updateRootSelectionVisual() {
    rootsLayer.selectAll("circle.root")
        .classed("selected", d => selectedRoots.has(d._idx));
    const rc = document.getElementById("roots-sel-count");
    rc.textContent = selectedRoots.size > 0 ? `(${selectedRoots.size})` : "";
    updateTransformGroupVisibility();
}

function updateMorphSelectionVisual() {
    if (morphPanelInited && morphLayer) {
        morphLayer.selectAll("circle.morph-coeff")
            .classed("selected", d => selectedMorphCoeffs.has(d._idx));
    }
    const mc = document.getElementById("morph-sel-count");
    if (mc) mc.textContent = selectedMorphCoeffs.size > 0 ? `(${selectedMorphCoeffs.size})` : "";
    updateTransformGroupVisibility();
}

// --- Marquee (area) selection ---

function installMarqueeSelection(svgSel, getCirclesSel, which) {
    const svgNode = svgSel.node();
    let dragging = false;
    let x0 = 0, y0 = 0;
    let rect = null;

    function begin(event) {
        const t = event.target;
        if (t && t.tagName === "circle") return;
        if (event.button != null && event.button !== 0) return;

        if (which === "coeff") { clearRootSelection(); clearMorphSelection(); }
        else if (which === "roots") { clearCoeffSelection(); clearMorphSelection(); }
        else { clearCoeffSelection(); clearRootSelection(); }

        dragging = true;
        const p = d3.pointer(event, svgNode);
        x0 = p[0]; y0 = p[1];

        rect = svgSel.append("rect")
            .attr("class", "sel-rect")
            .attr("x", x0).attr("y", y0)
            .attr("width", 0).attr("height", 0);
        event.preventDefault();
    }

    function move(event) {
        if (!dragging || !rect) return;
        const p = d3.pointer(event, svgNode);
        const x1 = p[0], y1 = p[1];
        rect.attr("x", Math.min(x0, x1)).attr("y", Math.min(y0, y1))
            .attr("width", Math.abs(x1 - x0)).attr("height", Math.abs(y1 - y0));
        event.preventDefault();
    }

    function end() {
        if (!dragging) return;
        dragging = false;
        if (!rect) return;

        const x = +rect.attr("x"), y = +rect.attr("y");
        const w = +rect.attr("width"), h = +rect.attr("height");
        rect.remove();
        rect = null;

        if (w < 3 || h < 3) return;

        const xMax = x + w, yMax = y + h;
        getCirclesSel().each(function(d) {
            const cx = +this.getAttribute("cx");
            const cy = +this.getAttribute("cy");
            if (cx >= x && cx <= xMax && cy >= y && cy <= yMax) {
                if (which === "coeff") {
                    selectedCoeffs.add(d._idx);
                    lastSelectedCoeff = d._idx;
                } else if (which === "morph") {
                    selectedMorphCoeffs.add(d._idx);
                } else {
                    selectedRoots.add(d._idx);
                }
            }
        });

        if (which === "coeff") {
            updateCoeffSelectionVisual();
            updateAnimBar();
        } else if (which === "morph") {
            updateMorphSelectionVisual();
        } else {
            updateRootSelectionVisual();
        }
    }

    svgSel.on("mousedown.marquee", begin);
    window.addEventListener("mousemove", move, { passive: false });
    window.addEventListener("mouseup", end, { passive: false });
}

// --- Coefficient right-click context menu ---

let ctxCoeffIdx = -1;
let ctxSnapshot = null; // snapshot for reverting on cancel: { pathsCopy, curveCopy }
let ctxQuadrant = 0;    // 0=BR, 1=BL, 2=TL, 3=TR â€” cycles on reposition button

function closeCoeffCtx(revert) {
    document.getElementById("coeff-ctx").classList.remove("open");
    if (revert && ctxSnapshot) {
        const c = coefficients[ctxCoeffIdx];
        c.pathType = ctxSnapshot.pathType;
        c.radius = ctxSnapshot.radius;
        c.speed = ctxSnapshot.speed;
        c.angle = ctxSnapshot.angle;
        c.ccw = ctxSnapshot.ccw;
        c.extra = ctxSnapshot.extra || {};
        c.curve = ctxSnapshot.curve;
        c.curveIndex = ctxSnapshot.curveIndex;
        updateAnimBar();
        renderCoeffTrails();
    }
    ctxCoeffIdx = -1;
    ctxSnapshot = null;
}

// --- D-node right-click context menu ---

let ctxDNodeIdx = -1;
let ctxDNodeSnapshot = null;
let ctxDNodeQuadrant = 0;

function closeDNodeCtx(revert) {
    document.getElementById("dnode-ctx").classList.remove("open");
    if (revert && ctxDNodeSnapshot) {
        const d = morphTargetCoeffs[ctxDNodeIdx];
        d.pathType = ctxDNodeSnapshot.pathType;
        d.radius = ctxDNodeSnapshot.radius;
        d.speed = ctxDNodeSnapshot.speed;
        d.angle = ctxDNodeSnapshot.angle;
        d.ccw = ctxDNodeSnapshot.ccw;
        d.extra = ctxDNodeSnapshot.extra || {};
        d.curve = ctxDNodeSnapshot.curve;
        d.curveIndex = ctxDNodeSnapshot.curveIndex;
        updateAnimBar();
    }
    ctxDNodeIdx = -1;
    ctxDNodeSnapshot = null;
}

function openDNodeCtx(event, dIdx) {
    event.preventDefault();
    if (ctxDNodeIdx >= 0) closeDNodeCtx(false);
    if (ctxCoeffIdx >= 0) closeCoeffCtx(false);
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeAudioPop === "function") closeAudioPop();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeColorPop === "function") closeColorPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();

    ctxDNodeIdx = dIdx;

    const dd = morphTargetCoeffs[dIdx];
    ctxDNodeSnapshot = {
        pathType: dd.pathType, radius: dd.radius, speed: dd.speed,
        angle: dd.angle, ccw: dd.ccw, extra: dd.extra ? { ...dd.extra } : {},
        curve: dd.curve.map(pt => ({ ...pt })),
        curveIndex: dd.curveIndex,
    };

    const ctx = document.getElementById("dnode-ctx");
    ctx.innerHTML = "";

    const n = morphTargetCoeffs.length;
    const subIdx = n - 1 - dIdx;

    // Title with reposition button
    const title = document.createElement("div");
    title.className = "ctx-title";
    const titleText = document.createElement("span");
    titleText.textContent = `d${subscript(subIdx)} trajectory`;
    title.appendChild(titleText);
    const moveBtn = document.createElement("button");
    moveBtn.className = "ctx-move";
    moveBtn.textContent = "\u21BB";
    moveBtn.title = "Move menu to another quadrant";
    moveBtn.addEventListener("click", () => {
        ctxDNodeQuadrant = (ctxDNodeQuadrant + 1) % 4;
        repositionDNodeCtx(dIdx);
    });
    title.appendChild(moveBtn);
    ctx.appendChild(title);

    const existing = dd;

    // Path type select (clone options from #anim-path, plus D-only "Follow C")
    const pathSel = document.createElement("select");
    pathSel.innerHTML = document.getElementById("anim-path").innerHTML;
    const _noneOpt = pathSel.querySelector('option[value="none"]');
    if (_noneOpt) { const _fc = document.createElement("option"); _fc.value = "follow-c"; _fc.textContent = "Follow C"; _noneOpt.after(_fc); }
    pathSel.value = existing.pathType;
    const pathRow = document.createElement("label");
    pathRow.textContent = "Path ";
    pathRow.appendChild(pathSel);
    ctx.appendChild(pathRow);

    // Dynamic controls container
    const ctxDynamic = document.createElement("div");
    ctx.appendChild(ctxDynamic);
    const ctxInputs = {};

    function buildCtxControls(pathType) {
        ctxDynamic.innerHTML = "";
        for (const k in ctxInputs) delete ctxInputs[k];
        const schema = PATH_PARAMS[pathType] || [];
        const d = morphTargetCoeffs[dIdx];
        for (const p of schema) {
            const val = getCoeffParam(d, p.key, p);
            if (p.type === "toggle") {
                const dirRow = document.createElement("div");
                dirRow.className = "ctx-row";
                const btn = document.createElement("button");
                btn.className = "ctx-dir" + (val ? " active" : "");
                btn.textContent = val ? p.labels[1] : p.labels[0];
                btn.addEventListener("click", () => {
                    const isActive = !btn.classList.contains("active");
                    btn.classList.toggle("active", isActive);
                    btn.textContent = isActive ? p.labels[1] : p.labels[0];
                    previewDNodeCtx();
                });
                dirRow.appendChild(btn);
                ctxDynamic.appendChild(dirRow);
                ctxInputs[p.key] = btn;
            } else if (p.type === "select") {
                const row = document.createElement("label");
                row.textContent = p.label + " ";
                const sel = document.createElement("select");
                for (const opt of p.options) { const o = document.createElement("option"); o.value = opt.value; o.textContent = opt.label; sel.appendChild(o); }
                sel.value = val || p.default;
                sel.addEventListener("change", () => previewDNodeCtx());
                row.appendChild(sel);
                ctxDynamic.appendChild(row);
                ctxInputs[p.key] = sel;
            } else {
                const row = document.createElement("label");
                const uiVal = p.toUI ? p.toUI(val) : val;
                const valSpan = document.createElement("span");
                valSpan.className = "ctx-val";
                valSpan.textContent = p.fmt(uiVal);
                const inp = document.createElement("input");
                inp.type = "range"; inp.min = p.min; inp.max = p.max; inp.step = p.step; inp.value = uiVal;
                inp.addEventListener("input", () => {
                    valSpan.textContent = p.fmt(parseFloat(inp.value));
                    previewDNodeCtx();
                });
                row.textContent = p.label + " ";
                row.appendChild(inp);
                row.appendChild(valSpan);
                ctxDynamic.appendChild(row);
                ctxInputs[p.key] = inp;
            }
        }
    }

    buildCtxControls(existing.pathType);

    pathSel.addEventListener("change", () => {
        buildCtxControls(pathSel.value);
        previewDNodeCtx();
    });

    // Accept button row
    const ctxBtnRow = document.createElement("div");
    ctxBtnRow.style.cssText = "display:flex;gap:6px;align-items:center;justify-content:center;margin-top:4px;";
    const acceptBtn = document.createElement("button");
    acceptBtn.className = "ctx-accept";
    acceptBtn.textContent = "Accept";
    acceptBtn.addEventListener("click", () => {
        ctxDNodeSnapshot = null;
        closeDNodeCtx(false);
        updateAnimBar();
        if (leftTab === "dlist") refreshDCoeffList();
    });
    ctxBtnRow.appendChild(acceptBtn);
    ctx.appendChild(ctxBtnRow);

    // Live preview â€” applies current menu settings immediately
    function previewDNodeCtx() {
        const d = morphTargetCoeffs[dIdx];
        d.pathType = pathSel.value;
        const schema = PATH_PARAMS[d.pathType] || [];
        for (const p of schema) {
            if (p.type === "toggle") {
                setCoeffParam(d, p.key, ctxInputs[p.key] ? ctxInputs[p.key].classList.contains("active") : p.default);
            } else if (p.type === "select") {
                setCoeffParam(d, p.key, ctxInputs[p.key] ? ctxInputs[p.key].value : p.default);
            } else {
                const ctxRaw = ctxInputs[p.key] ? parseFloat(ctxInputs[p.key].value) : null;
                setCoeffParam(d, p.key, ctxRaw !== null ? (p.fromUI ? p.fromUI(ctxRaw) : ctxRaw) : p.default);
            }
        }
        if (d.pathType === "none" || d.pathType === "follow-c") {
            d.curve = [{ re: d.re, im: d.im }];
        } else {
            const absRadius = d.radius / 100 * coeffExtent();
            d.curve = computeCurve(d.re, d.im, d.pathType, absRadius, d.angle, d.extra);
        }
        d.curveIndex = 0;
        animState.elapsedAtPause = null;
        updateAnimSeconds(0);
        playBtn.textContent = "â–¶ Play";
        updateAnimBar();
    }

    pathSel.addEventListener("change", previewDNodeCtx);

    ctx.classList.add("open");
    ctxDNodeQuadrant = 0;
    repositionDNodeCtx(dIdx);
}

function repositionDNodeCtx(dIdx) {
    const ctx = document.getElementById("dnode-ctx");
    const d = morphTargetCoeffs[dIdx];
    if (!morphSvg || !morphSvg.node()) { ctx.style.left = "100px"; ctx.style.top = "100px"; return; }
    const sx = cxs()(d.re), sy = cys()(d.im);
    const svgRect = morphSvg.node().getBoundingClientRect();
    const cx = svgRect.left + sx, cy = svgRect.top + sy;
    const GAP = 14;
    const rect = ctx.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const vw = window.innerWidth, vh = window.innerHeight;
    const offsets = [
        { left: cx + GAP,     top: cy + GAP },
        { left: cx - w - GAP, top: cy + GAP },
        { left: cx - w - GAP, top: cy - h - GAP },
        { left: cx + GAP,     top: cy - h - GAP },
    ];
    let pos = offsets[ctxDNodeQuadrant];
    pos.left = Math.max(4, Math.min(pos.left, vw - w - 4));
    pos.top  = Math.max(4, Math.min(pos.top,  vh - h - 4));
    ctx.style.left = pos.left + "px";
    ctx.style.top  = pos.top  + "px";
}

function addCoefficientAt(re, im, event) {
    if (ctxCoeffIdx >= 0) closeCoeffCtx(false);
    const c = {
        re, im, pathType: "none", radius: 25, speed: 1.0,
        angle: 0, ccw: false, extra: {},
        curve: [{ re, im }], curveIndex: 0,
    };
    // unshift: new coefficient = new highest power term
    coefficients.unshift(c);
    // Adjust selection indices (all shift up by 1)
    const newSel = new Set();
    for (const s of selectedCoeffs) newSel.add(s + 1);
    selectedCoeffs.clear();
    for (const s of newSel) selectedCoeffs.add(s);
    currentDegree = coefficients.length - 1;
    document.getElementById("degree-number").textContent = currentDegree;
    currentRoots = [];
    clearTrails();
    initMorphTarget();
    renderCoefficients();
    renderCoeffTrails();
    solveRoots();
    if (leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
    openCoeffCtx(event, 0);
}

function deleteCoefficient(idx) {
    if (coefficients.length <= 3) { uiBuzz(); return; }
    selectedCoeffs.delete(idx);
    const newSel = new Set();
    for (const s of selectedCoeffs) {
        if (s < idx) newSel.add(s);
        else if (s > idx) newSel.add(s - 1);
    }
    selectedCoeffs.clear();
    for (const s of newSel) selectedCoeffs.add(s);
    coefficients.splice(idx, 1);
    currentDegree = coefficients.length - 1;
    document.getElementById("degree-number").textContent = currentDegree;
    currentRoots = [];
    clearTrails();
    initMorphTarget();
    renderCoefficients();
    renderCoeffTrails();
    solveRoots();
    if (leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
}

function initMorphTarget() {
    morphTargetCoeffs = coefficients.map(c => ({
        re: c.re, im: c.im,
        pathType: "none", radius: 25, speed: 1, angle: 0, ccw: false, extra: {},
        curve: [{ re: c.re, im: c.im }], curveIndex: 0
    }));
    selectedMorphCoeffs.clear();
}

function openCoeffCtx(event, coeffIdx) {
    event.preventDefault();
    if (ctxCoeffIdx >= 0) closeCoeffCtx(false); // close previous without revert
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeAudioPop === "function") closeAudioPop();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeColorPop === "function") closeColorPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();

    ctxCoeffIdx = coeffIdx;

    // Snapshot current state for cancel/revert
    const cc = coefficients[coeffIdx];
    ctxSnapshot = {
        pathType: cc.pathType, radius: cc.radius, speed: cc.speed,
        angle: cc.angle, ccw: cc.ccw, extra: cc.extra ? { ...cc.extra } : {},
        curve: cc.curve.map(pt => ({ ...pt })),
        curveIndex: cc.curveIndex,
    };

    const ctx = document.getElementById("coeff-ctx");
    ctx.innerHTML = "";

    const n = coefficients.length;
    const subIdx = n - 1 - coeffIdx;

    // Title with reposition button
    const title = document.createElement("div");
    title.className = "ctx-title";
    const titleText = document.createElement("span");
    titleText.textContent = `c${subscript(subIdx)} trajectory`;
    title.appendChild(titleText);
    const moveBtn = document.createElement("button");
    moveBtn.className = "ctx-move";
    moveBtn.textContent = "\u21BB"; // â†»
    moveBtn.title = "Move menu to another quadrant";
    moveBtn.addEventListener("click", () => {
        ctxQuadrant = (ctxQuadrant + 1) % 4;
        repositionCtx(coeffIdx);
    });
    title.appendChild(moveBtn);
    ctx.appendChild(title);

    // Pre-fill from coefficient's trajectory settings
    const existing = cc;

    // Path type select (clone options from #anim-path)
    const pathSel = document.createElement("select");
    pathSel.innerHTML = document.getElementById("anim-path").innerHTML;
    pathSel.value = existing.pathType;
    const pathRow = document.createElement("label");
    pathRow.textContent = "Path ";
    pathRow.appendChild(pathSel);
    ctx.appendChild(pathRow);

    // Dynamic controls container
    const ctxDynamic = document.createElement("div");
    ctx.appendChild(ctxDynamic);
    const ctxInputs = {};

    function buildCtxControls(pathType) {
        ctxDynamic.innerHTML = "";
        for (const k in ctxInputs) delete ctxInputs[k];
        const schema = PATH_PARAMS[pathType] || [];
        const c = coefficients[coeffIdx];
        for (const p of schema) {
            const val = getCoeffParam(c, p.key, p);
            if (p.type === "toggle") {
                const dirRow = document.createElement("div");
                dirRow.className = "ctx-row";
                const btn = document.createElement("button");
                btn.className = "ctx-dir" + (val ? " active" : "");
                btn.textContent = val ? p.labels[1] : p.labels[0];
                btn.addEventListener("click", () => {
                    const isActive = !btn.classList.contains("active");
                    btn.classList.toggle("active", isActive);
                    btn.textContent = isActive ? p.labels[1] : p.labels[0];
                    previewCtx();
                });
                dirRow.appendChild(btn);
                ctxDynamic.appendChild(dirRow);
                ctxInputs[p.key] = btn;
            } else if (p.type === "select") {
                const row = document.createElement("label");
                row.textContent = p.label + " ";
                const sel = document.createElement("select");
                for (const opt of p.options) { const o = document.createElement("option"); o.value = opt.value; o.textContent = opt.label; sel.appendChild(o); }
                sel.value = val || p.default;
                sel.addEventListener("change", () => previewCtx());
                row.appendChild(sel);
                ctxDynamic.appendChild(row);
                ctxInputs[p.key] = sel;
            } else {
                const row = document.createElement("label");
                const uiVal = p.toUI ? p.toUI(val) : val;
                const valSpan = document.createElement("span");
                valSpan.className = "ctx-val";
                valSpan.textContent = p.fmt(uiVal);
                const inp = document.createElement("input");
                inp.type = "range"; inp.min = p.min; inp.max = p.max; inp.step = p.step; inp.value = uiVal;
                inp.addEventListener("input", () => {
                    valSpan.textContent = p.fmt(parseFloat(inp.value));
                    previewCtx();
                });
                row.textContent = p.label + " ";
                row.appendChild(inp);
                row.appendChild(valSpan);
                ctxDynamic.appendChild(row);
                ctxInputs[p.key] = inp;
            }
        }
    }

    buildCtxControls(existing.pathType);

    // Rebuild controls when path type changes in context menu
    pathSel.addEventListener("change", () => {
        buildCtxControls(pathSel.value);
        previewCtx();
    });

    // Accept + Delete buttons row
    const ctxBtnRow = document.createElement("div");
    ctxBtnRow.style.cssText = "display:flex;gap:6px;align-items:center;justify-content:center;margin-top:4px;";
    const acceptBtn = document.createElement("button");
    acceptBtn.className = "ctx-accept";
    acceptBtn.textContent = "Accept";
    acceptBtn.addEventListener("click", () => {
        ctxSnapshot = null; // discard snapshot â€” keep current state
        closeCoeffCtx(false);
        solveRoots();
    });
    ctxBtnRow.appendChild(acceptBtn);
    const delBtn = document.createElement("button");
    delBtn.className = "ctx-accept";
    delBtn.textContent = "Delete";
    delBtn.style.cssText = "padding:4px 8px;background:transparent;border:1px solid #a33;color:#c55;";
    delBtn.addEventListener("click", () => {
        ctxSnapshot = null;
        closeCoeffCtx(false);
        deleteCoefficient(coeffIdx);
    });
    ctxBtnRow.appendChild(delBtn);
    ctx.appendChild(ctxBtnRow);

    // Live preview helper â€” applies current menu settings immediately
    function previewCtx() {
        const c = coefficients[coeffIdx];
        c.pathType = pathSel.value;
        const schema = PATH_PARAMS[c.pathType] || [];
        for (const p of schema) {
            if (p.type === "toggle") {
                setCoeffParam(c, p.key, ctxInputs[p.key] ? ctxInputs[p.key].classList.contains("active") : p.default);
            } else if (p.type === "select") {
                setCoeffParam(c, p.key, ctxInputs[p.key] ? ctxInputs[p.key].value : p.default);
            } else {
                const ctxRaw = ctxInputs[p.key] ? parseFloat(ctxInputs[p.key].value) : null;
                setCoeffParam(c, p.key, ctxRaw !== null ? (p.fromUI ? p.fromUI(ctxRaw) : ctxRaw) : p.default);
            }
        }

        if (c.pathType === "none") {
            c.curve = [{ re: c.re, im: c.im }];
        } else {
            const absRadius = c.radius / 100 * coeffExtent();
            c.curve = computeCurve(c.re, c.im, c.pathType, absRadius, c.angle, c.extra);
        }
        c.curveIndex = 0;

        animState.elapsedAtPause = null;
        updateAnimSeconds(0);
        playBtn.textContent = "â–¶ Play";
        updateAnimBar();
        renderCoeffTrails();
    }

    // Also preview on path type change
    pathSel.addEventListener("change", previewCtx);

    // Show and position relative to coefficient dot
    ctx.classList.add("open");
    ctxQuadrant = 0; // reset to bottom-right on open
    repositionCtx(coeffIdx);
}

function repositionCtx(coeffIdx) {
    const ctx = document.getElementById("coeff-ctx");
    const c = coefficients[coeffIdx];
    // Get the coefficient's screen position from the SVG scale
    const sx = cxs()(c.re), sy = cys()(c.im);
    const svgRect = coeffSvg.node().getBoundingClientRect();
    const cx = svgRect.left + sx, cy = svgRect.top + sy;
    const GAP = 14;
    const rect = ctx.getBoundingClientRect();
    const w = rect.width, h = rect.height;
    const vw = window.innerWidth, vh = window.innerHeight;
    // Quadrant offsets: 0=BR, 1=BL, 2=TL, 3=TR
    const offsets = [
        { left: cx + GAP,     top: cy + GAP },
        { left: cx - w - GAP, top: cy + GAP },
        { left: cx - w - GAP, top: cy - h - GAP },
        { left: cx + GAP,     top: cy - h - GAP },
    ];
    let pos = offsets[ctxQuadrant];
    // Clamp to viewport
    pos.left = Math.max(4, Math.min(pos.left, vw - w - 4));
    pos.top  = Math.max(4, Math.min(pos.top,  vh - h - 4));
    ctx.style.left = pos.left + "px";
    ctx.style.top  = pos.top  + "px";
}

// --- Per-coefficient trajectory management ---

function coeffListLabel(coeffSet) {
    const n = coefficients.length;
    const sorted = [...coeffSet].sort((a, b) => a - b);
    if (sorted.length <= 4) {
        return sorted.map(i => `c${subscript(n - 1 - i)}`).join(' ');
    }
    return `${sorted.length} coeffs`;
}

function allAnimatedCoeffs() {
    const s = new Set();
    for (let i = 0; i < coefficients.length; i++) {
        if (coefficients[i].pathType !== "none") s.add(i);
    }
    return s;
}

function allAnimatedDCoeffs() {
    const s = new Set();
    for (let i = 0; i < morphTargetCoeffs.length; i++) {
        const pt = morphTargetCoeffs[i].pathType;
        if (pt !== "none" && pt !== "follow-c") s.add(i);
    }
    return s;
}

// True when any D-node is at a different position from its C-node (morph produces motion)
function hasMorphMotion() {
    if (morphTargetCoeffs.length !== coefficients.length) return false;
    for (let i = 0; i < morphTargetCoeffs.length; i++) {
        const d = morphTargetCoeffs[i];
        if (d.pathType === "follow-c") continue;
        const c = coefficients[i];
        if (Math.abs(d.re - c.re) > 1e-12 || Math.abs(d.im - c.im) > 1e-12) return true;
    }
    return false;
}

function advanceDNodesAlongCurves(elapsed) {
    for (let i = 0; i < morphTargetCoeffs.length; i++) {
        const d = morphTargetCoeffs[i];
        if (d.pathType === "follow-c" && i < coefficients.length) {
            d.re = coefficients[i].re; d.im = coefficients[i].im; continue;
        }
        if (d.pathType === "none") continue;
        const N = d.curve.length;
        const t = elapsed * d.speed * (d.ccw ? -1 : 1);
        const rawIdx = ((t % 1) + 1) % 1 * N;
        if (d.curve._isCloud) {
            const idx = Math.floor(rawIdx) % N;
            d.re = d.curve[idx].re;
            d.im = d.curve[idx].im;
            d.curveIndex = idx;
        } else {
            const lo = Math.floor(rawIdx) % N;
            const hi = (lo + 1) % N;
            const frac = rawIdx - Math.floor(rawIdx);
            d.re = d.curve[lo].re * (1 - frac) + d.curve[hi].re * frac;
            d.im = d.curve[lo].im * (1 - frac) + d.curve[hi].im * frac;
            d.curveIndex = lo;
        }
        if (d.curve._ditherSigmaPct) {
            const ds = d.curve._ditherSigmaPct / 100 * coeffExtent();
            const _dd = d.curve._ditherDist;
            d.re += _ditherRand(_dd) * ds; d.im += _ditherRand(_dd) * ds;
        }
    }
}

function updateMorphPanelDDots() {
    if (!morphPanelInited || !morphLayer) return;
    const nn = Math.min(coefficients.length, morphTargetCoeffs.length);
    morphLayer.selectAll("circle.morph-coeff")
        .attr("cx", (_, i) => i < nn ? cxs()(morphTargetCoeffs[i].re) : 0)
        .attr("cy", (_, i) => i < nn ? cys()(morphTargetCoeffs[i].im) : 0);
    morphLayer.selectAll(".morph-label")
        .attr("x", (_, i) => i < nn ? cxs()(morphTargetCoeffs[i].re) + 10 : 0)
        .attr("y", (_, i) => i < nn ? cys()(morphTargetCoeffs[i].im) + 3 : 0);
    morphInterpLayer.selectAll("line.morph-interp-line")
        .attr("x2", (_, i) => i < nn ? cxs()(morphTargetCoeffs[i].re) : 0)
        .attr("y2", (_, i) => i < nn ? cys()(morphTargetCoeffs[i].im) : 0);
}

function syncBarFromCoeff() {
    if (lastSelectedCoeff < 0 || !selectedCoeffs.has(lastSelectedCoeff)) {
        if (selectedCoeffs.size > 0) lastSelectedCoeff = [...selectedCoeffs][0];
        else return;
    }
    const c = coefficients[lastSelectedCoeff];
    barTitle.textContent = coeffListLabel(selectedCoeffs);
    animPathSel.value = c.pathType;
    rebuildBarControls(c.pathType);
    const schema = PATH_PARAMS[c.pathType] || [];
    for (const p of schema) {
        const val = getCoeffParam(c, p.key, p);
        if (p.type === "toggle") {
            const btn = barInputs[p.key];
            if (btn) { btn.textContent = val ? p.labels[1] : p.labels[0]; btn.classList.toggle("active", !!val); }
        } else if (p.type === "select") {
            const sel = barInputs[p.key];
            if (sel) sel.value = val || p.default;
        } else {
            const inp = barInputs[p.key];
            if (inp) { const uiVal = p.toUI ? p.toUI(val) : val; inp.value = uiVal; const vs = barInputs[p.key + "_val"]; const fm = barInputs[p.key + "_fmt"]; if (vs && fm) vs.textContent = fm(uiVal); }
        }
    }
}

function readBarParams(pathType) {
    const schema = PATH_PARAMS[pathType] || [];
    const vals = {};
    for (const p of schema) {
        if (p.type === "toggle") {
            vals[p.key] = barInputs[p.key] ? barInputs[p.key].classList.contains("active") : p.default;
        } else if (p.type === "select") {
            vals[p.key] = barInputs[p.key] ? barInputs[p.key].value : p.default;
        } else {
            const raw = barInputs[p.key] ? parseFloat(barInputs[p.key].value) : null;
            vals[p.key] = raw !== null ? (p.fromUI ? p.fromUI(raw) : raw) : p.default;
        }
    }
    return vals;
}

function applyBarToSelection() {
    if (selectedCoeffs.size === 0) { uiBuzz(); return; }
    const pt = animPathSel.value;
    rebuildBarControls(pt);
    const vals = readBarParams(pt);

    for (const idx of selectedCoeffs) {
        const c = coefficients[idx];
        const oldType = c.pathType, oldR = c.radius, oldA = c.angle;
        const oldExtra = c.extra ? { ...c.extra } : {};

        // Write all params
        c.pathType = pt;
        const schema = PATH_PARAMS[pt] || [];
        for (const p of schema) setCoeffParam(c, p.key, vals[p.key] !== undefined ? vals[p.key] : p.default);

        const r = c.radius, a = c.angle;
        // Determine if extra params changed
        let extraChanged = false;
        for (const p of schema) {
            if (!_STD_KEYS.has(p.key) && c.extra[p.key] !== oldExtra[p.key]) { extraChanged = true; break; }
        }

        if (pt === "none") {
            c.curve = [{ re: c.re, im: c.im }];
            c.curveIndex = 0;
            animState.elapsedAtPause = null;
        } else if (pt === "random" || pt !== oldType || extraChanged) {
            const absR = r / 100 * coeffExtent();
            c.curve = computeCurve(c.re, c.im, pt, absR, a, c.extra);
            c.curveIndex = 0;
            animState.elapsedAtPause = null;
        } else if (r !== oldR || a !== oldA) {
            transformCoeffCurve(c, oldR, oldA);
        }
    }

    if (animState.elapsedAtPause == null) {
        updateAnimSeconds(0);
        playBtn.textContent = "â–¶ Play";
    }

    coeffLayer.selectAll("circle.coeff")
        .filter(cd => selectedCoeffs.has(cd._idx))
        .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
    coeffLayer.selectAll(".coeff-label")
        .filter(ld => selectedCoeffs.has(ld._idx))
        .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);

    renderCoeffTrails();
    if (typeof leftTab !== "undefined" && leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
}

// Preview/revert pattern: sliders show a live preview, click-away reverts,
// "Update Whole Selection" commits.

function previewBarToSelection() {
    if (selectedCoeffs.size === 0) { uiBuzz(); return; }
    // Snapshot on first preview interaction
    if (!barSnapshots) {
        barSnapshots = {};
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            barSnapshots[idx] = {
                pathType: c.pathType, radius: c.radius, speed: c.speed,
                angle: c.angle, ccw: c.ccw, extra: c.extra ? { ...c.extra } : {},
                curve: c.curve.map(pt => ({ ...pt })),
                curveIndex: c.curveIndex,
            };
        }
    }
    // Apply bar params as a preview (same logic as applyBarToSelection)
    const pt = animPathSel.value;
    rebuildBarControls(pt);
    const vals = readBarParams(pt);
    for (const idx of selectedCoeffs) {
        const c = coefficients[idx];
        const oldType = c.pathType, oldR = c.radius, oldA = c.angle;
        const oldExtra = c.extra ? { ...c.extra } : {};
        c.pathType = pt;
        const schema = PATH_PARAMS[pt] || [];
        for (const p of schema) setCoeffParam(c, p.key, vals[p.key] !== undefined ? vals[p.key] : p.default);
        const r = c.radius, a = c.angle;
        let extraChanged = false;
        for (const p of schema) {
            if (!_STD_KEYS.has(p.key) && c.extra[p.key] !== oldExtra[p.key]) { extraChanged = true; break; }
        }
        if (pt === "none") {
            c.curve = [{ re: c.re, im: c.im }];
            c.curveIndex = 0;
        } else if (pt === "random" || pt !== oldType || extraChanged) {
            const absR = r / 100 * coeffExtent();
            c.curve = computeCurve(c.re, c.im, pt, absR, a, c.extra);
            c.curveIndex = 0;
        } else if (r !== oldR || a !== oldA) {
            transformCoeffCurve(c, oldR, oldA);
        }
    }
    coeffLayer.selectAll("circle.coeff")
        .filter(cd => selectedCoeffs.has(cd._idx))
        .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
    coeffLayer.selectAll(".coeff-label")
        .filter(ld => selectedCoeffs.has(ld._idx))
        .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);
    renderCoeffTrails();
}

function revertBarPreview() {
    if (!barSnapshots) return;
    for (const idx in barSnapshots) {
        const i = parseInt(idx);
        if (i >= coefficients.length) continue;
        const snap = barSnapshots[idx];
        const c = coefficients[i];
        c.pathType = snap.pathType;
        c.radius = snap.radius;
        c.speed = snap.speed;
        c.angle = snap.angle;
        c.ccw = snap.ccw;
        c.extra = snap.extra || {};
        c.curve = snap.curve;
        c.curveIndex = snap.curveIndex;
    }
    barSnapshots = null;
    renderCoeffTrails();
    syncBarFromCoeff();
}

function commitBarPreview() {
    barSnapshots = null;
    animState.elapsedAtPause = null;
    updateAnimSeconds(0);
    playBtn.textContent = "â–¶ Play";
    renderCoeffTrails();
    if (typeof leftTab !== "undefined" && leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
}

function transformCoeffCurve(c, oldRadius, oldAngle) {
    if (c.pathType === "none") return;
    // For cloud (random) or orbital (spiral) paths, regenerate instead of transforming
    if (c.curve._isCloud || c.curve._isOrbital) {
        const absR = c.radius / 100 * coeffExtent();
        c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
        c.curveIndex = 0;
        return;
    }
    const home = c.curve[0];
    const newRadius = c.radius;
    const newAngle = c.angle;
    const absOld = oldRadius / 100 * coeffExtent();
    const absNew = newRadius / 100 * coeffExtent();
    const scale = absOld > 1e-12 ? absNew / absOld : 1;
    const dAngle = (newAngle - oldAngle) * 2 * Math.PI;
    const cosD = Math.cos(dAngle), sinD = Math.sin(dAngle);
    for (let k = 0; k < c.curve.length; k++) {
        let dx = c.curve[k].re - home.re, dy = c.curve[k].im - home.im;
        dx *= scale; dy *= scale;
        c.curve[k].re = home.re + dx * cosD - dy * sinD;
        c.curve[k].im = home.im + dx * sinD + dy * cosD;
    }
    // Snap coefficient to nearest curve point
    let bestD = Infinity, bestK = 0;
    for (let k = 0; k < c.curve.length; k++) {
        const dx = c.re - c.curve[k].re, dy = c.im - c.curve[k].im;
        const d = dx * dx + dy * dy;
        if (d < bestD) { bestD = d; bestK = k; }
    }
    c.re = c.curve[bestK].re;
    c.im = c.curve[bestK].im;
    c.curveIndex = bestK;
}

function updateAnimBar() {
    revertBarPreview();
    if (selectedCoeffs.size === 0) {
        barTitle.textContent = "<no selection>";
        barTitle.classList.add("empty");
        barControls.classList.add("dimmed");
        sel2pathBtn.disabled = true;
        return;
    }
    barTitle.classList.remove("empty");
    barControls.classList.remove("dimmed");
    sel2pathBtn.disabled = false;
    syncBarFromCoeff();
}

// Path dropdown change â€” preview (not commit)
animPathSel.addEventListener("change", function () {
    previewBarToSelection();
});

// Update Whole Selection button â€” commit preview or apply directly
sel2pathBtn.addEventListener("click", function () {
    if (barSnapshots) {
        commitBarPreview();
    } else {
        applyBarToSelection();
    }
});

// Play/Pause button â€” cycle: Play â†’ Pause â†’ Resume â†’ Pause â†’ â€¦
playBtn.addEventListener("click", function () {
    if (animState.playing) {
        stopAnimation();
        playBtn.textContent = "â–¶ Resume";
    } else {
        if (allAnimatedCoeffs().size === 0 && allAnimatedDCoeffs().size === 0 && !hasMorphMotion()) { uiBuzz(); return; }
        const resuming = animState.elapsedAtPause != null;
        if (trailsEnabled && !resuming) {
            trailData = [];
            finalTrailData = [];
            trailLayer.selectAll("path.trail-path").remove();
            if (finalTrailLayer) finalTrailLayer.selectAll("path.trail-path").remove();
        }
        startAnimation();
        renderCoeffTrails();
        playBtn.textContent = "â¸ Pause";
    }
});

// Home button: reset coefficients to their curve[0] (start) positions
document.getElementById("home-btn").addEventListener("click", function () {
    if (animState.playing) {
        stopAnimation();
    }
    animState.elapsedAtPause = null;
    playBtn.textContent = "â–¶ Play";
    for (let i = 0; i < coefficients.length; i++) {
        const c = coefficients[i];
        c.re = c.curve[0].re; c.im = c.curve[0].im;
        c.curveIndex = 0;
    }
    for (let i = 0; i < morphTargetCoeffs.length; i++) {
        const d = morphTargetCoeffs[i];
        d.re = d.curve[0].re; d.im = d.curve[0].im;
        d.curveIndex = 0;
    }
    morphMu = 0; morphTheta = 0;
    if (morphPanelInited && leftTab === "morph") {
        const muEl = document.getElementById("morph-mu-val");
        if (muEl) muEl.textContent = "Î¼=" + morphMu.toFixed(2);
        updateMorphPanelDDots();
        updateMorphMarkers();
    }
    if (trailsEnabled) {
        trailData = [];
        finalTrailData = [];
        trailLayer.selectAll("path.trail-path").remove();
        if (finalTrailLayer) finalTrailLayer.selectAll("path.trail-path").remove();
    }
    // Reset jiggle state
    jiggleOffsets = null;
    jiggleStep = -1;
    jiggleWalkCache = null;
    updateJiggleStatus();

    resetAudioState();
    resetBitmap();
    clearStatsData();
    renderCoeffTrails();
    renderCoefficients(); // full re-render (not just animated) so scale + positions are always correct
    solveRoots();
    renderDomainColoringThrottled();
    updateAnimSeconds(0);
    scrubSlider.value = 0;
    uiBuzz();
});

// Scrub slider: adds seconds to current elapsed time (only when paused)
const scrubSlider = document.getElementById("scrub-slider");
const animSecondsEl = document.getElementById("anim-seconds");

function advanceToElapsed(elapsed) {
    for (let i = 0; i < coefficients.length; i++) {
        const c = coefficients[i];
        if (c.pathType === "none") continue;
        const N = c.curve.length;
        const t = elapsed * c.speed * (c.ccw ? -1 : 1);
        const rawIdx = ((t % 1) + 1) % 1 * N;
        if (c.curve._isCloud) {
            const idx = Math.floor(rawIdx) % N;
            c.re = c.curve[idx].re;
            c.im = c.curve[idx].im;
            c.curveIndex = idx;
        } else {
            const lo = Math.floor(rawIdx) % N;
            const hi = (lo + 1) % N;
            const frac = rawIdx - Math.floor(rawIdx);
            c.re = c.curve[lo].re * (1 - frac) + c.curve[hi].re * frac;
            c.im = c.curve[lo].im * (1 - frac) + c.curve[hi].im * frac;
            c.curveIndex = lo;
        }
        if (c.curve._ditherSigmaPct) {
            const ds = c.curve._ditherSigmaPct / 100 * coeffExtent();
            const _cd = c.curve._ditherDist;
            c.re += _ditherRand(_cd) * ds; c.im += _ditherRand(_cd) * ds;
        }
    }
    advanceDNodesAlongCurves(elapsed);
    if (morphEnabled) {
        morphTheta = 2 * Math.PI * morphRate * elapsed;
        morphMu = 0.5 - 0.5 * Math.cos(morphTheta);
        const muEl = document.getElementById("morph-mu-val");
        if (muEl) muEl.textContent = "Î¼=" + morphMu.toFixed(2);
    }
    const animated = allAnimatedCoeffs();
    coeffLayer.selectAll("circle.coeff")
        .filter(cd => animated.has(cd._idx))
        .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
    coeffLayer.selectAll(".coeff-label")
        .filter(ld => animated.has(ld._idx))
        .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);
    if (morphPanelInited && leftTab === "morph") {
        const nn = Math.min(coefficients.length, morphTargetCoeffs.length);
        morphGhostLayer.selectAll("circle.morph-ghost")
            .attr("cx", (_, i) => i < nn ? cxs()(coefficients[i].re) : 0)
            .attr("cy", (_, i) => i < nn ? cys()(coefficients[i].im) : 0);
        morphGhostLayer.selectAll(".morph-ghost-label")
            .attr("x", (_, i) => i < nn ? cxs()(coefficients[i].re) + 10 : 0)
            .attr("y", (_, i) => i < nn ? cys()(coefficients[i].im) + 3 : 0);
        morphInterpLayer.selectAll("line.morph-interp-line")
            .attr("x1", (_, i) => i < nn ? cxs()(coefficients[i].re) : 0)
            .attr("y1", (_, i) => i < nn ? cys()(coefficients[i].im) : 0);
        updateMorphPanelDDots();
        updateMorphMarkers();
    }
    animState.elapsedAtPause = elapsed;
    updateAnimSeconds(elapsed);
    solveRootsThrottled();
    renderDomainColoringThrottled();
    updateListCoords();
    updateDListCoords();
}

function updateAnimSeconds(elapsed) {
    if (animSecondsEl) animSecondsEl.textContent = elapsed.toFixed(2) + "s";
}

let scrubBase = 0; // elapsed at start of scrub drag
scrubSlider.addEventListener("mousedown", function () {
    scrubBase = animState.elapsedAtPause || 0;
});
scrubSlider.addEventListener("touchstart", function () {
    scrubBase = animState.elapsedAtPause || 0;
});
scrubSlider.addEventListener("input", function () {
    // Only works when animation is not running
    if (animState.playing) { this.value = 0; return; }
    const scrubOffset = this.value / 1000; // slider value in ms â†’ seconds
    const elapsed = scrubBase + scrubOffset;
    advanceToElapsed(elapsed);
    if (elapsed > 0) playBtn.textContent = "â–¶ Resume";
});
scrubSlider.addEventListener("change", function () {
    // On release, reset slider to 0 (elapsed already committed by advanceToElapsed)
    this.value = 0;
});

// Trails toggle button
trailsBtn.addEventListener("click", function () {
    trailsEnabled = !trailsEnabled;
    this.classList.toggle("active", trailsEnabled);
    clearTrails();
    renderCoeffTrails();
});

// --- Path functions ---

function animPathFn(name, t, center, radius, extra) {
    const baseName = name.endsWith("-dither") ? name.slice(0, -7) : name;
    const w = 2 * Math.PI; // one full cycle per second (scaled by speed)
    const wt = w * t;
    switch (baseName) {
        case "circle":
            return { re: center.re + radius * Math.cos(wt), im: center.im + radius * Math.sin(wt) };
        case "horizontal":
            return { re: center.re + radius * Math.cos(wt), im: center.im };
        case "vertical":
            return { re: center.re, im: center.im + radius * Math.cos(wt) };
        case "spiral":
            // Orbital spiral â€” handled directly in computeCurve
            return center;
        case "figure8": {
            const d = 1 + Math.sin(wt) * Math.sin(wt);
            return {
                re: center.re + radius * Math.cos(wt) / d,
                im: center.im + radius * Math.sin(wt) * Math.cos(wt) / d
            };
        }
        case "lissajous": {
            const la = (extra && extra.freqA) || 3;
            const lb = (extra && extra.freqB) || 2;
            return {
                re: center.re + radius * Math.sin(la * wt + Math.PI / 4),
                im: center.im + radius * Math.sin(lb * wt)
            };
        }
        case "cardioid": {
            // r_polar = 0.5*(1 + cos(Î¸)), parametric
            const s = 0.5 * (1 + Math.cos(wt));
            return {
                re: center.re + radius * s * Math.cos(wt),
                im: center.im + radius * s * Math.sin(wt)
            };
        }
        case "astroid":
            // Hypocycloid with 4 cusps: cosÂ³, sinÂ³
            return {
                re: center.re + radius * Math.cos(wt) * Math.cos(wt) * Math.cos(wt),
                im: center.im + radius * Math.sin(wt) * Math.sin(wt) * Math.sin(wt)
            };
        case "deltoid":
            // Hypocycloid with 3 cusps
            return {
                re: center.re + radius * (2 * Math.cos(wt) + Math.cos(2 * wt)) / 3,
                im: center.im + radius * (2 * Math.sin(wt) - Math.sin(2 * wt)) / 3
            };
        case "rose": {
            // 3-petal rose r = cos(3Î¸)
            const rr = radius * Math.cos(3 * wt);
            return {
                re: center.re + rr * Math.cos(wt),
                im: center.im + rr * Math.sin(wt)
            };
        }
        case "epitrochoid":
            // Spirograph: R=3, r=1, d=1 â†’ 3-lobed, scaled to fit radius
            return {
                re: center.re + radius * (4 * Math.cos(wt) - Math.cos(4 * wt)) / 5,
                im: center.im + radius * (4 * Math.sin(wt) - Math.sin(4 * wt)) / 5
            };
        case "hypotrochoid":
            // Spirograph inner: R=5, r=2, d=1 â†’ 5-lobed
            return {
                re: center.re + radius * (3 * Math.cos(wt) + Math.cos(1.5 * wt)) / 4,
                im: center.im + radius * (3 * Math.sin(wt) - Math.sin(1.5 * wt)) / 4
            };
        case "butterfly": {
            // Butterfly curve (polar)
            const rb = Math.exp(Math.cos(wt)) - 2 * Math.cos(4 * wt) + Math.pow(Math.sin(wt / 12), 5);
            const scale = radius / 3.5; // normalize to roughly fit radius
            return {
                re: center.re + scale * rb * Math.cos(wt),
                im: center.im + scale * rb * Math.sin(wt)
            };
        }
        case "star": {
            // 5-pointed star (pentagram) via inner/outer radius alternation
            // 10 vertices: 5 outer, 5 inner, linearly interpolated
            const period = wt / (2 * Math.PI); // 0..1 per cycle
            const seg = ((period % 1) + 1) % 1; // normalized 0..1
            const idx = seg * 10;
            const vi = Math.floor(idx) % 10;
            const frac = idx - Math.floor(idx);
            const angle1 = (vi / 10) * 2 * Math.PI - Math.PI / 2;
            const angle2 = ((vi + 1) / 10) * 2 * Math.PI - Math.PI / 2;
            const r1 = (vi % 2 === 0) ? radius : radius * 0.38;
            const r2 = ((vi + 1) % 2 === 0) ? radius : radius * 0.38;
            return {
                re: center.re + r1 * Math.cos(angle1) * (1 - frac) + r2 * Math.cos(angle2) * frac,
                im: center.im + r1 * Math.sin(angle1) * (1 - frac) + r2 * Math.sin(angle2) * frac
            };
        }
        case "square": {
            // Square path, one full cycle
            const period = wt / (2 * Math.PI);
            const seg = ((period % 1) + 1) % 1; // 0..1
            let x, y;
            if (seg < 0.25)      { const f = seg / 0.25;       x =  1 - 2*f; y =  1; }
            else if (seg < 0.5)  { const f = (seg-0.25) / 0.25; x = -1;       y =  1 - 2*f; }
            else if (seg < 0.75) { const f = (seg-0.5) / 0.25;  x = -1 + 2*f; y = -1; }
            else                 { const f = (seg-0.75) / 0.25;  x =  1;       y = -1 + 2*f; }
            return { re: center.re + radius * x, im: center.im + radius * y };
        }
        case "hilbert": {
            // Moore curve (closed Hilbert variant) â€” order 4, 256 segments
            const ORDER_H = 4, N_H = 1 << (2 * ORDER_H); // 256
            const seg_h = ((((wt / (2 * Math.PI)) % 1) + 1) % 1) * N_H;
            const i0_h = Math.floor(seg_h) % N_H, i1_h = (i0_h + 1) % N_H;
            const fr_h = seg_h - Math.floor(seg_h);
            const p0_h = _mooreXY(i0_h, ORDER_H), p1_h = _mooreXY(i1_h, ORDER_H);
            return {
                re: center.re + radius * (p0_h[0] * (1 - fr_h) + p1_h[0] * fr_h),
                im: center.im + radius * (p0_h[1] * (1 - fr_h) + p1_h[1] * fr_h)
            };
        }
        case "peano": {
            // Peano curve (out-and-back for closure) â€” order 3, 729 points (1458 total with out-and-back)
            const ORDER_P = 3, N_P = Math.pow(3, 2 * ORDER_P); // 729 points
            const TOTAL_P = N_P * 2; // out and back
            const seg_p = ((((wt / (2 * Math.PI)) % 1) + 1) % 1) * TOTAL_P;
            let idx_p;
            if (seg_p < N_P) {
                idx_p = Math.floor(seg_p) % N_P;
            } else {
                idx_p = N_P - 1 - (Math.floor(seg_p - N_P) % N_P);
            }
            const idx_p2 = (seg_p < N_P)
                ? (Math.floor(seg_p) + 1 < N_P ? Math.floor(seg_p) + 1 : N_P - 1)
                : (idx_p > 0 ? idx_p - 1 : 0);
            const fr_p = seg_p - Math.floor(seg_p);
            const p0_p = _peanoXY(idx_p, ORDER_P), p1_p = _peanoXY(idx_p2, ORDER_P);
            return {
                re: center.re + radius * (p0_p[0] * (1 - fr_p) + p1_p[0] * fr_p),
                im: center.im + radius * (p0_p[1] * (1 - fr_p) + p1_p[1] * fr_p)
            };
        }
        case "sierpinski": {
            // Sierpinski arrowhead â€” order 5, 243 segments, out-and-back for closure
            const ORDER_S = 5, N_S = Math.pow(3, ORDER_S); // 243 points
            const TOTAL_S = N_S * 2; // out and back
            const seg_s = ((((wt / (2 * Math.PI)) % 1) + 1) % 1) * TOTAL_S;
            let idx_s, idx_s2;
            if (seg_s < N_S) {
                idx_s = Math.floor(seg_s) % N_S;
                idx_s2 = Math.min(idx_s + 1, N_S - 1);
            } else {
                idx_s = N_S - 1 - (Math.floor(seg_s - N_S) % N_S);
                idx_s2 = Math.max(idx_s - 1, 0);
            }
            const fr_s = seg_s - Math.floor(seg_s);
            const p0_s = _sierpinskiXY(idx_s, ORDER_S), p1_s = _sierpinskiXY(idx_s2, ORDER_S);
            return {
                re: center.re + radius * (p0_s[0] * (1 - fr_s) + p1_s[0] * fr_s),
                im: center.im + radius * (p0_s[1] * (1 - fr_s) + p1_s[1] * fr_s)
            };
        }
        case "random": {
            // Pre-generated Gaussian cloud â€” return the same point for a given t
            // (actual generation happens in computeCurve; animPathFn just places a point at center)
            return { re: center.re, im: center.im };
        }
        default:
            return center;
    }
}

// --- Space-filling curve helpers ---

// Moore curve (closed Hilbert variant) via L-system turtle â€” guarantees continuous path
// Axiom: LFL+F+LFL, L â†’ -RF+LFL+FR-, R â†’ +LF-RFR-FL+
// + = turn right (CW), - = turn left (CCW)
function _mooreXY(d, order) {
    if (!_mooreXY._cache || _mooreXY._order !== order) {
        // Expand L-system string
        let str = "LFL+F+LFL";
        for (let i = 0; i < order - 1; i++) {
            let next = "";
            for (const ch of str) {
                if (ch === 'L') next += "-RF+LFL+FR-";
                else if (ch === 'R') next += "+LF-RFR-FL+";
                else next += ch;
            }
            str = next;
        }
        // Walk turtle â€” start facing up, + = CW, - = CCW
        const dx = [1, 0, -1, 0], dy = [0, 1, 0, -1];
        let x = 0, y = 0, angle = 1; // 1 = up
        let minX = 0, maxX = 0, minY = 0, maxY = 0;
        const raw = [[0, 0]];
        for (const ch of str) {
            if (ch === 'F') {
                x += dx[angle]; y += dy[angle];
                raw.push([x, y]);
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
            } else if (ch === '+') {
                angle = (angle + 3) % 4; // CW
            } else if (ch === '-') {
                angle = (angle + 1) % 4; // CCW
            }
        }
        // Normalize to [-1, 1]
        const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
        const span = Math.max(maxX - minX, maxY - minY) || 1;
        _mooreXY._cache = raw.map(([px, py]) => [2 * (px - cx) / span, 2 * (py - cy) / span]);
        _mooreXY._order = order;
    }
    const pts = _mooreXY._cache;
    return pts[((d % pts.length) + pts.length) % pts.length];
}
// Peano curve via L-system turtle â€” guarantees continuous path
// Axiom: L, L â†’ LFRFL-F-RFLFR+F+LFRFL, R â†’ RFLFR+F+LFRFL-F-RFLFR
function _peanoXY(d, order) {
    if (!_peanoXY._cache || _peanoXY._order !== order) {
        let str = "L";
        for (let i = 0; i < order; i++) {
            let next = "";
            for (const ch of str) {
                if (ch === 'L') next += "LFRFL-F-RFLFR+F+LFRFL";
                else if (ch === 'R') next += "RFLFR+F+LFRFL-F-RFLFR";
                else next += ch;
            }
            str = next;
        }
        const dx = [1, 0, -1, 0], dy = [0, 1, 0, -1];
        let x = 0, y = 0, angle = 0; // start facing right
        let minX = 0, maxX = 0, minY = 0, maxY = 0;
        const raw = [[0, 0]];
        for (const ch of str) {
            if (ch === 'F') {
                x += dx[angle]; y += dy[angle];
                raw.push([x, y]);
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
            } else if (ch === '+') {
                angle = (angle + 3) % 4; // CW
            } else if (ch === '-') {
                angle = (angle + 1) % 4; // CCW
            }
        }
        const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
        const span = Math.max(maxX - minX, maxY - minY) || 1;
        _peanoXY._cache = raw.map(([px, py]) => [2 * (px - cx) / span, 2 * (py - cy) / span]);
        _peanoXY._order = order;
    }
    const pts = _peanoXY._cache;
    return pts[((d % pts.length) + pts.length) % pts.length];
}

// Sierpinski arrowhead curve via L-system turtle â€” triangle-filling path
// Axiom: A (even order) or B (odd order), A â†’ B-A-B, B â†’ A+B+A
// + = turn left 60Â°, - = turn right 60Â°, F at depth 0
// 3^order segments, NOT naturally closed â€” animation uses out-and-back
function _sierpinskiXY(d, order) {
    if (!_sierpinskiXY._cache || _sierpinskiXY._order !== order) {
        const n = Math.pow(3, order); // 3^order segments
        let moves = "";
        function expand(ch, depth) {
            if (depth === 0) { moves += "F"; return; }
            if (ch === "A") {
                expand("B", depth - 1); moves += "-";
                expand("A", depth - 1); moves += "-";
                expand("B", depth - 1);
            } else {
                expand("A", depth - 1); moves += "+";
                expand("B", depth - 1); moves += "+";
                expand("A", depth - 1);
            }
        }
        expand(order % 2 === 0 ? "A" : "B", order);
        let angle = 0;
        if (order % 2 === 1) angle = 1;
        let x = 0, y = 0;
        let minX = 0, maxX = 0, minY = 0, maxY = 0;
        const raw = [[0, 0]];
        for (const ch of moves) {
            if (ch === "F") {
                const a = angle * Math.PI / 3;
                x += Math.cos(a); y += Math.sin(a);
                raw.push([x, y]);
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
            } else if (ch === "+") {
                angle = (angle + 1) % 6;
            } else if (ch === "-") {
                angle = ((angle - 1) % 6 + 6) % 6;
            }
        }
        const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
        const span = Math.max(maxX - minX, maxY - minY) || 1;
        _sierpinskiXY._cache = raw.map(([px, py]) => [2 * (px - cx) / span, 2 * (py - cy) / span]);
        _sierpinskiXY._order = order;
        _sierpinskiXY._n = n; // number of segments (n+1 points)
    }
    const pts = _sierpinskiXY._cache;
    return pts[((d % pts.length) + pts.length) % pts.length];
}

// --- Animation engine ---

const COEFF_TRAIL_SAMPLES = 200; // points per analytical curve (basic paths)
const COEFF_TRAIL_SAMPLES_HI = 1500; // points for space-filling curves (need more to capture zigzags)
const _HIRES_PATHS = new Set(["hilbert", "peano", "sierpinski", "spiral"]);

// Box-Muller transform for Gaussian random numbers
function _gaussRand() {
    let u, v;
    do { u = Math.random(); } while (u === 0);
    v = Math.random();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}
// Dither helper: returns random offset based on distribution type
function _ditherRand(dist) {
    return dist === "uniform" ? (Math.random() - 0.5) * 2 : _gaussRand();
}

// Compute a closed curve of absolute positions for a coefficient.
// curve[0] = {homeRe, homeIm} (the "home" position). Angle rotates the shape.
function computeCurve(homeRe, homeIm, pathType, radius, angle, extra) {
    const baseType = pathType.endsWith("-dither") ? pathType.slice(0, -7) : pathType;
    const N = _HIRES_PATHS.has(baseType) ? COEFF_TRAIL_SAMPLES_HI : COEFF_TRAIL_SAMPLES;
    return computeCurveN(homeRe, homeIm, pathType, radius, angle, extra, N);
}

function computeCurveN(homeRe, homeIm, pathType, radius, angle, extra, N) {
    const baseType = pathType.endsWith("-dither") ? pathType.slice(0, -7) : pathType;

    // Random path: pre-generate Gaussian point cloud (no connecting lines)
    if (baseType === "random") {
        const sigma = radius; // already scaled to absolute units by caller
        const curve = new Array(N);
        for (let k = 0; k < N; k++) {
            curve[k] = { re: homeRe + _gaussRand() * sigma,
                          im: homeIm + _gaussRand() * sigma };
        }
        curve._isCloud = true; // flag for rendering as dots
        return curve;
    }

    // Spiral path: orbital around the origin (0+0i)
    // Coefficient spirals from its current orbit to a wider/tighter orbit and back.
    if (baseType === "spiral") {
        const mult = (extra && extra.mult != null) ? extra.mult : 1.5;
        const turns = (extra && extra.turns) || 2;
        const R0 = Math.sqrt(homeRe * homeRe + homeIm * homeIm);
        const theta0 = Math.atan2(homeIm, homeRe);
        const R1 = R0 * mult;
        const totalTurns = 2 * turns + 1;
        const t1 = turns / totalTurns;        // end of outward spiral
        const t2 = (turns + 1) / totalTurns;  // end of revolution at target
        const W = 2 * Math.PI;

        const curve = new Array(N);
        for (let k = 0; k < N; k++) {
            const t = k / N;
            let r, theta;
            if (t <= t1) {
                const frac = t1 > 0 ? t / t1 : 0;
                r = R0 + (R1 - R0) * frac;
                theta = theta0 + frac * turns * W;
            } else if (t <= t2) {
                const frac = (t2 > t1) ? (t - t1) / (t2 - t1) : 0;
                r = R1;
                theta = theta0 + (turns + frac) * W;
            } else {
                const frac = (1 > t2) ? (t - t2) / (1 - t2) : 0;
                r = R1 + (R0 - R1) * frac;
                theta = theta0 + (turns + 1 + frac * turns) * W;
            }
            curve[k] = { re: r * Math.cos(theta), im: r * Math.sin(theta) };
        }
        curve._isOrbital = true; // flag: absolute positions, not relative to home
        if (pathType.endsWith("-dither")) {
            let _ds = (extra && extra.sigma != null) ? extra.sigma : 0.2;
            if (_ds > 1) _ds = _ds / 10; // backward compat: old 0â€“10 â†’ new 0â€“1
            curve._ditherSigmaPct = _ds;
            curve._ditherDist = (extra && extra.ditherDist) || "normal";
        }
        return curve;
    }

    // C-Ellipse: ellipse with vertices at coefficient home and origin (0+0i)
    if (baseType === "c-ellipse") {
        const w = (extra && extra.width != null) ? extra.width : 50;
        // Center = midpoint of home and origin
        const cx = homeRe / 2, cy = homeIm / 2;
        // Semi-major axis = half distance from home to origin
        const a = Math.sqrt(homeRe * homeRe + homeIm * homeIm) / 2;
        // Semi-minor axis = width% of semi-major
        const b = a * (w / 100);
        // Major axis direction: from origin to home
        const ux = a > 0 ? homeRe / (2 * a) : 1;
        const uy = a > 0 ? homeIm / (2 * a) : 0;
        // Perpendicular direction
        const vx = -uy, vy = ux;
        const W = 2 * Math.PI;
        const curve = new Array(N);
        for (let k = 0; k < N; k++) {
            const t = k / N;
            const wt = W * t;
            curve[k] = {
                re: cx + a * Math.cos(wt) * ux + b * Math.sin(wt) * vx,
                im: cy + a * Math.cos(wt) * uy + b * Math.sin(wt) * vy
            };
        }
        curve._isOrbital = true;
        if (pathType.endsWith("-dither")) {
            let _ds2 = (extra && extra.sigma != null) ? extra.sigma : 0.2;
            if (_ds2 > 1) _ds2 = _ds2 / 10; // backward compat: old 0â€“10 â†’ new 0â€“1
            curve._ditherSigmaPct = _ds2;
            curve._ditherDist = (extra && extra.ditherDist) || "normal";
        }
        return curve;
    }

    const origin = { re: 0, im: 0 };
    const d0 = animPathFn(pathType, 0, origin, radius, extra);
    const cosA = Math.cos(angle * 2 * Math.PI);
    const sinA = Math.sin(angle * 2 * Math.PI);
    const curve = new Array(N);
    for (let k = 0; k < N; k++) {
        const t = k / N;
        const pt = animPathFn(pathType, t, origin, radius, extra);
        const dx = pt.re - d0.re, dy = pt.im - d0.im;
        curve[k] = { re: homeRe + dx * cosA - dy * sinA,
                      im: homeIm + dx * sinA + dy * cosA };
    }
    if (pathType.endsWith("-dither")) {
        let _ds3 = (extra && extra.sigma != null) ? extra.sigma : 0.2;
        if (_ds3 > 1) _ds3 = _ds3 / 10; // backward compat: old 0â€“10 â†’ new 0â€“1
        curve._ditherSigmaPct = _ds3;
        curve._ditherDist = (extra && extra.ditherDist) || "normal";
    }
    return curve;
}

// Recompute curves using the coefficient's current position as home (curve[0]).
// The coefficient is always on the new path. Angle and radius come from the path settings.
function startAnimation() {
    if (fastModeActive) return;
    const animated = allAnimatedCoeffs();
    const animatedD = allAnimatedDCoeffs();
    if (animated.size === 0 && animatedD.size === 0 && !hasMorphMotion()) return;

    const resuming = animState.elapsedAtPause != null;

    if (!resuming) {
        for (const idx of animated) {
            const c = coefficients[idx];
            c.re = c.curve[0].re; c.im = c.curve[0].im;
            c.curveIndex = 0;
        }
        for (const idx of animatedD) {
            const d = morphTargetCoeffs[idx];
            d.re = d.curve[0].re; d.im = d.curve[0].im;
            d.curveIndex = 0;
        }
    }

    animState.playing = true;
    if (resuming) {
        animState.startTime = performance.now() - animState.elapsedAtPause * 1000;
        animState.elapsedAtPause = null;
    } else {
        animState.startTime = performance.now();
    }
    // Initialize jiggle for non-fast-mode animation
    if (jiggleMode !== "none") {
        computeJiggleForStep(0);
    }
    animState.rafId = requestAnimationFrame(animLoop);
}

function animLoop(now) {
    if (!animState.playing) return;
    if (fastModeActive) return;
    const elapsed = (now - animState.startTime) / 1000;

    for (let i = 0; i < coefficients.length; i++) {
        const c = coefficients[i];
        if (c.pathType === "none") continue;
        const N = c.curve.length;
        const t = elapsed * c.speed * (c.ccw ? -1 : 1);
        const rawIdx = ((t % 1) + 1) % 1 * N;
        if (c.curve._isCloud) {
            // Random cloud: snap to nearest point (no interpolation)
            const idx = Math.floor(rawIdx) % N;
            c.re = c.curve[idx].re;
            c.im = c.curve[idx].im;
            c.curveIndex = idx;
        } else {
            const lo = Math.floor(rawIdx) % N;
            const hi = (lo + 1) % N;
            const frac = rawIdx - Math.floor(rawIdx);
            c.re = c.curve[lo].re * (1 - frac) + c.curve[hi].re * frac;
            c.im = c.curve[lo].im * (1 - frac) + c.curve[hi].im * frac;
            c.curveIndex = lo;
        }
        if (c.curve._ditherSigmaPct) {
            const ds = c.curve._ditherSigmaPct / 100 * coeffExtent();
            const _cd = c.curve._ditherDist;
            c.re += _ditherRand(_cd) * ds; c.im += _ditherRand(_cd) * ds;
        }
    }

    // Advance D-nodes along their paths
    advanceDNodesAlongCurves(elapsed);

    // Jiggle: recompute if step changed (pure function of elapsed time)
    if (jiggleMode !== "none") {
        computeJiggleForStep(jiggleStepFromElapsed(elapsed));
    }

    if (morphEnabled) {
        morphTheta = 2 * Math.PI * morphRate * elapsed;
        morphMu = 0.5 - 0.5 * Math.cos(morphTheta);
        const muEl = document.getElementById("morph-mu-val");
        if (muEl) muEl.textContent = "Î¼=" + morphMu.toFixed(2);
    }

    // Update morph panel visuals if visible
    if (morphPanelInited && leftTab === "morph") {
        const nn = Math.min(coefficients.length, morphTargetCoeffs.length);
        morphGhostLayer.selectAll("circle.morph-ghost")
            .attr("cx", (_, i) => i < nn ? cxs()(coefficients[i].re) : 0)
            .attr("cy", (_, i) => i < nn ? cys()(coefficients[i].im) : 0);
        morphGhostLayer.selectAll(".morph-ghost-label")
            .attr("x", (_, i) => i < nn ? cxs()(coefficients[i].re) + 10 : 0)
            .attr("y", (_, i) => i < nn ? cys()(coefficients[i].im) + 3 : 0);
        morphInterpLayer.selectAll("line.morph-interp-line")
            .attr("x1", (_, i) => i < nn ? cxs()(coefficients[i].re) : 0)
            .attr("y1", (_, i) => i < nn ? cys()(coefficients[i].im) : 0);
        updateMorphPanelDDots();
        updateMorphMarkers();
    }

    const animated = allAnimatedCoeffs();
    coeffLayer.selectAll("circle.coeff")
        .filter(cd => animated.has(cd._idx))
        .attr("cx", cd => cxs()(cd.re)).attr("cy", cd => cys()(cd.im));
    coeffLayer.selectAll(".coeff-label")
        .filter(ld => animated.has(ld._idx))
        .attr("x", ld => cxs()(ld.re) + 12).attr("y", ld => cys()(ld.im) + 4);

    autoScaleCoeffPanel();
    solveRootsThrottled();
    renderDomainColoringThrottled();
    recordTick();
    updateListCoords();
    updateDListCoords();
    updateAnimSeconds(elapsed);

    animState.rafId = requestAnimationFrame(animLoop);
}

function stopAnimation() {
    if (animState.playing) {
        animState.elapsedAtPause = (performance.now() - animState.startTime) / 1000;
    }
    animState.playing = false;
    if (animState.rafId) {
        cancelAnimationFrame(animState.rafId);
        animState.rafId = null;
    }
    if (anySoundEnabled()) resetAudioState();
}

// --- Coefficient chain line (shown during any root drag) ---

function updateCoeffChainLine() {
    const xScale = cxs(), yScale = cys();
    const pts = coefficients.map(c => xScale(c.re) + "," + yScale(c.im)).join(" ");
    coeffChainLine.attr("points", pts);
}

// --- Render coefficients ---

function renderCoefficients() {
    // Auto-scale coeff panel to fit all coefficients
    const needed = computeRange(coefficients);
    updatePanelRange(coeffSvg, panels.coeff, needed);

    const n = coefficients.length;
    for (let i = 0; i < n; i++) coefficients[i]._idx = i;

    const circles = coeffLayer.selectAll("circle.coeff").data(coefficients, d => d._idx);

    circles.enter()
        .append("circle")
        .attr("class", "coeff")
        .attr("r", 10)
        .attr("stroke", "#fff")
        .call(drag)
        .on("contextmenu", function(event, d) { openCoeffCtx(event, d._idx); })
        .on("mouseover", function (event, d) { showTooltip(event, d.re, d.im); })
        .on("mouseout", hideTooltip)
      .merge(circles)
        .attr("cx", d => cxs()(d.re))
        .attr("cy", d => cys()(d.im))
        .attr("fill", (_, i) => coeffColor(i, n));

    circles.exit().remove();

    const labels = coeffLayer.selectAll(".coeff-label").data(coefficients, d => d._idx);

    labels.enter()
        .append("text")
        .attr("class", "coeff-label")
      .merge(labels)
        .attr("x", d => cxs()(d.re) + 12)
        .attr("y", d => cys()(d.im) + 4)
        .text((_, i) => `c${subscript(n - 1 - i)}`);

    labels.exit().remove();
}

function subscript(n) {
    const digits = "â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰";
    return String(n).split("").map(d => digits[+d]).join("");
}

// --- Morph panel rendering ---

let morphDragMoved = false;
let morphDragStartX = 0, morphDragStartY = 0;
const morphDrag = d3.drag()
    .on("start", function (event) {
        morphDragMoved = false;
        morphDragStartX = event.x;
        morphDragStartY = event.y;
        d3.select(this).raise().classed("dragging", true);
    })
    .on("drag", function (event, d) {
        if (!morphDragMoved && Math.hypot(event.x - morphDragStartX, event.y - morphDragStartY) < CLICK_DEAD_ZONE) return;
        morphDragMoved = true;
        const idx = d._idx;
        const newRe = cxs().invert(event.x);
        const newIm = cys().invert(event.y);
        if (selectedMorphCoeffs.has(idx) && selectedMorphCoeffs.size > 1) {
            // Group drag: apply delta to all selected D-nodes
            const deltaRe = newRe - d.re;
            const deltaIm = newIm - d.im;
            for (const si of selectedMorphCoeffs) {
                const mc = morphTargetCoeffs[si];
                mc.re += deltaRe; mc.im += deltaIm;
                mc.curve = [{ re: mc.re, im: mc.im }];
            }
            morphLayer.selectAll("circle.morph-coeff")
                .attr("cx", dd => cxs()(dd.re)).attr("cy", dd => cys()(dd.im));
            morphLayer.selectAll(".morph-label")
                .attr("x", dd => cxs()(dd.re) + 12).attr("y", dd => cys()(dd.im) + 4);
            if (morphInterpLayer) {
                const nD = morphTargetCoeffs.length;
                morphInterpLayer.selectAll("line.morph-interp-line")
                    .attr("x2", (_, j) => j < nD ? cxs()(morphTargetCoeffs[j].re) : 0)
                    .attr("y2", (_, j) => j < nD ? cys()(morphTargetCoeffs[j].im) : 0);
                morphInterpLayer.selectAll("circle.morph-interp-marker")
                    .attr("cx", (_, j) => { if (j >= nD) return 0; const p = morphInterpPoint(coefficients[j].re, coefficients[j].im, morphTargetCoeffs[j].re, morphTargetCoeffs[j].im, morphTheta, morphPathType, morphPathCcw, morphEllipseMinor); return cxs()(p.re); })
                    .attr("cy", (_, j) => { if (j >= nD) return 0; const p = morphInterpPoint(coefficients[j].re, coefficients[j].im, morphTargetCoeffs[j].re, morphTargetCoeffs[j].im, morphTheta, morphPathType, morphPathCcw, morphEllipseMinor); return cys()(p.im); });
            }
        } else {
            // Single drag
            d.re = newRe; d.im = newIm;
            d.curve = [{ re: d.re, im: d.im }];
            d3.select(this).attr("cx", event.x).attr("cy", event.y);
            morphLayer.selectAll(".morph-label")
                .filter(ld => ld._idx === d._idx)
                .attr("x", event.x + 12).attr("y", event.y + 4);
            if (morphInterpLayer) {
                const i = d._idx;
                morphInterpLayer.selectAll("line.morph-interp-line")
                    .filter((_, j) => j === i)
                    .attr("x2", event.x).attr("y2", event.y);
                const _mp = morphInterpPoint(coefficients[i].re, coefficients[i].im, d.re, d.im, morphTheta, morphPathType, morphPathCcw, morphEllipseMinor);
                morphInterpLayer.selectAll("circle.morph-interp-marker")
                    .filter((_, j) => j === i)
                    .attr("cx", cxs()(_mp.re))
                    .attr("cy", cys()(_mp.im));
            }
        }
        if (morphEnabled) solveRootsThrottled();
    })
    .on("end", function (event, d) {
        d3.select(this).classed("dragging", false);
        if (!morphDragMoved) {
            // Click: toggle selection (mutually exclusive: clear C-nodes and roots)
            clearCoeffSelection();
            clearRootSelection();
            const idx = d._idx;
            if (selectedMorphCoeffs.has(idx)) {
                selectedMorphCoeffs.delete(idx);
            } else {
                selectedMorphCoeffs.add(idx);
            }
            updateMorphSelectionVisual();
        }
    });

function renderMorphPanel() {
    if (!morphPanelInited) initMorphPanel();
    if (!morphTargetCoeffs.length) return;

    const n = coefficients.length;
    const nD = morphTargetCoeffs.length;

    // Tag with _idx for d3 key
    for (let i = 0; i < n; i++) coefficients[i]._idx = i;
    for (let i = 0; i < nD; i++) morphTargetCoeffs[i]._idx = i;

    // Ghost layer: C coefficients (faint, non-interactive)
    const ghosts = morphGhostLayer.selectAll("circle.morph-ghost").data(coefficients, d => d._idx);
    ghosts.enter()
        .append("circle")
        .attr("class", "morph-ghost")
        .attr("r", 8)
      .merge(ghosts)
        .attr("cx", d => cxs()(d.re))
        .attr("cy", d => cys()(d.im))
        .attr("fill", (_, i) => coeffColor(i, n))
        .attr("stroke", (_, i) => coeffColor(i, n));
    ghosts.exit().remove();

    const ghostLabels = morphGhostLayer.selectAll(".morph-ghost-label").data(coefficients, d => d._idx);
    ghostLabels.enter()
        .append("text")
        .attr("class", "morph-ghost-label")
      .merge(ghostLabels)
        .attr("x", d => cxs()(d.re) + 10)
        .attr("y", d => cys()(d.im) + 3)
        .text((_, i) => `c${subscript(n - 1 - i)}`);
    ghostLabels.exit().remove();

    // D layer: morph target coefficients (full color, draggable)
    const dots = morphLayer.selectAll("circle.morph-coeff").data(morphTargetCoeffs, d => d._idx);
    dots.enter()
        .append("circle")
        .attr("class", "morph-coeff")
        .attr("r", 10)
        .attr("stroke", "#fff")
        .call(morphDrag)
        .on("contextmenu", function(event, d) { openDNodeCtx(event, d._idx); })
      .merge(dots)
        .attr("cx", d => cxs()(d.re))
        .attr("cy", d => cys()(d.im))
        .attr("fill", (_, i) => coeffColor(i, nD))
        .classed("selected", d => selectedMorphCoeffs.has(d._idx));
    dots.exit().remove();

    const dLabels = morphLayer.selectAll(".morph-label").data(morphTargetCoeffs, d => d._idx);
    dLabels.enter()
        .append("text")
        .attr("class", "morph-label")
      .merge(dLabels)
        .attr("x", d => cxs()(d.re) + 12)
        .attr("y", d => cys()(d.im) + 4)
        .text((_, i) => `d${subscript(nD - 1 - i)}`);
    dLabels.exit().remove();

    // Interpolation lines: dashed from C[i] to D[i]
    const lines = morphInterpLayer.selectAll("line.morph-interp-line")
        .data(coefficients.slice(0, nD), d => d._idx);
    lines.enter()
        .append("line")
        .attr("class", "morph-interp-line")
      .merge(lines)
        .attr("x1", d => cxs()(d.re))
        .attr("y1", d => cys()(d.im))
        .attr("x2", (_, i) => cxs()(morphTargetCoeffs[i].re))
        .attr("y2", (_, i) => cys()(morphTargetCoeffs[i].im))
        .attr("stroke", (_, i) => coeffColor(i, n))
        .attr("stroke-opacity", 0.3)
        .attr("stroke-dasharray", "4,3");
    lines.exit().remove();

    // Interpolated position markers: position along C-D path
    const markers = morphInterpLayer.selectAll("circle.morph-interp-marker")
        .data(coefficients.slice(0, nD), d => d._idx);
    markers.enter()
        .append("circle")
        .attr("class", "morph-interp-marker")
        .attr("r", 5)
      .merge(markers)
        .attr("cx", (d, i) => { const p = morphInterpPoint(d.re, d.im, morphTargetCoeffs[i].re, morphTargetCoeffs[i].im, morphTheta, morphPathType, morphPathCcw, morphEllipseMinor); return cxs()(p.re); })
        .attr("cy", (d, i) => { const p = morphInterpPoint(d.re, d.im, morphTargetCoeffs[i].re, morphTargetCoeffs[i].im, morphTheta, morphPathType, morphPathCcw, morphEllipseMinor); return cys()(p.im); })
        .attr("fill", (_, i) => coeffColor(i, n))
        .attr("stroke", "#fff")
        .attr("stroke-width", 1);
    markers.exit().remove();

    // Update mu display
    const muEl = document.getElementById("morph-mu-val");
    if (muEl) muEl.textContent = "Î¼=" + morphMu.toFixed(2);
}

// --- Final panel: shows actual coefficients sent to the solver ---
let finalPanelInited = false;
let finalSvg, finalLayer, finalTrailLayer;

function initFinalPanel() {
    finalSvg = d3.select("#final-panel");
    finalTrailLayer = finalSvg.append("g").attr("class", "final-trail-layer");
    finalLayer = finalSvg.append("g");
    finalPanelInited = true;
}

function renderFinalPanel() {
    if (!finalPanelInited) initFinalPanel();
    const n = coefficients.length;
    const nD = morphTargetCoeffs.length;
    const doBlend = morphEnabled && nD === n;

    const finalCoeffs = [];
    for (let i = 0; i < n; i++) {
        const c = coefficients[i];
        let re, im;
        if (doBlend) {
            const d = morphTargetCoeffs[i];
            const mp = morphInterpPoint(c.re, c.im, d.re, d.im, morphTheta, morphPathType, morphPathCcw, morphEllipseMinor);
            re = mp.re;
            im = mp.im;
        } else {
            re = c.re;
            im = c.im;
        }
        const jOff = jiggleOffsets ? jiggleOffsets.get(i) : undefined;
        if (jOff) { re += jOff.re; im += jOff.im; }
        finalCoeffs.push({ re, im, _idx: i });
    }

    // Resize SVG to container
    const container = document.getElementById("final-container");
    if (!container) return;
    const w = container.clientWidth, h = container.clientHeight;
    if (w <= 0 || h <= 0) return;
    finalSvg.attr("width", w).attr("height", h);

    // Dots (read-only, no drag)
    const dots = finalLayer.selectAll("circle.final-coeff")
        .data(finalCoeffs, d => d._idx);
    dots.enter()
        .append("circle").attr("class", "final-coeff")
        .attr("r", 8).attr("stroke", "#fff").attr("stroke-width", 1)
      .merge(dots)
        .attr("cx", d => cxs()(d.re))
        .attr("cy", d => cys()(d.im))
        .attr("fill", (_, i) => coeffColor(i, n));
    dots.exit().remove();

    // Labels
    const labels = finalLayer.selectAll("text.final-label")
        .data(finalCoeffs, d => d._idx);
    labels.enter()
        .append("text").attr("class", "final-label")
        .attr("font-size", 10).attr("fill", "#ccc")
      .merge(labels)
        .attr("x", d => cxs()(d.re) + 12)
        .attr("y", d => cys()(d.im) + 4)
        .text((_, i) => `c${subscript(n - 1 - i)}`);
    labels.exit().remove();

    // Render trails on the final panel
    if (trailsEnabled && finalTrailData.length > 0) renderFinalTrails();
}

function renderFinalTrails() {
    if (!finalTrailLayer) return;
    const xScale = cxs(), yScale = cys();
    const n = finalTrailData.length;
    const jumpThresh = panels.coeff.range * 0.3;
    const paths = finalTrailLayer.selectAll("path.trail-path").data(finalTrailData);
    paths.enter()
        .append("path")
        .attr("class", "trail-path")
      .merge(paths)
        .attr("d", pts => {
            if (pts.length < 2) return "";
            let d = `M${xScale(pts[0].re)},${yScale(pts[0].im)}`;
            for (let j = 1; j < pts.length; j++) {
                const dist = Math.hypot(pts[j].re - pts[j-1].re, pts[j].im - pts[j-1].im);
                const cmd = dist > jumpThresh ? "M" : "L";
                d += `${cmd}${xScale(pts[j].re)},${yScale(pts[j].im)}`;
            }
            return d;
        })
        .attr("stroke", (_, i) => coeffColor(i, n));
    paths.exit().remove();
}

function updateMorphMarkers() {
    if (!morphPanelInited || !morphInterpLayer) return;
    const nn = Math.min(coefficients.length, morphTargetCoeffs.length);
    morphInterpLayer.selectAll("circle.morph-interp-marker")
        .attr("cx", (_, i) => { if (i >= nn) return 0; const p = morphInterpPoint(coefficients[i].re, coefficients[i].im, morphTargetCoeffs[i].re, morphTargetCoeffs[i].im, morphTheta, morphPathType, morphPathCcw, morphEllipseMinor); return cxs()(p.re); })
        .attr("cy", (_, i) => { if (i >= nn) return 0; const p = morphInterpPoint(coefficients[i].re, coefficients[i].im, morphTargetCoeffs[i].re, morphTargetCoeffs[i].im, morphTheta, morphPathType, morphPathCcw, morphEllipseMinor); return cys()(p.im); });
}

// --- Root drag behavior (roots â†’ coefficients) ---

let rootDragMoved = false;
let rootDragStartX = 0, rootDragStartY = 0;
const rootDrag = d3.drag()
    .on("start", function (event) {
        rootDragMoved = false;
        rootDragStartX = event.x;
        rootDragStartY = event.y;
        d3.select(this).raise().classed("dragging", true);
    })
    .on("drag", function (event, d) {
        if (!rootDragMoved && Math.hypot(event.x - rootDragStartX, event.y - rootDragStartY) < CLICK_DEAD_ZONE) return;
        rootDragMoved = true;
        const newRe = rxs().invert(event.x);
        const newIm = rys().invert(event.y);
        const idx = d._idx;

        if (selectedRoots.has(idx) && selectedRoots.size > 1) {
            // Group drag: apply delta to all selected roots
            const deltaRe = newRe - d.re;
            const deltaIm = newIm - d.im;
            for (const si of selectedRoots) {
                currentRoots[si].re += deltaRe;
                currentRoots[si].im += deltaIm;
            }
            rootsLayer.selectAll("circle.root")
                .attr("cx", rd => rxs()(rd.re)).attr("cy", rd => rys()(rd.im));
        } else {
            d.re = newRe;
            d.im = newIm;
            d3.select(this).attr("cx", rxs()(d.re)).attr("cy", rys()(d.im));
        }
        showTooltip(event.sourceEvent, d.re, d.im);
        autoScaleRootsPanel();
        // Recompute coefficients from current roots (all client-side)
        const rootsForCoeffs = currentRoots.map(r => ({ re: r.re, im: r.im }));
        const newCoeffs = rootsToCoefficients(rootsForCoeffs);
        // Update coefficient positions in-place, preserving curves and path assignments
        for (let ci = 0; ci < newCoeffs.length; ci++) {
            const deltaRe = newCoeffs[ci].re - coefficients[ci].re;
            const deltaIm = newCoeffs[ci].im - coefficients[ci].im;
            coefficients[ci].re = newCoeffs[ci].re;
            coefficients[ci].im = newCoeffs[ci].im;
            for (const pt of coefficients[ci].curve) {
                pt.re += deltaRe;
                pt.im += deltaIm;
            }
        }
        renderCoefficients();  // auto-scales panel (may change scale)
        renderCoeffTrails();   // must come AFTER scale update
        updateListCoords();
        // Show coefficient chain line during root drag
        coeffChainLine.style("display", null);
        updateCoeffChainLine();
        renderDomainColoringThrottled();
        if (anySoundEnabled()) updateAudio();
    })
    .on("end", function (event, d) {
        coeffChainLine.style("display", "none");
        d3.select(this).classed("dragging", false);
        hideTooltip();
        // Click detection: if mouse didn't move, toggle root selection
        if (!rootDragMoved) {
            const idx = d._idx;
            clearCoeffSelection();
            clearMorphSelection();
            if (selectedRoots.has(idx)) {
                selectedRoots.delete(idx);
            } else {
                selectedRoots.add(idx);
            }
            updateRootSelectionVisual();
        }
    });

function autoScaleRootsPanel() {
    let needed = computeRange(currentRoots);
    if (animState.playing || (trailsEnabled && trailData.length > 0)) {
        needed = Math.max(needed, panels.roots.range);
    }
    if (needed !== panels.roots.range) {
        updatePanelRange(rootsSvg, panels.roots, needed);
        rootsLayer.selectAll("circle.root")
            .attr("cx", d => rxs()(d.re)).attr("cy", d => rys()(d.im));
        if (trailsEnabled && trailData.length > 0) renderTrails();
    }
}

// --- Render roots ---

function renderRoots(newRoots) {
    // Update persistent root data
    while (currentRoots.length < newRoots.length) currentRoots.push({ re: 0, im: 0 });
    currentRoots.length = newRoots.length;
    for (let i = 0; i < newRoots.length; i++) {
        currentRoots[i].re = newRoots[i].re;
        currentRoots[i].im = newRoots[i].im;
    }

    // Auto-scale roots panel â€” zoom-out only while playing OR trails visible,
    // so pausing never shrinks the range and detaches trails from root dots.
    let needed = computeRange(currentRoots);
    if (animState.playing || (trailsEnabled && trailData.length > 0)) {
        needed = Math.max(needed, panels.roots.range);
    }
    updatePanelRange(rootsSvg, panels.roots, needed);

    const n = currentRoots.length;
    for (let i = 0; i < n; i++) currentRoots[i]._idx = i;

    // Skip SVG rendering when bitmap tab is active (performance)
    if (activeTab !== "bitmap") {
        renderDomainColoringThrottled();

        if (rootColorMode === "derivative") computeRootSensitivities();

        const circles = rootsLayer.selectAll("circle.root").data(currentRoots, d => d._idx);
        circles.enter()
            .append("circle")
            .attr("class", "root")
            .attr("r", 7)
            .attr("stroke", "#fff")
            .attr("stroke-width", 1)
            .call(rootDrag)
            .on("mouseover", function (event, d) { showTooltip(event, d.re, d.im); })
            .on("mouseout", hideTooltip)
          .merge(circles)
            .attr("cx", d => rxs()(d.re))
            .attr("cy", d => rys()(d.im))
            .attr("fill", (_, i) => rootColor(i, n));

        circles.exit().remove();
    }

    // Collect stats snapshot
    collectStatsSnapshot();
    if (activeTab === "stats" && statsState.dirty) drawAllStatsPlots();

    // Record trail points during animation
    if (trailsEnabled && animState.playing) {
        // Initialize trail arrays if needed
        while (trailData.length < n) trailData.push([]);
        trailData.length = n;
        for (let i = 0; i < n; i++) {
            trailData[i].push({ re: currentRoots[i].re, im: currentRoots[i].im });
            if (trailData[i].length > MAX_TRAIL_POINTS) trailData[i].shift();
        }
        // Final coefficient trails (blended C/D positions)
        const nC = coefficients.length;
        const nD = morphTargetCoeffs.length;
        const doBlend = morphEnabled && nD === nC;
        while (finalTrailData.length < nC) finalTrailData.push([]);
        finalTrailData.length = nC;
        for (let i = 0; i < nC; i++) {
            const c = coefficients[i];
            const mp = doBlend ? morphInterpPoint(c.re, c.im, morphTargetCoeffs[i].re, morphTargetCoeffs[i].im, morphTheta, morphPathType, morphPathCcw, morphEllipseMinor) : c;
            let re = mp.re;
            let im = mp.im;
            const jOff = jiggleOffsets ? jiggleOffsets.get(i) : undefined;
            if (jOff) { re += jOff.re; im += jOff.im; }
            finalTrailData[i].push({ re, im });
            if (finalTrailData[i].length > MAX_TRAIL_POINTS) finalTrailData[i].shift();
        }
    }
    // Always re-render trails when data exists â€” ensures coherence after
    // pause (the pending throttled solve fires with playing=false).
    if (trailsEnabled && trailData.length > 0 && activeTab !== "bitmap") {
        renderTrails();
    }


    if (anySoundEnabled()) updateAudio();
}

function renderTrails() {
    const xScale = rxs(), yScale = rys();
    const n = trailData.length;
    const jumpThresh = panels.roots.range * 0.3; // 30% of visible range = likely a root swap
    const paths = trailLayer.selectAll("path.trail-path").data(trailData);
    paths.enter()
        .append("path")
        .attr("class", "trail-path")
      .merge(paths)
        .attr("d", pts => {
            if (pts.length < 2) return "";
            let d = `M${xScale(pts[0].re)},${yScale(pts[0].im)}`;
            for (let j = 1; j < pts.length; j++) {
                const dist = Math.hypot(pts[j].re - pts[j-1].re, pts[j].im - pts[j-1].im);
                const cmd = dist > jumpThresh ? "M" : "L";
                d += `${cmd}${xScale(pts[j].re)},${yScale(pts[j].im)}`;
            }
            return d;
        })
        .attr("stroke", (_, i) => rootColor(i, n));
    paths.exit().remove();
}

function renderCoeffTrails() {
    // Draw the absolute curve points for each coefficient that has a curve.
    const xScale = cxs(), yScale = cys();
    const lineData = [];
    const cloudData = [];

    for (let i = 0; i < coefficients.length; i++) {
        const c = coefficients[i];
        if (c.pathType === "none") continue;
        if (c.curve._isCloud) cloudData.push({ idx: i });
        else lineData.push({ idx: i });
    }

    const nCoeff = coefficients.length;

    // Line paths (closed curves)
    const paths = coeffTrailLayer.selectAll("path.trail-path").data(lineData, d => d.idx);
    paths.enter()
        .append("path")
        .attr("class", "trail-path")
      .merge(paths)
        .attr("d", ({ idx }) => {
            const curve = coefficients[idx].curve;
            const N = curve.length;
            let d = "";
            for (let k = 0; k <= N; k++) {
                const pt = curve[k % N];
                d += (k === 0 ? "M" : "L") + xScale(pt.re) + "," + yScale(pt.im);
            }
            return d + "Z";
        })
        .attr("stroke", ({ idx }) => coeffColor(idx, nCoeff));
    paths.exit().remove();

    // Dot clouds (random/Gaussian paths)
    const clouds = coeffTrailLayer.selectAll("g.trail-cloud").data(cloudData, d => d.idx);
    const cloudEnter = clouds.enter().append("g").attr("class", "trail-cloud");
    const cloudMerge = cloudEnter.merge(clouds);
    cloudMerge.each(function({ idx }) {
        const curve = coefficients[idx].curve;
        const color = coeffColor(idx, nCoeff);
        const g = d3.select(this);
        const dots = g.selectAll("circle").data(curve);
        dots.enter().append("circle")
            .attr("r", 1.5)
            .attr("fill", color)
            .attr("opacity", 0.5)
          .merge(dots)
            .attr("cx", d => xScale(d.re))
            .attr("cy", d => yScale(d.im));
        dots.exit().remove();
    });
    clouds.exit().remove();
}

function clearTrails() {
    trailData = [];
    finalTrailData = [];
    trailLayer.selectAll("path.trail-path").remove();
    if (finalTrailLayer) finalTrailLayer.selectAll("path.trail-path").remove();
    // Coefficient paths are always visible â€” don't clear them here
}


// --- Domain coloring ---

function hueToChannel(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1/6) return p + (q - p) * 6 * t;
    if (t < 1/2) return q;
    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
    return p;
}

function hslToRgb(h, s, l) {
    if (s === 0) return [Math.round(l * 255), Math.round(l * 255), Math.round(l * 255)];
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    return [
        Math.round(hueToChannel(p, q, h + 1/3) * 255),
        Math.round(hueToChannel(p, q, h) * 255),
        Math.round(hueToChannel(p, q, h - 1/3) * 255)
    ];
}

function renderDomainColoring() {
    if (!domainColoringEnabled) return;

    const range = panels.roots.range;
    // Measure actual SVG position to align canvas precisely
    // (SVG may be centered by text-align:center, shifted by border, etc.)
    const svgEl = document.getElementById("roots-panel");
    const container = document.getElementById("roots-container");
    const svgRect = svgEl.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    const borderW = parseFloat(getComputedStyle(svgEl).borderLeftWidth) || 0;
    const contentW = svgRect.width - 2 * borderW;
    const vbScale = contentW / S; // viewBox units â†’ CSS pixels
    const plotSize = (S - 2 * MARGIN) * vbScale;
    const plotLeft = (svgRect.left - containerRect.left) + borderW + MARGIN * vbScale;
    const plotTop = (svgRect.top - containerRect.top) + borderW + MARGIN * vbScale;
    const dpr = window.devicePixelRatio || 1;
    const canvasW = Math.max(1, Math.floor(plotSize * DOMAIN_RES_SCALE * dpr));
    const canvasH = canvasW;

    domainCanvas.width = canvasW;
    domainCanvas.height = canvasH;
    domainCanvas.style.width = plotSize + "px";
    domainCanvas.style.height = plotSize + "px";
    domainCanvas.style.left = plotLeft + "px";
    domainCanvas.style.top = plotTop + "px";

    const imageData = domainCtx.createImageData(canvasW, canvasH);
    const data = imageData.data;

    const n = coefficients.length;
    if (n === 0) { domainCtx.putImageData(imageData, 0, 0); return; }

    // Precompute coefficient arrays for Horner's method
    const cRe = new Float64Array(n);
    const cIm = new Float64Array(n);
    for (let k = 0; k < n; k++) {
        cRe[k] = coefficients[k].re;
        cIm[k] = coefficients[k].im;
    }

    const TWO_PI = 2 * Math.PI;
    const INV_PI_180 = 180 / Math.PI;

    for (let py = 0; py < canvasH; py++) {
        const im = range - (2 * range * (py + 0.5)) / canvasH;
        for (let px = 0; px < canvasW; px++) {
            const re = -range + (2 * range * (px + 0.5)) / canvasW;

            // Horner's method: p(z) = c[0]*z^(n-1) + c[1]*z^(n-2) + ... + c[n-1]
            let pRe = cRe[0], pIm = cIm[0];
            for (let k = 1; k < n; k++) {
                const newRe = pRe * re - pIm * im + cRe[k];
                const newIm = pRe * im + pIm * re + cIm[k];
                pRe = newRe;
                pIm = newIm;
            }

            // Hue from argument
            let hue = Math.atan2(pIm, pRe) * INV_PI_180;
            if (hue < 0) hue += 360;

            // Lightness with log-modulus contour lines
            const mod2 = pRe * pRe + pIm * pIm;
            let lightness;
            if (mod2 < 1e-600) {
                lightness = 0;
            } else {
                const logMod = 0.5 * Math.log2(mod2); // = log2(|p(z)|)
                const frac = logMod - Math.floor(logMod);
                lightness = 0.5 + 0.4 * Math.cos(TWO_PI * frac);
            }

            const [r, g, b] = hslToRgb(hue / 360, 0.8, lightness);
            const idx = (py * canvasW + px) * 4;
            data[idx] = r;
            data[idx + 1] = g;
            data[idx + 2] = b;
            data[idx + 3] = 255;
        }
    }
    domainCtx.putImageData(imageData, 0, 0);
}

function renderDomainColoringThrottled() {
    if (!domainPendingRender) {
        domainPendingRender = true;
        requestAnimationFrame(() => {
            renderDomainColoring();
            domainPendingRender = false;
        });
    }
}

// --- Ehrlich-Aberth client-side root solver ---

function solveRootsEA(coeffs, warmStart) {
    // coeffs: array of {re, im} in descending degree order
    // warmStart: array of {re, im} initial guesses (or null)
    // Returns: array of {re, im} roots

    // Strip leading near-zero coefficients
    let start = 0;
    while (start < coeffs.length - 1 && Math.hypot(coeffs[start].re, coeffs[start].im) < 1e-15) {
        start++;
    }
    const c = coeffs.slice(start);
    const degree = c.length - 1;
    if (degree <= 0) return [];

    // Degree 1: linear case c[0]*z + c[1] = 0
    if (degree === 1) {
        const aRe = c[0].re, aIm = c[0].im;
        const bRe = c[1].re, bIm = c[1].im;
        const denom = aRe * aRe + aIm * aIm;
        if (denom < 1e-30) return [];
        const root = { re: -(bRe * aRe + bIm * aIm) / denom, im: -(bIm * aRe - bRe * aIm) / denom };
        return [root];
    }

    const MAX_ITER = 100;
    const TOL = 1e-12;

    // Initialize root guesses
    const roots = new Array(degree);
    if (warmStart && warmStart.length === degree) {
        for (let i = 0; i < degree; i++) {
            roots[i] = [warmStart[i].re, warmStart[i].im];
        }
    } else {
        // Spread initial guesses on a circle with radius from coefficient ratio
        const leadMod = Math.hypot(c[0].re, c[0].im);
        const trailMod = Math.hypot(c[degree].re, c[degree].im);
        const radius = leadMod > 1e-30
            ? Math.max(0.1, Math.min(Math.pow(trailMod / leadMod, 1 / degree), 10))
            : 1;
        for (let i = 0; i < degree; i++) {
            const angle = (2 * Math.PI * i) / degree + 0.37; // offset to break symmetry
            roots[i] = [radius * Math.cos(angle), radius * Math.sin(angle)];
        }
    }

    // Precompute coefficient arrays for Horner's method
    const n = c.length;
    const cRe = new Float64Array(n);
    const cIm = new Float64Array(n);
    for (let k = 0; k < n; k++) {
        cRe[k] = c[k].re;
        cIm[k] = c[k].im;
    }

    // Iterate
    for (let iter = 0; iter < MAX_ITER; iter++) {
        let maxCorr = 0;

        for (let i = 0; i < degree; i++) {
            const zRe = roots[i][0], zIm = roots[i][1];

            // Evaluate p(z) and p'(z) simultaneously via Horner
            let pRe = cRe[0], pIm = cIm[0];
            let dpRe = 0, dpIm = 0;
            for (let k = 1; k < n; k++) {
                // dp = dp * z + p
                const ndRe = dpRe * zRe - dpIm * zIm + pRe;
                const ndIm = dpRe * zIm + dpIm * zRe + pIm;
                dpRe = ndRe;
                dpIm = ndIm;
                // p = p * z + c[k]
                const npRe = pRe * zRe - pIm * zIm + cRe[k];
                const npIm = pRe * zIm + pIm * zRe + cIm[k];
                pRe = npRe;
                pIm = npIm;
            }

            // Newton step: w = p(z) / p'(z)
            const dpMod2 = dpRe * dpRe + dpIm * dpIm;
            if (dpMod2 < 1e-60) continue;
            const wRe = (pRe * dpRe + pIm * dpIm) / dpMod2;
            const wIm = (pIm * dpRe - pRe * dpIm) / dpMod2;

            // Aberth sum: S = Î£_{jâ‰ i} 1/(z_i - z_j)
            let sRe = 0, sIm = 0;
            for (let j = 0; j < degree; j++) {
                if (j === i) continue;
                const dRe = zRe - roots[j][0];
                const dIm = zIm - roots[j][1];
                const dMod2 = dRe * dRe + dIm * dIm;
                if (dMod2 < 1e-60) continue;
                sRe += dRe / dMod2;
                sIm += -dIm / dMod2;
            }

            // Aberth correction: correction = w / (1 - w * S)
            const wsRe = wRe * sRe - wIm * sIm;
            const wsIm = wRe * sIm + wIm * sRe;
            const denomRe = 1 - wsRe;
            const denomIm = -wsIm;
            const denomMod2 = denomRe * denomRe + denomIm * denomIm;
            if (denomMod2 < 1e-60) continue;

            const corrRe = (wRe * denomRe + wIm * denomIm) / denomMod2;
            const corrIm = (wIm * denomRe - wRe * denomIm) / denomMod2;

            roots[i][0] -= corrRe;
            roots[i][1] -= corrIm;

            const corrMag = Math.hypot(corrRe, corrIm);
            maxCorr = Math.max(maxCorr, corrMag);
        }

        if (maxCorr < TOL) break;
    }

    // Always return exactly `degree` roots â€” replace non-finite with warm-start or unit circle
    const result = new Array(degree);
    for (let i = 0; i < degree; i++) {
        let re, im;
        if (isFinite(roots[i][0]) && isFinite(roots[i][1])) {
            re = roots[i][0];
            im = roots[i][1];
        } else if (warmStart && warmStart[i] && isFinite(warmStart[i].re) && isFinite(warmStart[i].im)) {
            re = warmStart[i].re;
            im = warmStart[i].im;
        } else {
            const angle = (2 * Math.PI * i) / degree + 0.37;
            re = Math.cos(angle);
            im = Math.sin(angle);
        }
        result[i] = { re, im };
    }
    return result;
}

// Greedy nearest-neighbor matching: reorder newRoots to best match oldRoots indices.
// Preserves root identity across frames so trails track the same root continuously.
function matchRootOrder(newRoots, oldRoots) {
    if (oldRoots.length === 0 || newRoots.length !== oldRoots.length) return newRoots;
    const n = newRoots.length;
    const used = new Uint8Array(n); // which newRoots indices are taken
    const result = new Array(n);
    for (let i = 0; i < n; i++) {
        let bestJ = -1, bestDist = Infinity;
        for (let j = 0; j < n; j++) {
            if (used[j]) continue;
            const d2 = (newRoots[j].re - oldRoots[i].re) ** 2 + (newRoots[j].im - oldRoots[i].im) ** 2;
            if (d2 < bestDist) { bestDist = d2; bestJ = j; }
        }
        result[i] = newRoots[bestJ];
        used[bestJ] = 1;
    }
    return result;
}

function solveRoots() {
    let coeffsToSolve = coefficients;
    if (morphEnabled && morphTargetCoeffs.length === coefficients.length) {
        coeffsToSolve = coefficients.map((c, i) =>
            morphInterpPoint(c.re, c.im, morphTargetCoeffs[i].re, morphTargetCoeffs[i].im,
                             morphTheta, morphPathType, morphPathCcw, morphEllipseMinor));
    }
    // Apply jiggle offsets post-interpolation
    if (jiggleOffsets && jiggleOffsets.size > 0) {
        if (coeffsToSolve === coefficients) {
            coeffsToSolve = coefficients.map(c => ({ re: c.re, im: c.im }));
        }
        for (const [idx, off] of jiggleOffsets) {
            if (idx < coeffsToSolve.length) {
                coeffsToSolve[idx].re += off.re;
                coeffsToSolve[idx].im += off.im;
            }
        }
    }
    let roots = solveRootsEA(coeffsToSolve, currentRoots);
    roots = matchRootOrder(roots, currentRoots);
    renderRoots(roots);
    if (leftTab === "final") renderFinalPanel();
}

function solveRootsThrottled() {
    if (fastModeActive) return;
    if (!pendingSolve) {
        pendingSolve = true;
        requestAnimationFrame(() => {
            solveRoots();
            pendingSolve = false;
        });
    }
}

// --- Degree input ---

const degreeNumber = document.getElementById("degree-number");
let currentDegree = 5;

function applyPattern() {
    stopAnimation();
    animState.elapsedAtPause = null;
    playBtn.textContent = "â–¶ Play";
    updateAnimSeconds(0);
    scrubSlider.value = 0;
    lastSelectedCoeff = -1;
    clearAllSelection();
    clearTrails();
    clearStatsData();
    resetAudioState();
    resetBitmap();
    // Reset jiggle state so stale offsets don't affect scale/solve
    jiggleOffsets = null;
    jiggleStep = -1;
    jiggleWalkCache = null;
    updateJiggleStatus();
    currentRoots = [];
    rootsLayer.selectAll("circle.root").remove();
    updatePanelRange(rootsSvg, panels.roots, MIN_RANGE);
    initCoefficients(currentDegree);
    initMorphTarget();
    renderCoeffTrails(); // remove stale coefficient path SVGs (must be after initCoefficients so pathType="none")
    renderCoefficients();
    solveRoots();
    renderDomainColoring();
}

function setDegree(v) {
    v = Math.max(2, Math.min(30, Math.round(v)));
    if (v === currentDegree) return;
    currentDegree = v;
    degreeNumber.textContent = v;
    applyPattern();
}

// Degree popover (horizontal slider 2â€“30)
let degreePopEl = null;
let degreeToolActive = false;

function closeDegreePopover() {
    if (degreePopEl) { degreePopEl.classList.remove("open"); degreePopEl.innerHTML = ""; }
    degreeNumber.classList.remove("tool-active");
    degreeToolActive = false;
    window.removeEventListener("mousemove", degreeDragMove);
    window.removeEventListener("mouseup", degreeDragUp);
}
let degreeDragMove = null;
let degreeDragUp = null;

degreeNumber.addEventListener("click", function(e) {
    e.stopPropagation();
    if (degreeToolActive) { closeDegreePopover(); return; }
    // close any ops tool first
    if (typeof closeOpTool === "function") closeOpTool();
    degreeToolActive = true;
    degreeNumber.classList.add("tool-active");

    if (!degreePopEl) degreePopEl = document.getElementById("degree-pop");
    degreePopEl.innerHTML = "";

    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Degree";
    const valEl = document.createElement("div");
    valEl.className = "pop-val";
    valEl.textContent = currentDegree;

    const slider = document.createElement("div");
    slider.className = "hslider";
    slider.style.width = "180px";
    const thumb = document.createElement("div");
    thumb.className = "hslider-thumb";
    slider.appendChild(thumb);

    // ticks
    const tickRow = document.createElement("div");
    tickRow.className = "pop-row";
    tickRow.style.justifyContent = "space-between";
    tickRow.style.width = "180px";
    tickRow.style.fontSize = "9px";
    tickRow.textContent = "2 â€” 30";

    function uFromDeg(d) { return (d - 2) / (30 - 2); }
    function degFromU(u) { return Math.round(2 + u * (30 - 2)); }
    let u = uFromDeg(currentDegree);

    function updateVisual() {
        thumb.style.left = (u * 100) + "%";
        const d = degFromU(u);
        valEl.textContent = d;
    }

    function setFromX(clientX) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        updateVisual();
        setDegree(degFromU(u));
    }

    let dragging = false;
    slider.addEventListener("mousedown", ev => {
        dragging = true; setFromX(ev.clientX); ev.preventDefault();
    });
    degreeDragMove = ev => { if (dragging) setFromX(ev.clientX); };
    degreeDragUp = () => { dragging = false; };
    window.addEventListener("mousemove", degreeDragMove);
    window.addEventListener("mouseup", degreeDragUp);

    updateVisual();
    degreePopEl.appendChild(title);
    degreePopEl.appendChild(slider);
    degreePopEl.appendChild(valEl);
    degreePopEl.appendChild(tickRow);
    degreePopEl.classList.add("open");

    // position below the degree label
    const r = degreeNumber.getBoundingClientRect();
    degreePopEl.style.left = r.left + "px";
    degreePopEl.style.top = (r.bottom + 8) + "px";
});

// close degree popover on outside click
document.addEventListener("mousedown", function(e) {
    if (!degreeToolActive) return;
    if (degreePopEl && degreePopEl.contains(e.target)) return;
    if (degreeNumber.contains(e.target)) return;
    closeDegreePopover();
});
document.addEventListener("keydown", function(e) {
    if (e.key === "Escape" && degreeToolActive) { closeDegreePopover(); e.stopImmediatePropagation(); }
}, true);

document.getElementById("pattern").addEventListener("change", applyPattern);
document.getElementById("reset-btn").addEventListener("click", applyPattern);

document.getElementById("deselect-all-btn").addEventListener("click", clearAllSelection);

// Mid-bar All / None buttons â€” context-aware selection
document.getElementById("mid-all-btn").addEventListener("click", function () {
    if (selectedMorphCoeffs.size > 0) {
        // D-nodes context: select all D-nodes
        for (let i = 0; i < morphTargetCoeffs.length; i++) selectedMorphCoeffs.add(i);
        updateMorphSelectionVisual();
    } else if (selectedRoots.size > 0) {
        // Roots context: select all roots
        for (let i = 0; i < currentRoots.length; i++) selectedRoots.add(i);
        updateRootSelectionVisual();
    } else {
        // Coefficients context (default): select all coefficients
        clearRootSelection(); clearMorphSelection();
        for (let i = 0; i < coefficients.length; i++) selectedCoeffs.add(i);
        if (coefficients.length > 0) lastSelectedCoeff = coefficients.length - 1;
        updateCoeffSelectionVisual();
        updateAnimBar();
    }
});
document.getElementById("mid-none-btn").addEventListener("click", function () {
    if (selectedMorphCoeffs.size > 0) {
        clearMorphSelection();
    } else if (selectedRoots.size > 0) {
        clearRootSelection();
    } else {
        clearCoeffSelection();
    }
});

document.getElementById("select-all-coeffs-btn").addEventListener("click", function () {
    clearRootSelection();
    clearMorphSelection();
    for (let i = 0; i < coefficients.length; i++) selectedCoeffs.add(i);
    if (coefficients.length > 0) lastSelectedCoeff = coefficients.length - 1;
    updateCoeffSelectionVisual();
    updateAnimBar();
});

const domainToggleBtn = document.getElementById("domain-toggle-btn");
domainToggleBtn.addEventListener("click", function () {
    domainColoringEnabled = !domainColoringEnabled;
    this.classList.toggle("active", domainColoringEnabled);
    domainCanvas.style.display = domainColoringEnabled ? "block" : "none";
    rootsSvg.classed("domain-active", domainColoringEnabled);
    if (domainColoringEnabled) renderDomainColoring();
});

document.getElementById("select-all-roots-btn").addEventListener("click", function () {
    clearCoeffSelection();
    for (let i = 0; i < currentRoots.length; i++) selectedRoots.add(i);
    updateRootSelectionVisual();
});

document.getElementById("deselect-all-roots-btn").addEventListener("click", function () {
    clearRootSelection();
});

// Fit button â€” resize roots panel to fit all roots + trails
document.getElementById("roots-fit-btn").addEventListener("click", function () {
    const allPts = [...currentRoots];
    if (trailsEnabled) {
        for (const pts of trailData) {
            for (const p of pts) allPts.push(p);
        }
    }
    if (allPts.length === 0) { uiBuzz(); return; }
    const needed = computeRange(allPts);
    if (Math.abs(panels.roots.range - needed) < 0.01) { uiBuzz(); return; }
    // Force range (bypasses zoom-out-only guard)
    updatePanelRange(rootsSvg, panels.roots, needed);
    rootsLayer.selectAll("circle.root")
        .attr("cx", d => rxs()(d.re)).attr("cy", d => rys()(d.im));
    if (trailsEnabled && trailData.length > 0) renderTrails();
    renderDomainColoring();
    uiPing(660, 0.08);
});

// -25% zoom-in button
document.getElementById("roots-zoom-in-btn").addEventListener("click", function () {
    updatePanelRange(rootsSvg, panels.roots, panels.roots.range * 0.75);
    rootsLayer.selectAll("circle.root")
        .attr("cx", d => rxs()(d.re)).attr("cy", d => rys()(d.im));
    if (trailsEnabled && trailData.length > 0) renderTrails();
    renderDomainColoring();
});

// +25% zoom-out button
document.getElementById("roots-zoom-out-btn").addEventListener("click", function () {
    updatePanelRange(rootsSvg, panels.roots, panels.roots.range * 1.25);
    rootsLayer.selectAll("circle.root")
        .attr("cx", d => rxs()(d.re)).attr("cy", d => rys()(d.im));
    if (trailsEnabled && trailData.length > 0) renderTrails();
    renderDomainColoring();
});

// --- Root color popover ---
const colorPop = document.getElementById("color-pop");
const rootColorBtn = document.getElementById("root-color-btn");
let colorPopOpen = false;

function closeColorPop() {
    colorPop.classList.remove("open");
    colorPop.innerHTML = "";
    rootColorBtn.classList.remove("tool-active");
    colorPopOpen = false;
}

function refreshRootColors() {
    rootsLayer.selectAll("circle.root")
        .attr("fill", (_, i) => rootColor(i, currentRoots.length));
}

function buildColorPop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Root Color";
    pop.appendChild(title);

    const modes = [
        { key: "uniform", label: "Uniform" },
        { key: "rainbow", label: "Index Rainbow" },
        { key: "derivative", label: "Derivative" },
    ];
    const rows = [];
    let swatchWrap = null;

    function refreshSwatches() {
        if (swatchWrap) swatchWrap.style.opacity = rootColorMode === "uniform" ? "1" : "0.3";
    }

    modes.forEach(m => {
        const row = document.createElement("div");
        row.className = "audio-toggle" + (rootColorMode === m.key ? " on" : "");
        const dot = document.createElement("span");
        dot.className = "toggle-dot";
        const lbl = document.createElement("span");
        lbl.className = "toggle-label"; lbl.textContent = m.label;
        row.appendChild(dot);
        row.appendChild(lbl);
        row.addEventListener("click", () => {
            rootColorMode = m.key;
            rootColorBtn.classList.toggle("active", rootColorMode !== "uniform");
            rows.forEach(r => r.classList.remove("on"));
            row.classList.add("on");
            if (rootColorMode === "derivative") computeRootSensitivities();
            refreshRootColors();
            refreshSwatches();
        });
        pop.appendChild(row);
        rows.push(row);

        // Add color swatches after the "Uniform" row
        if (m.key === "uniform") {
            swatchWrap = document.createElement("div");
            swatchWrap.style.cssText = "display:flex;flex-wrap:wrap;gap:3px;padding:4px 2px 6px 20px;max-width:180px;";
            swatchWrap.style.opacity = rootColorMode === "uniform" ? "1" : "0.3";

            ROOT_COLOR_SWATCHES.forEach(ch => {
                const sw = document.createElement("div");
                const isActive = uniformRootColor[0] === ch.rgb[0] && uniformRootColor[1] === ch.rgb[1] && uniformRootColor[2] === ch.rgb[2];
                sw.style.cssText = `width:16px;height:16px;border-radius:50%;cursor:pointer;` +
                    `background:rgb(${ch.rgb[0]},${ch.rgb[1]},${ch.rgb[2]});` +
                    `border:2px solid ${isActive ? "#fff" : "rgba(255,255,255,0.15)"};` +
                    `box-sizing:border-box;flex-shrink:0;`;
                sw.title = ch.label;
                sw.addEventListener("click", () => {
                    uniformRootColor = ch.rgb.slice();
                    // Update swatch borders
                    swatchWrap.querySelectorAll("div").forEach(s => {
                        s.style.borderColor = "rgba(255,255,255,0.15)";
                    });
                    sw.style.borderColor = "#fff";
                    // Switch to uniform mode if not already
                    if (rootColorMode !== "uniform") {
                        rootColorMode = "uniform";
                        rootColorBtn.classList.toggle("active", false);
                        rows.forEach(r => r.classList.remove("on"));
                        rows[0].classList.add("on"); // "Uniform" is first
                        refreshSwatches();
                    }
                    refreshRootColors();
                });
                swatchWrap.appendChild(sw);
            });
            pop.appendChild(swatchWrap);
        }
    });
}

rootColorBtn.addEventListener("click", function () {
    if (colorPopOpen) { closeColorPop(); return; }
    closeColorPop();
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeAudioPop === "function") closeAudioPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();
    colorPopOpen = true;
    rootColorBtn.classList.add("tool-active");
    colorPop.innerHTML = "";
    buildColorPop(colorPop);
    colorPop.classList.add("open");
    const r = rootColorBtn.getBoundingClientRect();
    colorPop.style.left = (r.right + 8) + "px";
    colorPop.style.top = r.top + "px";
});

// --- Coefficient picker popover ---
const coeffPickPop = document.getElementById("coeff-pick-pop");
const coeffPickerBtn = document.getElementById("coeff-picker-btn");
let coeffPickOpen = false;

function closeCoeffPick() {
    coeffPickPop.classList.remove("open");
    coeffPickPop.innerHTML = "";
    coeffPickerBtn.classList.remove("tool-active");
    coeffPickOpen = false;
}

function buildCoeffPickPop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Coefficients";
    pop.appendChild(title);

    const scrollBox = document.createElement("div");
    scrollBox.style.cssText = "max-height:184px;overflow-y:auto;width:100%;";

    const deg = coefficients.length - 1;
    const n = coefficients.length;
    const coeffSens = computeCoeffSensitivities();
    for (let i = 0; i < n; i++) {
        const row = document.createElement("div");
        row.className = "cpick-row";

        const dot = document.createElement("span");
        dot.className = "cpick-dot";
        dot.style.background = coeffColor(i, n);

        const sensDot = document.createElement("span");
        sensDot.className = "cpick-dot";
        sensDot.style.background = coeffSens ? sensitivityColor(coeffSens[i]) : "#555";

        const label = document.createElement("span");
        label.className = "cpick-label";
        label.textContent = "c" + (deg - i);

        const power = document.createElement("span");
        power.className = "cpick-power";
        const exp = deg - i;
        power.textContent = exp === 0 ? "1" : exp === 1 ? "z" : "z" + superscript(exp);

        // Path info for this coefficient
        const pathSpan = document.createElement("span");
        pathSpan.className = "cpick-path";
        const ci = coefficients[i];
        if (ci.pathType !== "none") {
            const t = ci.pathType;
            const pName = t === "figure8" ? "Fig-8"
                : t === "epitrochoid" ? "Spiro" : t === "hypotrochoid" ? "Hypo"
                : t.charAt(0).toUpperCase() + t.slice(1);
            pathSpan.textContent = pName;
            const detail = document.createElement("span");
            detail.className = "cpick-detail";
            detail.textContent = ` R${Math.round(ci.radius)} S${Math.round(ci.speed * 1000)} A${ci.angle.toFixed(2)} ${ci.ccw ? "CCW" : "CW"}`;
            pathSpan.appendChild(detail);
        } else {
            pathSpan.textContent = "â€”";
        }

        // Point count for path curves
        const ptsSpan = document.createElement("span");
        ptsSpan.className = "cpick-pts";
        if (ci.pathType !== "none") {
            ptsSpan.textContent = ci.curve.length;
        } else {
            ptsSpan.textContent = "";
        }

        const coords = document.createElement("span");
        coords.className = "cpick-coords";
        const c = coefficients[i];
        const sign = c.im >= 0 ? "+" : "";
        coords.textContent = c.re.toFixed(2) + sign + c.im.toFixed(2) + "i";

        const cb = document.createElement("span");
        cb.className = "cpick-cb" + (selectedCoeffs.has(i) ? " checked" : "");

        row.appendChild(cb);
        row.appendChild(dot);
        row.appendChild(sensDot);
        row.appendChild(label);
        row.appendChild(power);
        row.appendChild(pathSpan);
        row.appendChild(ptsSpan);
        row.appendChild(coords);

        const idx = i;
        row.addEventListener("click", () => {
            clearRootSelection();
            if (selectedCoeffs.has(idx)) {
                selectedCoeffs.delete(idx);
                cb.classList.remove("checked");
            } else {
                selectedCoeffs.add(idx);
                cb.classList.add("checked");
                lastSelectedCoeff = idx;
            }
            updateCoeffSelectionVisual();
            updateAnimBar();
        });

        scrollBox.appendChild(row);
    }
    pop.appendChild(scrollBox);
}

function superscript(n) {
    const sup = "\u2070\u00B9\u00B2\u00B3\u2074\u2075\u2076\u2077\u2078\u2079";
    if (n < 10) return sup[n];
    return String(n).split("").map(d => sup[+d]).join("");
}

coeffPickerBtn.addEventListener("click", function () {
    if (coeffPickOpen) { closeCoeffPick(); return; }
    closeCoeffPick();
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeAudioPop === "function") closeAudioPop();
    if (typeof closeColorPop === "function") closeColorPop();
    coeffPickOpen = true;
    coeffPickerBtn.classList.add("tool-active");
    coeffPickPop.innerHTML = "";
    buildCoeffPickPop(coeffPickPop);
    coeffPickPop.classList.add("open");
    const r = coeffPickerBtn.getBoundingClientRect();
    coeffPickPop.style.left = (r.right + 8) + "px";
    coeffPickPop.style.top = r.top + "px";
});

// --- Audio instrument config popovers ---
const audioPop = document.getElementById("audio-pop");

function closeAudioPop() {
    audioPop.classList.remove("open");
    audioPop.innerHTML = "";
    if (activeAudioBtn) activeAudioBtn.classList.remove("tool-active");
    activeAudioBtn = null;
}

function openAudioPop(btnEl, buildFn) {
    if (activeAudioBtn === btnEl) { closeAudioPop(); return; }
    closeAudioPop();
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeColorPop === "function") closeColorPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();
    activeAudioBtn = btnEl;
    btnEl.classList.add("tool-active");
    audioPop.innerHTML = "";
    buildFn(audioPop);
    audioPop.classList.add("open");
    const r = btnEl.getBoundingClientRect();
    audioPop.style.left = r.left + "px";
    audioPop.style.top = (r.bottom + 6) + "px";
}

function toggleSound(flag, setFn, btnEl) {
    const wasAny = anySoundEnabled();
    setFn(flag);
    btnEl.classList.toggle("active", flag);
    const isAny = anySoundEnabled();
    if (isAny && !wasAny) {
        initAudio();
        if (audioCtx.state === "suspended") audioCtx.resume();
        audioWatchdogId = setInterval(audioWatchdog, 100);
    } else if (!isAny && wasAny) {
        if (audioWatchdogId) { clearInterval(audioWatchdogId); audioWatchdogId = null; }
        resetAudioState();
    }
}

const fmtHz = v => v < 100 ? v.toFixed(1) + " Hz" : Math.round(v) + " Hz";
const fmtMs = v => (v * 1000).toFixed(1) + " ms";
const fmtF = (d) => v => v.toFixed(d);
const fmtPct = v => (v * 100).toFixed(0) + "%";

function buildBasePop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Base";
    pop.appendChild(title);
    const btn = document.getElementById("base-toggle-btn");
    buildAudioToggle(pop, "Enabled", baseEnabled, on => toggleSound(on, v => { baseEnabled = v; }, btn));
    buildAudioSlider(pop, "Pitch",      55,    440,  baseConfig.freq,      true,  fmtHz,     v => { baseConfig.freq = v; });
    buildAudioSlider(pop, "Range",      0.5,   4.0,  baseConfig.octaves,   false, fmtF(1),   v => { baseConfig.octaves = v; });
    buildAudioSlider(pop, "FM Ratio",   0.5,   8.0,  baseConfig.modRatio,  false, v => "Ã—" + v.toFixed(1), v => { baseConfig.modRatio = v; });
    buildAudioSlider(pop, "FM Depth",   0,     800,  baseConfig.modDepth,  false, fmtHz,     v => { baseConfig.modDepth = v; });
    buildAudioSlider(pop, "Bright",     50,    1000, baseConfig.filterLo,  true,  fmtHz,     v => { baseConfig.filterLo = v; });
    buildAudioSlider(pop, "Volume",     0.05,  0.50, baseConfig.gainRange, false, fmtF(2),   v => { baseConfig.gainRange = v; });
    buildAudioSlider(pop, "Vibrato",    0,     25,   baseConfig.vibDepth,  false, fmtF(1),   v => { baseConfig.vibDepth = v; });
}

function buildMelodyPop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Melody";
    pop.appendChild(title);
    const btn = document.getElementById("melody-toggle-btn");
    buildAudioToggle(pop, "Enabled", melodyEnabled, on => toggleSound(on, v => { melodyEnabled = v; }, btn));
    buildAudioSlider(pop, "Rate",       2,     60,   melodyConfig.rate,     true,  v => Math.round(v) + "/s", v => { melodyConfig.rate = v; });
    buildAudioSlider(pop, "Cutoff",     2,  currentDegree, Math.min(melodyConfig.cutoff, currentDegree), false, v => Math.round(v) + "",  v => { melodyConfig.cutoff = v; });
    buildAudioSlider(pop, "Volume",     0.02,  0.30, melodyConfig.peak,     false, fmtF(2),   v => { melodyConfig.peak = v; });
    buildAudioSlider(pop, "Attack",     0.001, 0.020, melodyConfig.attack,  true,  fmtMs,     v => { melodyConfig.attack = v; });
    buildAudioSlider(pop, "Decay",      0.010, 0.200, melodyConfig.decay,   true,  fmtMs,     v => { melodyConfig.decay = v; });
    buildAudioSlider(pop, "Bright",     200,   4000, melodyConfig.filterLo, true,  fmtHz,     v => { melodyConfig.filterLo = v; });
}

function buildVoicePop(pop) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Voice";
    pop.appendChild(title);
    const btn = document.getElementById("voice-toggle-btn");
    buildAudioToggle(pop, "Enabled", voiceEnabled, on => toggleSound(on, v => { voiceEnabled = v; }, btn));
    buildAudioSlider(pop, "Cooldown",   0.01,  0.50,  voiceConfig.cooldown, true,  fmtMs,     v => { voiceConfig.cooldown = v; });
    buildAudioSlider(pop, "Volume",     0.02,  0.30,  voiceConfig.peak,     false, fmtF(2),   v => { voiceConfig.peak = v; });
    buildAudioSlider(pop, "Attack",     0.001, 0.020, voiceConfig.attack,   true,  fmtMs,     v => { voiceConfig.attack = v; });
    buildAudioSlider(pop, "Decay",      0.01,  0.30,  voiceConfig.ringdown, true,  fmtMs,     v => { voiceConfig.ringdown = v; });
}

document.getElementById("base-toggle-btn").addEventListener("click", function () { openAudioPop(this, buildBasePop); });
document.getElementById("melody-toggle-btn").addEventListener("click", function () { openAudioPop(this, buildMelodyPop); });
document.getElementById("voice-toggle-btn").addEventListener("click", function () { openAudioPop(this, buildVoicePop); });

// --- Config tab ---
(function initConfigTab() {
    const container = document.getElementById("config-sliders");

    // -- Encounters / Records --
    const sec1 = document.createElement("div");
    sec1.className = "config-section"; sec1.textContent = "Encounters Â· Records";
    container.appendChild(sec1);
    const stack = document.createElement("div");
    stack.className = "config-row-stack";
    buildAudioSlider(stack, "Memory",  1.0,  1.02, voiceConfig.decay,   true,  fmtF(4), v => { voiceConfig.decay = v; });
    buildAudioSlider(stack, "Novelty", 0.3,  1.0,  voiceConfig.novelty, false, fmtF(2), v => { voiceConfig.novelty = v; });
    container.appendChild(stack);

    // Mini slider builder for table cells
    function buildCellSlider(parent, min, max, value, logScale, fmt, onChange) {
        const wrap = document.createElement("div");
        wrap.className = "cell-slider-wrap";
        const track = document.createElement("div");
        track.className = "cell-slider";
        const thumb = document.createElement("div");
        thumb.className = "cell-slider-thumb";
        track.appendChild(thumb);
        const val = document.createElement("span");
        val.className = "cell-slider-val";
        function valToU(v) {
            if (logScale) return (Math.log(v) - Math.log(min)) / (Math.log(max) - Math.log(min));
            return (v - min) / (max - min);
        }
        function uToVal(u) {
            if (logScale) return Math.exp(Math.log(min) + u * (Math.log(max) - Math.log(min)));
            return min + u * (max - min);
        }
        let u = Math.max(0, Math.min(1, valToU(value)));
        function update() {
            thumb.style.left = (u * 100) + "%";
            const v = uToVal(u);
            val.textContent = fmt(v);
            onChange(v);
        }
        function setFromX(clientX) {
            const rect = track.getBoundingClientRect();
            u = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
            update();
        }
        let dragging = false;
        track.addEventListener("mousedown", e => { dragging = true; setFromX(e.clientX); e.preventDefault(); });
        window.addEventListener("mousemove", e => { if (dragging) setFromX(e.clientX); });
        window.addEventListener("mouseup", () => { dragging = false; });
        update();
        wrap.appendChild(track);
        wrap.appendChild(val);
        parent.appendChild(wrap);
    }

    // Builds a routing table for a given routes array
    function buildRouteTable(routes) {
        const table = document.createElement("table");
        table.className = "route-table";
        const thead = document.createElement("thead");
        const hrow = document.createElement("tr");
        ["Input signal", "Smooth", "Norm", "Feeding into"].forEach(t => {
            const th = document.createElement("th"); th.textContent = t; hrow.appendChild(th);
        });
        thead.appendChild(hrow); table.appendChild(thead);

        const tbody = document.createElement("tbody");
        for (let i = 0; i < routes.length; i++) {
            const route = routes[i];
            const tr = document.createElement("tr");

            // Col 1: Input signal dropdown
            const td1 = document.createElement("td");
            const sel = document.createElement("select");
            for (const src of ROUTE_SOURCES) {
                const opt = document.createElement("option");
                opt.value = src; opt.textContent = src;
                if (src === route.source) opt.selected = true;
                sel.appendChild(opt);
            }
            sel.addEventListener("change", () => { route.source = sel.value; });
            td1.appendChild(sel); tr.appendChild(td1);

            // Col 2: Smoothing slider (alpha 0.01â€“1.0, log scale)
            const td2 = document.createElement("td");
            buildCellSlider(td2, 0.01, 1.0, route.alpha, true, v => v.toFixed(2), v => { route.alpha = v; });
            tr.appendChild(td2);

            // Col 3: Normalization mode dropdown
            const td3 = document.createElement("td");
            const normSel = document.createElement("select");
            normSel.className = "norm-select";
            for (const m of NORM_MODES) {
                const opt = document.createElement("option");
                opt.value = m; opt.textContent = m === "fixed" ? "Fixed" : "RunMax";
                if (m === route.norm) opt.selected = true;
                normSel.appendChild(opt);
            }
            normSel.addEventListener("change", () => { route.norm = normSel.value; route.runMax = 0.001; });
            td3.appendChild(normSel); tr.appendChild(td3);

            // Col 4: Target label
            const td4 = document.createElement("td");
            td4.className = "target-label"; td4.textContent = route.target;
            tr.appendChild(td4);

            tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        return table;
    }

    // -- Base Routing Table --
    const sec2 = document.createElement("div");
    sec2.className = "config-section"; sec2.textContent = "Base Routing";
    container.appendChild(sec2);
    container.appendChild(buildRouteTable(baseRoutes));

    // -- Voice Routing Table --
    const sec3 = document.createElement("div");
    sec3.className = "config-section"; sec3.textContent = "Voice Routing";
    container.appendChild(sec3);
    container.appendChild(buildRouteTable(voiceRoutes));

    // -- Melody Routing Table --
    const sec4 = document.createElement("div");
    sec4.className = "config-section"; sec4.textContent = "Melody Routing";
    container.appendChild(sec4);
    container.appendChild(buildRouteTable(melodyRoutes));
})();

document.addEventListener("visibilitychange", function () {
    if (document.hidden && audioNodes && audioCtx) {
        audioNodes.masterGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.02);
    }
});

document.addEventListener("keydown", function (e) {
    if (e.key === "Escape") {
        if (barSnapshots) { revertBarPreview(); return; }
        if (ctxCoeffIdx >= 0) { closeCoeffCtx(true); return; }
        if (ctxDNodeIdx >= 0) { closeDNodeCtx(true); return; }
        if (typeof activeToolBtn !== "undefined" && activeToolBtn) { closeOpTool(); return; }
        if (activeAudioBtn) { closeAudioPop(); return; }
        if (colorPopOpen) { closeColorPop(); return; }
        if (coeffPickOpen) { closeCoeffPick(); return; }
        if (typeof snapPopOpen !== "undefined" && snapPopOpen) { closeSnapPop(); return; }
        if (typeof bitmapCfgPopOpen !== "undefined" && bitmapCfgPopOpen) { closeBitmapCfgPop(); return; }
        if (typeof pathPickOpen !== "undefined" && pathPickOpen) { closePathPickPop(true); return; }
        if (typeof dpathPickOpen !== "undefined" && dpathPickOpen) { closeDPathPickPop(true); return; }
        clearAllSelection();
    }
});

// --- Transform tools (popover with live preview) ---

const opsPop = document.getElementById("ops-pop");
let activeToolBtn = null;
let opSnapshot = null; // { which: "coeff"|"roots", items: [{idx, re, im}, ...] }

function snapshotSelection() {
    const items = [];
    if (selectedCoeffs.size > 0) {
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            items.push({ idx, re: c.re, im: c.im });
        }
        return { which: "coeff", items };
    } else if (selectedMorphCoeffs.size > 0) {
        for (const idx of selectedMorphCoeffs) {
            const d = morphTargetCoeffs[idx];
            items.push({ idx, re: d.re, im: d.im });
        }
        return { which: "morph", items };
    } else if (selectedRoots.size > 0) {
        for (const idx of selectedRoots) {
            const r = currentRoots[idx];
            items.push({ idx, re: r.re, im: r.im });
        }
        return { which: "roots", items };
    }
    return null;
}

function applyPreview(snap, fn) {
    if (!snap) return;
    if (snap.which === "coeff") {
        for (const s of snap.items) {
            const c = coefficients[s.idx];
            const r = fn(s.re, s.im);
            c.re = r.re; c.im = r.im;
        }
        for (const c of coefficients) {
            if (c.pathType === "none") {
                c.curve = [{ re: c.re, im: c.im }];
            } else {
                c.curve = computeCurve(c.re, c.im, c.pathType, c.radius / 100 * coeffExtent(), c.angle, c.extra);
            }
            c.curveIndex = 0;
        }
        autoScaleCoeffPanel();
        renderCoefficients();
        updateCoeffSelectionVisual();
        renderCoeffTrails();
        updateListCoords();
        solveRootsThrottled();
    } else if (snap.which === "roots") {
        for (const s of snap.items) {
            const r = currentRoots[s.idx];
            const res = fn(s.re, s.im);
            r.re = res.re; r.im = res.im;
        }
        autoScaleRootsPanel();
        // Update coefficients in-place (preserving trajectory metadata), same as root drag
        const newCoeffs = rootsToCoefficients(currentRoots.map(r => ({ re: r.re, im: r.im })));
        for (let ci = 0; ci < newCoeffs.length; ci++) {
            const deltaRe = newCoeffs[ci].re - coefficients[ci].re;
            const deltaIm = newCoeffs[ci].im - coefficients[ci].im;
            coefficients[ci].re = newCoeffs[ci].re;
            coefficients[ci].im = newCoeffs[ci].im;
            for (const pt of coefficients[ci].curve) {
                pt.re += deltaRe;
                pt.im += deltaIm;
            }
        }
        renderCoefficients();
        renderCoeffTrails();
        renderRoots(currentRoots);
        updateRootSelectionVisual();
        updateListCoords();
    } else if (snap.which === "morph") {
        for (const s of snap.items) {
            const d = morphTargetCoeffs[s.idx];
            const r = fn(s.re, s.im);
            d.re = r.re; d.im = r.im;
        }
        for (const d of morphTargetCoeffs) {
            if (d.pathType === "none" || d.pathType === "follow-c") {
                d.curve = [{ re: d.re, im: d.im }];
            } else {
                d.curve = computeCurve(d.re, d.im, d.pathType, d.radius / 100 * coeffExtent(), d.angle, d.extra);
            }
            d.curveIndex = 0;
        }
        if (leftTab === "morph") renderMorphPanel();
        updateMorphSelectionVisual();
        if (leftTab === "dlist") { refreshDCoeffList(); refreshDListCurveEditor(); }
        if (morphEnabled) solveRootsThrottled();
    }
}

function positionPopover(btnEl) {
    const r = btnEl.getBoundingClientRect();
    opsPop.style.left = (r.right + 8) + "px";
    opsPop.style.top = r.top + "px";
}

let opCloseCallback = null;

function closeOpTool() {
    if (opCloseCallback) { opCloseCallback(); opCloseCallback = null; }
    opsPop.classList.remove("open");
    opsPop.innerHTML = "";
    if (activeToolBtn) activeToolBtn.classList.remove("tool-active");
    activeToolBtn = null;
    opSnapshot = null;
    window.removeEventListener("mousemove", opToolMouseMove);
    window.removeEventListener("mouseup", opToolMouseUp);
}

let opToolMouseMove = null;
let opToolMouseUp = null;

function openOpTool(btnEl, buildFn) {
    if (activeToolBtn === btnEl) { closeOpTool(); return; }
    closeOpTool();
    closeDegreePopover();
    if (typeof closeAudioPop === "function") closeAudioPop();
    if (typeof closeColorPop === "function") closeColorPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();
    opSnapshot = snapshotSelection();
    if (!opSnapshot) { uiBuzz(); return; }
    activeToolBtn = btnEl;
    btnEl.classList.add("tool-active");
    opsPop.innerHTML = "";
    buildFn(opsPop, opSnapshot);
    opsPop.classList.add("open");
    positionPopover(btnEl);
}

// --- Scale tool: vertical slider, exponential mapping ---
// u in [0,1] mapped to scale = exp(k*(u - 0.5)*2) where k=ln(10) â†’ range [0.1, 10]
const SCALE_K = Math.log(10);
function uToScale(u) { return Math.exp(SCALE_K * (u * 2 - 1)); }
function scaleToU(s) { return (Math.log(s) / SCALE_K + 1) / 2; }

function buildScaleTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Scale";
    const valEl = document.createElement("div");
    valEl.className = "pop-val"; valEl.textContent = "1.00Ã—";

    const slider = document.createElement("div");
    slider.className = "vslider";
    const fill = document.createElement("div");
    fill.className = "vslider-fill";
    const thumb = document.createElement("div");
    thumb.className = "vslider-thumb";
    slider.appendChild(fill);
    slider.appendChild(thumb);

    let u = 0.5; // start at 1Ã—
    function updateVisual() {
        const pct = u * 100;
        fill.style.height = pct + "%";
        thumb.style.bottom = pct + "%";
        const s = uToScale(u);
        valEl.textContent = s.toFixed(2) + "Ã—";
        applyPreview(snap, (re, im) => ({ re: re * s, im: im * s }));
    }

    function setFromY(clientY) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, 1 - (clientY - rect.top) / rect.height));
        updateVisual();
    }

    let dragging = false;
    slider.addEventListener("mousedown", e => {
        dragging = true; setFromY(e.clientY); e.preventDefault();
    });
    opToolMouseMove = e => { if (dragging) setFromY(e.clientY); };
    opToolMouseUp = () => { dragging = false; };
    window.addEventListener("mousemove", opToolMouseMove);
    window.addEventListener("mouseup", opToolMouseUp);

    updateVisual();
    pop.appendChild(title);
    pop.appendChild(slider);
    pop.appendChild(valEl);
}

// --- Scale Re tool: vertical slider, scales only real part ---
function buildScaleReTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Scale Re";
    const valEl = document.createElement("div");
    valEl.className = "pop-val"; valEl.textContent = "1.00Ã—";

    const slider = document.createElement("div");
    slider.className = "vslider";
    const fill = document.createElement("div");
    fill.className = "vslider-fill";
    const thumb = document.createElement("div");
    thumb.className = "vslider-thumb";
    slider.appendChild(fill);
    slider.appendChild(thumb);

    let u = 0.5;
    function updateVisual() {
        const pct = u * 100;
        fill.style.height = pct + "%";
        thumb.style.bottom = pct + "%";
        const s = uToScale(u);
        valEl.textContent = s.toFixed(2) + "Ã—";
        applyPreview(snap, (re, im) => ({ re: re * s, im: im }));
    }

    function setFromY(clientY) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, 1 - (clientY - rect.top) / rect.height));
        updateVisual();
    }

    let dragging = false;
    slider.addEventListener("mousedown", e => {
        dragging = true; setFromY(e.clientY); e.preventDefault();
    });
    opToolMouseMove = e => { if (dragging) setFromY(e.clientY); };
    opToolMouseUp = () => { dragging = false; };
    window.addEventListener("mousemove", opToolMouseMove);
    window.addEventListener("mouseup", opToolMouseUp);

    updateVisual();
    pop.appendChild(title);
    pop.appendChild(slider);
    pop.appendChild(valEl);
}

// --- Scale Im tool: vertical slider, scales only imaginary part ---
function buildScaleImTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Scale Im";
    const valEl = document.createElement("div");
    valEl.className = "pop-val"; valEl.textContent = "1.00Ã—";

    const slider = document.createElement("div");
    slider.className = "vslider";
    const fill = document.createElement("div");
    fill.className = "vslider-fill";
    const thumb = document.createElement("div");
    thumb.className = "vslider-thumb";
    slider.appendChild(fill);
    slider.appendChild(thumb);

    let u = 0.5;
    function updateVisual() {
        const pct = u * 100;
        fill.style.height = pct + "%";
        thumb.style.bottom = pct + "%";
        const s = uToScale(u);
        valEl.textContent = s.toFixed(2) + "Ã—";
        applyPreview(snap, (re, im) => ({ re: re, im: im * s }));
    }

    function setFromY(clientY) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, 1 - (clientY - rect.top) / rect.height));
        updateVisual();
    }

    let dragging = false;
    slider.addEventListener("mousedown", e => {
        dragging = true; setFromY(e.clientY); e.preventDefault();
    });
    opToolMouseMove = e => { if (dragging) setFromY(e.clientY); };
    opToolMouseUp = () => { dragging = false; };
    window.addEventListener("mousemove", opToolMouseMove);
    window.addEventListener("mouseup", opToolMouseUp);

    updateVisual();
    pop.appendChild(title);
    pop.appendChild(slider);
    pop.appendChild(valEl);
}

// --- Shape morph tool: unified shape selector + morph slider ---
function regularPolyVerts(cRe, cIm, R, sides) {
    const v = [];
    for (let i = 0; i < sides; i++) {
        const a = Math.PI / 2 + i * 2 * Math.PI / sides;
        v.push({ re: cRe + R * Math.cos(a), im: cIm + R * Math.sin(a) });
    }
    return v;
}
function rayPolyHit(cRe, cIm, dx, dy, verts) {
    let tMin = Infinity;
    for (let i = 0, nv = verts.length; i < nv; i++) {
        const j = (i + 1) % nv;
        const eRe = verts[j].re - verts[i].re, eIm = verts[j].im - verts[i].im;
        const den = dy * eRe - dx * eIm;
        if (Math.abs(den) < 1e-15) continue;
        const dRe = verts[i].re - cRe, dIm = verts[i].im - cIm;
        const t = (dIm * eRe - dRe * eIm) / den;
        const s = (dx * dIm - dy * dRe) / den;
        if (t > 1e-9 && s >= -1e-9 && s <= 1 + 1e-9) tMin = Math.min(tMin, t);
    }
    if (tMin === Infinity) return null;
    return { re: cRe + tMin * dx, im: cIm + tMin * dy };
}
function shapeTargets(shape, items, cRe, cIm, R, bbox) {
    return items.map(s => {
        const dx = s.re - cRe, dy = s.im - cIm;
        if (Math.abs(dx) < 1e-15 && Math.abs(dy) < 1e-15) return { re: s.re, im: s.im };
        if (shape === "box") {
            const verts = [
                { re: bbox[0], im: bbox[3] }, { re: bbox[1], im: bbox[3] },
                { re: bbox[1], im: bbox[2] }, { re: bbox[0], im: bbox[2] }
            ];
            return rayPolyHit(cRe, cIm, dx, dy, verts) || { re: s.re, im: s.im };
        } else if (shape === "inf") {
            const theta = Math.atan2(dy, dx);
            const c = Math.cos(theta);
            const r = R * (0.2 + 0.8 * c * c);
            const d = Math.sqrt(dx * dx + dy * dy);
            return { re: cRe + dx * r / d, im: cIm + dy * r / d };
        } else {
            const sides = shape === "tri" ? 3 : shape === "pent" ? 5 : shape === "hex" ? 6 : 4;
            const verts = regularPolyVerts(cRe, cIm, R, sides);
            return rayPolyHit(cRe, cIm, dx, dy, verts) || { re: s.re, im: s.im };
        }
    });
}

// --- Pattern arrange: distribute n points equally on preset shapes ---
function distributeOnPath(n, verts, closed) {
    const nv = verts.length;
    if (n <= 0 || nv === 0) return [];
    if (n === 1) return [{ re: verts[0].re, im: verts[0].im }];
    const nEdges = closed ? nv : nv - 1;
    if (nEdges === 0) return Array.from({ length: n }, () => ({ re: verts[0].re, im: verts[0].im }));
    const cumDist = [0];
    for (let i = 0; i < nEdges; i++) {
        const j = closed ? (i + 1) % nv : i + 1;
        const dx = verts[j].re - verts[i].re, dy = verts[j].im - verts[i].im;
        cumDist.push(cumDist[i] + Math.sqrt(dx * dx + dy * dy));
    }
    const totalLen = cumDist[nEdges];
    if (totalLen < 1e-15) return Array.from({ length: n }, () => ({ re: verts[0].re, im: verts[0].im }));
    const spacing = closed ? totalLen / n : totalLen / Math.max(n - 1, 1);
    const pts = [];
    let edge = 0;
    for (let i = 0; i < n; i++) {
        const target = i * spacing;
        while (edge < nEdges - 1 && cumDist[edge + 1] < target - 1e-12) edge++;
        const edgeLen = cumDist[edge + 1] - cumDist[edge];
        const t = edgeLen > 1e-15 ? (target - cumDist[edge]) / edgeLen : 0;
        const j = closed ? (edge + 1) % nv : edge + 1;
        pts.push({
            re: verts[edge].re + t * (verts[j].re - verts[edge].re),
            im: verts[edge].im + t * (verts[j].im - verts[edge].im)
        });
    }
    return pts;
}

function patternPositions(pattern, n, cRe, cIm, R, opts) {
    if (n <= 0) return [];
    if (R < 1e-15) R = 1;
    if (n === 1) return [{ re: cRe, im: cIm }];
    if (!opts) opts = {};
    switch (pattern) {
        case "circle": {
            const pts = [];
            for (let i = 0; i < n; i++) {
                const a = Math.PI / 2 + 2 * Math.PI * i / n;
                pts.push({ re: cRe + R * Math.cos(a), im: cIm + R * Math.sin(a) });
            }
            return pts;
        }
        case "square": {
            const s = R;
            const verts = [
                { re: cRe - s, im: cIm + s }, { re: cRe + s, im: cIm + s },
                { re: cRe + s, im: cIm - s }, { re: cRe - s, im: cIm - s }
            ];
            return distributeOnPath(n, verts, true);
        }
        case "triangle": {
            const verts = regularPolyVerts(cRe, cIm, R, 3);
            return distributeOnPath(n, verts, true);
        }
        case "pentagon": {
            const verts = regularPolyVerts(cRe, cIm, R, 5);
            return distributeOnPath(n, verts, true);
        }
        case "hexagon": {
            const verts = regularPolyVerts(cRe, cIm, R, 6);
            return distributeOnPath(n, verts, true);
        }
        case "diamond": {
            const verts = regularPolyVerts(cRe, cIm, R, 4);
            return distributeOnPath(n, verts, true);
        }
        case "star": {
            const inner = R * (opts.starInner !== undefined ? opts.starInner : 0.38);
            const verts = [];
            for (let i = 0; i < 10; i++) {
                const a = Math.PI / 2 + Math.PI * i / 5;
                const r = i % 2 === 0 ? R : inner;
                verts.push({ re: cRe + r * Math.cos(a), im: cIm + r * Math.sin(a) });
            }
            return distributeOnPath(n, verts, true);
        }
        case "ellipse": {
            const asp = opts.aspect !== undefined ? opts.aspect : 0.5;
            const rx = R / Math.sqrt(asp), ry = R * Math.sqrt(asp);
            const nSamp = Math.max(n * 8, 200);
            const verts = [];
            for (let i = 0; i < nSamp; i++) {
                const a = Math.PI / 2 + 2 * Math.PI * i / nSamp;
                verts.push({ re: cRe + rx * Math.cos(a), im: cIm + ry * Math.sin(a) });
            }
            return distributeOnPath(n, verts, true);
        }
        case "infinity": {
            const infAmp = opts.amp !== undefined ? opts.amp : 0.5;
            const nSamp = Math.max(n * 8, 200);
            const verts = [];
            for (let i = 0; i < nSamp; i++) {
                const t = 2 * Math.PI * i / nSamp;
                verts.push({ re: cRe + R * Math.cos(t), im: cIm + R * infAmp * Math.sin(2 * t) });
            }
            return distributeOnPath(n, verts, true);
        }
        case "spiral": {
            const turns = opts.turns !== undefined ? opts.turns : 3;
            const nSamp = Math.max(n * 8, 300);
            const verts = [];
            for (let i = 0; i < nSamp; i++) {
                const f = i / (nSamp - 1);
                const r = R * f;
                const theta = turns * 2 * Math.PI * f + Math.PI / 2;
                verts.push({ re: cRe + r * Math.cos(theta), im: cIm + r * Math.sin(theta) });
            }
            return distributeOnPath(n, verts, false);
        }
        case "grid": {
            let cols = opts.cols !== undefined ? opts.cols : Math.round(Math.sqrt(n));
            if (cols < 1) cols = 1;
            const rows = Math.ceil(n / cols);
            const dx = cols > 1 ? 2 * R / (cols - 1) : 0;
            const dy = rows > 1 ? 2 * R / (rows - 1) : 0;
            const pts = [];
            let rem = n;
            for (let r = 0; r < rows; r++) {
                const inRow = Math.min(cols, rem);
                const rowOff = (cols - inRow) * dx / 2;
                for (let c = 0; c < inRow; c++) {
                    pts.push({ re: cRe - R + rowOff + c * dx, im: cIm + R - r * dy });
                }
                rem -= inRow;
            }
            return pts;
        }
        case "line": {
            const ang = (opts.angle !== undefined ? opts.angle : 0) * Math.PI / 180;
            const dx = Math.cos(ang), dy = Math.sin(ang);
            const pts = [];
            for (let i = 0; i < n; i++) {
                const f = n > 1 ? 2 * i / (n - 1) - 1 : 0;
                pts.push({ re: cRe + R * f * dx, im: cIm + R * f * dy });
            }
            return pts;
        }
        case "wave": {
            const wCycles = opts.cycles !== undefined ? opts.cycles : 1;
            const wAmp = opts.amp !== undefined ? opts.amp : 0.5;
            const pts = [];
            for (let i = 0; i < n; i++) {
                const t = n > 1 ? i / (n - 1) : 0.5;
                pts.push({ re: cRe - R + 2 * R * t, im: cIm + R * wAmp * Math.sin(2 * Math.PI * wCycles * t) });
            }
            return pts;
        }
        case "cross": {
            const arm = R, w = R * (opts.armWidth !== undefined ? opts.armWidth : 0.25);
            const verts = [
                { re: cRe - w, im: cIm + arm }, { re: cRe + w, im: cIm + arm },
                { re: cRe + w, im: cIm + w },   { re: cRe + arm, im: cIm + w },
                { re: cRe + arm, im: cIm - w },  { re: cRe + w, im: cIm - w },
                { re: cRe + w, im: cIm - arm },  { re: cRe - w, im: cIm - arm },
                { re: cRe - w, im: cIm - w },    { re: cRe - arm, im: cIm - w },
                { re: cRe - arm, im: cIm + w },  { re: cRe - w, im: cIm + w }
            ];
            return distributeOnPath(n, verts, true);
        }
        case "heart": {
            const nSamp = Math.max(n * 8, 200);
            const verts = [];
            for (let i = 0; i < nSamp; i++) {
                const t = 2 * Math.PI * i / nSamp;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                verts.push({ re: cRe + x * R / 17, im: cIm + y * R / 17 });
            }
            return distributeOnPath(n, verts, true);
        }
        case "lissajous": {
            const lA = opts.freqA !== undefined ? opts.freqA : 3;
            const lB = opts.freqB !== undefined ? opts.freqB : 2;
            const nSamp = Math.max(n * 8, 200);
            const verts = [];
            for (let i = 0; i < nSamp; i++) {
                const t = 2 * Math.PI * i / nSamp;
                verts.push({ re: cRe + R * Math.sin(lA * t), im: cIm + R * Math.sin(lB * t) });
            }
            return distributeOnPath(n, verts, true);
        }
        case "rose": {
            const rK = opts.petals !== undefined ? opts.petals : 3;
            const nSamp = Math.max(n * 8, 200);
            const verts = [];
            for (let i = 0; i < nSamp; i++) {
                const t = 2 * Math.PI * i / nSamp;
                const r = R * Math.abs(Math.cos(rK * t));
                verts.push({ re: cRe + r * Math.cos(t), im: cIm + r * Math.sin(t) });
            }
            return distributeOnPath(n, verts, true);
        }
        case "2-circles": {
            const d2c = opts.dist !== undefined ? opts.dist : 1.0;
            const half = Math.ceil(n / 2);
            const r = R * 0.45;
            const baseOff = R * 0.55;
            const off = baseOff * d2c;
            const pts = [];
            for (let i = 0; i < half; i++) {
                const a = Math.PI / 2 + 2 * Math.PI * i / half;
                pts.push({ re: cRe - off + r * Math.cos(a), im: cIm + r * Math.sin(a) });
            }
            const rest = n - half;
            for (let i = 0; i < rest; i++) {
                const a = Math.PI / 2 + 2 * Math.PI * i / rest;
                pts.push({ re: cRe + off + r * Math.cos(a), im: cIm + r * Math.sin(a) });
            }
            return pts;
        }
        case "2-squares": {
            const d2s = opts.dist !== undefined ? opts.dist : 1.0;
            const half = Math.ceil(n / 2);
            const s = R * 0.42;
            const baseOff = R * 0.5;
            const off = baseOff * d2s;
            const leftV = [
                { re: cRe - off - s, im: cIm + s }, { re: cRe - off + s, im: cIm + s },
                { re: cRe - off + s, im: cIm - s }, { re: cRe - off - s, im: cIm - s }
            ];
            const rightV = [
                { re: cRe + off - s, im: cIm + s }, { re: cRe + off + s, im: cIm + s },
                { re: cRe + off + s, im: cIm - s }, { re: cRe + off - s, im: cIm - s }
            ];
            return distributeOnPath(half, leftV, true).concat(distributeOnPath(n - half, rightV, true));
        }
        case "ring": {
            const rInner = opts.innerR !== undefined ? opts.innerR : 0.5;
            const half = Math.ceil(n / 2);
            const rest = n - half;
            const pts = [];
            for (let i = 0; i < half; i++) {
                const a = Math.PI / 2 + 2 * Math.PI * i / half;
                pts.push({ re: cRe + R * Math.cos(a), im: cIm + R * Math.sin(a) });
            }
            for (let i = 0; i < rest; i++) {
                const a = Math.PI / 2 + 2 * Math.PI * i / rest;
                pts.push({ re: cRe + R * rInner * Math.cos(a), im: cIm + R * rInner * Math.sin(a) });
            }
            return pts;
        }
        case "scatter": {
            const golden = Math.PI * (3 - Math.sqrt(5));
            const pts = [];
            for (let i = 0; i < n; i++) {
                const a = golden * i;
                const r = R * Math.sqrt((i + 0.5) / n);
                pts.push({ re: cRe + r * Math.cos(a), im: cIm + r * Math.sin(a) });
            }
            return pts;
        }
        default: return Array.from({ length: n }, () => ({ re: cRe, im: cIm }));
    }
}

const PATTERN_LIST = [
    { key: "circle", label: "Circle" }, { key: "square", label: "Square" },
    { key: "triangle", label: "Triangle" }, { key: "pentagon", label: "Pentagon" },
    { key: "hexagon", label: "Hexagon" }, { key: "diamond", label: "Diamond" },
    { key: "star", label: "Star" }, { key: "ellipse", label: "Ellipse" },
    { key: "infinity", label: "Infinity (\u221e)" }, { key: "spiral", label: "Spiral" },
    { key: "grid", label: "Grid" }, { key: "line", label: "Line" },
    { key: "wave", label: "Wave" }, { key: "cross", label: "Cross" },
    { key: "heart", label: "Heart" }, { key: "lissajous", label: "Lissajous" },
    { key: "rose", label: "Rose" }, { key: "2-circles", label: "2 Circles" },
    { key: "2-squares", label: "2 Squares" }, { key: "ring", label: "Ring" },
    { key: "scatter", label: "Scatter" }
];

const PTRN_PARAMS = {
    "star":       [{ key: "starInner", label: "Inner R",   min: 0.1, max: 0.9,  step: 0.01, def: 0.38 }],
    "ellipse":    [{ key: "aspect",    label: "Aspect",    min: 0.1, max: 3.0,  step: 0.1,  def: 0.5 }],
    "infinity":   [{ key: "amp",       label: "Amp",       min: 0.1, max: 1.0,  step: 0.01, def: 0.5 }],
    "spiral":     [{ key: "turns",     label: "Turns",     min: 0.5, max: 10,   step: 0.5,  def: 3 }],
    "grid":       [{ key: "cols",      label: "Cols",      min: 1,   max: 30,   step: 1,    def: 0 }],
    "line":       [{ key: "angle",     label: "Angle\u00b0", min: 0, max: 360,  step: 1,    def: 0 }],
    "wave":       [{ key: "cycles",    label: "Cycles",    min: 0.5, max: 5.0,  step: 0.5,  def: 1 },
                   { key: "amp",       label: "Amp",       min: 0.1, max: 1.0,  step: 0.05, def: 0.5 }],
    "cross":      [{ key: "armWidth",  label: "Width",     min: 0.05,max: 0.5,  step: 0.01, def: 0.25 }],
    "lissajous":  [{ key: "freqA",    label: "Freq A",    min: 1,   max: 8,    step: 1,    def: 3 },
                   { key: "freqB",    label: "Freq B",    min: 1,   max: 8,    step: 1,    def: 2 }],
    "rose":       [{ key: "petals",   label: "Petals",    min: 1,   max: 12,   step: 1,    def: 3 }],
    "2-circles":  [{ key: "dist",     label: "Distance",  min: 0,   max: 2.0,  step: 0.01, def: 1.0 }],
    "2-squares":  [{ key: "dist",     label: "Distance",  min: 0,   max: 2.0,  step: 0.01, def: 1.0 }],
    "ring":       [{ key: "innerR",   label: "Inner R",   min: 0.1, max: 0.95, step: 0.01, def: 0.5 }]
};

function buildPatternTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Pattern";

    const n = snap.items.length;
    let cRe = 0, cIm = 0;
    for (const s of snap.items) { cRe += s.re; cIm += s.im; }
    cRe /= n; cIm /= n;

    let R2 = 0;
    for (const s of snap.items) {
        const d2 = (s.re - cRe) ** 2 + (s.im - cIm) ** 2;
        if (d2 > R2) R2 = d2;
    }
    const R = Math.sqrt(R2) || 1;

    let currentPattern = "circle";
    let opts = {};

    const controlsDiv = document.createElement("div");
    controlsDiv.style.cssText = "width:100%;";

    function buildControls() {
        controlsDiv.innerHTML = "";
        const params = PTRN_PARAMS[currentPattern];
        if (!params) return;
        for (const p of params) {
            const row = document.createElement("div");
            row.style.cssText = "display:flex;align-items:center;gap:3px;margin:2px 0;font-size:9px;color:#aaa;";
            const lbl = document.createElement("span");
            lbl.textContent = p.label;
            lbl.style.cssText = "width:44px;flex-shrink:0;";
            const inp = document.createElement("input");
            inp.type = "range";
            let pMin = p.min, pMax = p.max;
            if (p.key === "cols") { pMax = n; }
            inp.min = pMin; inp.max = pMax; inp.step = p.step;
            const defVal = p.key === "cols" && p.def === 0 ? Math.round(Math.sqrt(n)) : p.def;
            inp.value = opts[p.key] !== undefined ? opts[p.key] : defVal;
            if (opts[p.key] === undefined) opts[p.key] = defVal;
            inp.style.cssText = "flex:1;height:12px;accent-color:var(--accent);";
            const val = document.createElement("span");
            val.textContent = Number(inp.value).toFixed(p.step < 1 ? (p.step < 0.1 ? 2 : 1) : 0);
            val.style.cssText = "width:28px;text-align:right;font-size:8px;flex-shrink:0;";
            inp.addEventListener("input", () => {
                opts[p.key] = parseFloat(inp.value);
                val.textContent = Number(inp.value).toFixed(p.step < 1 ? (p.step < 0.1 ? 2 : 1) : 0);
                refresh();
            });
            row.appendChild(lbl); row.appendChild(inp); row.appendChild(val);
            controlsDiv.appendChild(row);
        }
    }

    function refresh() {
        const targets = patternPositions(currentPattern, n, cRe, cIm, R, opts);
        let ci = 0;
        applyPreview(snap, () => targets[ci++]);
    }

    const sel = document.createElement("select");
    sel.style.cssText = "width:100%;font-size:10px;margin:4px 0;background:#333;color:#fff;border:1px solid #666;border-radius:3px;padding:2px;";
    for (const p of PATTERN_LIST) {
        const opt = document.createElement("option");
        opt.value = p.key; opt.textContent = p.label;
        sel.appendChild(opt);
    }
    sel.addEventListener("change", () => {
        currentPattern = sel.value;
        opts = {};
        buildControls();
        refresh();
    });

    const acceptBtn = document.createElement("button");
    acceptBtn.textContent = "\u2713 Accept";
    acceptBtn.style.cssText = "width:100%;font-size:10px;padding:3px;margin-top:6px;background:#4a4;color:#fff;border:1px solid #6c6;border-radius:3px;cursor:pointer;";
    let accepted = false;
    acceptBtn.addEventListener("click", () => { accepted = true; closeOpTool(); });

    opCloseCallback = () => {
        if (!accepted && opSnapshot) {
            applyPreview(opSnapshot, (re, im) => ({ re, im }));
        }
    };

    buildControls();
    refresh();

    pop.appendChild(title); pop.appendChild(sel);
    pop.appendChild(controlsDiv); pop.appendChild(acceptBtn);
}

function buildShapeTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Shape";
    const valEl = document.createElement("div");
    valEl.className = "pop-val"; valEl.textContent = "50%";

    const n = snap.items.length;
    let cRe = 0, cIm = 0;
    for (const s of snap.items) { cRe += s.re; cIm += s.im; }
    cRe /= n; cIm /= n;

    let R2 = 0;
    for (const s of snap.items) {
        const d2 = (s.re - cRe) ** 2 + (s.im - cIm) ** 2;
        if (d2 > R2) R2 = d2;
    }
    const R = Math.sqrt(R2);

    let bMinRe = Infinity, bMaxRe = -Infinity, bMinIm = Infinity, bMaxIm = -Infinity;
    for (const s of snap.items) {
        if (s.re < bMinRe) bMinRe = s.re;
        if (s.re > bMaxRe) bMaxRe = s.re;
        if (s.im < bMinIm) bMinIm = s.im;
        if (s.im > bMaxIm) bMaxIm = s.im;
    }
    const bbox = [bMinRe, bMaxRe, bMinIm, bMaxIm];

    let currentShape = "box";
    let targets = shapeTargets(currentShape, snap.items, cRe, cIm, R, bbox);

    // Shape selector chips
    const chipRow = document.createElement("div");
    chipRow.style.cssText = "display:flex;gap:3px;justify-content:center;margin:4px 0;";
    const shapes = [
        { key: "box", label: "Box" }, { key: "tri", label: "Tri" },
        { key: "inf", label: "\u221e" }, { key: "pent", label: "Pent" }
    ];
    const chips = {};
    for (const sh of shapes) {
        const chip = document.createElement("button");
        chip.textContent = sh.label;
        chip.style.cssText = "font-size:8px;padding:1px 5px;border-radius:4px;border:1px solid #888;color:#fff;cursor:pointer;background:" + (sh.key === currentShape ? "#4af" : "#333");
        chip.addEventListener("click", () => {
            currentShape = sh.key;
            targets = shapeTargets(currentShape, snap.items, cRe, cIm, R, bbox);
            for (const k in chips) chips[k].style.background = k === currentShape ? "#4af" : "#333";
            updateVisual();
        });
        chips[sh.key] = chip;
        chipRow.appendChild(chip);
    }

    const slider = document.createElement("div");
    slider.className = "vslider";
    const fill = document.createElement("div");
    fill.className = "vslider-fill";
    const thumb = document.createElement("div");
    thumb.className = "vslider-thumb";
    slider.appendChild(fill); slider.appendChild(thumb);

    let u = 0.5;
    function updateVisual() {
        const pct = u * 100;
        fill.style.height = pct + "%"; thumb.style.bottom = pct + "%";
        valEl.textContent = Math.round(pct) + "%";
        let ci = 0;
        applyPreview(snap, (re, im) => {
            const bp = targets[ci++];
            if (u <= 0.5) {
                const f = u * 2;
                return { re: cRe + f * (re - cRe), im: cIm + f * (im - cIm) };
            } else {
                const f = (u - 0.5) * 2;
                return { re: re + f * (bp.re - re), im: im + f * (bp.im - im) };
            }
        });
    }
    function setFromY(clientY) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, 1 - (clientY - rect.top) / rect.height));
        updateVisual();
    }
    let dragging = false;
    slider.addEventListener("mousedown", e => { dragging = true; setFromY(e.clientY); e.preventDefault(); });
    opToolMouseMove = e => { if (dragging) setFromY(e.clientY); };
    opToolMouseUp = () => { dragging = false; };
    window.addEventListener("mousemove", opToolMouseMove);
    window.addEventListener("mouseup", opToolMouseUp);

    updateVisual();
    pop.appendChild(title); pop.appendChild(chipRow);
    pop.appendChild(slider); pop.appendChild(valEl);
}

// --- Rotate tool: horizontal slider, -0.5 to 0.5 turns ---

function buildRotateTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Rotate";
    const valEl = document.createElement("div");
    valEl.className = "pop-val"; valEl.textContent = "0 turns";

    const slider = document.createElement("div");
    slider.className = "hslider";
    const center = document.createElement("div");
    center.className = "hslider-center";
    const thumb = document.createElement("div");
    thumb.className = "hslider-thumb";
    slider.appendChild(center);
    slider.appendChild(thumb);

    let u = 0.5; // center = 0 turns
    function updateVisual() {
        const pct = u * 100;
        thumb.style.left = pct + "%";
        const turns = u - 0.5; // -0.5 to 0.5
        const sign = turns >= 0 ? "+" : "";
        valEl.textContent = sign + turns.toFixed(3) + " turns";
        const angle = 2 * Math.PI * turns;
        const cosA = Math.cos(angle), sinA = Math.sin(angle);
        applyPreview(snap, (re, im) => ({
            re: re * cosA - im * sinA,
            im: re * sinA + im * cosA
        }));
    }

    function setFromX(clientX) {
        const rect = slider.getBoundingClientRect();
        u = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        updateVisual();
    }

    let dragging = false;
    slider.addEventListener("mousedown", e => {
        dragging = true; setFromX(e.clientX); e.preventDefault();
    });
    opToolMouseMove = e => { if (dragging) setFromX(e.clientX); };
    opToolMouseUp = () => { dragging = false; };
    window.addEventListener("mousemove", opToolMouseMove);
    window.addEventListener("mouseup", opToolMouseUp);

    updateVisual();
    pop.appendChild(title);
    pop.appendChild(slider);
    pop.appendChild(valEl);
}

// --- Add tool: 2D vector pad ---
// Pad maps pixel offset to complex offset. Range: +/-2 in each axis.
const PAD_RANGE = 2;

function buildAddTool(pop, snap) {
    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "Translate";
    const valEl = document.createElement("div");
    valEl.className = "pop-row";

    const pad = document.createElement("div");
    pad.className = "vec-pad";
    const axH = document.createElement("div");
    axH.className = "pad-axis h";
    const axV = document.createElement("div");
    axV.className = "pad-axis v";
    const dot = document.createElement("div");
    dot.className = "pad-dot";
    pad.appendChild(axH);
    pad.appendChild(axV);
    pad.appendChild(dot);

    let ux = 0.5, uy = 0.5; // center = (0,0)
    function updateVisual() {
        dot.style.left = (ux * 100) + "%";
        dot.style.top = (uy * 100) + "%";
        const dx = (ux - 0.5) * 2 * PAD_RANGE;
        const dy = -(uy - 0.5) * 2 * PAD_RANGE; // screen Y is inverted
        const signRe = dx >= 0 ? "+" : "";
        const signIm = dy >= 0 ? "+" : "";
        valEl.textContent = signRe + dx.toFixed(2) + " " + signIm + dy.toFixed(2) + "i";
        applyPreview(snap, (re, im) => ({ re: re + dx, im: im + dy }));
    }

    function setFromXY(clientX, clientY) {
        const rect = pad.getBoundingClientRect();
        ux = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        uy = Math.max(0, Math.min(1, (clientY - rect.top) / rect.height));
        updateVisual();
    }

    let dragging = false;
    pad.addEventListener("mousedown", e => {
        dragging = true; setFromXY(e.clientX, e.clientY); e.preventDefault();
    });
    opToolMouseMove = e => { if (dragging) setFromXY(e.clientX, e.clientY); };
    opToolMouseUp = () => { dragging = false; };
    window.addEventListener("mousemove", opToolMouseMove);
    window.addEventListener("mouseup", opToolMouseUp);

    updateVisual();
    pop.appendChild(title);
    pop.appendChild(pad);
    pop.appendChild(valEl);
}

// Wire up buttons
document.getElementById("scale-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildScaleTool);
});
document.getElementById("scale-re-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildScaleReTool);
});
document.getElementById("scale-im-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildScaleImTool);
});
document.getElementById("rotate-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildRotateTool);
});
document.getElementById("add-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildAddTool);
});
document.getElementById("shape-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildShapeTool);
});
document.getElementById("ptrn-tool-btn").addEventListener("click", function() {
    openOpTool(this, buildPatternTool);
});

// Inverse button: reverse coefficient order (reflects roots around unit circle)
document.getElementById("inverse-btn").addEventListener("click", function() {
    const n = coefficients.length;
    if (n < 2) { uiBuzz(); return; }
    // Swap coefficients[i] â†” coefficients[n-1-i] (all fields)
    for (let i = 0; i < Math.floor(n / 2); i++) {
        const j = n - 1 - i;
        const tmp = { ...coefficients[i], curve: coefficients[i].curve };
        Object.assign(coefficients[i], coefficients[j], { curve: coefficients[j].curve });
        Object.assign(coefficients[j], tmp, { curve: tmp.curve });
    }
    // Recompute curves from new positions
    for (const c of coefficients) {
        if (c.pathType === "none") {
            c.curve = [{ re: c.re, im: c.im }];
        } else {
            c.curve = computeCurve(c.re, c.im, c.pathType, c.radius / 100 * coeffExtent(), c.angle, c.extra);
        }
        c.curveIndex = 0;
    }
    autoScaleCoeffPanel();
    renderCoefficients();
    updateCoeffSelectionVisual();
    renderCoeffTrails();
    updateListCoords();
    solveRootsThrottled();
    renderDomainColoringThrottled();
    uiBuzz();
});

// Close popover on click outside
document.addEventListener("mousedown", e => {
    // Revert anim-bar preview on outside click
    if (barSnapshots) {
        const animBar = document.getElementById("anim-bar");
        if (!animBar.contains(e.target)) {
            revertBarPreview();
        }
    }
    // Close ops popover
    if (activeToolBtn) {
        if (!opsPop.contains(e.target) && !(e.target.id && e.target.id.endsWith("-tool-btn"))) {
            closeOpTool();
        }
    }
    // Close audio popover
    if (activeAudioBtn) {
        if (!audioPop.contains(e.target) && !(e.target.id && e.target.id.endsWith("-toggle-btn"))) {
            closeAudioPop();
        }
    }
    // Close color popover
    if (colorPopOpen) {
        if (!colorPop.contains(e.target) && e.target.id !== "root-color-btn") {
            closeColorPop();
        }
    }
    // Close coeff picker popover
    if (coeffPickOpen) {
        if (!coeffPickPop.contains(e.target) && e.target.id !== "coeff-picker-btn") {
            closeCoeffPick();
        }
    }
    // Close coefficient context menu (revert on outside click)
    if (ctxCoeffIdx >= 0) {
        const ctxEl = document.getElementById("coeff-ctx");
        if (!ctxEl.contains(e.target)) {
            closeCoeffCtx(true);
        }
    }
    // Close D-node context menu (revert on outside click)
    if (ctxDNodeIdx >= 0) {
        const dctxEl = document.getElementById("dnode-ctx");
        if (!dctxEl.contains(e.target)) {
            closeDNodeCtx(true);
        }
    }
    // Close snap popup
    if (typeof snapPopOpen !== "undefined" && snapPopOpen) {
        const sp = document.getElementById("snap-pop");
        if (sp && !sp.contains(e.target) && e.target.id !== "snap-btn") {
            if (typeof closeSnapPop === "function") closeSnapPop();
        }
    }
    // Close timing popup
    if (typeof timingPopOpen !== "undefined" && timingPopOpen) {
        const tp = document.getElementById("timing-pop");
        if (tp && !tp.contains(e.target) && e.target.id !== "timing-btn") {
            if (typeof closeTimingPop === "function") closeTimingPop();
        }
    }
    // Close bitmap cfg popup
    if (typeof bitmapCfgPopOpen !== "undefined" && bitmapCfgPopOpen) {
        const bcp = document.getElementById("bitmap-cfg-pop");
        if (bcp && !bcp.contains(e.target) && e.target.id !== "bitmap-cfg-btn") {
            if (typeof closeBitmapCfgPop === "function") closeBitmapCfgPop();
        }
    }
    // Close bitmap save popup
    if (typeof bitmapSavePopOpen !== "undefined" && bitmapSavePopOpen) {
        const bsp = document.getElementById("bitmap-save-pop");
        if (bsp && !bsp.contains(e.target) && e.target.id !== "bitmap-save-btn") {
            if (typeof closeBitmapSavePop === "function") closeBitmapSavePop();
        }
    }
    // Close path picker popup (revert on outside click)
    if (typeof pathPickOpen !== "undefined" && pathPickOpen) {
        const pp = document.getElementById("path-pick-pop");
        if (pp && !pp.contains(e.target) && !e.target.classList.contains("cpick-path-btn")) {
            if (typeof closePathPickPop === "function") closePathPickPop(true);
        }
    }
    // Close D-list path picker popup (revert on outside click)
    if (typeof dpathPickOpen !== "undefined" && dpathPickOpen) {
        const dp = document.getElementById("dpath-pick-pop");
        if (dp && !dp.contains(e.target) && !e.target.classList.contains("cpick-path-btn")) {
            if (typeof closeDPathPickPop === "function") closeDPathPickPop(true);
        }
    }
});

// Close ops tool on Escape
document.addEventListener("keydown", e => {
    if (e.key === "Escape" && activeToolBtn) {
        closeOpTool();
    }
});

// --- Video recording (MediaRecorder â†’ WebM) ---

let vidRec = {
    recording: false,
    mode: "roots",   // "roots" | "coeffs" | "both"
    canvas: null,
    ctx: null,
    stream: null,
    mr: null,
    chunks: []
};

// --- Panel drawing helpers for recording ---

function drawPanelGrid(ctx, x0, y0, pW, pH, range) {
    const xs = v => MARGIN + (v + range) / (2 * range) * (pW - 2 * MARGIN) + x0;
    const ys = v => (pH - MARGIN) - (v + range) / (2 * range) * (pH - 2 * MARGIN) + y0;

    // Grid
    ctx.strokeStyle = "#1f3354"; ctx.lineWidth = 0.5;
    const intMax = Math.floor(range);
    for (let v = -intMax; v <= intMax; v++) {
        ctx.beginPath(); ctx.moveTo(xs(v), ys(-range)); ctx.lineTo(xs(v), ys(range)); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(xs(-range), ys(v)); ctx.lineTo(xs(range), ys(v)); ctx.stroke();
    }
    // Axes
    ctx.strokeStyle = "#2a4a6b"; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(xs(-range), ys(0)); ctx.lineTo(xs(range), ys(0)); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(xs(0), ys(-range)); ctx.lineTo(xs(0), ys(range)); ctx.stroke();
    // Unit circle
    ctx.setLineDash([4, 3]);
    ctx.beginPath(); ctx.arc(xs(0), ys(0), Math.abs(xs(1) - xs(0)), 0, 2 * Math.PI); ctx.stroke();
    ctx.setLineDash([]);

    return { xs, ys };
}

function drawRootsToCtx(ctx, x0, y0, pW, pH) {
    const range = panels.roots.range;

    // Background + domain coloring
    if (domainColoringEnabled) {
        ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);
        ctx.drawImage(domainCanvas, x0 + MARGIN, y0 + MARGIN, pW - 2 * MARGIN, pH - 2 * MARGIN);
    } else {
        ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);
    }

    const { xs, ys } = drawPanelGrid(ctx, x0, y0, pW, pH, range);

    // Trails
    if (trailData.length > 0) {
        const jumpThresh = range * 0.3;
        ctx.lineWidth = 1.5; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.globalAlpha = 0.6;
        for (let i = 0; i < trailData.length; i++) {
            const pts = trailData[i];
            if (pts.length < 2) continue;
            ctx.strokeStyle = rootColor(i, trailData.length);
            ctx.beginPath(); ctx.moveTo(xs(pts[0].re), ys(pts[0].im));
            for (let j = 1; j < pts.length; j++) {
                const dist = Math.hypot(pts[j].re - pts[j-1].re, pts[j].im - pts[j-1].im);
                if (dist > jumpThresh) { ctx.stroke(); ctx.beginPath(); ctx.moveTo(xs(pts[j].re), ys(pts[j].im)); }
                else ctx.lineTo(xs(pts[j].re), ys(pts[j].im));
            }
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
    }

    // Root dots
    const nRoots = currentRoots.length;
    for (let i = 0; i < nRoots; i++) {
        const r = currentRoots[i];
        ctx.beginPath(); ctx.arc(xs(r.re), ys(r.im), 7, 0, 2 * Math.PI);
        ctx.fillStyle = rootColor(i, nRoots); ctx.fill();
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.stroke();
    }
}

function drawCoeffsToCtx(ctx, x0, y0, pW, pH) {
    const range = panels.coeff.range;

    ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);

    const { xs, ys } = drawPanelGrid(ctx, x0, y0, pW, pH, range);

    // Coefficient curve paths
    const nC = coefficients.length;
    ctx.lineWidth = 1.5; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.globalAlpha = 0.6;
    for (let idx = 0; idx < nC; idx++) {
        const c = coefficients[idx];
        if (c.pathType === "none") continue;
        if (c.curve._isCloud) {
            // Dot cloud rendering
            ctx.fillStyle = coeffColor(idx, nC);
            for (const pt of c.curve) {
                ctx.beginPath(); ctx.arc(xs(pt.re), ys(pt.im), 1.5, 0, 2 * Math.PI); ctx.fill();
            }
        } else {
            const N = c.curve.length;
            ctx.strokeStyle = coeffColor(idx, nC);
            ctx.beginPath();
            for (let k = 0; k <= N; k++) {
                const pt = c.curve[k % N];
                if (k === 0) ctx.moveTo(xs(pt.re), ys(pt.im)); else ctx.lineTo(xs(pt.re), ys(pt.im));
            }
            ctx.closePath(); ctx.stroke();
        }
    }
    ctx.globalAlpha = 1.0;

    // Coefficient dots + labels
    for (let i = 0; i < nC; i++) {
        const c = coefficients[i];
        ctx.beginPath(); ctx.arc(xs(c.re), ys(c.im), 7, 0, 2 * Math.PI);
        ctx.fillStyle = coeffColor(i, nC); ctx.fill();
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.stroke();
        ctx.fillStyle = "#aaa"; ctx.font = "10px sans-serif"; ctx.textAlign = "left";
        ctx.fillText("c" + subscript(nC - 1 - i), xs(c.re) + 10, ys(c.im) + 4);
    }
}

function drawStatsToCtx(ctx, x0, y0, pW, pH) {
    drawAllStatsPlots();
    ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);
    const gapS = 2, cols = 4, rows = 4;
    const cellW = (pW - gapS * (cols - 1)) / cols;
    const cellH = (pH - gapS * (rows - 1)) / rows;
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const i = r * cols + c;
            const cx = x0 + c * (cellW + gapS);
            const cy = y0 + r * (cellH + gapS);
            if (statsState.canvases[i]) {
                ctx.drawImage(statsState.canvases[i], cx, cy, cellW, cellH);
            }
            // Plot label overlay
            const label = PLOT_OPTIONS[statsState.plotConfigs[i]] || "";
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.font = "bold 8px system-ui";
            ctx.textAlign = "left";
            ctx.fillText(label, cx + 3, cy + 10);
        }
    }
}

function drawSoundToCtx(ctx, x0, y0, pW, pH) {
    ctx.fillStyle = "#16213e"; ctx.fillRect(x0, y0, pW, pH);
    ctx.textAlign = "left";
    const lineH = 16;
    const margin = 12;
    let y = y0 + margin + lineH;

    function drawSection(title, color, routes, config) {
        ctx.fillStyle = color; ctx.font = "bold 12px monospace";
        ctx.fillText(title, x0 + margin, y); y += lineH + 2;
        // Routes
        ctx.font = "11px monospace";
        for (const r of routes) {
            const src = r.source === "â€”" ? "(none)" : r.source;
            const line = `${src} â†’ ${r.target}  Î±=${r.alpha.toFixed(2)} ${r.norm}`;
            ctx.fillStyle = r.source === "â€”" ? "rgba(255,255,255,0.25)" : "rgba(255,255,255,0.7)";
            ctx.fillText(line, x0 + margin + 8, y); y += lineH;
        }
        // Config params
        if (config) {
            y += 4;
            ctx.fillStyle = "rgba(255,255,255,0.4)"; ctx.font = "10px monospace";
            const entries = Object.entries(config).map(([k, v]) => `${k}=${typeof v === "number" ? (v < 1 ? v.toFixed(3) : v.toFixed(1)) : v}`);
            // Wrap at ~60 chars
            let line = "";
            for (const e of entries) {
                if (line.length + e.length > 55) {
                    ctx.fillText(line, x0 + margin + 8, y); y += lineH - 2;
                    line = e;
                } else {
                    line += (line ? "  " : "") + e;
                }
            }
            if (line) { ctx.fillText(line, x0 + margin + 8, y); y += lineH - 2; }
        }
        y += 8;
    }

    // Encounters config
    ctx.fillStyle = "#aaa"; ctx.font = "bold 11px monospace";
    ctx.fillText("ENCOUNTERS", x0 + margin, y); y += lineH;
    ctx.fillStyle = "rgba(255,255,255,0.5)"; ctx.font = "10px monospace";
    ctx.fillText(`Memory=${voiceConfig.decay.toFixed(4)}  Novelty=${voiceConfig.novelty.toFixed(2)}`, x0 + margin + 8, y);
    y += lineH + 8;

    drawSection("BASE ROUTING", "#5ddb6a", baseRoutes, baseConfig);
    drawSection("VOICE ROUTING", "#e94560", voiceRoutes, voiceConfig);
    drawSection("MELODY ROUTING", "#4ea8de", melodyRoutes, melodyConfig);
}

function drawBitmapToCtx(ctx, x0, y0, pW, pH) {
    const bc = document.getElementById("bitmap-canvas");
    if (bitmapCtx && bitmapActive && bc.width > 0 && bc.height > 0) {
        ctx.drawImage(bc, x0, y0, pW, pH);
    } else {
        ctx.fillStyle = bitmapCanvasColor; ctx.fillRect(x0, y0, pW, pH);
    }
}

function drawRightPanelToCtx(ctx, x0, y0, pW, pH) {
    if (activeTab === "stats") drawStatsToCtx(ctx, x0, y0, pW, pH);
    else if (activeTab === "sound") drawSoundToCtx(ctx, x0, y0, pW, pH);
    else if (activeTab === "bitmap") drawBitmapToCtx(ctx, x0, y0, pW, pH);
    else drawRootsToCtx(ctx, x0, y0, pW, pH);
}

function drawInfoBar(ctx, x0, y0, barW, barH) {
    ctx.fillStyle = "#0a0a1a"; ctx.fillRect(x0, y0, barW, barH);
    ctx.fillStyle = "#888"; ctx.font = "10px sans-serif"; ctx.textAlign = "left";
    const deg = coefficients.length - 1;
    const pat = document.getElementById("pattern").value;
    const animated = coefficients.filter(c => c.pathType !== "none").length;
    const parts = [
        `Degree ${deg}`,
        `Pattern: ${pat}`,
        `Tab: ${activeTab}`,
        `Animated: ${animated}/${coefficients.length}`,
        trailsEnabled ? "Trails: ON" : "Trails: OFF",
    ];
    ctx.fillText(parts.join("   Â·   "), x0 + 8, y0 + barH * 0.65);
}

function recordTick() {
    if (!vidRec.recording) return;
    const ctx = vidRec.ctx;
    const mode = vidRec.mode;
    const gap = 8;
    const infoH = 20;

    if (mode === "roots") {
        ctx.clearRect(0, 0, S, S);
        drawRootsToCtx(ctx, 0, 0, S, S);
    } else if (mode === "coeffs") {
        ctx.clearRect(0, 0, S, S);
        drawCoeffsToCtx(ctx, 0, 0, S, S);
    } else if (mode === "stats") {
        ctx.clearRect(0, 0, S, S);
        drawStatsToCtx(ctx, 0, 0, S, S);
    } else if (mode === "sound") {
        ctx.clearRect(0, 0, S, S);
        drawSoundToCtx(ctx, 0, 0, S, S);
    } else if (mode === "bitmap") {
        ctx.clearRect(0, 0, S, S);
        drawBitmapToCtx(ctx, 0, 0, S, S);
    } else if (mode === "full") {
        const totalW = S * 2 + gap;
        ctx.fillStyle = "#0f1026"; ctx.fillRect(0, 0, totalW, S + infoH);
        drawCoeffsToCtx(ctx, 0, 0, S, S);
        drawRightPanelToCtx(ctx, S + gap, 0, S, S);
        drawInfoBar(ctx, 0, S, totalW, infoH);
    } else {
        // "both" â€” tab-aware side by side
        const totalW = S * 2 + gap;
        ctx.fillStyle = "#0f1026"; ctx.fillRect(0, 0, totalW, S);
        drawCoeffsToCtx(ctx, 0, 0, S, S);
        drawRightPanelToCtx(ctx, S + gap, 0, S, S);
    }
    // In fast mode, rAF isn't running so captureStream may not see canvas updates.
    // Explicitly request a frame capture from the video track.
    if (fastModeActive && vidRec.stream) {
        var vt = vidRec.stream.getVideoTracks()[0];
        if (vt && vt.requestFrame) vt.requestFrame();
    }
}

function startRecording() {
    if (vidRec.recording) { uiBuzz(); return; }

    const mode = document.getElementById("rec-mode").value;
    vidRec.mode = mode;

    const dpr = window.devicePixelRatio || 1;
    const gap = 8;
    const infoH = 20;
    const isDual = mode === "both" || mode === "full";
    const logW = isDual ? S * 2 + gap : S;
    const logH = mode === "full" ? S + infoH : S;

    if (!vidRec.canvas) {
        vidRec.canvas = document.createElement("canvas");
        vidRec.ctx = vidRec.canvas.getContext("2d");
    }
    vidRec.canvas.width = Math.floor(logW * dpr);
    vidRec.canvas.height = Math.floor(logH * dpr);
    vidRec.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const stream = vidRec.canvas.captureStream(60);
    // Merge audio track if sound is active
    if (audioNodes && audioNodes.mediaDest) {
        for (const track of audioNodes.mediaDest.stream.getAudioTracks()) {
            stream.addTrack(track);
        }
    }
    vidRec.stream = stream;
    vidRec.chunks = [];

    const candidates = ["video/webm;codecs=vp9", "video/webm;codecs=vp8", "video/webm"];
    let mimeType = "";
    for (const c of candidates) { if (MediaRecorder.isTypeSupported(c)) { mimeType = c; break; } }

    const mr = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
    vidRec.mr = mr;

    mr.ondataavailable = e => { if (e.data && e.data.size) vidRec.chunks.push(e.data); };
    mr.onerror = e => console.warn("MediaRecorder error:", e.error || e);
    mr.onstop = () => {
        if (!vidRec.chunks.length) {
            console.warn("Recording produced no data â€” not saving.");
            return;
        }
        const blob = new Blob(vidRec.chunks, { type: mr.mimeType || "video/webm" });
        const url = URL.createObjectURL(blob);
        const now = new Date();
        const ts = now.toISOString().replace(/[:.]/g, "-").slice(0, 19);
        const suffix = (mode === "both") ? "both-" + activeTab : mode;
        const basename = `polypaint-${suffix}-${ts}`;

        // Download video
        const a = document.createElement("a");
        a.href = url;
        a.download = `${basename}.webm`;
        a.click();
        URL.revokeObjectURL(url);

        // Download JSON metadata (mirrors snap metadata)
        const meta = {
            type: "recording",
            mode: mode,
            activeTab: activeTab,
            timestamp: now.toISOString(),
            degree: coefficients.length - 1,
            pattern: document.getElementById("pattern").value,
            domainColoring: domainColoringEnabled,
            rootColoring: rootColorMode !== "uniform",
            rootColorMode: rootColorMode,
            uniformRootColor: uniformRootColor.slice(),
            bitmapColorMode: bitmapColorMode,
            bitmapUniformColor: bitmapUniformColor.slice(),
            bitmapCanvasColor: bitmapCanvasColor,
            bitmapMatchStrategy: bitmapMatchStrategy,
            bitmapProxPalette: bitmapProxPaletteName,
            bitmapDerivPalette: bitmapDerivPaletteName,
            bitmapIdxProxGamma: bitmapIdxProxGamma,
            bitmapRatioGamma: bitmapRatioGamma,
            trails: trailsEnabled,
            selectedCoeffs: [...selectedCoeffs],
            selectedRoots: [...selectedRoots],
            coefficients: coefficients.map(c => ({
                pos: [c.re, c.im],
                home: [c.curve[0].re, c.curve[0].im],
                pathType: c.pathType, radius: c.radius, speed: c.speed,
                angle: c.angle, ccw: c.ccw
            })),
            roots: currentRoots.map(r => [r.re, r.im]),
            panels: {
                coeff: { range: panels.coeff.range },
                roots: { range: panels.roots.range }
            }
        };
        const jsonBlob = new Blob([JSON.stringify(meta, null, 2)], { type: "application/json" });
        const a2 = document.createElement("a");
        a2.href = URL.createObjectURL(jsonBlob);
        a2.download = `${basename}.json`;
        a2.click();
        URL.revokeObjectURL(a2.href);
    };

    vidRec.recording = true;
    mr.start(200);
    recordTick();          // draw first frame AFTER recorder starts

    document.getElementById("rec-roots-btn").classList.add("recording");
    document.getElementById("stop-roots-btn").style.display = "";
}

function stopRecording() {
    if (!vidRec.recording) { uiBuzz(); return; }
    vidRec.recording = false;
    if (vidRec.mr && vidRec.mr.state !== "inactive") {
        try { vidRec.mr.requestData(); } catch (_) {}  // flush pending data
        vidRec.mr.stop();
    }
    vidRec.mr = null;
    vidRec.stream = null;

    document.getElementById("rec-roots-btn").classList.remove("recording");
    document.getElementById("stop-roots-btn").style.display = "none";
}

document.getElementById("rec-roots-btn").addEventListener("click", startRecording);
document.getElementById("stop-roots-btn").addEventListener("click", stopRecording);

// --- State metadata ---

function buildStateMetadata(timestamp) {
    return {
        timestamp: timestamp || new Date().toISOString(),
        degree: coefficients.length - 1,
        pattern: document.getElementById("pattern").value,
        domainColoring: domainColoringEnabled,
        rootColoring: rootColorMode !== "uniform",
        rootColorMode: rootColorMode,
        uniformRootColor: uniformRootColor.slice(),
        bitmapColorMode: bitmapColorMode,
        bitmapUniformColor: bitmapUniformColor.slice(),
        bitmapCanvasColor: bitmapCanvasColor,
        bitmapMatchStrategy: bitmapMatchStrategy,
        bitmapProxPalette: bitmapProxPaletteName,
        bitmapDerivPalette: bitmapDerivPaletteName,
        bitmapIdxProxGamma: bitmapIdxProxGamma,
        bitmapExportFormat: bitmapExportFormat,
        trails: trailsEnabled,
        animPlaying: animState.playing,
        activeTab: activeTab,
        selectedCoeffs: [...selectedCoeffs],
        selectedRoots: [...selectedRoots],
        coefficients: coefficients.map(c => ({
            pos: [c.re, c.im],
            home: [c.curve[0].re, c.curve[0].im],
            pathType: c.pathType, radius: c.radius, speed: c.speed,
            angle: c.angle, ccw: c.ccw, extra: c.extra || {}
        })),
        roots: currentRoots.map(r => [r.re, r.im]),
        panels: {
            coeff: { range: panels.coeff.range },
            roots: { range: panels.roots.range }
        },
        trailData: trailData.map(pts => pts.map(p => [p.re, p.im])),
        jiggle: { mode: jiggleMode, sigma: jiggleSigma, angleSteps: jiggleAngleSteps, scaleStep: jiggleScaleStep, period: jigglePeriod, amplitude: jiggleAmplitude, lissFreqX: jiggleLissFreqX, lissFreqY: jiggleLissFreqY, circleSteps: jiggleCircleSteps },
        numWorkers: numWorkers,
        bitmapCoeffView: bitmapCoeffView,
        solverType: solverType,
        targetSeconds: jiggleInterval,
        morph: {
            enabled: morphEnabled,
            rate: morphRate,
            mu: morphMu,
            cdPathType: morphPathType,
            cdCcw: morphPathCcw,
            cdEllipseMinor: morphEllipseMinor,
            cdDitherStartSigma: morphDitherStartSigma,
            cdDitherMidSigma: morphDitherMidSigma,
            cdDitherEndSigma: morphDitherEndSigma,
            target: morphTargetCoeffs.map(d => ({
                pos: [d.re, d.im],
                home: [d.curve[0].re, d.curve[0].im],
                pathType: d.pathType, radius: d.radius, speed: d.speed,
                angle: d.angle, ccw: d.ccw, extra: d.extra || {}
            }))
        }
    };
}

// --- Snap (capture) ---

function snapDownload(canvas, mode) {
    const now = new Date();
    const ts = now.toISOString().replace(/[:.]/g, "-").slice(0, 19);
    let suffix = mode;
    if (mode === "both") suffix = "both-" + activeTab;
    const basename = `polypaint-${suffix}-${ts}`;

    const meta = buildStateMetadata(now.toISOString());
    meta.snapMode = mode;
    meta.activeTab = activeTab;

    canvas.toBlob(function (blob) {
        if (!blob) return;
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `${basename}.png`;
        a.click();
        URL.revokeObjectURL(a.href);
    }, "image/png");

    const jsonBlob = new Blob([JSON.stringify(meta, null, 2)], { type: "application/json" });
    const a2 = document.createElement("a");
    a2.href = URL.createObjectURL(jsonBlob);
    a2.download = `${basename}.json`;
    a2.click();
    URL.revokeObjectURL(a2.href);
}

function snapCapture(mode) {
    if (!mode) mode = "both";

    // "full" mode: capture the entire app UI via html2canvas
    if (mode === "full") {
        if (typeof html2canvas !== "function") {
            console.warn("html2canvas not loaded â€” falling back to 'both' mode");
            mode = "both";
        } else {
            // Close the snap popup first so it doesn't appear in the capture
            closeSnapPop();
            // Small delay to let the popup close render
            requestAnimationFrame(() => {
                html2canvas(document.body, {
                    backgroundColor: "#0f1026",
                    scale: window.devicePixelRatio || 1,
                    useCORS: true,
                    logging: false,
                    onclone: function(clonedDoc) {
                        clonedDoc.querySelectorAll("svg").forEach(svg => {
                            svg.style.overflow = "visible";
                        });
                        // Replace range inputs with visual track+thumb divs
                        const origRanges = document.querySelectorAll('input[type="range"]');
                        const cloneRanges = clonedDoc.querySelectorAll('input[type="range"]');
                        for (let i = cloneRanges.length - 1; i >= 0; i--) {
                            const clone = cloneRanges[i];
                            const orig = origRanges[i];
                            if (!orig || !clone.parentNode) continue;
                            const val = parseFloat(orig.value);
                            const min = parseFloat(orig.min || 0);
                            const max = parseFloat(orig.max || 100);
                            const pct = Math.max(0, Math.min(100, ((val - min) / (max - min)) * 100));
                            const rect = orig.getBoundingClientRect();
                            const w = rect.width || 100;
                            const h = rect.height || 20;
                            const wrap = clonedDoc.createElement("div");
                            wrap.style.cssText = `display:inline-block;width:${w}px;height:${h}px;position:relative;vertical-align:middle;`;
                            const track = clonedDoc.createElement("div");
                            track.style.cssText = "position:absolute;top:50%;left:2px;right:2px;height:4px;margin-top:-2px;border-radius:2px;background:rgba(255,255,255,0.12);";
                            wrap.appendChild(track);
                            const fill = clonedDoc.createElement("div");
                            fill.style.cssText = `position:absolute;top:50%;left:2px;width:${pct * (w - 4) / 100}px;height:4px;margin-top:-2px;border-radius:2px;background:#e94560;`;
                            wrap.appendChild(fill);
                            const thumb = clonedDoc.createElement("div");
                            const thumbX = 2 + pct * (w - 4) / 100;
                            thumb.style.cssText = `position:absolute;top:50%;left:${thumbX}px;width:10px;height:10px;margin-top:-5px;margin-left:-5px;border-radius:50%;background:#fff;box-shadow:0 0 3px rgba(0,0,0,0.5);`;
                            wrap.appendChild(thumb);
                            clone.parentNode.replaceChild(wrap, clone);
                        }
                        // Replace select elements with styled text divs
                        const origSelects = document.querySelectorAll("select");
                        const cloneSelects = clonedDoc.querySelectorAll("select");
                        for (let i = cloneSelects.length - 1; i >= 0; i--) {
                            const clone = cloneSelects[i];
                            const orig = origSelects[i];
                            if (!orig || !clone.parentNode) continue;
                            const text = orig.options[orig.selectedIndex]?.text || "";
                            const rect = orig.getBoundingClientRect();
                            const w = rect.width || 80;
                            const h = rect.height || 24;
                            const cs = window.getComputedStyle(orig);
                            const div = clonedDoc.createElement("div");
                            div.style.cssText = `display:inline-flex;align-items:center;width:${w}px;height:${h}px;` +
                                `background:rgba(255,255,255,0.04);color:${cs.color};` +
                                `border:1px solid rgba(255,255,255,0.08);border-radius:6px;` +
                                `padding:2px 6px;font-size:${cs.fontSize};font-family:${cs.fontFamily};` +
                                `box-sizing:border-box;overflow:hidden;white-space:nowrap;`;
                            div.textContent = text + " â–¾";
                            clone.parentNode.replaceChild(div, clone);
                        }
                    }
                }).then(canvas => {
                    snapDownload(canvas, "full");
                }).catch(err => {
                    console.warn("html2canvas failed:", err);
                });
            });
            return;
        }
    }

    const dpr = window.devicePixelRatio || 1;
    const gap = 16;
    const headerH = 24;

    const TAB_LABELS = { roots: "ROOTS", stats: "STATS", sound: "SOUND", bitmap: "BITMAP" };
    const rightLabel = TAB_LABELS[activeTab] || "ROOTS";

    // Determine canvas dimensions
    let cw, ch;
    const isSingle = mode === "coeffs" || mode === "roots" || mode === "stats" || mode === "sound";
    if (mode === "bitmap") {
        if (!bitmapCtx || !bitmapActive || !bitmapPersistentBuffer) return; // nothing to export
        cw = bitmapComputeRes; ch = bitmapComputeRes;
    } else if (isSingle) {
        cw = S; ch = S + headerH;
    } else {
        // "both" (default)
        cw = 2 * S + gap; ch = S + headerH;
    }

    const canvas = document.createElement("canvas");
    if (mode === "bitmap") {
        canvas.width = cw; canvas.height = ch; // native resolution, no DPR
    } else {
        canvas.width = cw * dpr; canvas.height = ch * dpr;
    }
    const ctx = canvas.getContext("2d");
    if (mode !== "bitmap") ctx.scale(dpr, dpr);

    // Background
    ctx.fillStyle = "#0f0f23";
    ctx.fillRect(0, 0, cw, ch);

    if (mode === "bitmap") {
        // Direct copy from persistent buffer at compute resolution
        ctx.putImageData(bitmapPersistentBuffer, 0, 0);
    } else if (isSingle) {
        // Single panel
        const label = mode === "coeffs" ? "COEFFICIENTS" : mode === "roots" ? "ROOTS" : mode === "stats" ? "STATS" : "SOUND";
        ctx.fillStyle = "#666"; ctx.font = "11px sans-serif"; ctx.textAlign = "center";
        ctx.fillText(label, S / 2, 16);

        if (mode === "coeffs") drawCoeffsToCtx(ctx, 0, headerH, S, S);
        else if (mode === "roots") drawRootsToCtx(ctx, 0, headerH, S, S);
        else if (mode === "stats") drawStatsToCtx(ctx, 0, headerH, S, S);
        else if (mode === "sound") drawSoundToCtx(ctx, 0, headerH, S, S);
    } else {
        // "both" â€” two panels, tab-aware
        ctx.fillStyle = "#666"; ctx.font = "11px sans-serif"; ctx.textAlign = "center";
        ctx.fillText("COEFFICIENTS", S / 2, 16);
        ctx.fillText(rightLabel, S + gap + S / 2, 16);

        drawCoeffsToCtx(ctx, 0, headerH, S, S);
        drawRightPanelToCtx(ctx, S + gap, headerH, S, S);
    }

    snapDownload(canvas, mode);
}

// --- Snap popup ---

const snapPop = document.getElementById("snap-pop");
let snapPopOpen = false;

function closeSnapPop() {
    snapPop.classList.remove("open");
    snapPopOpen = false;
}

function openSnapPop() {
    if (snapPopOpen) { closeSnapPop(); return; }
    if (typeof closeOpTool === "function") closeOpTool();
    if (typeof closeDegreePopover === "function") closeDegreePopover();
    if (typeof closeColorPop === "function") closeColorPop();
    if (typeof closeCoeffPick === "function") closeCoeffPick();
    if (typeof closeAudioPop === "function") closeAudioPop();
    snapPop.innerHTML = "";
    const modes = [
        { value: "both", label: "Both" },
        { value: "coeffs", label: "Coeffs" },
        { value: "roots", label: "Roots" },
        { value: "stats", label: "Stats" },
        { value: "sound", label: "Sound" },
        { value: "bitmap", label: "Bitmap" },
        { value: "full", label: "Full" },
    ];
    const title = document.createElement("div");
    title.className = "pop-title";
    title.textContent = "EXPORT";
    snapPop.appendChild(title);
    for (const m of modes) {
        const btn = document.createElement("button");
        btn.style.cssText = "width:100%;font-size:10px;padding:5px 10px;text-align:left;border:none;background:transparent;color:var(--muted);cursor:pointer;border-radius:6px;";
        btn.onmouseenter = () => { btn.style.background = "rgba(255,255,255,0.08)"; btn.style.color = "var(--text)"; };
        btn.onmouseleave = () => { btn.style.background = "transparent"; btn.style.color = "var(--muted)"; };
        btn.textContent = m.label;
        btn.addEventListener("click", () => { closeSnapPop(); snapCapture(m.value); });
        snapPop.appendChild(btn);
    }
    snapPop.classList.add("open");
    const r = document.getElementById("snap-btn").getBoundingClientRect();
    snapPop.style.left = r.left + "px";
    snapPop.style.top = (r.bottom + 6) + "px";
    snapPopOpen = true;
}

document.getElementById("snap-btn").addEventListener("click", openSnapPop);

// --- Bitmap cfg popup (solver + workers + jiggle + color) ---
let bitmapCfgPopOpen = false;
const bitmapCfgPop = document.getElementById("bitmap-cfg-pop");

function closeBitmapCfgPop() { bitmapCfgPop.classList.remove("open"); bitmapCfgPopOpen = false; }

function buildBitmapCfgPop() {
    bitmapCfgPop.innerHTML = "";
    const title = document.createElement("div");
    title.className = "pop-title";
    title.textContent = "SOLVER ENGINE (" + numWorkers + ")";
    bitmapCfgPop.appendChild(title);
    // Solver type row
    const row = document.createElement("div");
    row.style.cssText = "display:flex;align-items:center;gap:6px;margin:4px 0;";
    const lbl = document.createElement("span");
    lbl.style.cssText = "font-size:10px;color:var(--fg);";
    lbl.textContent = "Engine";
    row.appendChild(lbl);
    for (const opt of ["js", "wasm"]) {
        const btn = document.createElement("button");
        btn.style.cssText = "min-width:40px;height:22px;border-radius:6px;border:1px solid var(--stroke);background:" + (opt === solverType ? "var(--accent-dim)" : "transparent") + ";color:" + (opt === solverType ? "#fff" : "var(--muted)") + ";font-size:10px;cursor:pointer;padding:0 6px;font-weight:600;text-transform:uppercase;";
        btn.textContent = opt;
        btn.addEventListener("click", () => {
            solverType = opt;
            buildBitmapCfgPop(); // rebuild to update highlight
        });
        row.appendChild(btn);
    }
    bitmapCfgPop.appendChild(row);
    // Info
    const info = document.createElement("div");
    info.style.cssText = "font-size:9px;color:var(--muted);margin-top:2px;";
    info.textContent = solverType === "wasm" ? "WASM Ehrlich-Aberth (compiled C)" : "JavaScript Ehrlich-Aberth";
    bitmapCfgPop.appendChild(info);
    // Workers row
    const wRow = document.createElement("div");
    wRow.style.cssText = "display:flex;align-items:center;gap:6px;margin:6px 0 2px;";
    const wLbl = document.createElement("span");
    wLbl.style.cssText = "font-size:10px;color:var(--fg);";
    wLbl.textContent = "Workers";
    wRow.appendChild(wLbl);
    for (const wn of [1, 2, 4, 8, 16]) {
        const wBtn = document.createElement("button");
        wBtn.style.cssText = "min-width:26px;height:22px;border-radius:6px;border:1px solid var(--stroke);background:" + (wn === numWorkers ? "var(--accent-dim)" : "transparent") + ";color:" + (wn === numWorkers ? "#fff" : "var(--muted)") + ";font-size:10px;cursor:pointer;padding:0 4px;font-weight:600;";
        wBtn.textContent = String(wn);
        wBtn.addEventListener("click", () => {
            numWorkers = wn;
            fastModeTimingHistory = [];
            buildBitmapCfgPop();
        });
        wRow.appendChild(wBtn);
    }
    bitmapCfgPop.appendChild(wRow);
    // Background color
    const hr2 = document.createElement("hr");
    hr2.style.cssText = "border:none;border-top:1px solid var(--stroke);margin:8px 0 4px;";
    bitmapCfgPop.appendChild(hr2);
    const bgTitle = document.createElement("div");
    bgTitle.className = "pop-title";
    bgTitle.textContent = "BACKGROUND";
    bitmapCfgPop.appendChild(bgTitle);
    const bgGrid = document.createElement("div");
    bgGrid.style.cssText = "display:flex;flex-wrap:wrap;gap:3px;padding:4px 0;max-width:180px;";
    for (const c of CANVAS_BG_COLORS) {
        const sw = document.createElement("div");
        const isActive = bitmapCanvasColor.toLowerCase() === c.hex.toLowerCase();
        const isDark = parseInt(c.hex.slice(1, 3), 16) * 0.299 +
                       parseInt(c.hex.slice(3, 5), 16) * 0.587 +
                       parseInt(c.hex.slice(5, 7), 16) * 0.114 < 128;
        sw.style.cssText = `width:20px;height:20px;border-radius:50%;cursor:pointer;` +
            `background:${c.hex};border:2px solid ${isActive ? "#fff" : (isDark ? "rgba(255,255,255,0.15)" : "rgba(0,0,0,0.15)")};` +
            `flex-shrink:0;`;
        sw.title = c.label;
        sw.addEventListener("click", () => {
            bitmapCanvasColor = c.hex;
            document.getElementById("bitmap-container").style.background = c.hex;
            buildBitmapCfgPop(); // rebuild to update highlight
        });
        bgGrid.appendChild(sw);
    }
    bitmapCfgPop.appendChild(bgGrid);

    // --- ROOT COLOR section ---
    const hr3 = document.createElement("hr");
    hr3.style.cssText = "border:none;border-top:1px solid var(--stroke);margin:8px 0 4px;";
    bitmapCfgPop.appendChild(hr3);
    const colorModeLabels = { uniform: "Uniform", rainbow: "Rainbow", derivative: "Derivative", proximity: "Proximity", "idx-prox": "Idx \u00d7 Prox", ratio: "Min/Max Ratio" };
    const rcTitle = document.createElement("div");
    rcTitle.className = "pop-title"; rcTitle.textContent = "COLOR (" + (colorModeLabels[bitmapColorMode] || bitmapColorMode) + ")";
    bitmapCfgPop.appendChild(rcTitle);

    const bitmapModes = [
        { key: "uniform",    label: "Uniform" },
        { key: "rainbow",    label: "Index Rainbow" },
        { key: "derivative", label: "Derivative" },
        { key: "proximity",  label: "Root Proximity" },
        { key: "idx-prox",   label: "Idx \u00d7 Prox" },
        { key: "ratio",      label: "Min/Max Ratio" },
    ];
    const bmRows = [];
    let bmSwatchWrap = null;
    let bmMatchWrap = null;
    let bmDerivWrap = null;
    let bmProxWrap = null;
    let bmIdxProxMatchWrap = null;
    let bmRatioProxWrap = null;
    function refreshMatchChips() {
        if (bmMatchWrap) bmMatchWrap.style.opacity = bitmapColorMode === "rainbow" ? "1" : "0.3";
    }
    function refreshProxPalettes() {
        if (bmProxWrap) bmProxWrap.style.opacity = bitmapColorMode === "proximity" ? "1" : "0.3";
    }
    function refreshDerivPalettes() {
        if (bmDerivWrap) bmDerivWrap.style.opacity = bitmapColorMode === "derivative" ? "1" : "0.3";
    }
    function refreshBmSwatches() {
        if (bmSwatchWrap) bmSwatchWrap.style.opacity = bitmapColorMode === "uniform" ? "1" : "0.3";
        refreshMatchChips();
        refreshDerivPalettes();
        refreshProxPalettes();
        if (bmIdxProxMatchWrap) {
            bmIdxProxMatchWrap.style.opacity = bitmapColorMode === "idx-prox" ? "1" : "0.3";
            if (bmIdxProxMatchWrap._gammaWrap) bmIdxProxMatchWrap._gammaWrap.style.opacity = bitmapColorMode === "idx-prox" ? "1" : "0.3";
        }
        if (bmRatioProxWrap) {
            bmRatioProxWrap.style.opacity = bitmapColorMode === "ratio" ? "1" : "0.3";
            if (bmRatioProxWrap._gammaWrap) bmRatioProxWrap._gammaWrap.style.opacity = bitmapColorMode === "ratio" ? "1" : "0.3";
        }
    }
    bitmapModes.forEach(bm => {
        const row = document.createElement("div");
        row.className = "audio-toggle" + (bitmapColorMode === bm.key ? " on" : "");
        const dot = document.createElement("span");
        dot.className = "toggle-dot";
        const lbl = document.createElement("span");
        lbl.className = "toggle-label"; lbl.textContent = bm.label;
        row.appendChild(dot);
        row.appendChild(lbl);
        row.addEventListener("click", () => {
            bitmapColorMode = bm.key;
            bmRows.forEach(r => r.classList.remove("on"));
            row.classList.add("on");
            rcTitle.textContent = "COLOR (" + (colorModeLabels[bm.key] || bm.key) + ")";
            refreshBmSwatches();
        });
        bitmapCfgPop.appendChild(row);
        bmRows.push(row);

        if (bm.key === "uniform") {
            bmSwatchWrap = document.createElement("div");
            bmSwatchWrap.style.cssText = "display:flex;flex-wrap:wrap;gap:3px;padding:4px 2px 6px 20px;max-width:180px;";
            bmSwatchWrap.style.opacity = bitmapColorMode === "uniform" ? "1" : "0.3";
            ROOT_COLOR_SWATCHES.forEach(ch => {
                const sw = document.createElement("div");
                const isActive = bitmapUniformColor[0] === ch.rgb[0] && bitmapUniformColor[1] === ch.rgb[1] && bitmapUniformColor[2] === ch.rgb[2];
                sw.style.cssText = `width:16px;height:16px;border-radius:50%;cursor:pointer;` +
                    `background:rgb(${ch.rgb[0]},${ch.rgb[1]},${ch.rgb[2]});` +
                    `border:2px solid ${isActive ? "#fff" : "rgba(255,255,255,0.15)"};` +
                    `box-sizing:border-box;flex-shrink:0;`;
                sw.title = ch.label;
                sw.addEventListener("click", () => {
                    bitmapUniformColor = ch.rgb.slice();
                    bmSwatchWrap.querySelectorAll("div").forEach(s => {
                        s.style.borderColor = "rgba(255,255,255,0.15)";
                    });
                    sw.style.borderColor = "#fff";
                    if (bitmapColorMode !== "uniform") {
                        bitmapColorMode = "uniform";
                        bmRows.forEach(r => r.classList.remove("on"));
                        bmRows[0].classList.add("on");
                        rcTitle.textContent = "COLOR (Uniform)";
                        refreshBmSwatches();
                    }
                });
                bmSwatchWrap.appendChild(sw);
            });
            bitmapCfgPop.appendChild(bmSwatchWrap);
        }

        if (bm.key === "rainbow") {
            bmMatchWrap = document.createElement("div");
            bmMatchWrap.style.cssText = "display:flex;flex-wrap:wrap;gap:4px;padding:4px 2px 6px 20px;max-width:220px;";
            bmMatchWrap.style.opacity = bitmapColorMode === "rainbow" ? "1" : "0.3";
            const strategies = [
                { key: "hungarian1", label: "Hungarian", tip: "Optimal assignment every step (slower, perfect tracking)" },
                { key: "assign1",   label: "Greedy\u00d71", tip: "Nearest-neighbor every step" },
                { key: "assign4",   label: "Greedy\u00d74", tip: "Nearest-neighbor every 4th step (fastest)" },
            ];
            strategies.forEach(st => {
                const chip = document.createElement("div");
                const isActive = bitmapMatchStrategy === st.key;
                chip.style.cssText = `padding:2px 7px;border-radius:8px;cursor:pointer;font-size:9px;` +
                    `text-transform:uppercase;letter-spacing:0.06em;user-select:none;flex-shrink:0;` +
                    `background:${isActive ? "var(--accent)" : "rgba(255,255,255,0.08)"};` +
                    `color:${isActive ? "#000" : "var(--muted)"};` +
                    `border:1px solid ${isActive ? "var(--accent)" : "rgba(255,255,255,0.15)"};`;
                chip.textContent = st.label;
                chip.title = st.tip;
                chip.addEventListener("click", () => {
                    bitmapMatchStrategy = st.key;
                    bmMatchWrap.querySelectorAll("div").forEach(c => {
                        c.style.background = "rgba(255,255,255,0.08)";
                        c.style.color = "var(--muted)";
                        c.style.borderColor = "rgba(255,255,255,0.15)";
                    });
                    chip.style.background = "var(--accent)";
                    chip.style.color = "#000";
                    chip.style.borderColor = "var(--accent)";
                    if (bitmapColorMode !== "rainbow") {
                        bitmapColorMode = "rainbow";
                        bmRows.forEach(r => r.classList.remove("on"));
                        bmRows[1].classList.add("on");
                        rcTitle.textContent = "COLOR (Rainbow)";
                        refreshBmSwatches();
                    }
                });
                bmMatchWrap.appendChild(chip);
            });
            bitmapCfgPop.appendChild(bmMatchWrap);
        }

        if (bm.key === "derivative") {
            bmDerivWrap = document.createElement("div");
            bmDerivWrap.style.cssText = "display:flex;flex-wrap:wrap;gap:4px;padding:4px 2px 6px 20px;max-width:220px;";
            bmDerivWrap.style.opacity = bitmapColorMode === "derivative" ? "1" : "0.3";
            DERIV_PALETTE_CATALOG.forEach(pal => {
                const circle = document.createElement("div");
                const isActive = bitmapDerivPaletteName === pal.key;
                let bgStyle;
                if (pal.fn) {
                    const stops = [];
                    for (let s = 0; s < 8; s++) { const t = s / 7; stops.push(pal.fn(t) + " " + Math.round(t * 100) + "%"); }
                    bgStyle = `linear-gradient(to top, ${stops.join(", ")})`;
                } else {
                    bgStyle = "linear-gradient(to top, rgb(0,0,255) 0%, rgb(255,255,255) 50%, rgb(255,0,0) 100%)";
                }
                circle.style.cssText = `width:20px;height:20px;border-radius:50%;cursor:pointer;flex-shrink:0;` +
                    `background:${bgStyle};` +
                    `border:2px solid ${isActive ? "#fff" : "rgba(255,255,255,0.15)"};` +
                    `box-sizing:border-box;`;
                circle.title = pal.label;
                circle.addEventListener("click", () => {
                    setDerivPalette(pal.key);
                    bmDerivWrap.querySelectorAll("div").forEach(c => {
                        c.style.borderColor = "rgba(255,255,255,0.15)";
                    });
                    circle.style.borderColor = "#fff";
                    if (bitmapColorMode !== "derivative") {
                        bitmapColorMode = "derivative";
                        bmRows.forEach(r => r.classList.remove("on"));
                        bmRows[2].classList.add("on"); // derivative is index 2
                        rcTitle.textContent = "COLOR (Derivative)";
                        refreshBmSwatches();
                    }
                });
                bmDerivWrap.appendChild(circle);
            });
            bitmapCfgPop.appendChild(bmDerivWrap);
        }

        if (bm.key === "proximity") {
            bmProxWrap = document.createElement("div");
            bmProxWrap.style.cssText = "display:flex;flex-wrap:wrap;gap:4px;padding:4px 2px 6px 20px;max-width:220px;";
            bmProxWrap.style.opacity = bitmapColorMode === "proximity" ? "1" : "0.3";
            PROX_PALETTE_CATALOG.forEach(pal => {
                const circle = document.createElement("div");
                const isActive = bitmapProxPaletteName === pal.key;
                // Build vertical gradient (bottom=0, top=1) with 8 stops
                const stops = [];
                for (let s = 0; s < 8; s++) {
                    const t = s / 7;
                    stops.push(pal.fn(t) + " " + Math.round(t * 100) + "%");
                }
                circle.style.cssText = `width:20px;height:20px;border-radius:50%;cursor:pointer;flex-shrink:0;` +
                    `background:linear-gradient(to top, ${stops.join(", ")});` +
                    `border:2px solid ${isActive ? "#fff" : "rgba(255,255,255,0.15)"};` +
                    `box-sizing:border-box;`;
                circle.title = pal.label;
                circle.addEventListener("click", () => {
                    setProxPalette(pal.key);
                    bmProxWrap.querySelectorAll("div").forEach(c => {
                        c.style.borderColor = "rgba(255,255,255,0.15)";
                    });
                    circle.style.borderColor = "#fff";
                    if (bitmapColorMode !== "proximity") {
                        bitmapColorMode = "proximity";
                        bmRows.forEach(r => r.classList.remove("on"));
                        bmRows[3].classList.add("on"); // proximity is index 3
                        rcTitle.textContent = "COLOR (Proximity)";
                        refreshBmSwatches();
                    }
                });
                bmProxWrap.appendChild(circle);
            });
            bitmapCfgPop.appendChild(bmProxWrap);
        }

        if (bm.key === "idx-prox") {
            bmIdxProxMatchWrap = document.createElement("div");
            bmIdxProxMatchWrap.style.cssText = "display:flex;flex-wrap:wrap;gap:4px;padding:4px 2px 6px 20px;max-width:220px;";
            bmIdxProxMatchWrap.style.opacity = bitmapColorMode === "idx-prox" ? "1" : "0.3";
            const ipStrategies = [
                { key: "hungarian1", label: "Hungarian", tip: "Optimal assignment every step" },
                { key: "assign1",   label: "Greedy\u00d71", tip: "Nearest-neighbor every step" },
                { key: "assign4",   label: "Greedy\u00d74", tip: "Nearest-neighbor every 4th step (fastest)" },
            ];
            ipStrategies.forEach(st => {
                const chip = document.createElement("div");
                const isActive = bitmapMatchStrategy === st.key;
                chip.style.cssText = `padding:2px 7px;border-radius:8px;cursor:pointer;font-size:9px;` +
                    `text-transform:uppercase;letter-spacing:0.06em;user-select:none;flex-shrink:0;` +
                    `background:${isActive ? "var(--accent)" : "rgba(255,255,255,0.08)"};` +
                    `color:${isActive ? "#000" : "var(--muted)"};` +
                    `border:1px solid ${isActive ? "var(--accent)" : "rgba(255,255,255,0.15)"};`;
                chip.textContent = st.label;
                chip.title = st.tip;
                chip.addEventListener("click", () => {
                    bitmapMatchStrategy = st.key;
                    bmIdxProxMatchWrap.querySelectorAll("div").forEach(c => {
                        c.style.background = "rgba(255,255,255,0.08)";
                        c.style.color = "var(--muted)";
                        c.style.borderColor = "rgba(255,255,255,0.15)";
                    });
                    chip.style.background = "var(--accent)";
                    chip.style.color = "#000";
                    chip.style.borderColor = "var(--accent)";
                    if (bitmapColorMode !== "idx-prox") {
                        bitmapColorMode = "idx-prox";
                        bmRows.forEach(r => r.classList.remove("on"));
                        bmRows[4].classList.add("on");
                        rcTitle.textContent = "COLOR (Idx \u00d7 Prox)";
                        refreshBmSwatches();
                    }
                });
                bmIdxProxMatchWrap.appendChild(chip);
            });
            bitmapCfgPop.appendChild(bmIdxProxMatchWrap);
            // Gamma slider for IdxÃ—Prox brightness
            const gammaWrap = document.createElement("div");
            gammaWrap.style.cssText = "display:flex;align-items:center;gap:6px;padding:0 2px 6px 20px;";
            gammaWrap.style.opacity = bitmapColorMode === "idx-prox" ? "1" : "0.3";
            const gammaLabel = document.createElement("span");
            gammaLabel.style.cssText = "font-size:9px;color:var(--muted);white-space:nowrap;";
            gammaLabel.textContent = "\u03b3";
            const gammaSlider = document.createElement("input");
            gammaSlider.type = "range"; gammaSlider.min = "0.1"; gammaSlider.max = "1.0"; gammaSlider.step = "0.05";
            gammaSlider.value = bitmapIdxProxGamma;
            gammaSlider.style.cssText = "width:90px;height:12px;cursor:pointer;accent-color:var(--accent);";
            const gammaVal = document.createElement("span");
            gammaVal.style.cssText = "font-size:9px;color:var(--fg);font-family:monospace;min-width:28px;";
            gammaVal.textContent = bitmapIdxProxGamma.toFixed(2);
            gammaSlider.addEventListener("input", () => {
                bitmapIdxProxGamma = parseFloat(gammaSlider.value);
                gammaVal.textContent = bitmapIdxProxGamma.toFixed(2);
            });
            gammaWrap.appendChild(gammaLabel);
            gammaWrap.appendChild(gammaSlider);
            gammaWrap.appendChild(gammaVal);
            bitmapCfgPop.appendChild(gammaWrap);
            // Store ref for opacity refresh
            bmIdxProxMatchWrap._gammaWrap = gammaWrap;
        }

        if (bm.key === "ratio") {
            bmRatioProxWrap = document.createElement("div");
            bmRatioProxWrap.style.cssText = "display:flex;flex-wrap:wrap;gap:4px;padding:4px 2px 6px 20px;max-width:220px;";
            bmRatioProxWrap.style.opacity = bitmapColorMode === "ratio" ? "1" : "0.3";
            PROX_PALETTE_CATALOG.forEach(pal => {
                const circle = document.createElement("div");
                const isActive = bitmapProxPaletteName === pal.key;
                const stops = [];
                for (let s = 0; s < 8; s++) {
                    const t = s / 7;
                    stops.push(pal.fn(t) + " " + Math.round(t * 100) + "%");
                }
                circle.style.cssText = `width:20px;height:20px;border-radius:50%;cursor:pointer;flex-shrink:0;` +
                    `background:linear-gradient(to top, ${stops.join(", ")});` +
                    `border:2px solid ${isActive ? "#fff" : "rgba(255,255,255,0.15)"};` +
                    `box-sizing:border-box;`;
                circle.title = pal.label;
                circle.addEventListener("click", () => {
                    setProxPalette(pal.key);
                    bmRatioProxWrap.querySelectorAll("div").forEach(c => {
                        c.style.borderColor = "rgba(255,255,255,0.15)";
                    });
                    circle.style.borderColor = "#fff";
                    if (bitmapColorMode !== "ratio") {
                        bitmapColorMode = "ratio";
                        bmRows.forEach(r => r.classList.remove("on"));
                        bmRows[5].classList.add("on");
                        rcTitle.textContent = "COLOR (Min/Max Ratio)";
                        refreshBmSwatches();
                    }
                });
                bmRatioProxWrap.appendChild(circle);
            });
            bitmapCfgPop.appendChild(bmRatioProxWrap);
            // Gamma slider for Min/Max Ratio
            const rGammaWrap = document.createElement("div");
            rGammaWrap.style.cssText = "display:flex;align-items:center;gap:6px;padding:0 2px 6px 20px;";
            rGammaWrap.style.opacity = bitmapColorMode === "ratio" ? "1" : "0.3";
            const rGammaLabel = document.createElement("span");
            rGammaLabel.style.cssText = "font-size:9px;color:var(--muted);white-space:nowrap;";
            rGammaLabel.textContent = "\u03b3";
            const rGammaSlider = document.createElement("input");
            rGammaSlider.type = "range"; rGammaSlider.min = "0.1"; rGammaSlider.max = "1.0"; rGammaSlider.step = "0.05";
            rGammaSlider.value = bitmapRatioGamma;
            rGammaSlider.style.cssText = "width:90px;height:12px;cursor:pointer;accent-color:var(--accent);";
            const rGammaVal = document.createElement("span");
            rGammaVal.style.cssText = "font-size:9px;color:var(--fg);font-family:monospace;min-width:28px;";
            rGammaVal.textContent = bitmapRatioGamma.toFixed(2);
            rGammaSlider.addEventListener("input", () => {
                bitmapRatioGamma = parseFloat(rGammaSlider.value);
                rGammaVal.textContent = bitmapRatioGamma.toFixed(2);
            });
            rGammaWrap.appendChild(rGammaLabel);
            rGammaWrap.appendChild(rGammaSlider);
            rGammaWrap.appendChild(rGammaVal);
            bitmapCfgPop.appendChild(rGammaWrap);
            bmRatioProxWrap._gammaWrap = rGammaWrap;
        }
    });
}
function openBitmapCfgPop() {
    if (bitmapCfgPopOpen) { closeBitmapCfgPop(); return; }
    buildBitmapCfgPop();
    bitmapCfgPop.classList.add("open");
    const r = document.getElementById("bitmap-cfg-btn").getBoundingClientRect();
    bitmapCfgPop.style.left = r.left + "px";
    bitmapCfgPop.style.top = (r.bottom + 6) + "px";
    bitmapCfgPopOpen = true;
}
document.getElementById("bitmap-cfg-btn").addEventListener("click", openBitmapCfgPop);

// --- Bitmap save popup (format selection) ---
let bitmapSavePopOpen = false;
let bitmapExportFormat = "png";
const bitmapSavePop = document.getElementById("bitmap-save-pop");

function closeBitmapSavePop() { bitmapSavePop.classList.remove("open"); bitmapSavePopOpen = false; }

function buildBitmapSavePop() {
    bitmapSavePop.innerHTML = "";
    var wrap = document.createElement("div");
    wrap.style.cssText = "display:flex;flex-direction:column;gap:6px;padding:8px;";

    // Format label + select
    var fmtLabel = document.createElement("label");
    fmtLabel.style.cssText = "font-size:10px;color:var(--muted);";
    fmtLabel.textContent = "Format";
    wrap.appendChild(fmtLabel);

    var fmtSel = document.createElement("select");
    fmtSel.id = "bitmap-fmt-select";
    fmtSel.className = "bitmap-select";
    fmtSel.style.width = "100%";
    ["jpeg", "png", "bmp", "tiff"].forEach(function(f) {
        var opt = document.createElement("option");
        opt.value = f; opt.textContent = f.toUpperCase();
        if (f === bitmapExportFormat) opt.selected = true;
        fmtSel.appendChild(opt);
    });
    wrap.appendChild(fmtSel);

    // Quality row (JPEG only)
    var qRow = document.createElement("div");
    qRow.id = "bitmap-jpg-quality-row";
    qRow.style.cssText = "display:flex;align-items:center;gap:4px;" +
        (bitmapExportFormat !== "jpeg" ? "display:none;" : "");

    var qLabel = document.createElement("label");
    qLabel.style.cssText = "font-size:10px;color:var(--muted);white-space:nowrap;";
    qLabel.textContent = "Quality";
    qRow.appendChild(qLabel);

    var qSlider = document.createElement("input");
    qSlider.id = "bitmap-jpg-quality";
    qSlider.type = "range"; qSlider.min = "50"; qSlider.max = "100"; qSlider.value = "92";
    qSlider.style.flex = "1";
    qRow.appendChild(qSlider);

    var qVal = document.createElement("span");
    qVal.id = "bitmap-jpg-quality-val";
    qVal.style.cssText = "font-size:10px;color:var(--muted);width:24px;text-align:right;";
    qVal.textContent = "92";
    qRow.appendChild(qVal);
    wrap.appendChild(qRow);

    // Quality slider live update
    qSlider.addEventListener("input", function() { qVal.textContent = this.value; });

    // Format change â†’ toggle quality row + save preference
    fmtSel.addEventListener("change", function() {
        bitmapExportFormat = this.value;
        qRow.style.display = this.value === "jpeg" ? "" : "none";
    });

    // Download button
    var dlBtn = document.createElement("button");
    dlBtn.className = "bitmap-btn";
    dlBtn.style.width = "100%";
    dlBtn.textContent = "Download";
    var bitmapSaving = false;
    dlBtn.addEventListener("click", function() {
        if (bitmapSaving) { uiBuzz(); return; }
        if (!bitmapPersistentBuffer) { uiBuzz(); return; }
        bitmapSaving = true;
        dlBtn.textContent = "Saving...";
        dlBtn.style.opacity = "0.5";
        uiPing(660, 0.08);
        // Defer encoding so "Saving..." renders before blocking
        setTimeout(function() {
            try {
                var ts = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
                var base = "polypaint-bitmap-" + ts;
                var rgba = bitmapPersistentBuffer.data;
                var w = bitmapComputeRes, h = bitmapComputeRes;
                switch (bitmapExportFormat) {
                    case "bmp":  exportPersistentBufferAsBMP(rgba, w, h, base + ".bmp"); break;
                    case "jpeg": exportPersistentBufferAsJPEG(rgba, w, h,
                                     +(document.getElementById("bitmap-jpg-quality").value || 92),
                                     base + ".jpg"); break;
                    case "png":  exportPersistentBufferAsPNG(rgba, w, h, base + ".png"); break;
                    case "tiff": exportPersistentBufferAsTIFF(rgba, w, h, base + ".tiff"); break;
                }
                uiPing(1320, 0.06);
            } catch (e) {
                uiBuzz();
                console.error("Export failed:", e);
            }
            dlBtn.textContent = "Download";
            dlBtn.style.opacity = "";
            bitmapSaving = false;
            closeBitmapSavePop();
        }, 30);
    });
    wrap.appendChild(dlBtn);
    bitmapSavePop.appendChild(wrap);
}

function openBitmapSavePop() {
    if (bitmapSavePopOpen) { closeBitmapSavePop(); return; }
    buildBitmapSavePop();
    bitmapSavePop.classList.add("open");
    const r = document.getElementById("bitmap-save-btn").getBoundingClientRect();
    bitmapSavePop.style.left = r.left + "px";
    bitmapSavePop.style.top = (r.bottom + 6) + "px";
    bitmapSavePopOpen = true;
}

// --- Timing popup ---
let timingPopOpen = false;
const timingPop = document.getElementById("timing-pop");

function closeTimingPop() { timingPop.classList.remove("open"); timingPopOpen = false; }

function updateTimingPopup() {
    if (!timingPopOpen) return;
    const body = document.getElementById("timing-body");
    if (!body) return;
    body.innerHTML = "";
    if (fastModeTimingHistory.length === 0) {
        body.textContent = "No data yet. Run fast mode.";
        body.style.cssText = "font-size:10px;color:var(--muted);padding:4px 0;";
        return;
    }
    const last = fastModeTimingHistory[fastModeTimingHistory.length - 1];
    const nPasses = fastModeTimingHistory.length;
    const totalMs = fastModeTimingHistory.reduce((s, e) => s + e.passMs, 0);
    const totalSteps = fastModeTimingHistory.reduce((s, e) => s + e.steps, 0);
    const lines = [
        ["Last pass", (last.passMs / 1000).toFixed(2) + "s"],
        ["Steps/sec", last.stepsPerSec.toLocaleString()],
        ["Workers", String(last.workers)],
        ["Steps/pass", last.steps.toLocaleString()],
    ];
    if (fastModeTargetPasses > 0) {
        lines.push(["Passes", nPasses + "/" + Math.round(fastModeTargetPasses * 100) / 100]);
    } else {
        lines.push(["Passes", String(nPasses)]);
    }
    lines.push(["Total time", (totalMs / 1000).toFixed(2) + "s"]);
    lines.push(["Total steps", totalSteps.toLocaleString()]);
    if (nPasses > 1) {
        const avgSps = Math.round(totalSteps / (totalMs / 1000));
        lines.push(["Avg steps/s", avgSps.toLocaleString()]);
    }
    // Composite breakdown from last pass
    if (last.composite) {
        const c = last.composite;
        lines.push(["", ""]);
        lines.push(["Workers", last.workerMs.toFixed(1) + "ms"]);
        lines.push(["getImageData", c.getMs.toFixed(1) + "ms"]);
        lines.push(["pixel writes", c.writeMs.toFixed(1) + "ms (" + c.pixels.toLocaleString() + "px)"]);
        lines.push(["putImageData", c.putMs.toFixed(1) + "ms"]);
        lines.push(["composite", c.totalMs.toFixed(1) + "ms"]);
    }
    const tbl = document.createElement("div");
    tbl.style.cssText = "display:grid;grid-template-columns:auto auto;gap:2px 10px;font-size:10px;";
    for (const [k, v] of lines) {
        const kEl = document.createElement("span");
        kEl.style.color = "var(--muted)";
        kEl.textContent = k;
        const vEl = document.createElement("span");
        vEl.style.cssText = "color:var(--fg);text-align:right;font-variant-numeric:tabular-nums;";
        vEl.textContent = v;
        tbl.appendChild(kEl);
        tbl.appendChild(vEl);
    }
    body.appendChild(tbl);
    // Copy button
    const copyBtn = document.createElement("button");
    copyBtn.textContent = "Copy";
    copyBtn.style.cssText = "margin-top:6px;font-size:9px;padding:2px 8px;cursor:pointer;background:var(--bg);color:var(--accent);border:1px solid var(--accent-border);border-radius:4px;";
    copyBtn.addEventListener("click", function() {
        const data = {
            resolution: bitmapComputeRes || null,
            workers: last.workers,
            stepsPerPass: last.steps,
            passes: fastModeTimingHistory.slice(-10).map(function(h) {
                return {
                    passMs: +h.passMs.toFixed(1),
                    workerMs: h.workerMs ? +h.workerMs.toFixed(1) : null,
                    stepsPerSec: h.stepsPerSec,
                    composite: h.composite ? {
                        getMs: +h.composite.getMs.toFixed(1),
                        writeMs: +h.composite.writeMs.toFixed(1),
                        putMs: +h.composite.putMs.toFixed(1),
                        totalMs: +h.composite.totalMs.toFixed(1),
                        pixels: h.composite.pixels
                    } : null
                };
            })
        };
        navigator.clipboard.writeText(JSON.stringify(data, null, 2));
        copyBtn.textContent = "Copied!";
        setTimeout(function() { copyBtn.textContent = "Copy"; }, 1000);
    });
    body.appendChild(copyBtn);
}

function openTimingPop() {
    if (timingPopOpen) { closeTimingPop(); return; }
    timingPop.innerHTML = "";
    const title = document.createElement("div");
    title.className = "pop-title";
    title.textContent = "TIMING";
    timingPop.appendChild(title);
    const body = document.createElement("div");
    body.id = "timing-body";
    timingPop.appendChild(body);
    // Clear button
    const clearBtn = document.createElement("button");
    clearBtn.style.cssText = "font-size:9px;color:var(--muted);background:transparent;border:1px solid var(--stroke);border-radius:4px;padding:2px 8px;cursor:pointer;margin-top:4px;";
    clearBtn.textContent = "clear";
    clearBtn.addEventListener("click", () => { fastModeTimingHistory = []; updateTimingPopup(); });
    timingPop.appendChild(clearBtn);
    timingPop.classList.add("open");
    const r = document.getElementById("timing-btn").getBoundingClientRect();
    timingPop.style.left = r.left + "px";
    timingPop.style.top = (r.bottom + 6) + "px";
    timingPopOpen = true;
    updateTimingPopup();
}
document.getElementById("timing-btn").addEventListener("click", openTimingPop);

// --- Save / Load state ---

async function saveState() {
    const meta = buildStateMetadata();
    const json = JSON.stringify(meta, null, 2);
    const ts = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
    if (window.showSaveFilePicker) {
        try {
            const handle = await window.showSaveFilePicker({
                suggestedName: `polypaint-${ts}.json`,
                types: [{ description: "JSON", accept: { "application/json": [".json"] } }]
            });
            const w = await handle.createWritable();
            await w.write(json);
            await w.close();
            return;
        } catch (e) { if (e.name === "AbortError") return; }
    }
    const blob = new Blob([json], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `polypaint-${ts}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
}

async function loadState() {
    let text;
    if (window.showOpenFilePicker) {
        try {
            const [handle] = await window.showOpenFilePicker({
                types: [{ description: "JSON", accept: { "application/json": [".json"] } }]
            });
            const file = await handle.getFile();
            text = await file.text();
        } catch (e) { if (e.name === "AbortError") return; throw e; }
    } else {
        text = await new Promise((resolve, reject) => {
            const input = document.createElement("input");
            input.type = "file"; input.accept = ".json";
            input.onchange = async () => {
                if (input.files[0]) resolve(await input.files[0].text());
                else reject(new Error("No file selected"));
            };
            input.click();
        });
    }
    applyLoadedState(JSON.parse(text));
}

function applyLoadedState(meta) {
    // 1. Stop animation, clear everything
    stopAnimation();
    animState.elapsedAtPause = null;
    playBtn.textContent = "\u25b6 Play";
    updateAnimSeconds(0);
    scrubSlider.value = 0;
    lastSelectedCoeff = -1;
    clearAllSelection();
    clearTrails();
    clearStatsData();
    resetAudioState();
    renderCoeffTrails();
    currentRoots = [];
    rootsLayer.selectAll("circle.root").remove();

    // 2. Set degree + pattern (without triggering applyPattern)
    const deg = meta.degree || 5;
    currentDegree = deg;
    degreeNumber.textContent = deg;
    if (meta.pattern) document.getElementById("pattern").value = meta.pattern;

    // 3. Rebuild coefficients array from saved data
    const n = deg + 1;
    coefficients = [];
    for (let i = 0; i < n; i++) {
        const saved = meta.coefficients[i];
        if (!saved) { coefficients.push({ re: 0, im: 0, curve: [{ re: 0, im: 0 }], curveIndex: 0, pathType: "none", radius: 25, speed: 1, angle: 0, ccw: false, extra: {} }); continue; }
        const home = saved.home || saved.pos;
        coefficients.push({
            re: home[0], im: home[1],
            curve: [{ re: home[0], im: home[1] }],
            curveIndex: 0,
            pathType: saved.pathType || "none",
            radius: saved.radius ?? 25,
            speed: saved.speed ?? 1,
            angle: saved.angle ?? 0,
            ccw: saved.ccw ?? false,
            extra: saved.extra || {}
        });
    }

    // 4. Set panel ranges (must happen before computeCurve so coeffExtent works with correct scale)
    if (meta.panels) {
        if (meta.panels.coeff) { panels.coeff.range = meta.panels.coeff.range; initPanelScales(panels.coeff); drawGrid(coeffSvg, panels.coeff); }
        if (meta.panels.roots) { panels.roots.range = meta.panels.roots.range; initPanelScales(panels.roots); drawGrid(rootsSvg, panels.roots); }
    }

    // 5. Regenerate curves for all coefficients
    for (const c of coefficients) {
        if (c.pathType === "none") {
            c.curve = [{ re: c.re, im: c.im }];
        } else {
            c.curve = computeCurve(c.re, c.im, c.pathType, c.radius / 100 * coeffExtent(), c.angle, c.extra);
        }
        c.curveIndex = 0;
    }

    // 5b. Restore morph state
    morphEnabled = true; // always enabled (checkbox removed)
    if (meta.morph) {
        morphRate = meta.morph.rate ?? 0.01;
        morphMu = meta.morph.mu ?? 0.5;
        morphPathType = meta.morph.cdPathType || "line";
        morphPathCcw = !!meta.morph.cdCcw;
        morphEllipseMinor = meta.morph.cdEllipseMinor ?? 0.5;
        morphDitherMidSigma = meta.morph.cdDitherMidSigma ?? meta.morph.cdDitherSigma ?? 0;
        morphDitherEndSigma = meta.morph.cdDitherEndSigma ?? 0;
        morphDitherStartSigma = meta.morph.cdDitherStartSigma ?? morphDitherEndSigma;
        morphTheta = 0;
        if (meta.morph.target && meta.morph.target.length === coefficients.length) {
            morphTargetCoeffs = meta.morph.target.map(d => {
                const hasPath = d.pathType && d.pathType !== "none" && d.pathType !== "follow-c";
                const home = hasPath ? (d.home || d.pos) : d.pos;
                return {
                    re: home[0], im: home[1],
                    pathType: d.pathType || "none",
                    radius: d.radius ?? 25,
                    speed: d.speed ?? 1,
                    angle: d.angle ?? 0,
                    ccw: d.ccw ?? false,
                    extra: d.extra || {},
                    curve: [{ re: home[0], im: home[1] }],
                    curveIndex: 0
                };
            });
            // Regenerate curves for D-nodes with paths
            for (const d of morphTargetCoeffs) {
                if (d.pathType !== "none" && d.pathType !== "follow-c") {
                    d.curve = computeCurve(d.curve[0].re, d.curve[0].im, d.pathType, d.radius / 100 * coeffExtent(), d.angle, d.extra);
                }
                d.curveIndex = 0;
            }
        } else {
            initMorphTarget();
        }
        document.getElementById("morph-mu-val").textContent = "Î¼=" + morphMu.toFixed(2);
    } else {
        initMorphTarget();
    }

    // 6. Restore roots
    if (meta.roots && meta.roots.length) {
        currentRoots = meta.roots.map(r => ({ re: r[0], im: r[1] }));
    } else {
        solveRoots();
    }

    // 7. Restore UI flags + sync buttons
    trailsEnabled = meta.trails || false;
    trailsBtn.classList.toggle("active", trailsEnabled);

    domainColoringEnabled = meta.domainColoring || false;
    domainToggleBtn.classList.toggle("active", domainColoringEnabled);
    domainCanvas.style.display = domainColoringEnabled ? "block" : "none";
    rootsSvg.classed("domain-active", domainColoringEnabled);

    if (meta.rootColorMode) {
        rootColorMode = meta.rootColorMode;
    } else if (meta.rootColoring !== undefined) {
        rootColorMode = meta.rootColoring ? "rainbow" : "uniform";
    }
    if (meta.uniformRootColor && Array.isArray(meta.uniformRootColor)) {
        uniformRootColor = meta.uniformRootColor.slice();
    }
    if (meta.bitmapColorMode) {
        bitmapColorMode = meta.bitmapColorMode;
    } else {
        bitmapColorMode = rootColorMode; // backward compat: mirror animation mode
    }
    if (meta.bitmapUniformColor && Array.isArray(meta.bitmapUniformColor)) {
        bitmapUniformColor = meta.bitmapUniformColor.slice();
    } else {
        bitmapUniformColor = uniformRootColor.slice();
    }
    if (meta.bitmapCanvasColor) {
        bitmapCanvasColor = meta.bitmapCanvasColor;
        document.getElementById("bitmap-container").style.background = bitmapCanvasColor;
    }
    if (meta.bitmapExportFormat) {
        bitmapExportFormat = meta.bitmapExportFormat;
    }
    if (meta.bitmapMatchStrategy && ["assign4","assign1","hungarian1"].includes(meta.bitmapMatchStrategy)) {
        bitmapMatchStrategy = meta.bitmapMatchStrategy;
    } else {
        bitmapMatchStrategy = "assign4";
    }
    if (meta.bitmapProxPalette && PROX_PALETTE_CATALOG.some(p => p.key === meta.bitmapProxPalette)) {
        setProxPalette(meta.bitmapProxPalette);
    } else {
        setProxPalette("inferno");
    }
    if (meta.bitmapDerivPalette && DERIV_PALETTE_CATALOG.some(p => p.key === meta.bitmapDerivPalette)) {
        setDerivPalette(meta.bitmapDerivPalette);
    } else {
        setDerivPalette("bwr");
    }
    if (meta.bitmapIdxProxGamma != null && meta.bitmapIdxProxGamma >= 0.1 && meta.bitmapIdxProxGamma <= 1.0) {
        bitmapIdxProxGamma = meta.bitmapIdxProxGamma;
    } else {
        bitmapIdxProxGamma = 0.5;
    }
    if (meta.bitmapRatioGamma != null && meta.bitmapRatioGamma >= 0.1 && meta.bitmapRatioGamma <= 1.0) {
        bitmapRatioGamma = meta.bitmapRatioGamma;
    } else {
        bitmapRatioGamma = 0.5;
    }
    rootColorBtn.classList.toggle("active", rootColorMode !== "uniform");

    // 8. Restore trail data
    if (meta.trailData && meta.trailData.length) {
        trailData = meta.trailData.map(pts => pts.map(p => ({ re: p[0], im: p[1] })));
    }

    // 9. Restore jiggle settings
    if (meta.jiggle) {
        jiggleMode = meta.jiggle.mode || "random";
        if (jiggleMode === "spiral") jiggleMode = "spiral-centroid"; // backward compat
        if (jiggleMode === "scale") jiggleMode = "scale-center"; // backward compat
        jiggleSigma = meta.jiggle.sigma ?? 1;
        if (jiggleSigma > 10) jiggleSigma = jiggleSigma / 10; // backward compat: old 0â€“100 â†’ new 0â€“10
        // angleSteps is new; backward compat: convert old theta (turns) â†’ steps = round(1/theta)
        if (meta.jiggle.angleSteps != null) {
            jiggleAngleSteps = meta.jiggle.angleSteps;
        } else if (meta.jiggle.theta != null) {
            jiggleAngleSteps = Math.max(10, Math.min(5000, Math.round(1 / meta.jiggle.theta)));
        }
        jiggleScaleStep = meta.jiggle.scaleStep ?? 0.1;
        if (jiggleScaleStep > 1) jiggleScaleStep = 0.1; // backward compat: old snaps had integer values like 5
        jigglePeriod = meta.jiggle.period ?? 20;
        jiggleAmplitude = meta.jiggle.amplitude ?? 10;
        jiggleLissFreqX = meta.jiggle.lissFreqX ?? 1;
        jiggleLissFreqY = meta.jiggle.lissFreqY ?? 2;
        jiggleCircleSteps = meta.jiggle.circleSteps ?? 60;
    }
    jiggleStep = -1;
    jiggleWalkCache = null;
    jiggleOffsets = null;


    // 9c. Restore numWorkers
    if (typeof meta.numWorkers === "number" && meta.numWorkers >= 1 && meta.numWorkers <= 16) {
        numWorkers = meta.numWorkers;
    }

    // 9c2. Restore solver type
    if (meta.solverType === "js" || meta.solverType === "wasm") {
        solverType = meta.solverType;
    }
    if (typeof meta.targetSeconds === "number") jiggleInterval = meta.targetSeconds;

    // 9d. Restore bitmap coefficient view toggle
    bitmapCoeffView = !!meta.bitmapCoeffView;
    const bcBtn = document.getElementById("bitmap-coeff-btn");
    if (bcBtn) {
        bcBtn.classList.toggle("active", bitmapCoeffView);
        bcBtn.textContent = bitmapCoeffView ? "COEF" : "ROOT";
    }

    // 10. Restore selections
    if (meta.selectedCoeffs) for (const idx of meta.selectedCoeffs) selectedCoeffs.add(idx);
    if (meta.selectedRoots) for (const idx of meta.selectedRoots) selectedRoots.add(idx);

    // 10. Re-render everything
    renderCoefficients();
    renderRoots(currentRoots);
    renderCoeffTrails();
    if (trailData.length) renderTrails();
    if (domainColoringEnabled) renderDomainColoring();
    updateCoeffSelectionVisual();
    updateRootSelectionVisual();
}

document.getElementById("save-btn").addEventListener("click", saveState);
document.getElementById("load-btn").addEventListener("click", loadState);

// --- Resize handler ---

// --- Stats tab ---

(function initStatsCanvases() {
    const canvases = document.querySelectorAll(".stats-canvas");
    const selects = document.querySelectorAll(".stats-select");
    canvases.forEach((c, i) => {
        statsState.canvases[i] = c;
        statsState.ctxs[i] = c.getContext("2d");
    });
    selects.forEach((sel, plotIdx) => {
        PLOT_OPTIONS.forEach((name, si) => {
            const opt = document.createElement("option");
            opt.value = si; opt.textContent = name;
            sel.appendChild(opt);
        });
        sel.value = statsState.plotConfigs[plotIdx];
        sel.addEventListener("change", () => {
            statsState.plotConfigs[plotIdx] = parseInt(sel.value);
            drawStatsPlot(plotIdx);
        });
    });
    // Init ring buffers
    for (const name of STAT_TYPES) statsState.buffers[name] = new Float64Array(statsState.maxFrames);
})();

function resizeStatsCanvases() {
    const dpr = window.devicePixelRatio || 1;
    for (let i = 0; i < 16; i++) {
        const c = statsState.canvases[i];
        if (!c) continue;
        const rect = c.getBoundingClientRect();
        c.width = Math.floor(rect.width * dpr);
        c.height = Math.floor(rect.height * dpr);
        statsState.ctxs[i].setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    statsState.dirty = true;
}

function cacheRootForces() {
    // Per-root sensitivity w.r.t. moving coefficients â€” cached for Force/MinForce/MaxForce
    const nRoots = currentRoots.length;
    const nCoeffs = coefficients.length;
    const deg = nCoeffs - 1;
    if (!statsState.rootForces || statsState.rootForces.length !== nRoots) {
        statsState.rootForces = new Float64Array(nRoots);
    }
    if (nRoots === 0 || nCoeffs === 0) { statsState.rootForces.fill(0); return; }

    const movingSet = allAnimatedCoeffs();
    if (movingSet.size === 0) { statsState.rootForces.fill(0); return; }

    const cRe = new Float64Array(nCoeffs);
    const cIm = new Float64Array(nCoeffs);
    for (let i = 0; i < nCoeffs; i++) { cRe[i] = coefficients[i].re; cIm[i] = coefficients[i].im; }

    const invDpMag = new Float64Array(nRoots);
    const rMag = new Float64Array(nRoots);
    for (let j = 0; j < nRoots; j++) {
        const zRe = currentRoots[j].re, zIm = currentRoots[j].im;
        rMag[j] = Math.hypot(zRe, zIm);
        let pRe = cRe[0], pIm = cIm[0], dpRe = 0, dpIm = 0;
        for (let k = 1; k <= deg; k++) {
            const ndRe = dpRe * zRe - dpIm * zIm + pRe;
            const ndIm = dpRe * zIm + dpIm * zRe + pIm;
            dpRe = ndRe; dpIm = ndIm;
            const npRe = pRe * zRe - pIm * zIm + cRe[k];
            const npIm = pRe * zIm + pIm * zRe + cIm[k];
            pRe = npRe; pIm = npIm;
        }
        const dm = Math.hypot(dpRe, dpIm);
        invDpMag[j] = dm < 1e-30 ? 0 : 1 / dm;
    }

    for (let j = 0; j < nRoots; j++) {
        let f = 0;
        for (const k of movingSet) {
            f += Math.pow(rMag[j], deg - k) * invDpMag[j];
        }
        statsState.rootForces[j] = f;
    }
}

function computeForce() {
    const rf = statsState.rootForces;
    if (!rf || rf.length === 0) return 0;
    let total = 0;
    for (let j = 0; j < rf.length; j++) total += rf[j];
    return total;
}

function computeMinForce() {
    const rf = statsState.rootForces;
    if (!rf || rf.length === 0) return 0;
    let m = Infinity;
    for (let j = 0; j < rf.length; j++) if (rf[j] < m) m = rf[j];
    return m === Infinity ? 0 : m;
}

function computeMaxForce() {
    const rf = statsState.rootForces;
    if (!rf || rf.length === 0) return 0;
    let m = 0;
    for (let j = 0; j < rf.length; j++) if (rf[j] > m) m = rf[j];
    return m;
}

function computeSpeed() {
    const n = currentRoots.length;
    if (!statsState.prevRoots || statsState.prevRoots.length !== n) return 0;
    let total = 0;
    for (let i = 0; i < n; i++) {
        const dx = currentRoots[i].re - statsState.prevRoots[i].re;
        const dy = currentRoots[i].im - statsState.prevRoots[i].im;
        total += Math.hypot(dx, dy);
    }
    return total;
}

function computeMinDist() {
    const n = currentRoots.length;
    if (n < 2) return 0;
    let minD = Infinity;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const dx = currentRoots[i].re - currentRoots[j].re;
            const dy = currentRoots[i].im - currentRoots[j].im;
            const d = Math.hypot(dx, dy);
            if (d < minD) minD = d;
        }
    }
    return minD;
}

function computeMaxDist() {
    const n = currentRoots.length;
    if (n < 2) return 0;
    let maxD = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const dx = currentRoots[i].re - currentRoots[j].re;
            const dy = currentRoots[i].im - currentRoots[j].im;
            const d = Math.hypot(dx, dy);
            if (d > maxD) maxD = d;
        }
    }
    return maxD;
}

function computeRecords() {
    // Count per-pair closeness record updates using voiceConfig.novelty & .decay
    const n = currentRoots.length;
    if (n < 2) return 0;
    const nPairs = n * (n - 1) / 2;

    let seeding = false;
    if (!pairRecords || pairRecords.length !== nPairs) {
        pairRecords = new Float64Array(nPairs).fill(Infinity);
        seeding = true;
    }

    let count = 0;
    let idx = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const d = Math.hypot(
                currentRoots[i].re - currentRoots[j].re,
                currentRoots[i].im - currentRoots[j].im
            );
            if (seeding) {
                pairRecords[idx] = d;
            } else if (d < pairRecords[idx]) {
                count++;
                pairRecords[idx] = d * voiceConfig.novelty;
            }
            idx++;
        }
    }

    // Decay all records (memory > 1.0 â†’ records grow, becoming beatable again)
    if (!seeding) {
        for (let k = 0; k < nPairs; k++) {
            pairRecords[k] *= voiceConfig.decay;
        }
    }

    return count;
}

function computeMeanDist() {
    const n = currentRoots.length;
    if (n < 2) return 0;
    let total = 0;
    let count = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            total += Math.hypot(
                currentRoots[i].re - currentRoots[j].re,
                currentRoots[i].im - currentRoots[j].im
            );
            count++;
        }
    }
    return total / count;
}

function computeDeltaMeanDist() {
    // Read the just-written MeanDist from the current buffer slot
    const cur = statsState.buffers["MeanDist"][statsState.writeIdx];
    const prev = statsState.prevMeanDist;
    statsState.prevMeanDist = cur;
    if (prev === null) return 0;
    return Math.abs(cur - prev);
}

function computeMinSpeed() {
    const s = statsState.rootSpeeds;
    if (!s || s.length === 0) return 0;
    let m = Infinity;
    for (let i = 0; i < s.length; i++) if (s[i] < m) m = s[i];
    return m === Infinity ? 0 : m;
}

function computeMaxSpeed() {
    const s = statsState.rootSpeeds;
    if (!s || s.length === 0) return 0;
    let m = 0;
    for (let i = 0; i < s.length; i++) if (s[i] > m) m = s[i];
    return m;
}

function computeAngularMom() {
    // Î£ (râ±¼ âˆ’ centroid) Ã— vâ±¼  (2D cross product, signed)
    const n = currentRoots.length;
    if (n === 0 || !statsState.prevRoots || statsState.prevRoots.length !== n) return 0;
    let cx = 0, cy = 0;
    for (let i = 0; i < n; i++) { cx += currentRoots[i].re; cy += currentRoots[i].im; }
    cx /= n; cy /= n;
    let L = 0;
    for (let i = 0; i < n; i++) {
        const rx = currentRoots[i].re - cx;
        const ry = currentRoots[i].im - cy;
        const vx = currentRoots[i].re - statsState.prevRoots[i].re;
        const vy = currentRoots[i].im - statsState.prevRoots[i].im;
        L += rx * vy - ry * vx;
    }
    return L;
}

function computeSigmaSpeed() {
    const s = statsState.rootSpeeds;
    if (!s || s.length === 0) return 0;
    const n = s.length;
    let sum = 0;
    for (let i = 0; i < n; i++) sum += s[i];
    const mean = sum / n;
    let var_ = 0;
    for (let i = 0; i < n; i++) { const d = s[i] - mean; var_ += d * d; }
    return Math.sqrt(var_ / n);
}

function computeEMASpeed() {
    // Read the just-written Speed from the current buffer slot
    const cur = statsState.buffers["Speed"][statsState.writeIdx];
    statsState.emaSpeed += 0.05 * (cur - statsState.emaSpeed);
    return statsState.emaSpeed;
}

function computeSigmaDist() {
    const n = currentRoots.length;
    if (n < 2) return 0;
    // Read the just-written MeanDist
    const mean = statsState.buffers["MeanDist"][statsState.writeIdx];
    let var_ = 0, count = 0;
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            const d = Math.hypot(
                currentRoots[i].re - currentRoots[j].re,
                currentRoots[i].im - currentRoots[j].im
            ) - mean;
            var_ += d * d;
            count++;
        }
    }
    return Math.sqrt(var_ / count);
}

function computeOdometer() {
    const od = statsState.rootOdometers;
    if (!od) return 0;
    let total = 0;
    for (let i = 0; i < od.length; i++) total += od[i];
    return total;
}
function computeCycleCount() {
    return statsState.odometerCycleCount;
}

function computeMedianR() {
    // Median radius from centroid (same as audio r50), smoothed
    const n = currentRoots.length;
    if (n === 0) return 0;
    let cx = 0, cy = 0;
    for (let i = 0; i < n; i++) { cx += currentRoots[i].re; cy += currentRoots[i].im; }
    cx /= n; cy /= n;
    const radii = new Array(n);
    for (let i = 0; i < n; i++) radii[i] = Math.hypot(currentRoots[i].re - cx, currentRoots[i].im - cy);
    radii.sort((a, b) => a - b);
    const raw = percentileSorted(radii, 0.50);
    statsState.smoothMedianR += AUDIO_ALPHA * (raw - statsState.smoothMedianR);
    return statsState.smoothMedianR;
}

function computeSpread() {
    // r90 - r10 radius spread from centroid, smoothed
    const n = currentRoots.length;
    if (n === 0) return 0;
    let cx = 0, cy = 0;
    for (let i = 0; i < n; i++) { cx += currentRoots[i].re; cy += currentRoots[i].im; }
    cx /= n; cy /= n;
    const radii = new Array(n);
    for (let i = 0; i < n; i++) radii[i] = Math.hypot(currentRoots[i].re - cx, currentRoots[i].im - cy);
    radii.sort((a, b) => a - b);
    const raw = percentileSorted(radii, 0.90) - percentileSorted(radii, 0.10);
    statsState.smoothSpread += AUDIO_ALPHA * (raw - statsState.smoothSpread);
    return statsState.smoothSpread;
}

function computeEMed() {
    // 50th percentile of per-root speeds, smoothed
    const s = statsState.rootSpeeds;
    if (!s || s.length === 0) return 0;
    const sorted = Array.from(s).sort((a, b) => a - b);
    const raw = percentileSorted(sorted, 0.50);
    statsState.smoothEMed += AUDIO_ALPHA * (raw - statsState.smoothEMed);
    return statsState.smoothEMed;
}

function computeEHi() {
    // 85th percentile of per-root speeds, smoothed
    const s = statsState.rootSpeeds;
    if (!s || s.length === 0) return 0;
    const sorted = Array.from(s).sort((a, b) => a - b);
    const raw = percentileSorted(sorted, 0.85);
    statsState.smoothEHi += AUDIO_ALPHA * (raw - statsState.smoothEHi);
    return statsState.smoothEHi;
}

function computeCoherence() {
    // Angular coherence R = |mean(e^{iÎ¸})| around centroid, smoothed
    const n = currentRoots.length;
    if (n === 0) return 0;
    let cx = 0, cy = 0;
    for (let i = 0; i < n; i++) { cx += currentRoots[i].re; cy += currentRoots[i].im; }
    cx /= n; cy /= n;
    let au = 0, av = 0;
    for (let i = 0; i < n; i++) {
        const th = Math.atan2(currentRoots[i].im - cy, currentRoots[i].re - cx);
        au += Math.cos(th); av += Math.sin(th);
    }
    const raw = Math.hypot(au / n, av / n);
    statsState.smoothCoherence += AUDIO_ALPHA * (raw - statsState.smoothCoherence);
    return statsState.smoothCoherence;
}

function computeEncounters() {
    // Per-root top-3 closest distance records (mirrors audio close encounters), smoothed count
    const n = currentRoots.length;
    if (n < 2) return 0;
    const K = 3;

    let seeding = false;
    if (!statsState.statsEncounters || statsState.statsEncounters.length !== n * K) {
        statsState.statsEncounters = new Float64Array(n * K).fill(Infinity);
        seeding = true;
    }

    let count = 0;
    for (let i = 0; i < n; i++) {
        const closest = [Infinity, Infinity, Infinity];
        for (let j = 0; j < n; j++) {
            if (j === i) continue;
            const d = Math.hypot(currentRoots[i].re - currentRoots[j].re,
                                 currentRoots[i].im - currentRoots[j].im);
            if (d < closest[2]) {
                closest[2] = d;
                if (closest[2] < closest[1]) { const t = closest[1]; closest[1] = closest[2]; closest[2] = t; }
                if (closest[1] < closest[0]) { const t = closest[0]; closest[0] = closest[1]; closest[1] = t; }
            }
        }

        const base = i * K;
        if (seeding) {
            for (let k = 0; k < K; k++) statsState.statsEncounters[base + k] = closest[k];
        } else {
            for (let k = 0; k < K; k++) {
                const worstIdx = base + K - 1;
                if (closest[k] < statsState.statsEncounters[worstIdx]) {
                    count++;
                    statsState.statsEncounters[worstIdx] = closest[k] * voiceConfig.novelty;
                    // Bubble sort to maintain order
                    for (let a = K - 1; a > 0; a--) {
                        if (statsState.statsEncounters[base + a] < statsState.statsEncounters[base + a - 1]) {
                            const td = statsState.statsEncounters[base + a];
                            statsState.statsEncounters[base + a] = statsState.statsEncounters[base + a - 1];
                            statsState.statsEncounters[base + a - 1] = td;
                        }
                    }
                }
            }
        }
    }

    // Decay all records
    if (!seeding) {
        for (let k = 0; k < statsState.statsEncounters.length; k++) {
            statsState.statsEncounters[k] *= voiceConfig.decay;
        }
    }

    // Smooth the count with one-pole filter
    statsState.smoothEncounters += AUDIO_ALPHA * (count - statsState.smoothEncounters);
    return statsState.smoothEncounters;
}

const statComputeFns = [computeForce, computeMinForce, computeMaxForce, computeSpeed, computeMinSpeed, computeMaxSpeed, computeMinDist, computeMaxDist, computeRecords, computeMeanDist, computeDeltaMeanDist, computeAngularMom, computeSigmaSpeed, computeEMASpeed, computeSigmaDist, computeOdometer, computeCycleCount, computeMedianR, computeSpread, computeEMed, computeEHi, computeCoherence, computeEncounters];

function collectStatsSnapshot() {
    const n = currentRoots.length;
    if (n === 0) return;

    // Per-root displacement this tick (= speed in ticks-as-time units)
    if (!statsState.rootSpeeds || statsState.rootSpeeds.length !== n) {
        statsState.rootSpeeds = new Float64Array(n);
    }
    if (statsState.prevRoots && statsState.prevRoots.length === n) {
        for (let i = 0; i < n; i++) {
            statsState.rootSpeeds[i] = Math.hypot(
                currentRoots[i].re - statsState.prevRoots[i].re,
                currentRoots[i].im - statsState.prevRoots[i].im
            );
        }
    } else {
        statsState.rootSpeeds.fill(0);
    }

    // Update spectrum peak heights (all-time max per root)
    if (!statsState.spectrumPeaks || statsState.spectrumPeaks.length !== n) {
        statsState.spectrumPeaks = new Float64Array(n);
    }
    for (let i = 0; i < n; i++) {
        statsState.spectrumPeaks[i] = Math.max(statsState.rootSpeeds[i], statsState.spectrumPeaks[i]);
    }

    // Accumulate per-root odometers (cumulative distance)
    if (!statsState.rootOdometers || statsState.rootOdometers.length !== n) {
        statsState.rootOdometers = new Float64Array(n);
    }
    for (let i = 0; i < n; i++) {
        statsState.rootOdometers[i] += statsState.rootSpeeds[i];
    }

    // Accumulate per-root winding number (cumulative signed angle in turns, around origin)
    if (!statsState.rootWindings || statsState.rootWindings.length !== n) {
        statsState.rootWindings = new Float64Array(n);
    }
    if (statsState.prevRoots && statsState.prevRoots.length === n) {
        for (let i = 0; i < n; i++) {
            const x0 = statsState.prevRoots[i].re, y0 = statsState.prevRoots[i].im;
            const x1 = currentRoots[i].re, y1 = currentRoots[i].im;
            // Cross product and dot product of (prev, current) vectors from origin
            const cross = x0 * y1 - y0 * x1;
            const dot = x0 * x1 + y0 * y1;
            statsState.rootWindings[i] += Math.atan2(cross, dot) / (2 * Math.PI);
        }
    }

    // Accumulate per-root tortuosity components (path length + net displacement)
    if (!statsState.rootTortuosityOdo || statsState.rootTortuosityOdo.length !== n) {
        statsState.rootTortuosityOdo = new Float64Array(n);
        statsState.rootTortuosityNetDx = new Float64Array(n);
        statsState.rootTortuosityNetDy = new Float64Array(n);
    }
    if (statsState.prevRoots && statsState.prevRoots.length === n) {
        for (let i = 0; i < n; i++) {
            const dx = currentRoots[i].re - statsState.prevRoots[i].re;
            const dy = currentRoots[i].im - statsState.prevRoots[i].im;
            statsState.rootTortuosityOdo[i] += statsState.rootSpeeds[i];
            statsState.rootTortuosityNetDx[i] += dx;
            statsState.rootTortuosityNetDy[i] += dy;
        }
    }

    // Per-root odometer cycle detection (each root independently detects its own cycle)
    if (animState.playing && n > 0) {
        if (!statsState.odometerStartRoots || statsState.odometerStartRoots.length !== n) {
            statsState.odometerStartRoots = currentRoots.map(r => ({ re: r.re, im: r.im }));
            statsState.odometerFrameCounts = new Int32Array(n);
            statsState.odometerMaxDisps = new Float64Array(n);
            if (!statsState.odometerCycleLengths || statsState.odometerCycleLengths.length !== n) {
                statsState.odometerCycleLengths = new Float64Array(n);
            }
        } else {
            const thresh = panels.roots.range * 0.02;
            for (let i = 0; i < n; i++) {
                statsState.odometerFrameCounts[i]++;
                const d = Math.hypot(
                    currentRoots[i].re - statsState.odometerStartRoots[i].re,
                    currentRoots[i].im - statsState.odometerStartRoots[i].im
                );
                if (d > statsState.odometerMaxDisps[i]) statsState.odometerMaxDisps[i] = d;
                // Check closure: root must have moved significantly and returned near start
                if (statsState.odometerFrameCounts[i] > 5 &&
                    statsState.odometerMaxDisps[i] > thresh * 5 &&
                    d < thresh) {
                    // This root completed a cycle
                    statsState.odometerCycleCount++;
                    statsState.odometerCycleLengths[i] = statsState.rootOdometers[i];
                    statsState.rootOdometers[i] = 0;
                    statsState.odometerFrameCounts[i] = 0;
                    statsState.odometerMaxDisps[i] = 0;
                    statsState.odometerStartRoots[i].re = currentRoots[i].re;
                    statsState.odometerStartRoots[i].im = currentRoots[i].im;
                }
            }
        }
    }

    // Cache per-root forces before stat compute loop (MinForce/MaxForce read from cache)
    cacheRootForces();

    const idx = statsState.writeIdx;
    for (let s = 0; s < STAT_TYPES.length; s++) {
        statsState.buffers[STAT_TYPES[s]][idx] = statComputeFns[s]();
    }

    // Save previous roots for Speed computation next frame
    if (!statsState.prevRoots || statsState.prevRoots.length !== n) {
        statsState.prevRoots = [];
        for (let i = 0; i < n; i++) statsState.prevRoots.push({ re: 0, im: 0 });
    }
    for (let i = 0; i < n; i++) {
        statsState.prevRoots[i].re = currentRoots[i].re;
        statsState.prevRoots[i].im = currentRoots[i].im;
    }

    statsState.writeIdx = (idx + 1) % statsState.maxFrames;
    statsState.frameCount = Math.min(statsState.frameCount + 1, statsState.maxFrames);
    statsState.dirty = true;
}

function clearStatsData() {
    for (const name of STAT_TYPES) statsState.buffers[name].fill(0);
    statsState.frameCount = 0;
    statsState.writeIdx = 0;
    statsState.prevRoots = null;
    statsState.prevMeanDist = null;
    statsState.emaSpeed = 0;
    statsState.spectrumPeaks = null;
    statsState.rootForces = null;
    statsState.rootOdometers = null;
    statsState.odometerCycleLengths = null;
    statsState.odometerStartRoots = null;
    statsState.odometerFrameCounts = null;
    statsState.odometerMaxDisps = null;
    statsState.odometerCycleCount = 0;
    statsState.rootWindings = null;
    statsState.rootTortuosityOdo = null;
    statsState.rootTortuosityNetDx = null;
    statsState.rootTortuosityNetDy = null;
    statsState.smoothMedianR = 0;
    statsState.smoothSpread = 0;
    statsState.smoothEMed = 0;
    statsState.smoothEHi = 0;
    statsState.smoothCoherence = 0;
    statsState.smoothEncounters = 0;
    statsState.statsEncounters = null;
    pairRecords = null;
    statsState.dirty = true;
    if (activeTab === "stats") drawAllStatsPlots();
}

function drawStatsPlot(plotIdx) {
    const ctx = statsState.ctxs[plotIdx];
    if (!ctx) return;
    const c = statsState.canvases[plotIdx];
    const W = c.getBoundingClientRect().width;
    const H = c.getBoundingClientRect().height;
    if (W === 0 || H === 0) return;

    const optIdx = statsState.plotConfigs[plotIdx];
    const nFrames = statsState.frameCount;
    const startIdx = (nFrames < statsState.maxFrames) ? 0 : statsState.writeIdx;
    const ML = 6, MR = 4, MT = 4, MB = 4;
    const plotW = W - ML - MR;
    const plotH = H - MT - MB;

    // Clear
    ctx.fillStyle = "#151a3a";
    ctx.fillRect(0, 0, W, H);

    // Spectrum plot (bar chart)
    const spectrumIdx = optIdx - STAT_TYPES.length - PHASE_PLOTS.length;
    if (spectrumIdx >= 0) {
        const n = currentRoots.length;
        if (n === 0) return;

        // Extra bottom margin for index labels
        const sMB = 10;
        const sPlotH = plotH - sMB + MB;
        const barW = Math.max(1, plotW / n - 1);
        const gap = plotW / n;

        // Shared spectrum helper: grid + axis + index labels
        function drawSpectrumFrame() {
            ctx.strokeStyle = "rgba(255,255,255,0.04)";
            ctx.lineWidth = 0.5;
            for (const frac of [0.25, 0.5, 0.75]) {
                const y = MT + sPlotH * (1 - frac);
                ctx.beginPath(); ctx.moveTo(ML, y); ctx.lineTo(ML + plotW, y); ctx.stroke();
            }
            ctx.strokeStyle = "rgba(255,255,255,0.08)";
            ctx.lineWidth = 0.5;
            ctx.beginPath(); ctx.moveTo(ML, MT + sPlotH); ctx.lineTo(ML + plotW, MT + sPlotH); ctx.stroke();
        }
        function drawSpectrumLabels() {
            ctx.globalAlpha = 0.6;
            ctx.font = `${Math.min(8, gap * 0.8)}px system-ui`;
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            for (let i = 0; i < n; i++) {
                ctx.fillStyle = rootColor(i, n);
                ctx.fillText(i, ML + gap * (i + 0.5), MT + sPlotH + 1);
            }
            ctx.globalAlpha = 1.0;
        }

        if (spectrumIdx === 0) {
            // SpeedSpectrum
            const speeds = statsState.rootSpeeds;
            if (!speeds || speeds.length !== n) return;
            let sMax = 0;
            const peaks = statsState.spectrumPeaks;
            for (let i = 0; i < n; i++) {
                if (speeds[i] > sMax) sMax = speeds[i];
                if (peaks && peaks.length === n && peaks[i] > sMax) sMax = peaks[i];
            }
            if (sMax < 1e-12) sMax = 1;

            drawSpectrumFrame();
            for (let i = 0; i < n; i++) {
                const x = ML + gap * (i + 0.5);
                const h = (speeds[i] / sMax) * sPlotH;
                ctx.strokeStyle = rootColor(i, n);
                ctx.lineWidth = Math.min(barW, 4);
                ctx.lineCap = "butt";
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(x, MT + sPlotH);
                ctx.lineTo(x, MT + sPlotH - h);
                ctx.stroke();
            }
            if (peaks && peaks.length === n) {
                const dotR = Math.min(barW * 0.6, 3);
                for (let i = 0; i < n; i++) {
                    const ph = (peaks[i] / sMax) * sPlotH;
                    const y = MT + sPlotH - ph;
                    ctx.fillStyle = rootColor(i, n);
                    ctx.globalAlpha = 0.95;
                    ctx.beginPath();
                    ctx.arc(ML + gap * (i + 0.5), y, dotR, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            drawSpectrumLabels();

        } else if (spectrumIdx === 1) {
            // OdometerSpectrum
            const od = statsState.rootOdometers;
            if (!od || od.length !== n) return;
            const cl = statsState.odometerCycleLengths;
            let sMax = 0;
            for (let i = 0; i < n; i++) {
                if (od[i] > sMax) sMax = od[i];
                if (cl && cl.length === n && cl[i] > sMax) sMax = cl[i];
            }
            if (sMax < 1e-12) sMax = 1;

            drawSpectrumFrame();
            for (let i = 0; i < n; i++) {
                const x = ML + gap * (i + 0.5);
                const h = (od[i] / sMax) * sPlotH;
                ctx.strokeStyle = rootColor(i, n);
                ctx.lineWidth = Math.min(barW, 4);
                ctx.lineCap = "butt";
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(x, MT + sPlotH);
                ctx.lineTo(x, MT + sPlotH - h);
                ctx.stroke();
            }
            // Cycle-length dots (max from last completed loop)
            if (cl && cl.length === n) {
                const dotR = Math.min(barW * 0.6, 3);
                for (let i = 0; i < n; i++) {
                    const ch = (cl[i] / sMax) * sPlotH;
                    const y = MT + sPlotH - ch;
                    ctx.fillStyle = rootColor(i, n);
                    ctx.globalAlpha = 0.95;
                    ctx.beginPath();
                    ctx.arc(ML + gap * (i + 0.5), y, dotR, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            drawSpectrumLabels();

        } else if (spectrumIdx === 2) {
            // WindingSpectrum â€” cumulative winding number per root (signed, in turns)
            const w = statsState.rootWindings;
            if (!w || w.length !== n) return;
            // Find max absolute winding for symmetric scale
            let wMax = 0;
            for (let i = 0; i < n; i++) {
                const a = Math.abs(w[i]);
                if (a > wMax) wMax = a;
            }
            if (wMax < 1e-6) wMax = 1;
            const halfH = sPlotH / 2;

            drawSpectrumFrame();
            // Draw zero line at center
            ctx.strokeStyle = "rgba(255,255,255,0.12)";
            ctx.lineWidth = 0.5;
            ctx.beginPath(); ctx.moveTo(ML, MT + halfH); ctx.lineTo(ML + plotW, MT + halfH); ctx.stroke();
            // Draw bars (positive = up from center, negative = down from center)
            for (let i = 0; i < n; i++) {
                const x = ML + gap * (i + 0.5);
                const h = (w[i] / wMax) * halfH;
                ctx.strokeStyle = rootColor(i, n);
                ctx.lineWidth = Math.min(barW, 4);
                ctx.lineCap = "butt";
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(x, MT + halfH);
                ctx.lineTo(x, MT + halfH - h);
                ctx.stroke();
            }
            // Y-axis labels: show max winding value
            ctx.fillStyle = "rgba(255,255,255,0.35)";
            ctx.font = "8px system-ui";
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            ctx.globalAlpha = 1.0;
            ctx.fillText("+" + wMax.toFixed(1), ML - 2, MT + 4);
            ctx.fillText("-" + wMax.toFixed(1), ML - 2, MT + sPlotH - 4);
            ctx.fillText("0", ML - 2, MT + halfH);
            drawSpectrumLabels();

        } else if (spectrumIdx === 3) {
            // TortuositySpectrum â€” net displacement / path length (directness)
            // Auto-scaled y-axis to largest value so differences are visible
            const odo = statsState.rootTortuosityOdo;
            const ndx = statsState.rootTortuosityNetDx;
            const ndy = statsState.rootTortuosityNetDy;
            if (!odo || odo.length !== n) return;
            const dir = new Float64Array(n);
            let dMax = 0;
            for (let i = 0; i < n; i++) {
                const netD = Math.hypot(ndx[i], ndy[i]);
                dir[i] = odo[i] > 1e-8 ? netD / odo[i] : 1;
                if (dir[i] > dMax) dMax = dir[i];
            }
            if (dMax < 1e-12) dMax = 1;

            drawSpectrumFrame();
            for (let i = 0; i < n; i++) {
                const x = ML + gap * (i + 0.5);
                const h = (dir[i] / dMax) * sPlotH;
                ctx.strokeStyle = rootColor(i, n);
                ctx.lineWidth = Math.min(barW, 4);
                ctx.lineCap = "butt";
                ctx.globalAlpha = 0.9;
                ctx.beginPath();
                ctx.moveTo(x, MT + sPlotH);
                ctx.lineTo(x, MT + sPlotH - h);
                ctx.stroke();
            }
            drawSpectrumLabels();
        }

        return;
    }

    // Phase-space plot
    const phaseIdx = optIdx - STAT_TYPES.length;
    if (phaseIdx >= 0) {
        const phase = PHASE_PLOTS[phaseIdx];
        const bufX = statsState.buffers[phase.xStat];
        const bufY = statsState.buffers[phase.yStat];
        const color = phase.color;

        // Find tight bounding box then add 10% padding
        let xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity;
        for (let f = 0; f < nFrames; f++) {
            const bi = (startIdx + f) % statsState.maxFrames;
            const vx = bufX[bi], vy = bufY[bi];
            if (vx < xMin) xMin = vx; if (vx > xMax) xMax = vx;
            if (vy < yMin) yMin = vy; if (vy > yMax) yMax = vy;
        }
        if (xMin === Infinity) { xMin = 0; xMax = 1; }
        if (yMin === Infinity) { yMin = 0; yMax = 1; }
        let xSpan = xMax - xMin, ySpan = yMax - yMin;
        if (xSpan < 1e-12) { xMin -= 0.5; xMax += 0.5; xSpan = 1; }
        if (ySpan < 1e-12) { yMin -= 0.5; yMax += 0.5; ySpan = 1; }
        const pad = 0.1;
        xMin -= xSpan * pad; xMax += xSpan * pad;
        yMin -= ySpan * pad; yMax += ySpan * pad;
        // Clamp lower bound to 0 when data is non-negative (these stats are all â‰¥ 0)
        if (xMin < 0 && xMin + xSpan * pad >= 0) xMin = 0;
        if (yMin < 0 && yMin + ySpan * pad >= 0) yMin = 0;

        const pxOf = (v) => ML + ((v - xMin) / (xMax - xMin)) * plotW;
        const pyOf = (v) => MT + plotH - ((v - yMin) / (yMax - yMin)) * plotH;

        // Grid
        ctx.strokeStyle = "rgba(255,255,255,0.04)";
        ctx.lineWidth = 0.5;
        for (const frac of [0.25, 0.5, 0.75]) {
            const y = MT + plotH * (1 - frac);
            ctx.beginPath(); ctx.moveTo(ML, y); ctx.lineTo(ML + plotW, y); ctx.stroke();
            const x = ML + plotW * frac;
            ctx.beginPath(); ctx.moveTo(x, MT); ctx.lineTo(x, MT + plotH); ctx.stroke();
        }

        // Axes
        ctx.strokeStyle = "rgba(255,255,255,0.08)";
        ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(ML, MT + plotH); ctx.lineTo(ML + plotW, MT + plotH); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(ML, MT); ctx.lineTo(ML, MT + plotH); ctx.stroke();

        if (nFrames < 2) return;

        // Draw phase path with age-based opacity (old=dim, new=bright)
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = 1.5;
        for (let f = 1; f < nFrames; f++) {
            const bi0 = (startIdx + f - 1) % statsState.maxFrames;
            const bi1 = (startIdx + f) % statsState.maxFrames;
            const alpha = 0.15 + 0.75 * (f / (nFrames - 1));
            ctx.strokeStyle = color;
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.moveTo(pxOf(bufX[bi0]), pyOf(bufY[bi0]));
            ctx.lineTo(pxOf(bufX[bi1]), pyOf(bufY[bi1]));
            ctx.stroke();
        }
        ctx.globalAlpha = 1.0;

        // Current position dot
        const lastBi = (startIdx + nFrames - 1) % statsState.maxFrames;
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(pxOf(bufX[lastBi]), pyOf(bufY[lastBi]), 3, 0, Math.PI * 2);
        ctx.fill();

        // Axis labels (inside plot area)
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.font = "8px system-ui";
        ctx.textAlign = "center";
        ctx.fillText(phase.xStat, ML + plotW / 2, MT + plotH - 3);
        ctx.save();
        ctx.translate(ML + 10, MT + plotH / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText(phase.yStat, 0, 0);
        ctx.restore();
        return;
    }

    // Time-series plot (optIdx < STAT_TYPES.length)
    const statName = STAT_TYPES[optIdx];
    const buf = statsState.buffers[statName];
    const color = STAT_COLORS[statName];

    // Find min/max value in visible buffer
    let yMin = 0, yMax = 0;
    for (let f = 0; f < nFrames; f++) {
        const bufIdx = (startIdx + f) % statsState.maxFrames;
        const v = buf[bufIdx];
        if (v > yMax) yMax = v;
        if (v < yMin) yMin = v;
    }
    const signed = yMin < -1e-12;
    if (signed) {
        // Symmetric axis around zero
        const absMax = Math.max(Math.abs(yMin), Math.abs(yMax));
        yMin = -absMax || -1; yMax = absMax || 1;
    } else {
        yMin = 0;
        if (yMax < 1e-12) yMax = 1;
    }

    const xOf = (f) => ML + (nFrames > 1 ? (f / (nFrames - 1)) * plotW : 0);
    const yOf = (v) => MT + plotH - ((v - yMin) / (yMax - yMin)) * plotH;

    // Subtle horizontal gridlines at 0.25, 0.5, 0.75
    ctx.strokeStyle = "rgba(255,255,255,0.04)";
    ctx.lineWidth = 0.5;
    for (const frac of [0.25, 0.5, 0.75]) {
        const y = MT + plotH * (1 - frac);
        ctx.beginPath(); ctx.moveTo(ML, y); ctx.lineTo(ML + plotW, y); ctx.stroke();
    }

    // Bottom axis (or zero line for signed stats)
    ctx.strokeStyle = signed ? "rgba(255,255,255,0.15)" : "rgba(255,255,255,0.08)";
    ctx.lineWidth = 0.5;
    if (signed) {
        // Draw zero line in the middle
        const zeroY = yOf(0);
        ctx.beginPath(); ctx.moveTo(ML, zeroY); ctx.lineTo(ML + plotW, zeroY); ctx.stroke();
    } else {
        ctx.beginPath(); ctx.moveTo(ML, MT + plotH); ctx.lineTo(ML + plotW, MT + plotH); ctx.stroke();
    }

    if (nFrames < 2) return;

    // Draw stat line
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.globalAlpha = 0.9;
    ctx.beginPath();
    for (let f = 0; f < nFrames; f++) {
        const bufIdx = (startIdx + f) % statsState.maxFrames;
        const x = xOf(f);
        const y = yOf(buf[bufIdx]);
        if (f === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1.0;

    // Current value label (top-right)
    const lastIdx = (startIdx + nFrames - 1) % statsState.maxFrames;
    const curVal = buf[lastIdx];
    ctx.fillStyle = color;
    ctx.font = "bold 7px system-ui";
    ctx.textAlign = "right";
    ctx.fillText(curVal < 100 ? curVal.toFixed(3) : curVal.toFixed(1), W - MR - 2, MT + 10);
}

function drawAllStatsPlots() {
    statsState.dirty = false;
    for (let i = 0; i < 16; i++) drawStatsPlot(i);
}

// --- Bitmap trail canvas ---

function fillPersistentBuffer(hexColor) {
    if (!bitmapPersistentBuffer) return;
    var data = bitmapPersistentBuffer.data;
    var r = parseInt(hexColor.slice(1, 3), 16);
    var g = parseInt(hexColor.slice(3, 5), 16);
    var b = parseInt(hexColor.slice(5, 7), 16);
    data[0] = r; data[1] = g; data[2] = b; data[3] = 255;
    var len = data.length, filled = 4;
    while (filled < len) {
        var chunk = Math.min(filled, len - filled);
        data.copyWithin(filled, 0, chunk);
        filled += chunk;
    }
}

function fillDisplayBuffer(hexColor) {
    if (!bitmapDisplayBuffer) return;
    var data = bitmapDisplayBuffer.data;
    var r = parseInt(hexColor.slice(1, 3), 16);
    var g = parseInt(hexColor.slice(3, 5), 16);
    var b = parseInt(hexColor.slice(5, 7), 16);
    data[0] = r; data[1] = g; data[2] = b; data[3] = 255;
    var len = data.length, filled = 4;
    while (filled < len) {
        var chunk = Math.min(filled, len - filled);
        data.copyWithin(filled, 0, chunk);
        filled += chunk;
    }
}

function exportPersistentBufferAsBMP(rgba, width, height, filename) {
    filename = filename || "polypaint.bmp";
    var bytesPerPixel = 3;
    var rowSize = (width * bytesPerPixel + 3) & ~3;
    var pixelBytes = rowSize * height;
    var fileHeaderSize = 14;
    var dibHeaderSize = 40;
    var offset = fileHeaderSize + dibHeaderSize;
    var fileSize = offset + pixelBytes;

    var header = new ArrayBuffer(offset);
    var dv = new DataView(header);
    // BITMAPFILEHEADER
    dv.setUint8(0, 0x42); dv.setUint8(1, 0x4D); // "BM"
    dv.setUint32(2, fileSize, true);
    dv.setUint16(6, 0, true); dv.setUint16(8, 0, true);
    dv.setUint32(10, offset, true);
    // BITMAPINFOHEADER
    dv.setUint32(14, dibHeaderSize, true);
    dv.setInt32(18, width, true);
    dv.setInt32(22, height, true);
    dv.setUint16(26, 1, true);       // color planes
    dv.setUint16(28, 24, true);      // bits per pixel
    dv.setUint32(30, 0, true);       // no compression
    dv.setUint32(34, pixelBytes, true);
    dv.setInt32(38, 2835, true); dv.setInt32(42, 2835, true); // 72 DPI
    dv.setUint32(46, 0, true); dv.setUint32(50, 0, true);

    var parts = [header];
    var TARGET_CHUNK_BYTES = 8 * 1024 * 1024;
    var rowsPerChunk = Math.max(1, Math.floor(TARGET_CHUNK_BYTES / rowSize));
    var pad = rowSize - width * bytesPerPixel;
    var padBytes = pad ? new Uint8Array(pad) : null;

    // BMP stores rows bottom-up
    for (var y0 = height - 1; y0 >= 0; y0 -= rowsPerChunk) {
        var y1 = Math.max(-1, y0 - rowsPerChunk);
        var rows = y0 - y1;
        var chunk = new Uint8Array(rows * rowSize);
        var woff = 0;
        for (var y = y0; y > y1; y--) {
            var roff = (y * width) * 4;
            for (var x = 0; x < width; x++) {
                chunk[woff]     = rgba[roff + 2]; // B
                chunk[woff + 1] = rgba[roff + 1]; // G
                chunk[woff + 2] = rgba[roff];     // R
                woff += 3; roff += 4;
            }
            if (padBytes) { chunk.set(padBytes, woff); woff += pad; }
        }
        parts.push(chunk);
    }

    var blob = new Blob(parts, { type: "image/bmp" });
    downloadBlob(blob, filename);
}

function downloadBlob(blob, filename) {
    var url = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.href = url; a.download = filename; a.click();
    setTimeout(function() { URL.revokeObjectURL(url); }, 10000);
}

function exportPersistentBufferAsJPEG(rgba, width, height, quality, filename) {
    filename = filename || "polypaint.jpg";
    var encoder = window["jpeg-js"] && window["jpeg-js"].encode;
    if (!encoder) { alert("jpeg-js library not loaded"); return; }
    var rawImageData = { data: rgba, width: width, height: height };
    var jpegData = encoder(rawImageData, quality);
    var blob = new Blob([jpegData.data], { type: "image/jpeg" });
    downloadBlob(blob, filename);
}

function exportPersistentBufferAsPNG(rgba, width, height, filename) {
    filename = filename || "polypaint.png";
    if (typeof UPNG === "undefined") { alert("UPNG.js library not loaded"); return; }
    var png = UPNG.encode([rgba.buffer], width, height, 0);
    var blob = new Blob([png], { type: "image/png" });
    downloadBlob(blob, filename);
}

function exportPersistentBufferAsTIFF(rgba, width, height, filename) {
    filename = filename || "polypaint.tiff";
    if (typeof UTIF === "undefined") { alert("UTIF.js library not loaded"); return; }
    var tiff = UTIF.encodeImage(rgba, width, height);
    var blob = new Blob([tiff], { type: "image/tiff" });
    downloadBlob(blob, filename);
}

function initBitmapCanvas() {
    const canvas = document.getElementById("bitmap-canvas");
    const res = parseInt(document.getElementById("bitmap-res-select").value, 10) || 2000;
    bitmapComputeRes = res;
    bitmapDisplayRes = Math.min(res, BITMAP_DISPLAY_CAP);

    // Canvas gets DISPLAY resolution (small GPU footprint)
    canvas.width = bitmapDisplayRes;
    canvas.height = bitmapDisplayRes;
    bitmapCtx = canvas.getContext("2d");
    bitmapCtx.fillStyle = bitmapCanvasColor;
    bitmapCtx.fillRect(0, 0, bitmapDisplayRes, bitmapDisplayRes);

    // Persistent buffer at COMPUTE resolution (CPU-only, no GPU)
    try {
        bitmapPersistentBuffer = new ImageData(bitmapComputeRes, bitmapComputeRes);
    } catch (e) {
        alert("Cannot allocate " + bitmapComputeRes + "px buffer (" +
              Math.round(bitmapComputeRes * bitmapComputeRes * 4 / 1e9 * 10) / 10 +
              " GB). Try a lower resolution.");
        bitmapPersistentBuffer = null;
        return;
    }
    fillPersistentBuffer(bitmapCanvasColor);

    // Display buffer only needed when split is active
    if (bitmapComputeRes > BITMAP_DISPLAY_CAP) {
        bitmapDisplayBuffer = new ImageData(bitmapDisplayRes, bitmapDisplayRes);
        fillDisplayBuffer(bitmapCanvasColor);
    } else {
        bitmapDisplayBuffer = null;
    }

    bitmapRange = panels.roots.range;
    bitmapRangeInitial = bitmapRange;
    updateBitmapZoomLabel();
    bitmapFrameCount = 0;
    fastModeElapsedOffset = 0;
    fastModePassCount = 0;
    fastModeWorkerRoots = null;
    // Clear jiggle state for a clean slate
    jiggleOffsets = null;
    jiggleStep = -1;
    jiggleWalkCache = null;
    bitmapActive = true;
}

// --- Fast mode: high-res bitmap rendering ---

function paintBitmapFrameFast() {
    if (!bitmapCtx || !bitmapRange) return;
    const w = bitmapCtx.canvas.width, h = bitmapCtx.canvas.height;
    const range = bitmapRange;
    const n = currentRoots.length;
    const colors = fastModeRootColors;
    const proxMode = bitmapColorMode === "proximity";
    const derivMode = bitmapColorMode === "derivative";
    const idxProxMode = bitmapColorMode === "idx-prox";
    const ratioMode = bitmapColorMode === "ratio";
    // Precompute derivative sensitivities if needed
    let derivSens = null;
    if (derivMode) {
        computeRootSensitivities();
        derivSens = rootSensitivities;
    }
    // Precompute proximity distances for this frame
    let proxDists = null, maxDists = null, proxMax = 1;
    if ((proxMode || idxProxMode || ratioMode) && n > 1) {
        proxDists = new Float64Array(n);
        if (ratioMode) maxDists = new Float64Array(n);
        for (let i = 0; i < n; i++) {
            let md = Infinity, mx = 0;
            for (let j = 0; j < n; j++) {
                if (j === i) continue;
                const dx = currentRoots[i].re - currentRoots[j].re;
                const dy = currentRoots[i].im - currentRoots[j].im;
                const d2 = dx * dx + dy * dy;
                if (d2 < md) md = d2;
                if (ratioMode && d2 > mx) mx = d2;
            }
            proxDists[i] = Math.sqrt(md);
            if (ratioMode) maxDists[i] = Math.sqrt(mx);
        }
        for (let i = 0; i < n; i++) if (proxDists[i] > proxMax) proxMax = proxDists[i];
    }
    for (let i = 0; i < n; i++) {
        const r = currentRoots[i];
        const px = (r.re / range + 1) * 0.5 * w;
        const py = (1 - r.im / range) * 0.5 * h;
        if (px < 0 || px >= w || py < 0 || py >= h) continue;
        if (derivMode && derivSens && i < derivSens.length) {
            const palIdx = Math.min(15, Math.round(derivSens[i] * 15));
            const c = DERIV_PALETTE[palIdx];
            bitmapCtx.fillStyle = `rgb(${c[0]},${c[1]},${c[2]})`;
        } else if (idxProxMode && proxDists) {
            const b = Math.pow(Math.min(1, proxDists[i] / proxMax), bitmapIdxProxGamma);
            const c = d3.color(colors[i]);
            bitmapCtx.fillStyle = `rgb(${(c.r*b)|0},${(c.g*b)|0},${(c.b*b)|0})`;
        } else if (proxMode && proxDists) {
            const t = 1 - Math.min(1, proxDists[i] / proxMax);
            const palIdx = (t * 15) | 0;
            const c = PROX_PALETTE[palIdx];
            bitmapCtx.fillStyle = `rgb(${c[0]},${c[1]},${c[2]})`;
        } else if (ratioMode && proxDists && maxDists) {
            const ratio = maxDists[i] > 0 ? Math.pow(proxDists[i] / maxDists[i], bitmapRatioGamma) : 0;
            const palIdx = Math.min(15, (ratio * 15 + 0.5) | 0);
            const c = PROX_PALETTE[palIdx];
            bitmapCtx.fillStyle = `rgb(${c[0]},${c[1]},${c[2]})`;
        } else {
            bitmapCtx.fillStyle = colors[i];
        }
        bitmapCtx.fillRect(px | 0, py | 0, 1, 1);
    }
    bitmapFrameCount++;
}

function setCurrentRootsInPlace(newRoots) {
    while (currentRoots.length < newRoots.length) currentRoots.push({ re: 0, im: 0 });
    currentRoots.length = newRoots.length;
    for (let i = 0; i < newRoots.length; i++) {
        currentRoots[i].re = newRoots[i].re;
        currentRoots[i].im = newRoots[i].im;
    }
}

// --- Web Worker fast mode ---

function createFastModeWorkerBlob() {
    const code = `'use strict';

// Flat-array Ehrlich-Aberth solver (same algorithm as main thread)
function solveEA(cRe, cIm, nCoeffs, warmRe, warmIm, nRoots) {
    var start = 0;
    while (start < nCoeffs - 1 && cRe[start]*cRe[start] + cIm[start]*cIm[start] < 1e-30) start++;
    var degree = nCoeffs - 1 - start;
    if (degree <= 0) return;
    if (degree === 1) {
        var aR = cRe[start], aI = cIm[start], bR = cRe[start+1], bI = cIm[start+1];
        var d = aR*aR + aI*aI;
        if (d < 1e-30) return;
        warmRe[0] = -(bR*aR + bI*aI) / d;
        warmIm[0] = -(bI*aR - bR*aI) / d;
        return;
    }
    var n = nCoeffs - start;
    var cr = new Float64Array(n), ci = new Float64Array(n);
    for (var k = 0; k < n; k++) { cr[k] = cRe[start+k]; ci[k] = cIm[start+k]; }
    var rRe = new Float64Array(degree), rIm = new Float64Array(degree);
    for (var i = 0; i < degree; i++) { rRe[i] = warmRe[i]; rIm[i] = warmIm[i]; }
    for (var iter = 0; iter < 64; iter++) {
        var maxCorr2 = 0;
        for (var i = 0; i < degree; i++) {
            var zR = rRe[i], zI = rIm[i];
            var pR = cr[0], pI = ci[0], dpR = 0, dpI = 0;
            for (var k = 1; k < n; k++) {
                var ndR = dpR*zR - dpI*zI + pR, ndI = dpR*zI + dpI*zR + pI;
                dpR = ndR; dpI = ndI;
                var npR = pR*zR - pI*zI + cr[k], npI = pR*zI + pI*zR + ci[k];
                pR = npR; pI = npI;
            }
            var dpM = dpR*dpR + dpI*dpI;
            if (dpM < 1e-60) continue;
            var wR = (pR*dpR + pI*dpI)/dpM, wI = (pI*dpR - pR*dpI)/dpM;
            var sR = 0, sI = 0;
            for (var j = 0; j < degree; j++) {
                if (j === i) continue;
                var dR = zR - rRe[j], dI = zI - rIm[j];
                var dM = dR*dR + dI*dI;
                if (dM < 1e-60) continue;
                sR += dR/dM; sI += -dI/dM;
            }
            var wsR = wR*sR - wI*sI, wsI = wR*sI + wI*sR;
            var dnR = 1 - wsR, dnI = -wsI;
            var dnM = dnR*dnR + dnI*dnI;
            if (dnM < 1e-60) continue;
            var crrR = (wR*dnR + wI*dnI)/dnM, crrI = (wI*dnR - wR*dnI)/dnM;
            rRe[i] -= crrR; rIm[i] -= crrI;
            var h2 = crrR*crrR + crrI*crrI;
            if (h2 > maxCorr2) maxCorr2 = h2;
        }
        if (maxCorr2 < 1e-16) break;
    }
    for (var i = 0; i < degree; i++) {
        if (isFinite(rRe[i]) && isFinite(rIm[i])) {
            warmRe[i] = rRe[i]; warmIm[i] = rIm[i];
        } else {
            // Rescue: re-seed non-finite root on unit circle so next call has valid warm-start
            var angle = (2 * Math.PI * i) / degree + 0.37;
            warmRe[i] = Math.cos(angle);
            warmIm[i] = Math.sin(angle);
        }
    }
}

function matchRoots(newRe, newIm, oldRe, oldIm, n) {
    var used = new Uint8Array(n);
    var tmpRe = new Float64Array(n), tmpIm = new Float64Array(n);
    for (var i = 0; i < n; i++) {
        var bestJ = 0, bestD = Infinity;
        for (var j = 0; j < n; j++) {
            if (used[j]) continue;
            var d = (newRe[j]-oldRe[i])*(newRe[j]-oldRe[i]) + (newIm[j]-oldIm[i])*(newIm[j]-oldIm[i]);
            if (d < bestD) { bestD = d; bestJ = j; }
        }
        tmpRe[i] = newRe[bestJ]; tmpIm[i] = newIm[bestJ];
        used[bestJ] = 1;
    }
    for (var i = 0; i < n; i++) { newRe[i] = tmpRe[i]; newIm[i] = tmpIm[i]; }
}

function hungarianMatch(newRe, newIm, oldRe, oldIm, n) {
    // Build nÃ—n squared-distance cost matrix
    var cost = new Float64Array(n * n);
    for (var i = 0; i < n; i++)
        for (var j = 0; j < n; j++) {
            var dr = newRe[j] - oldRe[i], di = newIm[j] - oldIm[i];
            cost[i * n + j] = dr * dr + di * di;
        }
    // Kuhn-Munkres O(nÂ³) â€” 1-indexed potentials
    var INF = 1e18;
    var u = new Float64Array(n + 1);
    var v = new Float64Array(n + 1);
    var p = new Int32Array(n + 1);   // p[j] = row assigned to col j
    var way = new Int32Array(n + 1);
    for (var i = 1; i <= n; i++) {
        p[0] = i;
        var j0 = 0;
        var minv = new Float64Array(n + 1);
        var used = new Uint8Array(n + 1);
        for (var jj = 0; jj <= n; jj++) { minv[jj] = INF; used[jj] = 0; }
        do {
            used[j0] = 1;
            var i0 = p[j0], delta = INF, j1 = -1;
            for (var j = 1; j <= n; j++) {
                if (used[j]) continue;
                var cur = cost[(i0 - 1) * n + (j - 1)] - u[i0] - v[j];
                if (cur < minv[j]) { minv[j] = cur; way[j] = j0; }
                if (minv[j] < delta) { delta = minv[j]; j1 = j; }
            }
            for (var j = 0; j <= n; j++) {
                if (used[j]) { u[p[j]] += delta; v[j] -= delta; }
                else { minv[j] -= delta; }
            }
            j0 = j1;
        } while (p[j0] !== 0);
        do { var jj = way[j0]; p[j0] = p[jj]; j0 = jj; } while (j0);
    }
    // Apply: p[j]=i means old root i-1 matched to new root j-1
    var tmpRe = new Float64Array(n), tmpIm = new Float64Array(n);
    for (var j = 1; j <= n; j++) {
        tmpRe[p[j] - 1] = newRe[j - 1];
        tmpIm[p[j] - 1] = newIm[j - 1];
    }
    for (var i = 0; i < n; i++) { newRe[i] = tmpRe[i]; newIm[i] = tmpIm[i]; }
}

function rankNorm(raw, n) {
    var maxFinite = -Infinity;
    for (var i = 0; i < n; i++)
        if (raw[i] === raw[i] && raw[i] !== Infinity && raw[i] !== -Infinity && raw[i] > maxFinite)
            maxFinite = raw[i];
    if (maxFinite === -Infinity) return null;
    var pairs = new Array(n);
    for (var i = 0; i < n; i++)
        pairs[i] = { v: (raw[i] === raw[i] && raw[i] !== Infinity && raw[i] !== -Infinity) ? raw[i] : maxFinite, i: i };
    pairs.sort(function(a, b) { return a.v - b.v; });
    var result = new Float64Array(n);
    var rank = 0;
    for (var p = 0; p < n; p++) {
        if (p > 0 && pairs[p].v !== pairs[p - 1].v) rank = p;
        result[pairs[p].i] = rank;
    }
    var maxRank = n - 1;
    if (maxRank === 0) { result.fill(0.5); return result; }
    for (var i = 0; i < n; i++) result[i] /= maxRank;
    return result;
}

function computeSens(coeffsRe, coeffsIm, nCoeffs, rootsRe, rootsIm, nRoots, selIndices) {
    var deg = nCoeffs - 1;
    var raw = new Float64Array(nRoots);
    for (var j = 0; j < nRoots; j++) {
        var zRe = rootsRe[j], zIm = rootsIm[j];
        var pRe = coeffsRe[0], pIm = coeffsIm[0];
        var dpRe = 0, dpIm = 0;
        for (var k = 1; k <= deg; k++) {
            var ndRe = dpRe * zRe - dpIm * zIm + pRe;
            var ndIm = dpRe * zIm + dpIm * zRe + pIm;
            dpRe = ndRe; dpIm = ndIm;
            var npRe = pRe * zRe - pIm * zIm + coeffsRe[k];
            var npIm = pRe * zIm + pIm * zRe + coeffsIm[k];
            pRe = npRe; pIm = npIm;
        }
        var dpMag2 = dpRe * dpRe + dpIm * dpIm;
        if (dpMag2 < 1e-60) { raw[j] = Infinity; continue; }
        var dpMag = Math.sqrt(dpMag2);
        var rMag = Math.sqrt(zRe * zRe + zIm * zIm);
        var sum = 0;
        for (var s = 0; s < selIndices.length; s++) {
            sum += Math.pow(rMag, deg - selIndices[s]);
        }
        raw[j] = sum / dpMag;
    }
    return rankNorm(raw, nRoots);
}

// --- WASM solver support (solver-only tier removed; step loop handles all) ---

// --- WASM step loop support ---
var S_useWasmLoop = false;
var wasmLoopExports = null;
var wasmLoopMemory = null;
var wasmLoopLayout = null;
var wasmLoopNRoots = 0;
var wasmLoopNCoeffs = 0;
var wasmLoopWorkerId = 0;
var wasmLoopTotalRunSteps = 0;

function wasmReportProgress(step) {
    self.postMessage({type: 'progress', workerId: wasmLoopWorkerId, step: step, total: wasmLoopTotalRunSteps});
}

function computeWasmLayout(nc, nr, maxP, nE, nDE, nFC, nSI, tCP, tDP, heapBase) {
    var o = heapBase || 65536;
    function a8(x) { return (x + 7) & ~7; }
    var L = {};
    L.cfgI = o; o = a8(o + 69 * 4);
    L.cfgD = o; o = a8(o + 7 * 8);
    L.cRe = o; o = a8(o + nc * 8);
    L.cIm = o; o = a8(o + nc * 8);
    L.clR = o; o = a8(o + nr);
    L.clG = o; o = a8(o + nr);
    L.clB = o; o = a8(o + nr);
    L.jRe = o; o = a8(o + nc * 8);
    L.jIm = o; o = a8(o + nc * 8);
    L.mTR = o; o = a8(o + nc * 8);
    L.mTI = o; o = a8(o + nc * 8);
    L.ppR = o; o = a8(o + 16);
    L.ppG = o; o = a8(o + 16);
    L.ppB = o; o = a8(o + 16);
    L.dpR = o; o = a8(o + 16);
    L.dpG = o; o = a8(o + 16);
    L.dpB = o; o = a8(o + 16);
    L.sI = o; o = a8(o + Math.max(nSI, 1) * 4);
    L.fCI = o; o = a8(o + Math.max(nFC, 1) * 4);
    L.eIdx = o; o = a8(o + Math.max(nE, 1) * 4);
    L.eSpd = o; o = a8(o + Math.max(nE, 1) * 8);
    L.eCcw = o; o = a8(o + Math.max(nE, 1) * 4);
    L.eDth = o; o = a8(o + Math.max(nE, 1) * 8);
    L.eDd = o; o = a8(o + Math.max(nE, 1) * 4);
    L.cOff = o; o = a8(o + Math.max(nE, 1) * 4);
    L.cLen = o; o = a8(o + Math.max(nE, 1) * 4);
    L.cCld = o; o = a8(o + Math.max(nE, 1) * 4);
    L.dIdx = o; o = a8(o + Math.max(nDE, 1) * 4);
    L.dSpd = o; o = a8(o + Math.max(nDE, 1) * 8);
    L.dCcw = o; o = a8(o + Math.max(nDE, 1) * 4);
    L.dDth = o; o = a8(o + Math.max(nDE, 1) * 8);
    L.dDd = o; o = a8(o + Math.max(nDE, 1) * 4);
    L.dOff = o; o = a8(o + Math.max(nDE, 1) * 4);
    L.dLen = o; o = a8(o + Math.max(nDE, 1) * 4);
    L.dCld = o; o = a8(o + Math.max(nDE, 1) * 4);
    L.cvF = o; o = a8(o + Math.max(tCP, 1) * 2 * 8);
    L.dcF = o; o = a8(o + Math.max(tDP, 1) * 2 * 8);
    L.wCR = o; o = a8(o + nc * 8);
    L.wCI = o; o = a8(o + nc * 8);
    L.tRe = o; o = a8(o + nr * 8);
    L.tIm = o; o = a8(o + nr * 8);
    L.mWR = o; o = a8(o + nc * 8);
    L.mWI = o; o = a8(o + nc * 8);
    L.pRR = o; o = a8(o + nr * 8);
    L.pRI = o; o = a8(o + nr * 8);
    L.piO = o; o = a8(o + maxP * 4);
    L.prO = o; o = a8(o + maxP);
    L.pgO = o; o = a8(o + maxP);
    L.pbO = o; o = a8(o + maxP);
    L.pages = Math.ceil(o / 65536);
    return L;
}

function initWasmStepLoop(d) {
    var nc = d.nCoeffs, nr = d.nRoots;
    var entries = d.animEntries || [];
    var dEntries = d.dAnimEntries || [];
    var followC = d.dFollowCIndices || [];
    var selIdx = d.selectedCoeffIndices || [];
    var tCP = d.totalCPts || 0;
    var tDP = d.totalDPts || 0;
    var maxP = d.maxPaintsPerWorker || (d.totalSteps * nr);

    var raw = atob(d.wasmStepLoopB64);
    var bytes = new Uint8Array(raw.length);
    for (var i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i);
    var mod = new WebAssembly.Module(bytes.buffer);

    /* Instantiate with small memory first to read __heap_base */
    wasmLoopMemory = new WebAssembly.Memory({initial: 2});
    var inst = new WebAssembly.Instance(mod, {
        env: {
            memory: wasmLoopMemory,
            cos: Math.cos,
            sin: Math.sin,
            log: Math.log,
            reportProgress: wasmReportProgress
        }
    });
    wasmLoopExports = inst.exports;

    /* Read __heap_base â€” this is where C's BSS ends and free memory begins */
    var heapBase = 65536;
    if (wasmLoopExports.__heap_base) heapBase = wasmLoopExports.__heap_base.value;

    var L = computeWasmLayout(nc, nr, maxP, entries.length, dEntries.length, followC.length, selIdx.length, tCP, tDP, heapBase);

    /* Grow memory to fit the full layout */
    var curPages = wasmLoopMemory.buffer.byteLength / 65536;
    if (L.pages > curPages) wasmLoopMemory.grow(L.pages - curPages);
    var buf = wasmLoopMemory.buffer;

    var colorMode = 1;
    if (d.noColor) colorMode = 0;
    else if (d.proxColor) colorMode = 2;
    else if (d.derivColor) colorMode = 3;

    var ms = 0;
    var msStr = d.matchStrategy || "assign4";
    if (msStr === "assign1") ms = 1;
    else if (msStr === "hungarian1") ms = 2;

    var cfgI32 = new Int32Array(buf, L.cfgI, 67);
    cfgI32[0] = nc; cfgI32[1] = nr;
    cfgI32[2] = d.canvasW; cfgI32[3] = d.canvasH;
    cfgI32[4] = d.totalSteps; cfgI32[5] = colorMode; cfgI32[6] = ms;
    cfgI32[7] = d.morphEnabled ? 1 : 0;
    cfgI32[8] = entries.length; cfgI32[9] = dEntries.length;
    cfgI32[10] = followC.length; cfgI32[11] = selIdx.length;
    cfgI32[12] = (d.jiggleRe && d.jiggleIm) ? 1 : 0;
    cfgI32[13] = d.uniformR || 255; cfgI32[14] = d.uniformG || 255; cfgI32[15] = d.uniformB || 255;
    cfgI32[16] = (Math.random() * 0xFFFFFFFF) >>> 0;
    cfgI32[17] = (Math.random() * 0xFFFFFFFF) >>> 0;
    cfgI32[18] = (Math.random() * 0xFFFFFFFF) >>> 0;
    cfgI32[19] = (Math.random() * 0xFFFFFFFF) >>> 0;
    cfgI32[20] = L.cRe; cfgI32[21] = L.cIm;
    cfgI32[22] = L.clR; cfgI32[23] = L.clG; cfgI32[24] = L.clB;
    cfgI32[25] = L.jRe; cfgI32[26] = L.jIm;
    cfgI32[27] = L.mTR; cfgI32[28] = L.mTI;
    cfgI32[29] = L.ppR; cfgI32[30] = L.ppG; cfgI32[31] = L.ppB;
    cfgI32[32] = L.dpR; cfgI32[33] = L.dpG; cfgI32[34] = L.dpB;
    cfgI32[35] = L.sI; cfgI32[36] = L.fCI;
    cfgI32[37] = L.eIdx; cfgI32[38] = L.eSpd; cfgI32[39] = L.eCcw; cfgI32[40] = L.eDth;
    cfgI32[41] = L.cOff; cfgI32[42] = L.cLen; cfgI32[43] = L.cCld;
    cfgI32[44] = L.dIdx; cfgI32[45] = L.dSpd; cfgI32[46] = L.dCcw; cfgI32[47] = L.dDth;
    cfgI32[48] = L.dOff; cfgI32[49] = L.dLen; cfgI32[50] = L.dCld;
    cfgI32[51] = L.cvF; cfgI32[52] = L.dcF;
    cfgI32[53] = L.wCR; cfgI32[54] = L.wCI;
    cfgI32[55] = L.tRe; cfgI32[56] = L.tIm;
    cfgI32[57] = L.mWR; cfgI32[58] = L.mWI;
    cfgI32[59] = L.pRR; cfgI32[60] = L.pRI;
    cfgI32[61] = L.piO; cfgI32[62] = L.prO; cfgI32[63] = L.pgO; cfgI32[64] = L.pbO;
    cfgI32[65] = ["line","circle","ellipse","figure8"].indexOf(d.morphPathType || "line");
    cfgI32[66] = d.morphPathCcw ? 1 : 0;
    cfgI32[67] = L.eDd; cfgI32[68] = L.dDd;

    var cfgF64 = new Float64Array(buf, L.cfgD, 7);
    cfgF64[0] = d.bitmapRange; cfgF64[1] = d.FAST_PASS_SECONDS; cfgF64[2] = d.morphRate || 0;
    cfgF64[3] = d.morphEllipseMinor ?? 0.5; cfgF64[4] = d.morphDitherStartAbs || 0; cfgF64[5] = d.morphDitherMidAbs || 0; cfgF64[6] = d.morphDitherEndAbs || 0;

    new Float64Array(buf, L.cRe, nc).set(new Float64Array(d.coeffsRe));
    new Float64Array(buf, L.cIm, nc).set(new Float64Array(d.coeffsIm));
    new Uint8Array(buf, L.clR, nr).set(new Uint8Array(d.colorsR));
    new Uint8Array(buf, L.clG, nr).set(new Uint8Array(d.colorsG));
    new Uint8Array(buf, L.clB, nr).set(new Uint8Array(d.colorsB));
    if (d.jiggleRe) new Float64Array(buf, L.jRe, nc).set(new Float64Array(d.jiggleRe));
    if (d.jiggleIm) new Float64Array(buf, L.jIm, nc).set(new Float64Array(d.jiggleIm));
    if (d.morphTargetRe) {
        new Float64Array(buf, L.mTR, nc).set(new Float64Array(d.morphTargetRe));
        new Float64Array(buf, L.mTI, nc).set(new Float64Array(d.morphTargetIm));
        new Float64Array(buf, L.mWR, nc).set(new Float64Array(d.morphTargetRe));
        new Float64Array(buf, L.mWI, nc).set(new Float64Array(d.morphTargetIm));
    }
    if (d.proxPalR) new Uint8Array(buf, L.ppR, 16).set(new Uint8Array(d.proxPalR));
    if (d.proxPalG) new Uint8Array(buf, L.ppG, 16).set(new Uint8Array(d.proxPalG));
    if (d.proxPalB) new Uint8Array(buf, L.ppB, 16).set(new Uint8Array(d.proxPalB));
    if (d.derivPalR) new Uint8Array(buf, L.dpR, 16).set(new Uint8Array(d.derivPalR));
    if (d.derivPalG) new Uint8Array(buf, L.dpG, 16).set(new Uint8Array(d.derivPalG));
    if (d.derivPalB) new Uint8Array(buf, L.dpB, 16).set(new Uint8Array(d.derivPalB));
    if (selIdx.length > 0) new Int32Array(buf, L.sI, selIdx.length).set(selIdx);
    if (followC.length > 0) new Int32Array(buf, L.fCI, followC.length).set(followC);

    if (entries.length > 0) {
        var eI = new Int32Array(buf, L.eIdx, entries.length);
        var eS = new Float64Array(buf, L.eSpd, entries.length);
        var eC = new Int32Array(buf, L.eCcw, entries.length);
        var eD = new Float64Array(buf, L.eDth, entries.length);
        var eDd = new Int32Array(buf, L.eDd, entries.length);
        var cO = new Int32Array(buf, L.cOff, entries.length);
        var cL = new Int32Array(buf, L.cLen, entries.length);
        var cC = new Int32Array(buf, L.cCld, entries.length);
        for (var i = 0; i < entries.length; i++) {
            eI[i] = entries[i].idx; eS[i] = entries[i].speed;
            eC[i] = entries[i].ccw ? 1 : 0; eD[i] = entries[i].ditherSigma || 0;
            eDd[i] = entries[i].ditherDist || 0;
            cO[i] = d.curveOffsets[i]; cL[i] = d.curveLengths[i]; cC[i] = d.curveIsCloud[i] ? 1 : 0;
        }
    }
    if (dEntries.length > 0) {
        var dI = new Int32Array(buf, L.dIdx, dEntries.length);
        var dS = new Float64Array(buf, L.dSpd, dEntries.length);
        var dC2 = new Int32Array(buf, L.dCcw, dEntries.length);
        var dD = new Float64Array(buf, L.dDth, dEntries.length);
        var dDd = new Int32Array(buf, L.dDd, dEntries.length);
        var dO = new Int32Array(buf, L.dOff, dEntries.length);
        var dL = new Int32Array(buf, L.dLen, dEntries.length);
        var dCl = new Int32Array(buf, L.dCld, dEntries.length);
        for (var i = 0; i < dEntries.length; i++) {
            dI[i] = dEntries[i].idx; dS[i] = dEntries[i].speed;
            dC2[i] = dEntries[i].ccw ? 1 : 0; dD[i] = dEntries[i].ditherSigma || 0;
            dDd[i] = dEntries[i].ditherDist || 0;
            dO[i] = d.dCurveOffsets[i]; dL[i] = d.dCurveLengths[i]; dCl[i] = d.dCurveIsCloud[i] ? 1 : 0;
        }
    }
    if (tCP > 0) new Float64Array(buf, L.cvF, tCP * 2).set(new Float64Array(d.curvesFlat));
    if (tDP > 0 && d.dCurvesFlat) new Float64Array(buf, L.dcF, tDP * 2).set(new Float64Array(d.dCurvesFlat));

    new Float64Array(buf, L.wCR, nc).set(new Float64Array(d.coeffsRe));
    new Float64Array(buf, L.wCI, nc).set(new Float64Array(d.coeffsIm));

    wasmLoopExports.init(L.cfgI, L.cfgD);
    wasmLoopLayout = L;
    wasmLoopNRoots = nr;
    wasmLoopNCoeffs = nc;
}

function wGaussRand() {
    var u, v;
    do { u = Math.random(); } while (u === 0);
    v = Math.random();
    return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}
function wDitherRand(dist) {
    return dist ? (Math.random() - 0.5) * 2 : wGaussRand();
}

// --- Persistent worker state (set by "init", reused across "run" calls) ---
var S_coeffsRe, S_coeffsIm, S_nCoeffs, S_degree, S_nRoots;
var S_colorsR, S_colorsG, S_colorsB;
var S_W, S_H, S_range;
var S_curvesFlat, S_entries, S_offsets, S_lengths, S_isCloud;
var S_noColor, S_uniformR, S_uniformG, S_uniformB;
var S_totalSteps, S_FPS;
var S_proxColor, S_proxPalR, S_proxPalG, S_proxPalB;
var S_derivColor, S_derivPalR, S_derivPalG, S_derivPalB, S_selIndices;
var S_idxProxColor = false, S_idxProxGamma = 0.5, S_ratioColor = false, S_ratioGamma = 0.5;
var S_morphEnabled = false, S_morphRate = 0, S_morphTargetRe = null, S_morphTargetIm = null;
var S_morphPathType = "line", S_morphPathCcw = false, S_morphEllipseMinor = 0.5, S_morphDitherStartAbs = 0, S_morphDitherMidAbs = 0, S_morphDitherEndAbs = 0;
var S_matchStrategy = "assign4";

// Worker-side morph interpolation (mirrors main-thread morphInterpPoint)
function morphInterpW(cRe, cIm, dRe, dIm, theta) {
    var dx = dRe - cRe, dy = dIm - cIm;
    var len = Math.sqrt(dx * dx + dy * dy);
    if (len < 1e-15) return [cRe, cIm];
    if (S_morphPathType === "line") {
        var mu = 0.5 - 0.5 * Math.cos(theta);
        return [cRe * (1 - mu) + dRe * mu, cIm * (1 - mu) + dIm * mu];
    }
    var ux = dx / len, uy = dy / len;
    var vx = -uy, vy = ux;
    var midRe = (cRe + dRe) * 0.5, midIm = (cIm + dIm) * 0.5;
    var semi = len * 0.5;
    var sign = S_morphPathCcw ? 1 : -1;
    var lx, ly;
    if (S_morphPathType === "circle") {
        lx = -semi * Math.cos(theta); ly = sign * semi * Math.sin(theta);
    } else if (S_morphPathType === "ellipse") {
        lx = -semi * Math.cos(theta); ly = sign * (S_morphEllipseMinor * semi) * Math.sin(theta);
    } else { // figure8
        lx = -semi * Math.cos(theta); ly = sign * (semi * 0.5) * Math.sin(2 * theta);
    }
    return [midRe + lx * ux + ly * vx, midIm + lx * uy + ly * vy];
}
var S_dCurvesFlat = null, S_dEntries = null, S_dOffsets = null, S_dLengths = null, S_dIsCloud = null;
var S_dFollowC = null;
var S_jiggleRe = null, S_jiggleIm = null;

self.onmessage = function(e) {
    var d = e.data;

    if (d.type === "init") {
        S_coeffsRe = new Float64Array(d.coeffsRe);
        S_coeffsIm = new Float64Array(d.coeffsIm);
        S_nCoeffs = d.nCoeffs; S_degree = d.degree; S_nRoots = d.nRoots;
        S_colorsR = new Uint8Array(d.colorsR);
        S_colorsG = new Uint8Array(d.colorsG);
        S_colorsB = new Uint8Array(d.colorsB);
        S_W = d.canvasW; S_H = d.canvasH; S_range = d.bitmapRange;
        S_curvesFlat = new Float64Array(d.curvesFlat);
        S_entries = d.animEntries;
        S_offsets = d.curveOffsets; S_lengths = d.curveLengths; S_isCloud = d.curveIsCloud;
        S_noColor = !!d.noColor;
        S_proxColor = !!d.proxColor;
        S_proxPalR = d.proxPalR ? new Uint8Array(d.proxPalR) : null;
        S_proxPalG = d.proxPalG ? new Uint8Array(d.proxPalG) : null;
        S_proxPalB = d.proxPalB ? new Uint8Array(d.proxPalB) : null;
        S_derivColor = !!d.derivColor;
        S_derivPalR = d.derivPalR ? new Uint8Array(d.derivPalR) : null;
        S_derivPalG = d.derivPalG ? new Uint8Array(d.derivPalG) : null;
        S_derivPalB = d.derivPalB ? new Uint8Array(d.derivPalB) : null;
        S_selIndices = d.selectedCoeffIndices || null;
        S_idxProxColor = !!d.idxProxColor;
        S_idxProxGamma = d.idxProxGamma || 0.5;
        S_ratioColor = !!d.ratioColor;
        S_ratioGamma = d.ratioGamma || 0.5;
        S_uniformR = d.uniformR || 255; S_uniformG = d.uniformG || 255; S_uniformB = d.uniformB || 255;
        S_totalSteps = d.totalSteps; S_FPS = d.FAST_PASS_SECONDS;
        // WASM init: try full step loop, else pure JS
        S_useWasmLoop = false;
        if (d.useWasm && d.wasmStepLoopB64) {
            try { initWasmStepLoop(d); S_useWasmLoop = true; } catch(e) { S_useWasmLoop = false; }
        }
        // Force JS step loop for modes not supported by WASM step_loop.c
        if (S_useWasmLoop && (S_idxProxColor || S_ratioColor)) S_useWasmLoop = false;
        // Morph init
        S_morphEnabled = !!d.morphEnabled;
        S_morphRate = d.morphRate || 0;
        S_morphTargetRe = d.morphTargetRe ? new Float64Array(d.morphTargetRe) : null;
        S_morphTargetIm = d.morphTargetIm ? new Float64Array(d.morphTargetIm) : null;
        S_morphPathType = d.morphPathType || "line";
        S_morphPathCcw = !!d.morphPathCcw;
        S_morphEllipseMinor = d.morphEllipseMinor ?? 0.5;
        S_morphDitherStartAbs = d.morphDitherStartAbs || 0;
        S_morphDitherMidAbs = d.morphDitherMidAbs || 0;
        S_morphDitherEndAbs = d.morphDitherEndAbs || 0;
        // WASM step loop now supports all morph path types (line, circle, ellipse, figure-8)
        S_matchStrategy = d.matchStrategy || "assign4";
        // D-curve init (animated morph targets)
        S_dEntries = d.dAnimEntries || [];
        S_dCurvesFlat = d.dCurvesFlat ? new Float64Array(d.dCurvesFlat) : null;
        S_dOffsets = d.dCurveOffsets || [];
        S_dLengths = d.dCurveLengths || [];
        S_dIsCloud = d.dCurveIsCloud || [];
        S_dFollowC = d.dFollowCIndices || [];
        // Jiggle offsets (applied post-interpolation)
        S_jiggleRe = d.jiggleRe ? new Float64Array(d.jiggleRe) : null;
        S_jiggleIm = d.jiggleIm ? new Float64Array(d.jiggleIm) : null;
        return;
    }

    if (d.type !== "run") return;

    // --- WASM step loop fast path ---
    if (S_useWasmLoop && wasmLoopExports) {
        var stepStart = d.stepStart, stepEnd = d.stepEnd, workerId = d.workerId;
        var elapsedOff = d.elapsedOffset || 0;
        var nr = wasmLoopNRoots;
        var L = wasmLoopLayout;
        var buf = wasmLoopMemory.buffer;

        wasmLoopWorkerId = workerId;
        wasmLoopTotalRunSteps = stepEnd - stepStart;

        new Float64Array(buf, L.pRR, nr).set(new Float64Array(d.rootsRe));
        new Float64Array(buf, L.pRI, nr).set(new Float64Array(d.rootsIm));

        var pc;
        try {
            pc = wasmLoopExports.runStepLoop(stepStart, stepEnd, elapsedOff);
        } catch(wasmErr) {
            self.postMessage({type: 'error', workerId: workerId, error: String(wasmErr)});
            S_useWasmLoop = false;
            return;
        }

        var paintIdx = new Int32Array(buf, L.piO, pc).slice();
        var paintR = new Uint8Array(buf, L.prO, pc).slice();
        var paintG = new Uint8Array(buf, L.pgO, pc).slice();
        var paintB = new Uint8Array(buf, L.pbO, pc).slice();
        var rootsReFinal = new Float64Array(buf, L.pRR, nr).slice();
        var rootsImFinal = new Float64Array(buf, L.pRI, nr).slice();

        self.postMessage({
            type: 'done', workerId: workerId,
            paintIdx: paintIdx.buffer, paintR: paintR.buffer,
            paintG: paintG.buffer, paintB: paintB.buffer,
            paintCount: pc,
            rootsRe: rootsReFinal.buffer, rootsIm: rootsImFinal.buffer
        }, [paintIdx.buffer, paintR.buffer, paintG.buffer, paintB.buffer]);
        return;
    }

    // --- JS step loop fallback ---
    var stepStart = d.stepStart, stepEnd = d.stepEnd, workerId = d.workerId;
    var elapsedOff = d.elapsedOffset || 0;
    var rootsRe = new Float64Array(d.rootsRe);
    var rootsIm = new Float64Array(d.rootsIm);

    // Copy base coefficients (mutated during interpolation each step)
    var coeffsRe = new Float64Array(S_coeffsRe);
    var coeffsIm = new Float64Array(S_coeffsIm);
    var nCoeffs = S_nCoeffs, nRoots = S_nRoots;
    var W = S_W, H = S_H, range = S_range;
    var entries = S_entries, offsets = S_offsets, lengths = S_lengths, isCloud = S_isCloud;
    var curvesFlat = S_curvesFlat;
    var total = S_totalSteps, FPS = S_FPS;
    var noColor = S_noColor;
    var proxColor = S_proxColor;
    var idxProxColor = S_idxProxColor;
    var idxProxGamma = S_idxProxGamma;
    var ratioColor = S_ratioColor;
    var ratioGamma = S_ratioGamma;
    var proxPalR = S_proxPalR, proxPalG = S_proxPalG, proxPalB = S_proxPalB;
    var derivColor = S_derivColor;
    var derivPalR = S_derivPalR, derivPalG = S_derivPalG, derivPalB = S_derivPalB;
    var selIndices = S_selIndices;
    var colorsR = S_colorsR, colorsG = S_colorsG, colorsB = S_colorsB;
    var uniformR = S_uniformR, uniformG = S_uniformG, uniformB = S_uniformB;
    // D-curve locals (animated morph targets)
    var dEntries = S_dEntries, dOffsets = S_dOffsets, dLengths = S_dLengths, dIsCloud = S_dIsCloud;
    var dCurvesFlat = S_dCurvesFlat;
    var dFollowC = S_dFollowC;
    // Pre-allocate morph target arrays (copy base, overwrite animated D each step)
    var morphRe = S_morphTargetRe ? new Float64Array(S_morphTargetRe) : null;
    var morphIm = S_morphTargetIm ? new Float64Array(S_morphTargetIm) : null;

    // Sparse pixel accumulation (avoids W*H*4 buffer per worker)
    var maxPaints = (stepEnd - stepStart) * nRoots;
    var paintIdx = new Int32Array(maxPaints);
    var paintR = new Uint8Array(maxPaints);
    var paintG = new Uint8Array(maxPaints);
    var paintB = new Uint8Array(maxPaints);
    var pc = 0;

    var tmpRe = new Float64Array(nRoots), tmpIm = new Float64Array(nRoots);
    var minDists = (proxColor || idxProxColor || ratioColor) ? new Float64Array(nRoots) : null;
    var maxDists = ratioColor ? new Float64Array(nRoots) : null;
    var proxRunMax = 1;

    for (var step = stepStart; step < stepEnd; step++) {
        var elapsed = elapsedOff + (step / total) * FPS;

        // Reset non-animated coefficients to base values before jiggle
        if (S_jiggleRe) {
            coeffsRe.set(S_coeffsRe);
            coeffsIm.set(S_coeffsIm);
        }

        for (var a = 0; a < entries.length; a++) {
            var idx = entries[a].idx;
            var dir = entries[a].ccw ? -1 : 1;
            var t = elapsed * entries[a].speed * dir;
            var u = ((t % 1) + 1) % 1;
            var N = lengths[a];
            var rawIdx = u * N;
            var base = offsets[a] * 2;

            if (isCloud[a]) {
                var k = (rawIdx | 0) % N;
                coeffsRe[idx] = curvesFlat[base + k*2];
                coeffsIm[idx] = curvesFlat[base + k*2 + 1];
            } else {
                var lo = (rawIdx | 0) % N;
                var hi = (lo + 1) % N;
                var frac = rawIdx - (rawIdx | 0);
                coeffsRe[idx] = curvesFlat[base+lo*2]*(1-frac) + curvesFlat[base+hi*2]*frac;
                coeffsIm[idx] = curvesFlat[base+lo*2+1]*(1-frac) + curvesFlat[base+hi*2+1]*frac;
            }
            if (entries[a].ditherSigma) {
                coeffsRe[idx] += wDitherRand(entries[a].ditherDist) * entries[a].ditherSigma;
                coeffsIm[idx] += wDitherRand(entries[a].ditherDist) * entries[a].ditherSigma;
            }
        }

        // Advance animated D-nodes along D-curves
        if (dEntries && dEntries.length > 0 && dCurvesFlat) {
            for (var da = 0; da < dEntries.length; da++) {
                var dIdx = dEntries[da].idx;
                var dDir = dEntries[da].ccw ? -1 : 1;
                var dT = elapsed * dEntries[da].speed * dDir;
                var dU = ((dT % 1) + 1) % 1;
                var dN = dLengths[da];
                var dRawIdx = dU * dN;
                var dBase = dOffsets[da] * 2;

                if (dIsCloud[da]) {
                    var dK = (dRawIdx | 0) % dN;
                    morphRe[dIdx] = dCurvesFlat[dBase + dK*2];
                    morphIm[dIdx] = dCurvesFlat[dBase + dK*2 + 1];
                } else {
                    var dLo = (dRawIdx | 0) % dN;
                    var dHi = (dLo + 1) % dN;
                    var dFrac = dRawIdx - (dRawIdx | 0);
                    morphRe[dIdx] = dCurvesFlat[dBase+dLo*2]*(1-dFrac) + dCurvesFlat[dBase+dHi*2]*dFrac;
                    morphIm[dIdx] = dCurvesFlat[dBase+dLo*2+1]*(1-dFrac) + dCurvesFlat[dBase+dHi*2+1]*dFrac;
                }
                if (dEntries[da].ditherSigma) {
                    morphRe[dIdx] += wDitherRand(dEntries[da].ditherDist) * dEntries[da].ditherSigma;
                    morphIm[dIdx] += wDitherRand(dEntries[da].ditherDist) * dEntries[da].ditherSigma;
                }
            }
        }

        // Follow-C: D-nodes that mirror current C-node position
        if (dFollowC && dFollowC.length > 0 && morphRe) {
            for (var fc = 0; fc < dFollowC.length; fc++) {
                var fci = dFollowC[fc];
                morphRe[fci] = coeffsRe[fci];
                morphIm[fci] = coeffsIm[fci];
            }
        }

        if (S_morphEnabled) {
            var theta = 2 * Math.PI * S_morphRate * elapsed;
            for (var m = 0; m < nCoeffs; m++) {
                var mp = morphInterpW(coeffsRe[m], coeffsIm[m], morphRe[m], morphIm[m], theta);
                coeffsRe[m] = mp[0]; coeffsIm[m] = mp[1];
            }
            if (S_morphDitherStartAbs > 0 || S_morphDitherMidAbs > 0 || S_morphDitherEndAbs > 0) {
                var sinT = Math.sin(theta), cosT = Math.cos(theta);
                var startEnv = cosT > 0 ? cosT * cosT : 0;
                var endEnv = cosT < 0 ? cosT * cosT : 0;
                var mds = S_morphDitherStartAbs * startEnv + S_morphDitherMidAbs * sinT * sinT + S_morphDitherEndAbs * endEnv;
                if (mds > 0) for (var md = 0; md < nCoeffs; md++) {
                    coeffsRe[md] += (Math.random() - 0.5) * 2 * mds;
                    coeffsIm[md] += (Math.random() - 0.5) * 2 * mds;
                }
            }
        }

        // Apply jiggle offsets post-interpolation
        if (S_jiggleRe) {
            for (var j = 0; j < nCoeffs; j++) {
                coeffsRe[j] += S_jiggleRe[j];
                coeffsIm[j] += S_jiggleIm[j];
            }
        }

        tmpRe.set(rootsRe); tmpIm.set(rootsIm);
        solveEA(coeffsRe, coeffsIm, nCoeffs, tmpRe, tmpIm, nRoots);

        if (derivColor) {
            // Root matching every 4th step for stable identity
            if ((step - stepStart) % 4 === 0) {
                matchRoots(tmpRe, tmpIm, rootsRe, rootsIm, nRoots);
            }
            var sens = computeSens(coeffsRe, coeffsIm, nCoeffs, tmpRe, tmpIm, nRoots, selIndices);
            rootsRe.set(tmpRe); rootsIm.set(tmpIm);
            if (sens) {
                for (var i = 0; i < nRoots; i++) {
                    var ix = ((rootsRe[i] / range + 1) * 0.5 * W) | 0;
                    var iy = ((1 - rootsIm[i] / range) * 0.5 * H) | 0;
                    if (ix < 0 || ix >= W || iy < 0 || iy >= H) continue;
                    var palIdx = (sens[i] * 15 + 0.5) | 0;
                    if (palIdx > 15) palIdx = 15;
                    paintIdx[pc] = iy * W + ix;
                    paintR[pc] = derivPalR[palIdx]; paintG[pc] = derivPalG[palIdx]; paintB[pc] = derivPalB[palIdx];
                    pc++;
                }
            }
        } else if (idxProxColor) {
            // Root matching (same strategies as rainbow)
            var ms = S_matchStrategy;
            if (ms === "hungarian1") hungarianMatch(tmpRe, tmpIm, rootsRe, rootsIm, nRoots);
            else if (ms === "assign1") matchRoots(tmpRe, tmpIm, rootsRe, rootsIm, nRoots);
            else { if ((step - stepStart) % 4 === 0) matchRoots(tmpRe, tmpIm, rootsRe, rootsIm, nRoots); }
            // Min distances
            for (var i = 0; i < nRoots; i++) {
                var md = Infinity;
                for (var j = 0; j < nRoots; j++) {
                    if (j === i) continue;
                    var dx = tmpRe[i] - tmpRe[j], dy = tmpIm[i] - tmpIm[j];
                    var d2 = dx * dx + dy * dy;
                    if (d2 < md) md = d2;
                }
                minDists[i] = Math.sqrt(md);
            }
            for (var i = 0; i < nRoots; i++) if (minDists[i] > proxRunMax) proxRunMax = minDists[i];
            proxRunMax *= 0.999;
            rootsRe.set(tmpRe); rootsIm.set(tmpIm);
            for (var i = 0; i < nRoots; i++) {
                var ix = ((rootsRe[i] / range + 1) * 0.5 * W) | 0;
                var iy = ((1 - rootsIm[i] / range) * 0.5 * H) | 0;
                if (ix < 0 || ix >= W || iy < 0 || iy >= H) continue;
                var b = Math.pow(Math.min(1, minDists[i] / proxRunMax), idxProxGamma);
                paintIdx[pc] = iy * W + ix;
                paintR[pc] = (colorsR[i] * b) | 0;
                paintG[pc] = (colorsG[i] * b) | 0;
                paintB[pc] = (colorsB[i] * b) | 0;
                pc++;
            }
        } else if (proxColor) {
            // Compute per-root minimum distance to nearest neighbor
            for (var i = 0; i < nRoots; i++) {
                var md = Infinity;
                for (var j = 0; j < nRoots; j++) {
                    if (j === i) continue;
                    var dx = tmpRe[i] - tmpRe[j], dy = tmpIm[i] - tmpIm[j];
                    var d2 = dx * dx + dy * dy;
                    if (d2 < md) md = d2;
                }
                minDists[i] = Math.sqrt(md);
            }
            // Update running max with slow decay for adaptive normalization
            for (var i = 0; i < nRoots; i++) {
                if (minDists[i] > proxRunMax) proxRunMax = minDists[i];
            }
            proxRunMax *= 0.999;
            rootsRe.set(tmpRe); rootsIm.set(tmpIm);
            for (var i = 0; i < nRoots; i++) {
                var ix = ((rootsRe[i] / range + 1) * 0.5 * W) | 0;
                var iy = ((1 - rootsIm[i] / range) * 0.5 * H) | 0;
                if (ix < 0 || ix >= W || iy < 0 || iy >= H) continue;
                var t = 1 - Math.min(1, minDists[i] / proxRunMax);
                var palIdx = (t * 15) | 0;
                paintIdx[pc] = iy * W + ix;
                paintR[pc] = proxPalR[palIdx]; paintG[pc] = proxPalG[palIdx]; paintB[pc] = proxPalB[palIdx];
                pc++;
            }
        } else if (ratioColor) {
            // Min AND max distances in a single O(n^2) pass
            for (var i = 0; i < nRoots; i++) {
                var mn = Infinity, mx = 0;
                for (var j = 0; j < nRoots; j++) {
                    if (j === i) continue;
                    var dx = tmpRe[i] - tmpRe[j], dy = tmpIm[i] - tmpIm[j];
                    var d2 = dx * dx + dy * dy;
                    if (d2 < mn) mn = d2;
                    if (d2 > mx) mx = d2;
                }
                minDists[i] = Math.sqrt(mn);
                maxDists[i] = Math.sqrt(mx);
            }
            rootsRe.set(tmpRe); rootsIm.set(tmpIm);
            for (var i = 0; i < nRoots; i++) {
                var ix = ((rootsRe[i] / range + 1) * 0.5 * W) | 0;
                var iy = ((1 - rootsIm[i] / range) * 0.5 * H) | 0;
                if (ix < 0 || ix >= W || iy < 0 || iy >= H) continue;
                var ratio = maxDists[i] > 0 ? Math.pow(minDists[i] / maxDists[i], ratioGamma) : 0;
                var palIdx = (ratio * 15 + 0.5) | 0;
                if (palIdx > 15) palIdx = 15;
                paintIdx[pc] = iy * W + ix;
                paintR[pc] = proxPalR[palIdx]; paintG[pc] = proxPalG[palIdx]; paintB[pc] = proxPalB[palIdx];
                pc++;
            }
        } else if (noColor) {
            rootsRe.set(tmpRe); rootsIm.set(tmpIm);
            for (var i = 0; i < nRoots; i++) {
                var ix = ((rootsRe[i] / range + 1) * 0.5 * W) | 0;
                var iy = ((1 - rootsIm[i] / range) * 0.5 * H) | 0;
                if (ix < 0 || ix >= W || iy < 0 || iy >= H) continue;
                paintIdx[pc] = iy * W + ix;
                paintR[pc] = uniformR; paintG[pc] = uniformG; paintB[pc] = uniformB;
                pc++;
            }
        } else {
            // Root matching controlled by bitmapMatchStrategy
            var ms = S_matchStrategy;
            if (ms === "hungarian1") {
                hungarianMatch(tmpRe, tmpIm, rootsRe, rootsIm, nRoots);
            } else if (ms === "assign1") {
                matchRoots(tmpRe, tmpIm, rootsRe, rootsIm, nRoots);
            } else {
                if ((step - stepStart) % 4 === 0) {
                    matchRoots(tmpRe, tmpIm, rootsRe, rootsIm, nRoots);
                }
            }
            rootsRe.set(tmpRe); rootsIm.set(tmpIm);
            for (var i = 0; i < nRoots; i++) {
                var ix = ((rootsRe[i] / range + 1) * 0.5 * W) | 0;
                var iy = ((1 - rootsIm[i] / range) * 0.5 * H) | 0;
                if (ix < 0 || ix >= W || iy < 0 || iy >= H) continue;
                paintIdx[pc] = iy * W + ix;
                paintR[pc] = colorsR[i]; paintG[pc] = colorsG[i]; paintB[pc] = colorsB[i];
                pc++;
            }
        }

        if ((step - stepStart) % 2000 === 0) {
            self.postMessage({type: 'progress', workerId: workerId, step: step - stepStart, total: stepEnd - stepStart});
        }
    }

    // Transfer sparse pixel data + final roots
    self.postMessage({
        type: 'done', workerId: workerId,
        paintIdx: paintIdx.buffer, paintR: paintR.buffer,
        paintG: paintG.buffer, paintB: paintB.buffer,
        paintCount: pc,
        rootsRe: new Float64Array(rootsRe).buffer,
        rootsIm: new Float64Array(rootsIm).buffer
    }, [paintIdx.buffer, paintR.buffer, paintG.buffer, paintB.buffer]);
};`;
    return URL.createObjectURL(new Blob([code], { type: "application/javascript" }));
}

function fmtPassCount() {
    return String(Math.round(fastModeElapsedOffset)).padStart(6, "0") + "s";
}

// Find nearest integer speed (1â€“100) that is coprime with all other animated coefficients' speeds
// and also different from all of them. excludeSet = indices to skip (the coefficient(s) being edited).
function findPrimeSpeed(currentIntSpeed, excludeSet) {
    function gcd(a, b) { while (b) { [a, b] = [b, a % b]; } return a; }
    const otherSpeeds = [];
    for (let i = 0; i < coefficients.length; i++) {
        if (excludeSet.has(i)) continue;
        if (coefficients[i].pathType === "none") continue;
        const s = Math.round(coefficients[i].speed * 1000);
        if (s > 0) otherSpeeds.push(s);
    }
    if (otherSpeeds.length === 0) return currentIntSpeed; // no others â€” keep current
    function isValid(s) {
        for (const o of otherSpeeds) {
            if (s === o || gcd(s, o) > 1) return false;
        }
        return true;
    }
    // Search outward from current speed
    for (let d = 0; d <= 1000; d++) {
        if (currentIntSpeed + d <= 1000 && isValid(currentIntSpeed + d)) return currentIntSpeed + d;
        if (d > 0 && currentIntSpeed - d >= 1 && isValid(currentIntSpeed - d)) return currentIntSpeed - d;
    }
    return currentIntSpeed; // fallback (1 is coprime with everything, so this shouldn't happen)
}

function plotCoeffCurvesOnBitmap(animated, stepsVal) {
    if (!bitmapCtx || !bitmapRange) return;
    const w = bitmapDisplayRes || bitmapCtx.canvas.width, h = bitmapDisplayRes || bitmapCtx.canvas.height;
    const range = bitmapRange;
    const nCoeffs = coefficients.length;

    // Pre-compute coefficient colors as CSS strings
    const colors = [];
    for (let i = 0; i < nCoeffs; i++) colors.push(coeffColor(i, nCoeffs));

    // Build fixed positions for non-animated coefficients
    const fixedRe = new Float64Array(nCoeffs);
    const fixedIm = new Float64Array(nCoeffs);
    for (let i = 0; i < nCoeffs; i++) {
        fixedRe[i] = coefficients[i].re;
        fixedIm[i] = coefficients[i].im;
    }

    // Use ImageData for fast pixel writes
    const imgData = bitmapCtx.getImageData(0, 0, w, h);
    const data = imgData.data;

    // Parse hex colors to RGB for pixel writing
    const colR = new Uint8Array(nCoeffs);
    const colG = new Uint8Array(nCoeffs);
    const colB = new Uint8Array(nCoeffs);
    for (let i = 0; i < nCoeffs; i++) {
        const c = colors[i];
        // d3.interpolateRainbow returns "rgb(r, g, b)" strings
        const m = c.match(/(\d+)/g);
        if (m && m.length >= 3) {
            colR[i] = +m[0]; colG[i] = +m[1]; colB[i] = +m[2];
        } else {
            colR[i] = 255; colG[i] = 255; colB[i] = 255;
        }
    }

    for (let step = 0; step < stepsVal; step++) {
        for (let ci = 0; ci < nCoeffs; ci++) {
            let re, im;
            const curve = fastModeCurves.get(ci);
            if (curve) {
                // Animated: read from pre-computed hi-res curve
                const idx = step % curve.length;
                re = curve[idx].re;
                im = curve[idx].im;
            } else {
                // Non-animated: fixed position
                re = fixedRe[ci];
                im = fixedIm[ci];
            }
            // Apply jiggle offsets post-interpolation
            if (jiggleOffsets && jiggleOffsets.has(ci)) {
                re += jiggleOffsets.get(ci).re;
                im += jiggleOffsets.get(ci).im;
            }
            const px = ((re / range + 1) * 0.5 * w) | 0;
            const py = ((1 - im / range) * 0.5 * h) | 0;
            if (px < -1 || px > w || py < -1 || py > h) continue;
            // 3x3 square
            for (let dy = -1; dy <= 1; dy++) {
                const sy = py + dy;
                if (sy < 0 || sy >= h) continue;
                for (let dx = -1; dx <= 1; dx++) {
                    const sx = px + dx;
                    if (sx < 0 || sx >= w) continue;
                    const off = (sy * w + sx) * 4;
                    data[off] = colR[ci];
                    data[off + 1] = colG[ci];
                    data[off + 2] = colB[ci];
                    data[off + 3] = 255;
                }
            }
        }
    }

    bitmapCtx.putImageData(imgData, 0, 0);
    bitmapFrameCount += stepsVal;
}

function enterFastMode() {
    if (fastModeActive) { uiBuzz(); return; }

    // Stop interactive animation
    stopAnimation();
    animState.elapsedAtPause = null;
    playBtn.textContent = "\u25b6 Play";
    updateAnimSeconds(0);
    scrubSlider.value = 0;

    // Ensure bitmap canvas exists + range frozen, and resolution matches dropdown
    const wantRes = parseInt(document.getElementById("bitmap-res-select").value, 10) || 2000;
    const canvas = document.getElementById("bitmap-canvas");
    if (!bitmapCtx || !bitmapActive || bitmapComputeRes !== wantRes) {
        initBitmapCanvas();
        document.getElementById("bitmap-save-btn").disabled = false;
        document.getElementById("bitmap-clear-btn").disabled = false;
        document.getElementById("bitmap-coeff-btn").disabled = false;
    }

    // Read steps from dropdown
    const stepsVal = parseInt(document.getElementById("bitmap-steps-select").value, 10) || 10000;

    // Precompute hi-res curves for all animated coefficients
    fastModeCurves = new Map();
    const animated = allAnimatedCoeffs();

    // Snap animated coefficients to home so coeffExtent() matches interactive mode
    const savedPos = [];
    for (const idx of animated) {
        const c = coefficients[idx];
        savedPos.push({ idx, re: c.re, im: c.im });
        c.re = c.curve[0].re; c.im = c.curve[0].im;
    }
    const extentAtHome = coeffExtent();
    for (const s of savedPos) { coefficients[s.idx].re = s.re; coefficients[s.idx].im = s.im; }

    for (const idx of animated) {
        const c = coefficients[idx];
        const absR = (c.radius / 100) * extentAtHome;
        // Use home position (curve[0]), not current animated position (c.re/c.im)
        const homeRe = c.curve[0].re;
        const homeIm = c.curve[0].im;
        const curve = computeCurveN(homeRe, homeIm, c.pathType, absR, c.angle, c.extra, stepsVal);
        fastModeCurves.set(idx, curve);
    }

    // Precompute hi-res D-curves for animated morph targets
    fastModeDCurves = new Map();
    if (morphEnabled && morphTargetCoeffs.length === coefficients.length) {
        const animatedD = allAnimatedDCoeffs();
        for (const idx of animatedD) {
            const d = morphTargetCoeffs[idx];
            const absR = (d.radius / 100) * extentAtHome;
            let homeRe = d.curve[0].re, homeIm = d.curve[0].im;
            const dCurve = computeCurveN(homeRe, homeIm, d.pathType, absR, d.angle, d.extra, stepsVal);
            fastModeDCurves.set(idx, dCurve);
        }
    }

    const nRoots = currentRoots.length;
    // Compute bitmap CSS colors from bitmapColorMode (only used by bitmap painters)
    fastModeRootColors = new Array(nRoots);
    for (let i = 0; i < nRoots; i++) {
        if (bitmapColorMode === "uniform") {
            fastModeRootColors[i] = `rgb(${bitmapUniformColor[0]},${bitmapUniformColor[1]},${bitmapUniformColor[2]})`;
        } else {
            fastModeRootColors[i] = d3.interpolateRainbow(i / nRoots);
        }
    }

    fastModeActive = true;
    fastModeStepIndex = 0;
    fastModeTotalSteps = stepsVal;
    fastModeCycleStartTime = performance.now();
    fastModeTargetPasses = jiggleInterval;

    document.body.classList.add("fast-mode");
    document.getElementById("bitmap-fast-btn").textContent = "pause";
    const passEl0 = document.getElementById("bitmap-pass-count");
    if (passEl0) { passEl0.style.display = ""; passEl0.textContent = fmtPassCount(); }

    // Coefficient view: plot coefficient curve positions directly (no solver, no workers)
    if (bitmapCoeffView) {
        // Use coefficient panel range so positions are visible
        bitmapRange = panels.coeff.range;
        bitmapRangeInitial = bitmapRange;
        updateBitmapZoomLabel();
        plotCoeffCurvesOnBitmap(animated, stepsVal);
        fastModePassCount++;
        fastModeElapsedOffset += FAST_PASS_SECONDS;
        // Update pass counter display
        const passEl = document.getElementById("bitmap-pass-count");
        if (passEl) passEl.textContent = fmtPassCount();
        // Continuous jiggle cycle
        function coeffJiggleCycle() {
            if (!fastModeActive) return;
            // Check jiggle boundary
            if (jiggleMode !== "none" && fastModeTargetPasses > 0
                && fastModePassCount >= fastModeTargetPasses) {
                fastModePassCount = 0;
                computeJiggleForStep(jiggleStepFromElapsed(fastModeElapsedOffset));
            }
            plotCoeffCurvesOnBitmap(allAnimatedCoeffs(), stepsVal);
            fastModePassCount++;
            fastModeElapsedOffset += FAST_PASS_SECONDS;
            if (passEl) passEl.textContent = fmtPassCount();
            if (fastModeActive) {
                fastModeTimerId = setTimeout(coeffJiggleCycle, 0);
            }
        }
        fastModeTimerId = setTimeout(coeffJiggleCycle, 0);
        return;
    }

    // Legacy fallback for browsers without Worker
    if (typeof Worker === "undefined") {
        fastModeTimerId = setTimeout(fastModeChunkLegacy, 0);
        return;
    }

    // Serialize shared data (reused for all workers)
    fastModeSharedData = serializeFastModeData(animated, stepsVal, nRoots);
    fastModeLastRoots = null;
    fastModeLastStep = 0;

    initFastModeWorkers();
}

function serializeFastModeData(animated, stepsVal, nRoots) {
    const nCoeffs = coefficients.length;
    const degree = nCoeffs - 1;
    const coeffsRe = new Float64Array(nCoeffs);
    const coeffsIm = new Float64Array(nCoeffs);
    for (let i = 0; i < nCoeffs; i++) {
        coeffsRe[i] = coefficients[i].re;
        coeffsIm[i] = coefficients[i].im;
    }
    // Build jiggle offset arrays (applied post-interpolation in worker)
    const jiggleRe = new Float64Array(nCoeffs);
    const jiggleIm = new Float64Array(nCoeffs);
    if (jiggleOffsets) {
        for (const [idx, off] of jiggleOffsets) {
            if (idx < nCoeffs) {
                jiggleRe[idx] = off.re;
                jiggleIm[idx] = off.im;
            }
        }
    }

    // Serialize curves into one flat Float64Array + metadata
    const animEntries = [];
    const curveOffsets = [];
    const curveLengths = [];
    const curveIsCloud = [];
    let totalPts = 0;
    for (const [idx, curve] of fastModeCurves.entries()) {
        const c = coefficients[idx];
        animEntries.push({ idx, ccw: !!c.ccw, speed: c.speed, ditherSigma: curve._ditherSigmaPct ? (curve._ditherSigmaPct / 100 * coeffExtent()) : 0, ditherDist: curve._ditherDist === "uniform" ? 1 : 0 });
        curveOffsets.push(totalPts);
        curveLengths.push(curve.length);
        curveIsCloud.push(!!curve._isCloud);
        totalPts += curve.length;
    }
    const curvesFlat = new Float64Array(totalPts * 2);
    let off = 0;
    for (const [, curve] of fastModeCurves.entries()) {
        for (let k = 0; k < curve.length; k++) {
            curvesFlat[off++] = curve[k].re;
            curvesFlat[off++] = curve[k].im;
        }
    }

    // Serialize D-curves (animated morph targets)
    const dAnimEntries = [];
    const dCurveOffsets = [];
    const dCurveLengths = [];
    const dCurveIsCloud = [];
    let dTotalPts = 0;
    if (fastModeDCurves && fastModeDCurves.size > 0) {
        for (const [idx, curve] of fastModeDCurves.entries()) {
            const d = morphTargetCoeffs[idx];
            dAnimEntries.push({ idx, ccw: !!d.ccw, speed: d.speed, ditherSigma: curve._ditherSigmaPct ? (curve._ditherSigmaPct / 100 * coeffExtent()) : 0, ditherDist: curve._ditherDist === "uniform" ? 1 : 0 });
            dCurveOffsets.push(dTotalPts);
            dCurveLengths.push(curve.length);
            dCurveIsCloud.push(!!curve._isCloud);
            dTotalPts += curve.length;
        }
    }
    const dCurvesFlat = new Float64Array(dTotalPts * 2);
    if (fastModeDCurves) {
        let dOff = 0;
        for (const [, curve] of fastModeDCurves.entries()) {
            for (let k = 0; k < curve.length; k++) {
                dCurvesFlat[dOff++] = curve[k].re;
                dCurvesFlat[dOff++] = curve[k].im;
            }
        }
    }

    // Serialize current roots (or use last-pass roots for warm start)
    const rootsRe = new Float64Array(nRoots);
    const rootsIm = new Float64Array(nRoots);
    if (fastModeWorkerRoots) {
        const prevRe = new Float64Array(fastModeWorkerRoots.re);
        const prevIm = new Float64Array(fastModeWorkerRoots.im);
        for (let i = 0; i < nRoots; i++) { rootsRe[i] = prevRe[i]; rootsIm[i] = prevIm[i]; }
    } else {
        for (let i = 0; i < nRoots; i++) {
            rootsRe[i] = currentRoots[i].re;
            rootsIm[i] = currentRoots[i].im;
        }
    }

    // Precompute RGB color arrays from bitmapColorMode
    const colorsR = new Uint8Array(nRoots);
    const colorsG = new Uint8Array(nRoots);
    const colorsB = new Uint8Array(nRoots);
    for (let i = 0; i < nRoots; i++) {
        if (bitmapColorMode === "uniform") {
            colorsR[i] = bitmapUniformColor[0];
            colorsG[i] = bitmapUniformColor[1];
            colorsB[i] = bitmapUniformColor[2];
        } else {
            const css = d3.interpolateRainbow(i / nRoots);
            const m = css.match(/(\d+)/g);
            colorsR[i] = m ? +m[0] : 233;
            colorsG[i] = m ? +m[1] : 69;
            colorsB[i] = m ? +m[2] : 96;
        }
    }

    return {
        coeffsRe, coeffsIm, nCoeffs, degree, nRoots,
        animEntries, curvesFlat, curveOffsets, curveLengths, curveIsCloud,
        rootsRe, rootsIm,
        colorsR, colorsG, colorsB,
        canvasW: bitmapComputeRes, canvasH: bitmapComputeRes,
        bitmapRange, stepsVal,
        noColor: bitmapColorMode === "uniform",
        uniformR: bitmapUniformColor[0], uniformG: bitmapUniformColor[1], uniformB: bitmapUniformColor[2],
        proxColor: bitmapColorMode === "proximity",
        proxPalR: PROX_PAL_R.buffer.slice(0), proxPalG: PROX_PAL_G.buffer.slice(0), proxPalB: PROX_PAL_B.buffer.slice(0),
        derivColor: bitmapColorMode === "derivative",
        derivPalR: DERIV_PAL_R.buffer.slice(0), derivPalG: DERIV_PAL_G.buffer.slice(0), derivPalB: DERIV_PAL_B.buffer.slice(0),
        idxProxColor: bitmapColorMode === "idx-prox",
        idxProxGamma: bitmapIdxProxGamma,
        ratioColor: bitmapColorMode === "ratio",
        ratioGamma: bitmapRatioGamma,
        selectedCoeffIndices: selectedCoeffs.size > 0
            ? [...selectedCoeffs].sort((a, b) => a - b)
            : Array.from({length: nCoeffs}, (_, i) => i),
        morphEnabled: morphEnabled && morphTargetCoeffs.length === nCoeffs,
        morphRate: morphRate,
        morphPathType: morphPathType,
        morphPathCcw: morphPathCcw,
        morphEllipseMinor: morphEllipseMinor,
        morphDitherStartAbs: morphDitherStartSigma > 0 ? (morphDitherStartSigma / 100 * coeffExtent()) : 0,
        morphDitherMidAbs: morphDitherMidSigma > 0 ? (morphDitherMidSigma / 100 * coeffExtent()) : 0,
        morphDitherEndAbs: morphDitherEndSigma > 0 ? (morphDitherEndSigma / 100 * coeffExtent()) : 0,
        morphTargetRe: morphEnabled ? Float64Array.from(morphTargetCoeffs, d => d.re) : null,
        morphTargetIm: morphEnabled ? Float64Array.from(morphTargetCoeffs, d => d.im) : null,
        matchStrategy: bitmapMatchStrategy,
        dAnimEntries, dCurvesFlat, dCurveOffsets, dCurveLengths, dCurveIsCloud,
        dFollowCIndices: morphEnabled ? morphTargetCoeffs.reduce((a, d, i) => { if (d.pathType === "follow-c") a.push(i); return a; }, []) : [],
        jiggleRe, jiggleIm,
        totalCPts: totalPts,
        totalDPts: dTotalPts,
    };
}

let fastModeSharedData = null; // serialized data for current pass

function initFastModeWorkers() {
    const sd = fastModeSharedData;
    if (!sd) return;
    const actualWorkers = Math.min(numWorkers, sd.stepsVal);

    fastModeWorkers = [];
    for (let w = 0; w < actualWorkers; w++) {
        const blobUrl = createFastModeWorkerBlob();
        const worker = new Worker(blobUrl);
        URL.revokeObjectURL(blobUrl);

        worker.onmessage = handleFastModeWorkerMessage;
        worker.onerror = function(err) {
            console.error("Fast mode worker", w, "error:", err);
            exitFastMode();
        };

        // Send static data once (persists across runs within this cycle)
        worker.postMessage({
            type: "init",
            coeffsRe: sd.coeffsRe.buffer.slice(0),
            coeffsIm: sd.coeffsIm.buffer.slice(0),
            nCoeffs: sd.nCoeffs, degree: sd.degree, nRoots: sd.nRoots,
            animEntries: sd.animEntries,
            curvesFlat: sd.curvesFlat.buffer.slice(0),
            curveOffsets: sd.curveOffsets, curveLengths: sd.curveLengths, curveIsCloud: sd.curveIsCloud,
            colorsR: sd.colorsR.buffer.slice(0),
            colorsG: sd.colorsG.buffer.slice(0),
            colorsB: sd.colorsB.buffer.slice(0),
            canvasW: sd.canvasW, canvasH: sd.canvasH, bitmapRange: sd.bitmapRange,
            noColor: sd.noColor,
            uniformR: sd.uniformR, uniformG: sd.uniformG, uniformB: sd.uniformB,
            proxColor: sd.proxColor,
            proxPalR: sd.proxPalR, proxPalG: sd.proxPalG, proxPalB: sd.proxPalB,
            derivColor: sd.derivColor,
            derivPalR: sd.derivPalR, derivPalG: sd.derivPalG, derivPalB: sd.derivPalB,
            idxProxColor: sd.idxProxColor,
            idxProxGamma: sd.idxProxGamma,
            ratioColor: sd.ratioColor,
            ratioGamma: sd.ratioGamma,
            selectedCoeffIndices: sd.selectedCoeffIndices,
            totalSteps: sd.stepsVal, FAST_PASS_SECONDS,
            useWasm: solverType === "wasm",
            // wasmB64 removed â€” solver-only WASM tier eliminated
            morphEnabled: sd.morphEnabled,
            morphRate: sd.morphRate,
            morphPathType: sd.morphPathType,
            morphPathCcw: sd.morphPathCcw,
            morphEllipseMinor: sd.morphEllipseMinor,
            morphDitherStartAbs: sd.morphDitherStartAbs || 0,
            morphDitherMidAbs: sd.morphDitherMidAbs || 0,
            morphDitherEndAbs: sd.morphDitherEndAbs || 0,
            morphTargetRe: sd.morphTargetRe ? sd.morphTargetRe.buffer.slice(0) : null,
            morphTargetIm: sd.morphTargetIm ? sd.morphTargetIm.buffer.slice(0) : null,
            matchStrategy: sd.matchStrategy,
            dAnimEntries: sd.dAnimEntries,
            dCurvesFlat: sd.dCurvesFlat.buffer.slice(0),
            dCurveOffsets: sd.dCurveOffsets,
            dCurveLengths: sd.dCurveLengths,
            dCurveIsCloud: sd.dCurveIsCloud,
            jiggleRe: sd.jiggleRe ? sd.jiggleRe.buffer.slice(0) : null,
            jiggleIm: sd.jiggleIm ? sd.jiggleIm.buffer.slice(0) : null,
            dFollowCIndices: sd.dFollowCIndices || [],
            wasmStepLoopB64: solverType === "wasm" ? WASM_STEP_LOOP_B64 : null,
            totalCPts: sd.totalCPts || 0,
            totalDPts: sd.totalDPts || 0,
            maxPaintsPerWorker: Math.ceil(sd.stepsVal / actualWorkers) * sd.nRoots,
        });

        fastModeWorkers.push(worker);
    }

    // Dispatch first pass immediately (worker processes init then run in order)
    dispatchPassToWorkers();
}

function dispatchPassToWorkers() {
    const sd = fastModeSharedData;
    if (!sd || fastModeWorkers.length === 0) return;
    const stepsVal = sd.stepsVal;
    const nw = fastModeWorkers.length;
    const base = Math.floor(stepsVal / nw);
    const extra = stepsVal % nw;

    fastModeWorkersComplete = 0;
    fastModeWorkerPixels = new Array(nw);
    fastModeWorkerProgress = new Array(nw).fill(0);
    fastModePassStartTime = performance.now();

    let offset = 0;
    for (let w = 0; w < nw; w++) {
        const count = base + (w < extra ? 1 : 0);
        const stepStart = offset;
        const stepEnd = offset + count;
        offset = stepEnd;

        // Only roots + elapsed change per pass (small data, structured clone is fine)
        fastModeWorkers[w].postMessage({
            type: "run",
            workerId: w,
            stepStart, stepEnd,
            elapsedOffset: fastModeElapsedOffset,
            rootsRe: sd.rootsRe.buffer.slice(0),
            rootsIm: sd.rootsIm.buffer.slice(0),
        });
    }
}

function handleFastModeWorkerMessage(e) {
    const msg = e.data;
    if (!fastModeActive) return;

    if (msg.type === "progress") {
        fastModeWorkerProgress[msg.workerId] = msg.step;
    }
    else if (msg.type === "error") {
        console.error("WASM worker " + msg.workerId + " error:", msg.error);
    }
    else if (msg.type === "done") {
        // Collect this worker's sparse pixel data
        fastModeWorkerPixels[msg.workerId] = {
            paintIdx: msg.paintIdx, paintR: msg.paintR,
            paintG: msg.paintG, paintB: msg.paintB,
            paintCount: msg.paintCount
        };

        // Keep roots from the LAST range worker (highest step range) for next-pass warm start
        if (msg.workerId === fastModeWorkers.length - 1) {
            fastModeWorkerRoots = { re: msg.rootsRe, im: msg.rootsIm };
        }

        fastModeWorkersComplete++;

        if (fastModeWorkersComplete === fastModeWorkers.length) {
            // All workers done â€” composite, record timing, advance
            const workerMs = performance.now() - fastModePassStartTime;
            compositeWorkerPixels();
            recordTick();
            recordPassTiming(workerMs);
            advancePass();
        }
    }
}

function compositeWorkerPixels() {
    if (!bitmapCtx) return;
    const cW = bitmapComputeRes;
    const dW = bitmapDisplayRes;
    const split = bitmapDisplayBuffer !== null;

    // Ensure persistent buffer exists and matches compute size
    if (!bitmapPersistentBuffer || bitmapPersistentBuffer.width !== cW || bitmapPersistentBuffer.height !== cW) {
        try {
            bitmapPersistentBuffer = new ImageData(cW, cW);
        } catch (e) { return; }
        fillPersistentBuffer(bitmapCanvasColor);
    }

    const t0 = performance.now();
    const t1 = t0;

    const out = bitmapPersistentBuffer.data;
    const dispData = split ? bitmapDisplayBuffer.data : null;
    const invScale = split ? dW / cW : 1;
    let totalPainted = 0;
    // Dirty rect tracked in display-space
    let minX = dW, maxX = 0, minY = dW, maxY = 0;
    for (const result of fastModeWorkerPixels) {
        if (!result) continue;
        const idx = new Int32Array(result.paintIdx);
        const r = new Uint8Array(result.paintR);
        const g = new Uint8Array(result.paintG);
        const b = new Uint8Array(result.paintB);
        const count = result.paintCount;
        totalPainted += count;
        for (let i = 0; i < count; i++) {
            const pixIdx = idx[i];
            const off = pixIdx * 4;
            // Write to persistent buffer at compute resolution
            out[off] = r[i];
            out[off + 1] = g[i];
            out[off + 2] = b[i];
            out[off + 3] = 255;

            if (split) {
                // Downsample to display buffer
                const cx = pixIdx % cW;
                const cy = (pixIdx / cW) | 0;
                const dx = (cx * invScale) | 0;
                const dy = (cy * invScale) | 0;
                const dOff = (dy * dW + dx) * 4;
                dispData[dOff] = r[i];
                dispData[dOff + 1] = g[i];
                dispData[dOff + 2] = b[i];
                dispData[dOff + 3] = 255;
                if (dx < minX) minX = dx;
                if (dx > maxX) maxX = dx;
                if (dy < minY) minY = dy;
                if (dy > maxY) maxY = dy;
            } else {
                // No split: dirty rect in compute-space (= display-space)
                const px = pixIdx % cW;
                const py = (pixIdx / cW) | 0;
                if (px < minX) minX = px;
                if (px > maxX) maxX = px;
                if (py < minY) minY = py;
                if (py > maxY) maxY = py;
            }
        }
    }
    const t2 = performance.now();

    if (totalPainted > 0) {
        const buf = split ? bitmapDisplayBuffer : bitmapPersistentBuffer;
        bitmapCtx.putImageData(buf, 0, 0, minX, minY, maxX - minX + 1, maxY - minY + 1);
    }
    const t3 = performance.now();

    fastModeCompositeBreakdown = {
        getMs: t1 - t0,
        writeMs: t2 - t1,
        putMs: t3 - t2,
        totalMs: t3 - t0,
        pixels: totalPainted
    };
    fastModeWorkerPixels = [];
}

function recordPassTiming(workerMs) {
    const ms = performance.now() - fastModePassStartTime;
    fastModeTimingHistory.push({
        passMs: ms,
        stepsPerSec: Math.round(fastModeTotalSteps / (ms / 1000)),
        workers: fastModeWorkers.length,
        steps: fastModeTotalSteps,
        workerMs: workerMs || ms,
        composite: fastModeCompositeBreakdown
    });
    updateTimingPopup();
}

function advancePass() {
    fastModeElapsedOffset += FAST_PASS_SECONDS;
    fastModePassCount++;
    const passEl = document.getElementById("bitmap-pass-count");
    if (passEl) passEl.textContent = fmtPassCount();

    // Jiggle boundary â€” check if step changed, reinit workers with new offsets
    if (jiggleMode !== "none" && fastModeTargetPasses > 0
        && fastModePassCount >= fastModeTargetPasses) {
        fastModePassCount = 0;
        const newStep = jiggleStepFromElapsed(fastModeElapsedOffset);
        computeJiggleForStep(newStep);
        reinitWorkersForJiggle();
        return;
    }

    // Warm-start roots for next pass
    if (fastModeWorkerRoots && fastModeSharedData) {
        fastModeSharedData.rootsRe = new Float64Array(fastModeWorkerRoots.re);
        fastModeSharedData.rootsIm = new Float64Array(fastModeWorkerRoots.im);
    }
    dispatchPassToWorkers();
}

function reinitWorkersForJiggle() {
    const savedRoots = fastModeWorkerRoots;

    for (const wk of fastModeWorkers) wk.terminate();
    fastModeWorkers = [];
    fastModeWorkersComplete = 0;
    fastModeWorkerPixels = [];
    fastModeWorkerProgress = [];
    fastModeSharedData = null;

    // Jiggle offsets already computed by caller via computeJiggleForStep()
    fastModeWorkerRoots = savedRoots;

    const animated = allAnimatedCoeffs();
    const nRoots = currentRoots.length;
    fastModeSharedData = serializeFastModeData(animated, fastModeTotalSteps, nRoots);
    fastModeStepIndex = 0;
    fastModeCycleStartTime = performance.now();
    initFastModeWorkers();
}

function exitFastMode() {
    if (!fastModeActive) { uiBuzz(); return; }

    // Advance elapsed offset proportionally for mid-pass interruption
    if (fastModeWorkerProgress.length > 0 && fastModeTotalSteps > 0) {
        const totalDone = fastModeWorkerProgress.reduce((a, b) => a + b, 0);
        if (totalDone > 0 && totalDone < fastModeTotalSteps) {
            fastModeElapsedOffset += (totalDone / fastModeTotalSteps) * FAST_PASS_SECONDS;
        }
    }

    // Terminate all workers
    for (const wk of fastModeWorkers) wk.terminate();
    fastModeWorkers = [];
    fastModeWorkersComplete = 0;
    fastModeWorkerPixels = [];
    fastModeWorkerProgress = [];
    fastModeSharedData = null;

    // Legacy fallback cleanup
    if (fastModeTimerId) { clearTimeout(fastModeTimerId); fastModeTimerId = null; }

    // Restore root state from last worker snapshot
    if (fastModeWorkerRoots) {
        const rRe = new Float64Array(fastModeWorkerRoots.re);
        const rIm = new Float64Array(fastModeWorkerRoots.im);
        for (let i = 0; i < currentRoots.length && i < rRe.length; i++) {
            currentRoots[i].re = rRe[i];
            currentRoots[i].im = rIm[i];
        }
    } else if (fastModeLastRoots) {
        // Legacy fallback
        const rRe = new Float64Array(fastModeLastRoots.re);
        const rIm = new Float64Array(fastModeLastRoots.im);
        for (let i = 0; i < currentRoots.length && i < rRe.length; i++) {
            currentRoots[i].re = rRe[i];
            currentRoots[i].im = rIm[i];
        }
    }

    fastModeActive = false;
    fastModeCurves = null;
    fastModeDCurves = null;
    fastModeRootColors = null;
    fastModeLastPixels = null;
    fastModeLastRoots = null;
    fastModeLastStep = 0;

    document.body.classList.remove("fast-mode");
    document.getElementById("bitmap-fast-btn").textContent = "cont";
    const passEl = document.getElementById("bitmap-pass-count");
    if (passEl) passEl.style.display = "none";

    // Bring interactive UI back in sync
    renderCoefficients();
    renderCoeffTrails();
    solveRoots();
}

function fastModeChunkLegacy() {
    if (!fastModeActive) return;

    const deg = coefficients.length - 1;
    const chunkSize = Math.max(10, Math.floor(200 / Math.max(3, deg)));

    const animated = fastModeCurves;
    const total = fastModeTotalSteps;
    let step = fastModeStepIndex;

    for (let s = 0; s < chunkSize && step < total; s++, step++) {
        // Virtual elapsed seconds for this step (offset for multi-pass)
        const elapsed = fastModeElapsedOffset + (step / total) * FAST_PASS_SECONDS;

        // Step coefficients on their hi-res curves
        if (animated && animated.size) {
            for (const [idx, curve] of animated.entries()) {
                const c = coefficients[idx];
                const N = curve.length;
                const dir = c.ccw ? -1 : 1;
                const t = elapsed * c.speed * dir;
                const u = ((t % 1) + 1) % 1;
                const rawIdx = u * N;

                if (curve._isCloud) {
                    const k = (rawIdx | 0) % N;
                    c.re = curve[k].re;
                    c.im = curve[k].im;
                } else {
                    const lo = (rawIdx | 0) % N;
                    const hi = (lo + 1) % N;
                    const frac = rawIdx - (rawIdx | 0);
                    c.re = curve[lo].re * (1 - frac) + curve[hi].re * frac;
                    c.im = curve[lo].im * (1 - frac) + curve[hi].im * frac;
                }
                if (curve._ditherSigmaPct) {
                    const ds = curve._ditherSigmaPct / 100 * coeffExtent();
                    const _cd2 = curve._ditherDist;
                    c.re += _ditherRand(_cd2) * ds; c.im += _ditherRand(_cd2) * ds;
                }
            }
        }

        // Advance animated D-nodes along D-curves
        if (fastModeDCurves && fastModeDCurves.size) {
            for (const [idx, curve] of fastModeDCurves.entries()) {
                const d = morphTargetCoeffs[idx];
                const N = curve.length;
                const dir = d.ccw ? -1 : 1;
                const t = elapsed * d.speed * dir;
                const u = ((t % 1) + 1) % 1;
                const rawIdx = u * N;
                if (curve._isCloud) {
                    const k = (rawIdx | 0) % N;
                    d.re = curve[k].re; d.im = curve[k].im;
                } else {
                    const lo = (rawIdx | 0) % N;
                    const hi = (lo + 1) % N;
                    const frac = rawIdx - (rawIdx | 0);
                    d.re = curve[lo].re * (1 - frac) + curve[hi].re * frac;
                    d.im = curve[lo].im * (1 - frac) + curve[hi].im * frac;
                }
                if (curve._ditherSigmaPct) {
                    const ds = curve._ditherSigmaPct / 100 * coeffExtent();
                    const _dd2 = curve._ditherDist;
                    d.re += _ditherRand(_dd2) * ds; d.im += _ditherRand(_dd2) * ds;
                }
            }
        }
        // Follow-C D-nodes: copy from current C-node position
        for (let fi = 0; fi < morphTargetCoeffs.length; fi++) {
            if (morphTargetCoeffs[fi].pathType === "follow-c" && fi < coefficients.length) {
                morphTargetCoeffs[fi].re = coefficients[fi].re;
                morphTargetCoeffs[fi].im = coefficients[fi].im;
            }
        }

        // Morph blending â€” build blended coefficients along C-D path
        let coeffsToSolve = coefficients;
        if (morphEnabled && morphTargetCoeffs.length === coefficients.length) {
            const theta = 2 * Math.PI * morphRate * elapsed;
            coeffsToSolve = coefficients.map((c, i) =>
                morphInterpPoint(c.re, c.im, morphTargetCoeffs[i].re, morphTargetCoeffs[i].im,
                                 theta, morphPathType, morphPathCcw, morphEllipseMinor));
            if (morphDitherStartSigma > 0 || morphDitherMidSigma > 0 || morphDitherEndSigma > 0) {
                const ext = coeffExtent();
                const sinT = Math.sin(theta), cosT = Math.cos(theta);
                const startEnv = cosT > 0 ? cosT * cosT : 0;
                const endEnv = cosT < 0 ? cosT * cosT : 0;
                const ds = morphDitherStartSigma / 100 * ext * startEnv + morphDitherMidSigma / 100 * ext * sinT * sinT + morphDitherEndSigma / 100 * ext * endEnv;
                if (ds > 0) for (let i = 0; i < coeffsToSolve.length; i++) {
                    coeffsToSolve[i].re += (Math.random() - 0.5) * 2 * ds;
                    coeffsToSolve[i].im += (Math.random() - 0.5) * 2 * ds;
                }
            }
        }

        // Apply jiggle offsets post-interpolation
        if (jiggleOffsets && jiggleOffsets.size > 0) {
            if (coeffsToSolve === coefficients) {
                coeffsToSolve = coefficients.map(c => ({ re: c.re, im: c.im }));
            }
            for (const [idx, off] of jiggleOffsets) {
                if (idx < coeffsToSolve.length) {
                    coeffsToSolve[idx].re += off.re;
                    coeffsToSolve[idx].im += off.im;
                }
            }
        }

        // Solve roots (warm-start), preserve identity, update in-place
        let roots = solveRootsEA(coeffsToSolve, currentRoots);
        if (bitmapColorMode !== "uniform") roots = matchRootOrder(roots, currentRoots);
        setCurrentRootsInPlace(roots);

        // Paint
        paintBitmapFrameFast();
    }

    fastModeStepIndex = step;

    if (fastModeStepIndex >= fastModeTotalSteps) {
        // Pass complete â€” advance offset, reset step counter, continue
        fastModeElapsedOffset += FAST_PASS_SECONDS;
        fastModePassCount++;
        fastModeStepIndex = 0;
        fastModeLastStep = 0;
        const passEl = document.getElementById("bitmap-pass-count");
        if (passEl) passEl.textContent = fmtPassCount();
        // Jiggle boundary â€” continuous, no exit/re-enter
        if (jiggleMode !== "none" && fastModeTargetPasses > 0
            && fastModePassCount >= fastModeTargetPasses) {
            fastModePassCount = 0;
            computeJiggleForStep(jiggleStepFromElapsed(fastModeElapsedOffset));
        }
    }

    fastModeTimerId = setTimeout(fastModeChunkLegacy, 0);
}

function resetBitmap() {
    if (fastModeActive) exitFastMode();
    bitmapActive = false;
    bitmapCtx = null;
    bitmapRange = null;
    bitmapRangeInitial = null;
    updateBitmapZoomLabel();
    bitmapFrameCount = 0;
    bitmapPersistentBuffer = null;
    bitmapDisplayBuffer = null;
    bitmapComputeRes = 0;
    bitmapDisplayRes = 0;
    fastModeElapsedOffset = 0;
    const startBtn = document.getElementById("bitmap-start-btn");
    const saveBtn = document.getElementById("bitmap-save-btn");
    const clearBtn = document.getElementById("bitmap-clear-btn");
    const fastBtn = document.getElementById("bitmap-fast-btn");
    if (startBtn) startBtn.textContent = "init";
    if (saveBtn) saveBtn.disabled = true;
    if (clearBtn) clearBtn.disabled = true;
    if (fastBtn) { fastBtn.disabled = true; fastBtn.textContent = "start"; }
}

// Tab switching
// --- Right panel tabs ---
const tabButtons = [...document.querySelectorAll(".tab-bar [data-tab]")];
const tabContents = {
    roots: document.getElementById("roots-content"),
    stats: document.getElementById("stats-content"),
    sound: document.getElementById("sound-content"),
    bitmap: document.getElementById("bitmap-content")
};

function switchTab(tabName) {
    if (tabName === activeTab) return;
    const prevTab = activeTab;
    activeTab = tabName;
    tabButtons.forEach(btn => btn.classList.toggle("active", btn.dataset.tab === tabName));
    for (const [key, el] of Object.entries(tabContents)) el.classList.toggle("active", key === tabName);
    if (tabName === "stats") { resizeStatsCanvases(); drawAllStatsPlots(); }
    // Re-render SVG roots when switching back from bitmap (they were skipped)
    if (prevTab === "bitmap" && tabName === "roots") {
        renderDomainColoring();
        solveRoots();
    }
}
tabButtons.forEach(btn => btn.addEventListener("click", () => switchTab(btn.dataset.tab)));

// --- Left panel tabs ---
let leftTab = "coeffs";
const leftTabButtons = [...document.querySelectorAll("#left-tab-bar [data-ltab]")];
const leftTabContents = {
    coeffs: document.getElementById("coeffs-content"),
    list: document.getElementById("list-content"),
    morph: document.getElementById("morph-content"),
    dlist: document.getElementById("dlist-content"),
    jiggle: document.getElementById("jiggle-content"),
    final: document.getElementById("final-content")
};

function switchLeftTab(tabName) {
    if (tabName === leftTab) return;
    leftTab = tabName;
    leftTabButtons.forEach(btn => btn.classList.toggle("active", btn.dataset.ltab === tabName));
    for (const [key, el] of Object.entries(leftTabContents)) el.classList.toggle("active", key === tabName);
    if (tabName === "list") { refreshCoeffList(); refreshListCurveEditor(); }
    if (tabName === "dlist") { refreshDCoeffList(); refreshDListCurveEditor(); }
    if (tabName === "morph") renderMorphPanel();
    if (tabName === "jiggle") buildJigglePanel();
    if (tabName === "final") renderFinalPanel();
}
leftTabButtons.forEach(btn => btn.addEventListener("click", () => switchLeftTab(btn.dataset.ltab)));

// --- C-D Path popup ---
let cdpathPopOpen = false;
function buildCDPathPop() {
    const pop = document.getElementById("cdpath-pop");
    const btn = document.getElementById("morph-cdpath-btn");
    if (cdpathPopOpen) { pop.classList.remove("open"); cdpathPopOpen = false; return; }
    pop.innerHTML = "";

    // Snapshot current values for revert on Escape/outside-click
    const prevPathType = morphPathType, prevRate = morphRate, prevCcw = morphPathCcw, prevMinor = morphEllipseMinor, prevDitherStart = morphDitherStartSigma, prevDitherMid = morphDitherMidSigma, prevDitherEnd = morphDitherEndSigma;

    const title = document.createElement("div");
    title.className = "pop-title"; title.textContent = "C-D Path";
    pop.appendChild(title);

    // Path type dropdown
    const sel = document.createElement("select");
    sel.style.cssText = "width:100%;font-size:10px;margin:4px 0;background:#333;color:#fff;border:1px solid #666;border-radius:3px;padding:2px;";
    for (const [val, label] of [["line","Line"],["circle","Circle"],["ellipse","Ellipse"],["figure8","Figure-8"]]) {
        const opt = document.createElement("option");
        opt.value = val; opt.textContent = label;
        if (val === morphPathType) opt.selected = true;
        sel.appendChild(opt);
    }
    pop.appendChild(sel);

    // Rate slider: 0â€“100 â†’ 0.0000â€“0.0100 Hz
    const rateRow = document.createElement("div");
    rateRow.style.cssText = "display:flex;align-items:center;gap:3px;margin:2px 0;font-size:9px;color:#aaa;";
    const rateLbl = document.createElement("span"); rateLbl.textContent = "Rate"; rateLbl.style.cssText = "width:32px;flex-shrink:0;";
    const rateInp = document.createElement("input");
    rateInp.type = "range"; rateInp.min = "0"; rateInp.max = "100"; rateInp.step = "1";
    rateInp.value = Math.round(morphRate * 10000);
    rateInp.style.cssText = "flex:1;height:12px;accent-color:var(--accent);";
    const rateVal = document.createElement("span");
    rateVal.style.cssText = "width:50px;text-align:right;font-size:8px;flex-shrink:0;";
    rateVal.textContent = morphRate.toFixed(4) + " Hz";
    rateInp.addEventListener("input", () => {
        morphRate = rateInp.value / 10000;
        rateVal.textContent = morphRate.toFixed(4) + " Hz";
    });
    rateRow.appendChild(rateLbl); rateRow.appendChild(rateInp); rateRow.appendChild(rateVal);
    pop.appendChild(rateRow);

    // CW/CCW toggle (hidden for line)
    const ccwRow = document.createElement("div");
    ccwRow.style.cssText = "display:flex;align-items:center;gap:3px;margin:2px 0;font-size:9px;color:#aaa;";
    const ccwBtn = document.createElement("button");
    ccwBtn.style.cssText = "font-size:9px;padding:2px 8px;cursor:pointer;background:var(--bg);color:var(--accent);border:1px solid var(--accent-border);border-radius:3px;";
    ccwBtn.textContent = morphPathCcw ? "CCW" : "CW";
    ccwBtn.addEventListener("click", () => {
        morphPathCcw = !morphPathCcw;
        ccwBtn.textContent = morphPathCcw ? "CCW" : "CW";
    });
    ccwRow.appendChild(ccwBtn);
    pop.appendChild(ccwRow);
    ccwRow.style.display = morphPathType === "line" ? "none" : "flex";

    // Minor axis slider (shown only for ellipse)
    const minorRow = document.createElement("div");
    minorRow.style.cssText = "display:flex;align-items:center;gap:3px;margin:2px 0;font-size:9px;color:#aaa;";
    const minorLbl = document.createElement("span"); minorLbl.textContent = "Minor"; minorLbl.style.cssText = "width:32px;flex-shrink:0;";
    const minorInp = document.createElement("input");
    minorInp.type = "range"; minorInp.min = "10"; minorInp.max = "100"; minorInp.step = "1";
    minorInp.value = Math.round(morphEllipseMinor * 100);
    minorInp.style.cssText = "flex:1;height:12px;accent-color:var(--accent);";
    const minorVal = document.createElement("span");
    minorVal.style.cssText = "width:28px;text-align:right;font-size:8px;flex-shrink:0;";
    minorVal.textContent = Math.round(morphEllipseMinor * 100) + "%";
    minorInp.addEventListener("input", () => {
        morphEllipseMinor = minorInp.value / 100;
        minorVal.textContent = Math.round(morphEllipseMinor * 100) + "%";
    });
    minorRow.appendChild(minorLbl); minorRow.appendChild(minorInp); minorRow.appendChild(minorVal);
    pop.appendChild(minorRow);
    minorRow.style.display = morphPathType === "ellipse" ? "flex" : "none";

    // Start Ïƒ slider: 0â€“100 â†’ 0.0000â€“0.0100%
    const startRow = document.createElement("div");
    startRow.style.cssText = "display:flex;align-items:center;gap:3px;margin:2px 0;font-size:9px;color:#aaa;";
    const startLbl = document.createElement("span"); startLbl.textContent = "Start \u03C3"; startLbl.style.cssText = "width:32px;flex-shrink:0;";
    const startInp = document.createElement("input");
    startInp.type = "range"; startInp.min = "0"; startInp.max = "100"; startInp.step = "1";
    startInp.value = Math.round(morphDitherStartSigma * 10000);
    startInp.style.cssText = "flex:1;height:12px;accent-color:var(--accent);";
    const startVal = document.createElement("span");
    startVal.style.cssText = "width:40px;text-align:right;font-size:8px;flex-shrink:0;";
    startVal.textContent = morphDitherStartSigma.toFixed(4) + "%";
    startInp.addEventListener("input", () => {
        morphDitherStartSigma = startInp.value / 10000;
        startVal.textContent = morphDitherStartSigma.toFixed(4) + "%";
    });
    startRow.appendChild(startLbl); startRow.appendChild(startInp); startRow.appendChild(startVal);
    pop.appendChild(startRow);

    // Midpoint Ïƒ slider: 0â€“100 â†’ 0.000â€“0.100%
    const midRow = document.createElement("div");
    midRow.style.cssText = "display:flex;align-items:center;gap:3px;margin:2px 0;font-size:9px;color:#aaa;";
    const midLbl = document.createElement("span"); midLbl.textContent = "Mid \u03C3"; midLbl.style.cssText = "width:32px;flex-shrink:0;";
    const midInp = document.createElement("input");
    midInp.type = "range"; midInp.min = "0"; midInp.max = "100"; midInp.step = "1";
    midInp.value = Math.round(morphDitherMidSigma * 1000);
    midInp.style.cssText = "flex:1;height:12px;accent-color:var(--accent);";
    const midVal = document.createElement("span");
    midVal.style.cssText = "width:40px;text-align:right;font-size:8px;flex-shrink:0;";
    midVal.textContent = morphDitherMidSigma.toFixed(3) + "%";
    midInp.addEventListener("input", () => {
        morphDitherMidSigma = midInp.value / 1000;
        midVal.textContent = morphDitherMidSigma.toFixed(3) + "%";
    });
    midRow.appendChild(midLbl); midRow.appendChild(midInp); midRow.appendChild(midVal);
    pop.appendChild(midRow);

    // Endpoint Ïƒ slider: 0â€“100 â†’ 0.000â€“0.010%
    const endRow = document.createElement("div");
    endRow.style.cssText = "display:flex;align-items:center;gap:3px;margin:2px 0;font-size:9px;color:#aaa;";
    const endLbl = document.createElement("span"); endLbl.textContent = "End \u03C3"; endLbl.style.cssText = "width:32px;flex-shrink:0;";
    const endInp = document.createElement("input");
    endInp.type = "range"; endInp.min = "0"; endInp.max = "100"; endInp.step = "1";
    endInp.value = Math.round(morphDitherEndSigma * 10000);
    endInp.style.cssText = "flex:1;height:12px;accent-color:var(--accent);";
    const endVal = document.createElement("span");
    endVal.style.cssText = "width:40px;text-align:right;font-size:8px;flex-shrink:0;";
    endVal.textContent = morphDitherEndSigma.toFixed(4) + "%";
    endInp.addEventListener("input", () => {
        morphDitherEndSigma = endInp.value / 10000;
        endVal.textContent = morphDitherEndSigma.toFixed(4) + "%";
    });
    endRow.appendChild(endLbl); endRow.appendChild(endInp); endRow.appendChild(endVal);
    pop.appendChild(endRow);

    // Update visibility when path type changes
    sel.addEventListener("change", () => {
        morphPathType = sel.value;
        ccwRow.style.display = morphPathType === "line" ? "none" : "flex";
        minorRow.style.display = morphPathType === "ellipse" ? "flex" : "none";
    });

    // Accept button
    const acceptBtn = document.createElement("button");
    acceptBtn.textContent = "\u2713 Accept";
    acceptBtn.style.cssText = "width:100%;font-size:10px;padding:3px;margin-top:6px;background:#4a4;color:#fff;border:1px solid #6c6;border-radius:3px;cursor:pointer;";
    let accepted = false;
    acceptBtn.addEventListener("click", () => {
        accepted = true;
        pop.classList.remove("open"); cdpathPopOpen = false;
    });
    pop.appendChild(acceptBtn);

    // Position popup below button
    const r = btn.getBoundingClientRect();
    pop.style.left = r.left + "px";
    pop.style.top = (r.bottom + 4) + "px";
    pop.classList.add("open");
    cdpathPopOpen = true;

    // Outside-click / Escape to revert
    function closeRevert(e) {
        if (e && pop.contains(e.target)) return;
        if (e && btn.contains(e.target)) return;
        if (!accepted) {
            morphPathType = prevPathType; morphRate = prevRate;
            morphPathCcw = prevCcw; morphEllipseMinor = prevMinor;
            morphDitherStartSigma = prevDitherStart; morphDitherMidSigma = prevDitherMid; morphDitherEndSigma = prevDitherEnd;
        }
        pop.classList.remove("open"); cdpathPopOpen = false;
        document.removeEventListener("mousedown", closeRevert, true);
        document.removeEventListener("keydown", escHandler, true);
    }
    function escHandler(e) {
        if (e.key === "Escape") { closeRevert(); e.stopPropagation(); }
    }
    setTimeout(() => {
        document.addEventListener("mousedown", closeRevert, true);
        document.addEventListener("keydown", escHandler, true);
    }, 0);
}
document.getElementById("morph-cdpath-btn").addEventListener("click", buildCDPathPop);
document.getElementById("morph-copy-btn").addEventListener("click", function () {
    initMorphTarget();
    if (leftTab === "morph") renderMorphPanel();
    if (morphEnabled) solveRoots();
});
document.getElementById("morph-swap-btn").addEventListener("click", function () {
    if (morphTargetCoeffs.length !== coefficients.length) { uiBuzz(); return; }
    for (let i = 0; i < coefficients.length; i++) {
        const c = coefficients[i], d = morphTargetCoeffs[i];
        const tmpRe = c.re, tmpIm = c.im;
        c.re = d.re; c.im = d.im;
        d.re = tmpRe; d.im = tmpIm;
        d.curve = [{ re: d.re, im: d.im }];
        if (c.pathType === "none") {
            c.curve = [{ re: c.re, im: c.im }];
        } else {
            c.curve = computeCurve(c.re, c.im, c.pathType, c.radius / 100 * coeffExtent(), c.angle, c.extra);
            c.curveIndex = 0;
        }
    }
    renderCoefficients();
    renderCoeffTrails();
    if (leftTab === "morph") renderMorphPanel();
    solveRoots();
});

// --- Path display name helper ---
function pathDisplayName(t) {
    if (t === "none") return "\u2014";
    if (t === "follow-c") return "Follow C";
    if (t.endsWith("-dither")) return pathDisplayName(t.slice(0, -7)) + "~";
    if (t === "figure8") return "Fig-8";
    if (t === "epitrochoid") return "Spiro";
    if (t === "hypotrochoid") return "Hypo";
    if (t === "rose") return "Rose";
    if (t === "hilbert") return "Hilbert";
    if (t === "peano") return "Peano";
    if (t === "sierpinski") return "Sierpinski";
    if (t === "c-ellipse") return "C-Ellipse";
    return t.charAt(0).toUpperCase() + t.slice(1);
}

// --- Path picker popup (full trajectory editor, mirrors right-click context menu) ---

const pathPickPop = document.getElementById("path-pick-pop");
let pathPickOpen = false;
let pathPickCoeffIdx = -1;
let pathPickSnapshot = null;

function closePathPickPop(revert) {
    pathPickPop.classList.remove("open");
    if (revert && pathPickSnapshot && pathPickCoeffIdx >= 0) {
        const c = coefficients[pathPickCoeffIdx];
        c.pathType = pathPickSnapshot.pathType;
        c.radius = pathPickSnapshot.radius;
        c.speed = pathPickSnapshot.speed;
        c.angle = pathPickSnapshot.angle;
        c.ccw = pathPickSnapshot.ccw;
        c.extra = pathPickSnapshot.extra || {};
        c.curve = pathPickSnapshot.curve;
        c.curveIndex = pathPickSnapshot.curveIndex;
        renderCoeffTrails();
    }
    pathPickOpen = false;
    pathPickCoeffIdx = -1;
    pathPickSnapshot = null;
    if (typeof leftTab !== "undefined" && leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
}

function openPathPickPop(coeffIdx, anchorEl) {
    if (pathPickOpen && pathPickCoeffIdx === coeffIdx) { closePathPickPop(true); return; }
    if (pathPickOpen) closePathPickPop(true);
    pathPickCoeffIdx = coeffIdx;

    // Snapshot for cancel/revert
    const cc = coefficients[coeffIdx];
    pathPickSnapshot = {
        pathType: cc.pathType, radius: cc.radius, speed: cc.speed,
        angle: cc.angle, ccw: cc.ccw, extra: cc.extra ? { ...cc.extra } : {},
        curve: cc.curve.map(pt => ({ ...pt })),
        curveIndex: cc.curveIndex,
    };

    pathPickPop.innerHTML = "";
    const n = coefficients.length;
    const subIdx = n - 1 - coeffIdx;

    // Title
    const title = document.createElement("div");
    title.className = "ctx-title";
    title.textContent = "c" + subscript(subIdx) + " trajectory";
    pathPickPop.appendChild(title);

    // Path type select (clone from #anim-path)
    const pathSel = document.createElement("select");
    pathSel.innerHTML = document.getElementById("anim-path").innerHTML;
    pathSel.value = cc.pathType;
    const pathRow = document.createElement("label");
    pathRow.textContent = "Path ";
    pathRow.appendChild(pathSel);
    pathPickPop.appendChild(pathRow);

    // Dynamic controls container
    const dynContainer = document.createElement("div");
    pathPickPop.appendChild(dynContainer);
    const ppInputs = {};

    function buildPPControls(pathType) {
        dynContainer.innerHTML = "";
        for (const k in ppInputs) delete ppInputs[k];
        const schema = PATH_PARAMS[pathType] || [];
        const c = coefficients[coeffIdx];
        for (const p of schema) {
            const val = getCoeffParam(c, p.key, p);
            if (p.type === "toggle") {
                const dirRow = document.createElement("div");
                dirRow.className = "ctx-row";
                const btn = document.createElement("button");
                btn.className = "ctx-dir" + (val ? " active" : "");
                btn.textContent = val ? p.labels[1] : p.labels[0];
                btn.addEventListener("click", () => {
                    const isActive = !btn.classList.contains("active");
                    btn.classList.toggle("active", isActive);
                    btn.textContent = isActive ? p.labels[1] : p.labels[0];
                    previewPP();
                });
                dirRow.appendChild(btn);
                dynContainer.appendChild(dirRow);
                ppInputs[p.key] = btn;
            } else if (p.type === "select") {
                const row = document.createElement("label");
                row.textContent = p.label + " ";
                const sel = document.createElement("select");
                for (const opt of p.options) { const o = document.createElement("option"); o.value = opt.value; o.textContent = opt.label; sel.appendChild(o); }
                sel.value = val || p.default;
                sel.addEventListener("change", () => previewPP());
                row.appendChild(sel);
                dynContainer.appendChild(row);
                ppInputs[p.key] = sel;
            } else {
                const row = document.createElement("label");
                const ppUiVal = p.toUI ? p.toUI(val) : val;
                const valSpan = document.createElement("span");
                valSpan.className = "ctx-val";
                valSpan.textContent = p.fmt(ppUiVal);
                const inp = document.createElement("input");
                inp.type = "range"; inp.min = p.min; inp.max = p.max; inp.step = p.step; inp.value = ppUiVal;
                inp.addEventListener("input", () => {
                    valSpan.textContent = p.fmt(parseFloat(inp.value));
                    previewPP();
                });
                row.textContent = p.label + " ";
                row.appendChild(inp);
                row.appendChild(valSpan);
                dynContainer.appendChild(row);
                ppInputs[p.key] = inp;
            }
        }
    }

    buildPPControls(cc.pathType);

    pathSel.addEventListener("change", () => {
        buildPPControls(pathSel.value);
        previewPP();
    });

    // Accept button row
    const ppBtnRow = document.createElement("div");
    ppBtnRow.style.cssText = "display:flex;gap:6px;align-items:center;justify-content:center;margin-top:4px;";
    const acceptBtn = document.createElement("button");
    acceptBtn.className = "ctx-accept";
    acceptBtn.textContent = "Accept";
    acceptBtn.addEventListener("click", () => {
        pathPickSnapshot = null; // discard snapshot â€” keep current state
        closePathPickPop(false);
    });
    ppBtnRow.appendChild(acceptBtn);
    pathPickPop.appendChild(ppBtnRow);

    // Live preview â€” applies current settings immediately
    function previewPP() {
        const c = coefficients[coeffIdx];
        c.pathType = pathSel.value;
        const schema = PATH_PARAMS[c.pathType] || [];
        for (const p of schema) {
            if (p.type === "toggle") {
                setCoeffParam(c, p.key, ppInputs[p.key] ? ppInputs[p.key].classList.contains("active") : p.default);
            } else if (p.type === "select") {
                setCoeffParam(c, p.key, ppInputs[p.key] ? ppInputs[p.key].value : p.default);
            } else {
                const ppRaw = ppInputs[p.key] ? parseFloat(ppInputs[p.key].value) : null;
                setCoeffParam(c, p.key, ppRaw !== null ? (p.fromUI ? p.fromUI(ppRaw) : ppRaw) : p.default);
            }
        }
        if (c.pathType === "none") {
            c.curve = [{ re: c.re, im: c.im }];
        } else {
            const absRadius = c.radius / 100 * coeffExtent();
            c.curve = computeCurve(c.re, c.im, c.pathType, absRadius, c.angle, c.extra);
        }
        c.curveIndex = 0;
        animState.elapsedAtPause = null;
        updateAnimSeconds(0);
        playBtn.textContent = "â–¶ Play";
        renderCoeffTrails();
    }

    // Show and position
    pathPickPop.classList.add("open");
    const r = anchorEl.getBoundingClientRect();
    const popRect = pathPickPop.getBoundingClientRect();
    let left = r.right + 6;
    let top = r.top;
    // Keep within viewport
    if (left + popRect.width > window.innerWidth - 4) left = r.left - popRect.width - 6;
    top = Math.max(4, Math.min(top, window.innerHeight - popRect.height - 4));
    pathPickPop.style.left = left + "px";
    pathPickPop.style.top = top + "px";
    pathPickOpen = true;
}

// --- Coefficient list helpers ---

// --- Coefficient list tab ---
function refreshCoeffList() {
    buildCurveCycleTypes();
    updateCurveCycleLabel();
    const container = document.getElementById("coeff-list-scroll");
    container.innerHTML = "";
    const deg = coefficients.length - 1;
    const n = coefficients.length;
    const coeffSens = computeCoeffSensitivities();
    document.getElementById("list-count").textContent = n + " coefficients";
    for (let i = 0; i < n; i++) {
        const row = document.createElement("div");
        row.className = "cpick-row";

        const cb = document.createElement("span");
        cb.className = "cpick-cb" + (selectedCoeffs.has(i) ? " checked" : "");

        const dot = document.createElement("span");
        dot.className = "cpick-dot";
        dot.style.background = coeffColor(i, n);

        const sensDot = document.createElement("span");
        sensDot.className = "cpick-dot";
        sensDot.style.background = coeffSens ? sensitivityColor(coeffSens[i]) : "#555";

        const label = document.createElement("span");
        label.className = "cpick-label";
        label.textContent = "c" + (deg - i);

        const power = document.createElement("span");
        power.className = "cpick-power";
        const exp = deg - i;
        power.textContent = exp === 0 ? "1" : exp === 1 ? "z" : "z" + superscript(exp);

        const pathBtn = document.createElement("button");
        pathBtn.className = "cpick-path-btn";
        const ci = coefficients[i];
        if (ci.pathType !== "none") {
            pathBtn.textContent = pathDisplayName(ci.pathType);
        } else {
            pathBtn.textContent = "\u2014";
        }

        const speedSpan = document.createElement("span");
        speedSpan.className = "cpick-speed";
        speedSpan.textContent = ci.pathType !== "none" ? String(Math.round(ci.speed * 1000)) : "\u2014";

        const radiusSpan = document.createElement("span");
        radiusSpan.className = "cpick-radius";
        radiusSpan.textContent = ci.pathType !== "none" ? String(ci.radius) : "\u2014";

        const plenSpan = document.createElement("span");
        plenSpan.className = "cpick-plen";
        plenSpan.textContent = String(ci.curve.length);

        const posSpan = document.createElement("span");
        posSpan.className = "cpick-pos";
        posSpan.textContent = String(ci.curveIndex);

        const coords = document.createElement("span");
        coords.className = "cpick-coords";
        const c = coefficients[i];
        const sign = c.im >= 0 ? "+" : "";
        coords.textContent = c.re.toFixed(2) + sign + c.im.toFixed(2) + "i";

        row.appendChild(cb);
        row.appendChild(dot);
        row.appendChild(sensDot);
        row.appendChild(label);
        row.appendChild(power);
        row.appendChild(pathBtn);
        row.appendChild(speedSpan);
        row.appendChild(radiusSpan);
        row.appendChild(plenSpan);
        row.appendChild(posSpan);
        row.appendChild(coords);

        const idx = i;
        cb.addEventListener("click", (e) => {
            e.stopPropagation();
            clearRootSelection();
            if (selectedCoeffs.has(idx)) {
                selectedCoeffs.delete(idx);
                cb.classList.remove("checked");
            } else {
                selectedCoeffs.add(idx);
                cb.classList.add("checked");
                lastSelectedCoeff = idx;
            }
            updateCoeffSelectionVisual();
            updateAnimBar();
            refreshListCurveEditor();
        });
        pathBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            openPathPickPop(idx, pathBtn);
        });

        container.appendChild(row);
    }
}

// Lightweight update: refresh coordinate text + pos in existing list rows (called every frame during anim/drag)
function updateListCoords() {
    if (typeof leftTab === "undefined" || leftTab !== "list") return;
    const rows = document.querySelectorAll("#coeff-list-scroll .cpick-row");
    const n = coefficients.length;
    if (rows.length !== n) { refreshCoeffList(); return; } // size mismatch â€” full rebuild
    for (let i = 0; i < n; i++) {
        const c = coefficients[i];
        const coordsEl = rows[i].querySelector(".cpick-coords");
        if (coordsEl) {
            const sign = c.im >= 0 ? "+" : "";
            coordsEl.textContent = c.re.toFixed(2) + sign + c.im.toFixed(2) + "i";
        }
        const posEl = rows[i].querySelector(".cpick-pos");
        if (posEl) {
            posEl.textContent = String(c.curveIndex);
        }
    }
}

// Full column update: refresh path, speed, pts columns (called after trajectory changes)
function updateListPathCols() {
    if (typeof leftTab === "undefined" || leftTab !== "list") return;
    const rows = document.querySelectorAll("#coeff-list-scroll .cpick-row");
    const n = coefficients.length;
    if (rows.length !== n) { refreshCoeffList(); return; }
    for (let i = 0; i < n; i++) {
        const c = coefficients[i];
        const pathBtn = rows[i].querySelector(".cpick-path-btn");
        if (pathBtn) {
            pathBtn.textContent = c.pathType !== "none" ? pathDisplayName(c.pathType) : "\u2014";
        }
        const speedEl = rows[i].querySelector(".cpick-speed");
        if (speedEl) {
            speedEl.textContent = c.pathType !== "none" ? String(Math.round(c.speed * 1000)) : "\u2014";
        }
        const radiusEl = rows[i].querySelector(".cpick-radius");
        if (radiusEl) {
            radiusEl.textContent = c.pathType !== "none" ? String(c.radius) : "\u2014";
        }
        const plenEl = rows[i].querySelector(".cpick-plen");
        if (plenEl) {
            plenEl.textContent = String(c.curve.length);
        }
    }
}

document.getElementById("list-select-all-btn").addEventListener("click", () => {
    clearRootSelection();
    for (let i = 0; i < coefficients.length; i++) selectedCoeffs.add(i);
    updateCoeffSelectionVisual();
    updateAnimBar();
    if (leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
});
document.getElementById("list-deselect-all-btn").addEventListener("click", () => {
    selectedCoeffs.clear();
    lastSelectedCoeff = -1;
    updateCoeffSelectionVisual();
    updateAnimBar();
    if (leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
});
{
    const selSpd = document.getElementById("list-sel-speed");
    const selSpdVal = document.getElementById("list-sel-speed-val");
    selSpd.addEventListener("input", () => { selSpdVal.textContent = selSpd.value; });
    const selP2 = document.getElementById("list-sel-param2");
    const selP2Val = document.getElementById("list-sel-param2-val");
    selP2.addEventListener("input", () => { selP2Val.textContent = selP2.value; });
}
document.getElementById("list-transform").addEventListener("change", function() {
    const action = this.value;
    this.value = "none";
    if (action === "none") return;
    if (selectedCoeffs.size === 0) { uiBuzz(); return; }
    const param1 = parseInt(document.getElementById("list-sel-speed").value, 10);
    const param2 = parseInt(document.getElementById("list-sel-param2").value, 10);
    let changed = false;
    if (action === "PrimeSpeeds") {
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            if (c.pathType === "none") continue;
            const cur = Math.round(c.speed * 1000);
            const ps = findPrimeSpeed(cur, new Set([idx]));
            if (ps !== cur) { c.speed = ps / 1000; changed = true; }
        }
    } else if (action === "SetAllSpeeds") {
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            if (c.pathType === "none") continue;
            c.speed = param1 / 1000;
            changed = true;
        }
    } else if (action === "RandomSpeed") {
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            if (c.pathType === "none") continue;
            c.speed = Math.round(Math.random() * param1) / 1000;
            changed = true;
        }
    } else if (action === "RandomAngle") {
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            if (c.pathType === "none") continue;
            const schema = PATH_PARAMS[c.pathType] || [];
            if (schema.some(p => p.key === "angle")) {
                c.angle = Math.random() * param1 / 100;
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
                changed = true;
            }
        }
    } else if (action === "RandomRadius") {
        const lo = Math.min(param1, param2), hi = Math.max(param1, param2);
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            if (c.pathType === "none") continue;
            c.radius = Math.round(lo + Math.random() * (hi - lo));
            const absR = c.radius / 100 * coeffExtent();
            c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
            c.curveIndex = 0;
            changed = true;
        }
    } else if (action === "LerpSpeed") {
        const idxArr = [...selectedCoeffs].filter(i => coefficients[i].pathType !== "none").sort((a, b) => a - b);
        if (idxArr.length > 0) {
            const lo = param1, hi = param2;
            for (let k = 0; k < idxArr.length; k++) {
                const c = coefficients[idxArr[k]];
                c.speed = Math.round(idxArr.length === 1 ? lo : lo + k * (hi - lo) / (idxArr.length - 1)) / 1000;
                changed = true;
            }
        }
    } else if (action === "LerpRadius") {
        const idxArr = [...selectedCoeffs].filter(i => coefficients[i].pathType !== "none").sort((a, b) => a - b);
        if (idxArr.length > 0) {
            const lo = param1, hi = param2;
            for (let k = 0; k < idxArr.length; k++) {
                const c = coefficients[idxArr[k]];
                c.radius = Math.round(idxArr.length === 1 ? lo : lo + k * (hi - lo) / (idxArr.length - 1));
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
                changed = true;
            }
        }
    } else if (action === "LerpAngle") {
        const idxArr = [...selectedCoeffs].filter(i => {
            const c = coefficients[i];
            if (c.pathType === "none") return false;
            const schema = PATH_PARAMS[c.pathType] || [];
            return schema.some(p => p.key === "angle");
        }).sort((a, b) => a - b);
        if (idxArr.length > 0) {
            const lo = param1 / 100, hi = param2 / 100;
            for (let k = 0; k < idxArr.length; k++) {
                const c = coefficients[idxArr[k]];
                c.angle = idxArr.length === 1 ? lo : lo + k * (hi - lo) / (idxArr.length - 1);
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
                changed = true;
            }
        }
    } else if (action === "RandomDirection") {
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            if (c.pathType === "none") continue;
            const schema = PATH_PARAMS[c.pathType] || [];
            if (schema.some(p => p.key === "ccw")) {
                c.ccw = Math.random() < 0.5;
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
                changed = true;
            }
        }
    } else if (action === "FlipAllDirections") {
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            if (c.pathType === "none") continue;
            const schema = PATH_PARAMS[c.pathType] || [];
            if (schema.some(p => p.key === "ccw")) {
                c.ccw = !c.ccw;
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
                changed = true;
            }
        }
    } else if (action === "ShuffleCurves") {
        const idxArr = [...selectedCoeffs].filter(i => coefficients[i].pathType !== "none");
        if (idxArr.length >= 2) {
            const curves = idxArr.map(i => {
                const c = coefficients[i];
                return { pathType: c.pathType, radius: c.radius, speed: c.speed,
                         angle: c.angle, ccw: c.ccw, extra: JSON.parse(JSON.stringify(c.extra || {})) };
            });
            for (let k = curves.length - 1; k > 0; k--) {
                const j = Math.floor(Math.random() * (k + 1));
                [curves[k], curves[j]] = [curves[j], curves[k]];
            }
            for (let k = 0; k < idxArr.length; k++) {
                const c = coefficients[idxArr[k]];
                const s = curves[k];
                c.pathType = s.pathType; c.radius = s.radius; c.speed = s.speed;
                c.angle = s.angle; c.ccw = s.ccw; c.extra = s.extra;
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "ShufflePositions") {
        const idxArr = [...selectedCoeffs];
        if (idxArr.length >= 2) {
            const positions = idxArr.map(i => ({ re: coefficients[i].re, im: coefficients[i].im }));
            for (let k = positions.length - 1; k > 0; k--) {
                const j = Math.floor(Math.random() * (k + 1));
                [positions[k], positions[j]] = [positions[j], positions[k]];
            }
            for (let k = 0; k < idxArr.length; k++) {
                const c = coefficients[idxArr[k]];
                c.re = positions[k].re; c.im = positions[k].im;
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "CircleLayout") {
        const idxArr = [...selectedCoeffs].sort((a, b) => a - b);
        if (idxArr.length > 0) {
            const r = param1 / 100 * coeffExtent();
            for (let k = 0; k < idxArr.length; k++) {
                const ang = 2 * Math.PI * k / idxArr.length;
                const c = coefficients[idxArr[k]];
                c.re = r * Math.cos(ang); c.im = r * Math.sin(ang);
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "RotatePositions") {
        const idxArr = [...selectedCoeffs];
        if (idxArr.length > 0) {
            let cx = 0, cy = 0;
            for (const i of idxArr) { cx += coefficients[i].re; cy += coefficients[i].im; }
            cx /= idxArr.length; cy /= idxArr.length;
            const theta = param1 / 100 * 2 * Math.PI;
            const cosT = Math.cos(theta), sinT = Math.sin(theta);
            for (const i of idxArr) {
                const c = coefficients[i];
                const dx = c.re - cx, dy = c.im - cy;
                c.re = cx + dx * cosT - dy * sinT;
                c.im = cy + dx * sinT + dy * cosT;
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "ScalePositions") {
        const idxArr = [...selectedCoeffs];
        if (idxArr.length > 0) {
            let cx = 0, cy = 0;
            for (const i of idxArr) { cx += coefficients[i].re; cy += coefficients[i].im; }
            cx /= idxArr.length; cy /= idxArr.length;
            const scale = param1 / 50; // 50=1x, 100=2x, 25=0.5x
            for (const i of idxArr) {
                const c = coefficients[i];
                c.re = cx + (c.re - cx) * scale;
                c.im = cy + (c.im - cy) * scale;
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "JitterPositions") {
        const idxArr = [...selectedCoeffs];
        if (idxArr.length > 0) {
            const mag = param1 / 100 * coeffExtent();
            for (const i of idxArr) {
                const c = coefficients[i];
                c.re += (Math.random() - 0.5) * 2 * mag;
                c.im += (Math.random() - 0.5) * 2 * mag;
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "Conjugate") {
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            c.im = -c.im;
            const absR = c.radius / 100 * coeffExtent();
            c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
            c.curveIndex = 0;
            changed = true;
        }
    } else if (action === "InvertPositions") {
        for (const idx of selectedCoeffs) {
            const c = coefficients[idx];
            const m2 = c.re * c.re + c.im * c.im;
            if (m2 < 1e-30) continue;
            c.re = c.re / m2; c.im = -c.im / m2;
            const absR = c.radius / 100 * coeffExtent();
            c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
            c.curveIndex = 0;
            changed = true;
        }
    } else if (action === "SortByModulus") {
        const idxArr = [...selectedCoeffs].sort((a, b) => a - b);
        if (idxArr.length >= 2) {
            const positions = idxArr.map(i => ({ re: coefficients[i].re, im: coefficients[i].im }));
            positions.sort((a, b) => (a.re * a.re + a.im * a.im) - (b.re * b.re + b.im * b.im));
            for (let k = 0; k < idxArr.length; k++) {
                const c = coefficients[idxArr[k]];
                c.re = positions[k].re; c.im = positions[k].im;
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "SortByArgument") {
        const idxArr = [...selectedCoeffs].sort((a, b) => a - b);
        if (idxArr.length >= 2) {
            const positions = idxArr.map(i => ({ re: coefficients[i].re, im: coefficients[i].im }));
            positions.sort((a, b) => Math.atan2(a.im, a.re) - Math.atan2(b.im, b.re));
            for (let k = 0; k < idxArr.length; k++) {
                const c = coefficients[idxArr[k]];
                c.re = positions[k].re; c.im = positions[k].im;
                const absR = c.radius / 100 * coeffExtent();
                c.curve = computeCurve(c.re, c.im, c.pathType, absR, c.angle, c.extra);
                c.curveIndex = 0;
            }
            changed = true;
        }
    }
    if (changed) {
        uiPing(1320, 0.06);
        renderCoeffTrails();
        solveRootsThrottled();
        if (leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
    } else { uiBuzz(); }
});
// --- Curve type cycler ---
let curveCycleTypes = [];  // sorted list of all unique path types across all coefficients
let curveCycleIdx = 0;

function buildCurveCycleTypes() {
    const types = new Set();
    for (const c of coefficients) types.add(c.pathType);
    curveCycleTypes = [...types].sort();
    if (curveCycleTypes.length === 0) curveCycleTypes = ["none"];
}

function updateCurveCycleLabel() {
    const label = document.getElementById("list-curve-cycle");
    if (curveCycleTypes.length === 0) { label.textContent = "\u2014"; return; }
    if (curveCycleIdx >= curveCycleTypes.length) curveCycleIdx = 0;
    if (curveCycleIdx < 0) curveCycleIdx = curveCycleTypes.length - 1;
    label.textContent = pathDisplayName(curveCycleTypes[curveCycleIdx]);
}

function selectByCurveType(type) {
    clearRootSelection();
    selectedCoeffs.clear();
    for (let i = 0; i < coefficients.length; i++) {
        if (coefficients[i].pathType === type) selectedCoeffs.add(i);
    }
    updateCoeffSelectionVisual();
    updateAnimBar();
    if (leftTab === "list") { refreshCoeffList(); refreshListCurveEditor(); }
}

// "Same Curve" button: select all coefficients with the currently displayed curve type
document.getElementById("list-all-curves-btn").addEventListener("click", () => {
    if (curveCycleTypes.length === 0) return;
    selectByCurveType(curveCycleTypes[curveCycleIdx]);
});

document.getElementById("list-curve-prev").addEventListener("click", () => {
    buildCurveCycleTypes();
    if (curveCycleTypes.length === 0) return;
    curveCycleIdx = (curveCycleIdx - 1 + curveCycleTypes.length) % curveCycleTypes.length;
    updateCurveCycleLabel();
    selectByCurveType(curveCycleTypes[curveCycleIdx]);
});

document.getElementById("list-curve-next").addEventListener("click", () => {
    buildCurveCycleTypes();
    if (curveCycleTypes.length === 0) return;
    curveCycleIdx = (curveCycleIdx + 1) % curveCycleTypes.length;
    updateCurveCycleLabel();
    selectByCurveType(curveCycleTypes[curveCycleIdx]);
});

// --- List curve editor ---
const lcePanel = document.getElementById("list-curve-editor");
const lcePathSel = document.getElementById("lce-path-sel");
const lceControls = document.getElementById("lce-controls");
let lceInputs = {};       // { key: <input or button element> }
let lceCurrentPath = "";  // path type currently shown in dropdown
let lceRefIdx = -1;       // first selected coefficient (reference for controls)

function refreshListCurveEditor() {
    if (selectedCoeffs.size === 0) {
        lcePanel.style.opacity = "0.3";
        lcePanel.style.pointerEvents = "none";
        lceRefIdx = -1;
        return;
    }
    lcePanel.style.opacity = "1";
    lcePanel.style.pointerEvents = "";

    lceRefIdx = [...selectedCoeffs].sort((a, b) => a - b)[0];
    const c = coefficients[lceRefIdx];
    lcePathSel.value = c.pathType || "none";
    lceCurrentPath = lcePathSel.value;

    buildLceControls(lceCurrentPath);
}

// When dropdown changes, rebuild controls with defaults for the new path type
lcePathSel.addEventListener("change", () => {
    lceCurrentPath = lcePathSel.value;
    buildLceControls(lceCurrentPath);
});

function buildLceControls(pathType) {
    lceControls.innerHTML = "";
    lceInputs = {};
    const schema = PATH_PARAMS[pathType] || [];
    if (schema.length === 0 || lceRefIdx < 0) return;
    const c = coefficients[lceRefIdx];
    for (const p of schema) {
        const val = getCoeffParam(c, p.key, p);
        if (p.type === "toggle") {
            const btn = document.createElement("button");
            btn.className = "ctx-dir" + (val ? " active" : "");
            btn.textContent = val ? p.labels[1] : p.labels[0];
            btn.addEventListener("click", () => {
                const isActive = !btn.classList.contains("active");
                btn.classList.toggle("active", isActive);
                btn.textContent = isActive ? p.labels[1] : p.labels[0];
            });
            lceControls.appendChild(btn);
            lceInputs[p.key] = btn;
        } else if (p.type === "select") {
            const row = document.createElement("label");
            row.textContent = p.label + " ";
            const sel = document.createElement("select");
            for (const opt of p.options) { const o = document.createElement("option"); o.value = opt.value; o.textContent = opt.label; sel.appendChild(o); }
            sel.value = val || p.default;
            row.appendChild(sel);
            lceControls.appendChild(row);
            lceInputs[p.key] = sel;
        } else {
            const row = document.createElement("label");
            const lceUiVal = p.toUI ? p.toUI(val) : val;
            const valSpan = document.createElement("span");
            valSpan.className = "ctx-val";
            valSpan.textContent = p.fmt(lceUiVal);
            const inp = document.createElement("input");
            inp.type = "range"; inp.min = p.min; inp.max = p.max; inp.step = p.step; inp.value = lceUiVal;
            inp.addEventListener("input", () => {
                valSpan.textContent = p.fmt(parseFloat(inp.value));
            });
            row.textContent = p.label + " ";
            row.appendChild(inp);
            row.appendChild(valSpan);
            lceControls.appendChild(row);
            lceInputs[p.key] = inp;
        }
    }
}

function lceReadParams() {
    // Read current slider/toggle values into an object
    const schema = PATH_PARAMS[lceCurrentPath] || [];
    const params = {};
    for (const p of schema) {
        if (p.type === "toggle") {
            params[p.key] = lceInputs[p.key] ? lceInputs[p.key].classList.contains("active") : p.default;
        } else if (p.type === "select") {
            params[p.key] = lceInputs[p.key] ? lceInputs[p.key].value : p.default;
        } else {
            const lceRaw = lceInputs[p.key] ? parseFloat(lceInputs[p.key].value) : null;
            params[p.key] = lceRaw !== null ? (p.fromUI ? p.fromUI(lceRaw) : lceRaw) : p.default;
        }
    }
    return params;
}

function lceApplyToCoeff(ci, params) {
    const c = coefficients[ci];
    // Set path type from dropdown
    c.pathType = lceCurrentPath;
    const schema = PATH_PARAMS[lceCurrentPath] || [];
    for (const p of schema) {
        setCoeffParam(c, p.key, params[p.key]);
    }
    if (c.pathType === "none") {
        c.curve = [{ re: c.re, im: c.im }];
    } else {
        const absRadius = c.radius / 100 * coeffExtent();
        c.curve = computeCurve(c.re, c.im, c.pathType, absRadius, c.angle, c.extra);
    }
    c.curveIndex = 0;
}

document.getElementById("lce-update-sel").addEventListener("click", () => {
    if (selectedCoeffs.size === 0) { uiBuzz(); return; }
    const params = lceReadParams();
    for (const ci of selectedCoeffs) {
        lceApplyToCoeff(ci, params);
    }
    animState.elapsedAtPause = null;
    updateAnimSeconds(0);
    playBtn.textContent = "â–¶ Play";
    renderCoeffTrails();
    buildCurveCycleTypes(); updateCurveCycleLabel();
    if (leftTab === "list") { updateListPathCols(); updateListCoords(); }
});

// ============================================================================
// D-LIST TAB â€” mirrors C-List for morphTargetCoeffs / selectedMorphCoeffs
// ============================================================================

const dpathPickPop = document.getElementById("dpath-pick-pop");
let dpathPickOpen = false;
let dpathPickCoeffIdx = -1;
let dpathPickSnapshot = null;

function closeDPathPickPop(revert) {
    dpathPickPop.classList.remove("open");
    if (revert && dpathPickSnapshot && dpathPickCoeffIdx >= 0) {
        const d = morphTargetCoeffs[dpathPickCoeffIdx];
        d.pathType = dpathPickSnapshot.pathType;
        d.radius = dpathPickSnapshot.radius;
        d.speed = dpathPickSnapshot.speed;
        d.angle = dpathPickSnapshot.angle;
        d.ccw = dpathPickSnapshot.ccw;
        d.extra = dpathPickSnapshot.extra || {};
        d.curve = dpathPickSnapshot.curve;
        d.curveIndex = dpathPickSnapshot.curveIndex;
    }
    dpathPickOpen = false;
    dpathPickCoeffIdx = -1;
    dpathPickSnapshot = null;
    if (typeof leftTab !== "undefined" && leftTab === "dlist") { refreshDCoeffList(); refreshDListCurveEditor(); }
}

function openDPathPickPop(dIdx, anchorEl) {
    if (dpathPickOpen && dpathPickCoeffIdx === dIdx) { closeDPathPickPop(true); return; }
    if (dpathPickOpen) closeDPathPickPop(true);
    dpathPickCoeffIdx = dIdx;

    const dd = morphTargetCoeffs[dIdx];
    dpathPickSnapshot = {
        pathType: dd.pathType, radius: dd.radius, speed: dd.speed,
        angle: dd.angle, ccw: dd.ccw, extra: dd.extra ? { ...dd.extra } : {},
        curve: dd.curve.map(pt => ({ ...pt })),
        curveIndex: dd.curveIndex,
    };

    dpathPickPop.innerHTML = "";

    const title = document.createElement("div");
    title.className = "ctx-title";
    title.textContent = "d" + subscript(dIdx) + " trajectory";
    dpathPickPop.appendChild(title);

    const pathSel = document.createElement("select");
    pathSel.innerHTML = document.getElementById("anim-path").innerHTML;
    { const _n = pathSel.querySelector('option[value="none"]'); if (_n) { const _f = document.createElement("option"); _f.value = "follow-c"; _f.textContent = "Follow C"; _n.after(_f); } }
    pathSel.value = dd.pathType;
    const pathRow = document.createElement("label");
    pathRow.textContent = "Path ";
    pathRow.appendChild(pathSel);
    dpathPickPop.appendChild(pathRow);

    const dynContainer = document.createElement("div");
    dpathPickPop.appendChild(dynContainer);
    const ppInputs = {};

    function buildPPControls(pathType) {
        dynContainer.innerHTML = "";
        for (const k in ppInputs) delete ppInputs[k];
        const schema = PATH_PARAMS[pathType] || [];
        const d = morphTargetCoeffs[dIdx];
        for (const p of schema) {
            const val = getCoeffParam(d, p.key, p);
            if (p.type === "toggle") {
                const dirRow = document.createElement("div");
                dirRow.className = "ctx-row";
                const btn = document.createElement("button");
                btn.className = "ctx-dir" + (val ? " active" : "");
                btn.textContent = val ? p.labels[1] : p.labels[0];
                btn.addEventListener("click", () => {
                    const isActive = !btn.classList.contains("active");
                    btn.classList.toggle("active", isActive);
                    btn.textContent = isActive ? p.labels[1] : p.labels[0];
                    previewDPP();
                });
                dirRow.appendChild(btn);
                dynContainer.appendChild(dirRow);
                ppInputs[p.key] = btn;
            } else if (p.type === "select") {
                const row = document.createElement("label");
                row.textContent = p.label + " ";
                const sel = document.createElement("select");
                for (const opt of p.options) { const o = document.createElement("option"); o.value = opt.value; o.textContent = opt.label; sel.appendChild(o); }
                sel.value = val || p.default;
                sel.addEventListener("change", () => previewDPP());
                row.appendChild(sel);
                dynContainer.appendChild(row);
                ppInputs[p.key] = sel;
            } else {
                const row = document.createElement("label");
                const ppUiVal = p.toUI ? p.toUI(val) : val;
                const valSpan = document.createElement("span");
                valSpan.className = "ctx-val";
                valSpan.textContent = p.fmt(ppUiVal);
                const inp = document.createElement("input");
                inp.type = "range"; inp.min = p.min; inp.max = p.max; inp.step = p.step; inp.value = ppUiVal;
                inp.addEventListener("input", () => {
                    valSpan.textContent = p.fmt(parseFloat(inp.value));
                    previewDPP();
                });
                row.textContent = p.label + " ";
                row.appendChild(inp);
                row.appendChild(valSpan);
                dynContainer.appendChild(row);
                ppInputs[p.key] = inp;
            }
        }
    }

    buildPPControls(dd.pathType);

    pathSel.addEventListener("change", () => {
        buildPPControls(pathSel.value);
        previewDPP();
    });

    const ppBtnRow = document.createElement("div");
    ppBtnRow.style.cssText = "display:flex;gap:6px;align-items:center;justify-content:center;margin-top:4px;";
    const acceptBtn = document.createElement("button");
    acceptBtn.className = "ctx-accept";
    acceptBtn.textContent = "Accept";
    acceptBtn.addEventListener("click", () => {
        dpathPickSnapshot = null;
        closeDPathPickPop(false);
    });
    ppBtnRow.appendChild(acceptBtn);
    dpathPickPop.appendChild(ppBtnRow);

    function previewDPP() {
        const d = morphTargetCoeffs[dIdx];
        d.pathType = pathSel.value;
        const schema = PATH_PARAMS[d.pathType] || [];
        for (const p of schema) {
            if (p.type === "toggle") {
                setCoeffParam(d, p.key, ppInputs[p.key] ? ppInputs[p.key].classList.contains("active") : p.default);
            } else if (p.type === "select") {
                setCoeffParam(d, p.key, ppInputs[p.key] ? ppInputs[p.key].value : p.default);
            } else {
                const ppRaw = ppInputs[p.key] ? parseFloat(ppInputs[p.key].value) : null;
                setCoeffParam(d, p.key, ppRaw !== null ? (p.fromUI ? p.fromUI(ppRaw) : ppRaw) : p.default);
            }
        }
        if (d.pathType === "none" || d.pathType === "follow-c") {
            d.curve = [{ re: d.re, im: d.im }];
        } else {
            const absRadius = d.radius / 100 * coeffExtent();
            d.curve = computeCurve(d.re, d.im, d.pathType, absRadius, d.angle, d.extra);
        }
        d.curveIndex = 0;
        if (morphEnabled) solveRootsThrottled();
    }

    dpathPickPop.classList.add("open");
    const r = anchorEl.getBoundingClientRect();
    const popRect = dpathPickPop.getBoundingClientRect();
    let left = r.right + 6;
    let top = r.top;
    if (left + popRect.width > window.innerWidth - 4) left = r.left - popRect.width - 6;
    top = Math.max(4, Math.min(top, window.innerHeight - popRect.height - 4));
    dpathPickPop.style.left = left + "px";
    dpathPickPop.style.top = top + "px";
    dpathPickOpen = true;
}

// Prime speed for D-nodes (excludes given set, checks only D-node speeds)
function findDPrimeSpeed(currentIntSpeed, excludeSet) {
    const others = [];
    for (let i = 0; i < morphTargetCoeffs.length; i++) {
        if (excludeSet && excludeSet.has(i)) continue;
        const d = morphTargetCoeffs[i];
        if (d.pathType === "none" || d.pathType === "follow-c") continue;
        others.push(Math.round(d.speed * 1000));
    }
    if (others.length === 0) return currentIntSpeed;
    function gcd(a, b) { while (b) { [a, b] = [b, a % b]; } return a; }
    function coprime(x) { return others.every(o => gcd(Math.abs(x), Math.abs(o)) === 1); }
    if (coprime(currentIntSpeed)) return currentIntSpeed;
    for (let delta = 1; delta < 2000; delta++) {
        if (currentIntSpeed + delta <= 2000 && coprime(currentIntSpeed + delta)) return currentIntSpeed + delta;
        if (currentIntSpeed - delta >= 1 && coprime(currentIntSpeed - delta)) return currentIntSpeed - delta;
    }
    return currentIntSpeed;
}

// --- D-List core functions ---
function refreshDCoeffList() {
    buildDCurveCycleTypes();
    updateDCurveCycleLabel();
    const container = document.getElementById("dcoeff-list-scroll");
    container.innerHTML = "";
    const n = morphTargetCoeffs.length;
    document.getElementById("dlist-count").textContent = n + " D-nodes";
    for (let i = 0; i < n; i++) {
        const row = document.createElement("div");
        row.className = "cpick-row";

        const cb = document.createElement("span");
        cb.className = "cpick-cb" + (selectedMorphCoeffs.has(i) ? " checked" : "");

        const dot = document.createElement("span");
        dot.className = "cpick-dot";
        dot.style.background = coeffColor(i, n);

        const sensDot = document.createElement("span");
        sensDot.className = "cpick-dot";
        sensDot.style.background = "#555";

        const label = document.createElement("span");
        label.className = "cpick-label";
        label.textContent = "d" + i;

        const power = document.createElement("span");
        power.className = "cpick-power";
        power.textContent = "";

        const pathBtn = document.createElement("button");
        pathBtn.className = "cpick-path-btn";
        const di = morphTargetCoeffs[i];
        const dHasPath = di.pathType !== "none" && di.pathType !== "follow-c";
        pathBtn.textContent = dHasPath ? pathDisplayName(di.pathType) : (di.pathType === "follow-c" ? "Follow C" : "\u2014");

        const speedSpan = document.createElement("span");
        speedSpan.className = "cpick-speed";
        speedSpan.textContent = dHasPath ? String(Math.round(di.speed * 1000)) : "\u2014";

        const radiusSpan = document.createElement("span");
        radiusSpan.className = "cpick-radius";
        radiusSpan.textContent = dHasPath ? String(di.radius) : "\u2014";

        const plenSpan = document.createElement("span");
        plenSpan.className = "cpick-plen";
        plenSpan.textContent = String(di.curve.length);

        const posSpan = document.createElement("span");
        posSpan.className = "cpick-pos";
        posSpan.textContent = String(di.curveIndex);

        const coords = document.createElement("span");
        coords.className = "cpick-coords";
        const sign = di.im >= 0 ? "+" : "";
        coords.textContent = di.re.toFixed(2) + sign + di.im.toFixed(2) + "i";

        row.appendChild(cb);
        row.appendChild(dot);
        row.appendChild(sensDot);
        row.appendChild(label);
        row.appendChild(power);
        row.appendChild(pathBtn);
        row.appendChild(speedSpan);
        row.appendChild(radiusSpan);
        row.appendChild(plenSpan);
        row.appendChild(posSpan);
        row.appendChild(coords);

        const idx = i;
        cb.addEventListener("click", (e) => {
            e.stopPropagation();
            clearRootSelection();
            if (selectedMorphCoeffs.has(idx)) {
                selectedMorphCoeffs.delete(idx);
                cb.classList.remove("checked");
            } else {
                selectedMorphCoeffs.add(idx);
                cb.classList.add("checked");
            }
            updateMorphSelectionVisual();
            refreshDListCurveEditor();
        });
        pathBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            openDPathPickPop(idx, pathBtn);
        });

        container.appendChild(row);
    }
}

function updateDListCoords() {
    if (typeof leftTab === "undefined" || leftTab !== "dlist") return;
    const rows = document.querySelectorAll("#dcoeff-list-scroll .cpick-row");
    const n = morphTargetCoeffs.length;
    if (rows.length !== n) { refreshDCoeffList(); return; }
    for (let i = 0; i < n; i++) {
        const d = morphTargetCoeffs[i];
        const coordsEl = rows[i].querySelector(".cpick-coords");
        if (coordsEl) {
            const sign = d.im >= 0 ? "+" : "";
            coordsEl.textContent = d.re.toFixed(2) + sign + d.im.toFixed(2) + "i";
        }
        const posEl = rows[i].querySelector(".cpick-pos");
        if (posEl) posEl.textContent = String(d.curveIndex);
    }
}

function updateDListPathCols() {
    if (typeof leftTab === "undefined" || leftTab !== "dlist") return;
    const rows = document.querySelectorAll("#dcoeff-list-scroll .cpick-row");
    const n = morphTargetCoeffs.length;
    if (rows.length !== n) { refreshDCoeffList(); return; }
    for (let i = 0; i < n; i++) {
        const d = morphTargetCoeffs[i];
        const dHasP = d.pathType !== "none" && d.pathType !== "follow-c";
        const pathBtn = rows[i].querySelector(".cpick-path-btn");
        if (pathBtn) pathBtn.textContent = dHasP ? pathDisplayName(d.pathType) : (d.pathType === "follow-c" ? "Follow C" : "\u2014");
        const speedEl = rows[i].querySelector(".cpick-speed");
        if (speedEl) speedEl.textContent = dHasP ? String(Math.round(d.speed * 1000)) : "\u2014";
        const radiusEl = rows[i].querySelector(".cpick-radius");
        if (radiusEl) radiusEl.textContent = dHasP ? String(d.radius) : "\u2014";
        const plenEl = rows[i].querySelector(".cpick-plen");
        if (plenEl) plenEl.textContent = String(d.curve.length);
    }
}

// --- D-List toolbar event handlers ---
document.getElementById("dlist-select-all-btn").addEventListener("click", () => {
    clearRootSelection();
    for (let i = 0; i < morphTargetCoeffs.length; i++) selectedMorphCoeffs.add(i);
    updateMorphSelectionVisual();
    if (leftTab === "dlist") { refreshDCoeffList(); refreshDListCurveEditor(); }
});
document.getElementById("dlist-deselect-all-btn").addEventListener("click", () => {
    selectedMorphCoeffs.clear();
    updateMorphSelectionVisual();
    if (leftTab === "dlist") { refreshDCoeffList(); refreshDListCurveEditor(); }
});
{
    const dSelSpd = document.getElementById("dlist-sel-speed");
    const dSelSpdVal = document.getElementById("dlist-sel-speed-val");
    dSelSpd.addEventListener("input", () => { dSelSpdVal.textContent = dSelSpd.value; });
    const dSelP2 = document.getElementById("dlist-sel-param2");
    const dSelP2Val = document.getElementById("dlist-sel-param2-val");
    dSelP2.addEventListener("input", () => { dSelP2Val.textContent = dSelP2.value; });
}

document.getElementById("dlist-transform").addEventListener("change", function() {
    const action = this.value;
    this.value = "none";
    if (action === "none") return;
    if (selectedMorphCoeffs.size === 0) { uiBuzz(); return; }
    const param1 = parseInt(document.getElementById("dlist-sel-speed").value, 10);
    const param2 = parseInt(document.getElementById("dlist-sel-param2").value, 10);
    let changed = false;
    if (action === "PrimeSpeeds") {
        for (const idx of selectedMorphCoeffs) {
            const d = morphTargetCoeffs[idx];
            if (d.pathType === "none" || d.pathType === "follow-c") continue;
            const cur = Math.round(d.speed * 1000);
            const ps = findDPrimeSpeed(cur, new Set([idx]));
            if (ps !== cur) { d.speed = ps / 1000; changed = true; }
        }
    } else if (action === "SetAllSpeeds") {
        for (const idx of selectedMorphCoeffs) {
            const d = morphTargetCoeffs[idx];
            if (d.pathType === "none" || d.pathType === "follow-c") continue;
            d.speed = param1 / 1000;
            changed = true;
        }
    } else if (action === "RandomSpeed") {
        for (const idx of selectedMorphCoeffs) {
            const d = morphTargetCoeffs[idx];
            if (d.pathType === "none" || d.pathType === "follow-c") continue;
            d.speed = Math.round(Math.random() * param1) / 1000;
            changed = true;
        }
    } else if (action === "RandomAngle") {
        for (const idx of selectedMorphCoeffs) {
            const d = morphTargetCoeffs[idx];
            if (d.pathType === "none" || d.pathType === "follow-c") continue;
            const schema = PATH_PARAMS[d.pathType] || [];
            if (schema.some(p => p.key === "angle")) {
                d.angle = Math.random() * param1 / 100;
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
                changed = true;
            }
        }
    } else if (action === "RandomRadius") {
        const lo = Math.min(param1, param2), hi = Math.max(param1, param2);
        for (const idx of selectedMorphCoeffs) {
            const d = morphTargetCoeffs[idx];
            if (d.pathType === "none" || d.pathType === "follow-c") continue;
            d.radius = Math.round(lo + Math.random() * (hi - lo));
            const absR = d.radius / 100 * coeffExtent();
            d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
            d.curveIndex = 0;
            changed = true;
        }
    } else if (action === "LerpSpeed") {
        const idxArr = [...selectedMorphCoeffs].filter(i => { const pt = morphTargetCoeffs[i].pathType; return pt !== "none" && pt !== "follow-c"; }).sort((a, b) => a - b);
        if (idxArr.length > 0) {
            const lo = param1, hi = param2;
            for (let k = 0; k < idxArr.length; k++) {
                const d = morphTargetCoeffs[idxArr[k]];
                d.speed = Math.round(idxArr.length === 1 ? lo : lo + k * (hi - lo) / (idxArr.length - 1)) / 1000;
                changed = true;
            }
        }
    } else if (action === "LerpRadius") {
        const idxArr = [...selectedMorphCoeffs].filter(i => { const pt = morphTargetCoeffs[i].pathType; return pt !== "none" && pt !== "follow-c"; }).sort((a, b) => a - b);
        if (idxArr.length > 0) {
            const lo = param1, hi = param2;
            for (let k = 0; k < idxArr.length; k++) {
                const d = morphTargetCoeffs[idxArr[k]];
                d.radius = Math.round(idxArr.length === 1 ? lo : lo + k * (hi - lo) / (idxArr.length - 1));
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
                changed = true;
            }
        }
    } else if (action === "LerpAngle") {
        const idxArr = [...selectedMorphCoeffs].filter(i => {
            const d = morphTargetCoeffs[i];
            if (d.pathType === "none" || d.pathType === "follow-c") return false;
            return (PATH_PARAMS[d.pathType] || []).some(p => p.key === "angle");
        }).sort((a, b) => a - b);
        if (idxArr.length > 0) {
            const lo = param1 / 100, hi = param2 / 100;
            for (let k = 0; k < idxArr.length; k++) {
                const d = morphTargetCoeffs[idxArr[k]];
                d.angle = idxArr.length === 1 ? lo : lo + k * (hi - lo) / (idxArr.length - 1);
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
                changed = true;
            }
        }
    } else if (action === "RandomDirection") {
        for (const idx of selectedMorphCoeffs) {
            const d = morphTargetCoeffs[idx];
            if (d.pathType === "none" || d.pathType === "follow-c") continue;
            if ((PATH_PARAMS[d.pathType] || []).some(p => p.key === "ccw")) {
                d.ccw = Math.random() < 0.5;
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
                changed = true;
            }
        }
    } else if (action === "FlipAllDirections") {
        for (const idx of selectedMorphCoeffs) {
            const d = morphTargetCoeffs[idx];
            if (d.pathType === "none" || d.pathType === "follow-c") continue;
            if ((PATH_PARAMS[d.pathType] || []).some(p => p.key === "ccw")) {
                d.ccw = !d.ccw;
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
                changed = true;
            }
        }
    } else if (action === "ShuffleCurves") {
        const idxArr = [...selectedMorphCoeffs].filter(i => { const pt = morphTargetCoeffs[i].pathType; return pt !== "none" && pt !== "follow-c"; });
        if (idxArr.length >= 2) {
            const curves = idxArr.map(i => {
                const d = morphTargetCoeffs[i];
                return { pathType: d.pathType, radius: d.radius, speed: d.speed,
                         angle: d.angle, ccw: d.ccw, extra: JSON.parse(JSON.stringify(d.extra || {})) };
            });
            for (let k = curves.length - 1; k > 0; k--) {
                const j = Math.floor(Math.random() * (k + 1));
                [curves[k], curves[j]] = [curves[j], curves[k]];
            }
            for (let k = 0; k < idxArr.length; k++) {
                const d = morphTargetCoeffs[idxArr[k]];
                const s = curves[k];
                d.pathType = s.pathType; d.radius = s.radius; d.speed = s.speed;
                d.angle = s.angle; d.ccw = s.ccw; d.extra = s.extra;
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "ShufflePositions") {
        const idxArr = [...selectedMorphCoeffs];
        if (idxArr.length >= 2) {
            const positions = idxArr.map(i => ({ re: morphTargetCoeffs[i].re, im: morphTargetCoeffs[i].im }));
            for (let k = positions.length - 1; k > 0; k--) {
                const j = Math.floor(Math.random() * (k + 1));
                [positions[k], positions[j]] = [positions[j], positions[k]];
            }
            for (let k = 0; k < idxArr.length; k++) {
                const d = morphTargetCoeffs[idxArr[k]];
                d.re = positions[k].re; d.im = positions[k].im;
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "CircleLayout") {
        const idxArr = [...selectedMorphCoeffs].sort((a, b) => a - b);
        if (idxArr.length > 0) {
            const r = param1 / 100 * coeffExtent();
            for (let k = 0; k < idxArr.length; k++) {
                const ang = 2 * Math.PI * k / idxArr.length;
                const d = morphTargetCoeffs[idxArr[k]];
                d.re = r * Math.cos(ang); d.im = r * Math.sin(ang);
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "RotatePositions") {
        const idxArr = [...selectedMorphCoeffs];
        if (idxArr.length > 0) {
            let cx = 0, cy = 0;
            for (const i of idxArr) { cx += morphTargetCoeffs[i].re; cy += morphTargetCoeffs[i].im; }
            cx /= idxArr.length; cy /= idxArr.length;
            const theta = param1 / 100 * 2 * Math.PI;
            const cosT = Math.cos(theta), sinT = Math.sin(theta);
            for (const i of idxArr) {
                const d = morphTargetCoeffs[i];
                const dx = d.re - cx, dy = d.im - cy;
                d.re = cx + dx * cosT - dy * sinT;
                d.im = cy + dx * sinT + dy * cosT;
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "ScalePositions") {
        const idxArr = [...selectedMorphCoeffs];
        if (idxArr.length > 0) {
            let cx = 0, cy = 0;
            for (const i of idxArr) { cx += morphTargetCoeffs[i].re; cy += morphTargetCoeffs[i].im; }
            cx /= idxArr.length; cy /= idxArr.length;
            const scale = param1 / 50;
            for (const i of idxArr) {
                const d = morphTargetCoeffs[i];
                d.re = cx + (d.re - cx) * scale;
                d.im = cy + (d.im - cy) * scale;
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "JitterPositions") {
        const idxArr = [...selectedMorphCoeffs];
        if (idxArr.length > 0) {
            const mag = param1 / 100 * coeffExtent();
            for (const i of idxArr) {
                const d = morphTargetCoeffs[i];
                d.re += (Math.random() - 0.5) * 2 * mag;
                d.im += (Math.random() - 0.5) * 2 * mag;
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "Conjugate") {
        for (const idx of selectedMorphCoeffs) {
            const d = morphTargetCoeffs[idx];
            d.im = -d.im;
            const absR = d.radius / 100 * coeffExtent();
            d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
            d.curveIndex = 0;
            changed = true;
        }
    } else if (action === "InvertPositions") {
        for (const idx of selectedMorphCoeffs) {
            const d = morphTargetCoeffs[idx];
            const m2 = d.re * d.re + d.im * d.im;
            if (m2 < 1e-30) continue;
            d.re = d.re / m2; d.im = -d.im / m2;
            const absR = d.radius / 100 * coeffExtent();
            d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
            d.curveIndex = 0;
            changed = true;
        }
    } else if (action === "SortByModulus") {
        const idxArr = [...selectedMorphCoeffs].sort((a, b) => a - b);
        if (idxArr.length >= 2) {
            const positions = idxArr.map(i => ({ re: morphTargetCoeffs[i].re, im: morphTargetCoeffs[i].im }));
            positions.sort((a, b) => (a.re * a.re + a.im * a.im) - (b.re * b.re + b.im * b.im));
            for (let k = 0; k < idxArr.length; k++) {
                const d = morphTargetCoeffs[idxArr[k]];
                d.re = positions[k].re; d.im = positions[k].im;
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
            }
            changed = true;
        }
    } else if (action === "SortByArgument") {
        const idxArr = [...selectedMorphCoeffs].sort((a, b) => a - b);
        if (idxArr.length >= 2) {
            const positions = idxArr.map(i => ({ re: morphTargetCoeffs[i].re, im: morphTargetCoeffs[i].im }));
            positions.sort((a, b) => Math.atan2(a.im, a.re) - Math.atan2(b.im, b.re));
            for (let k = 0; k < idxArr.length; k++) {
                const d = morphTargetCoeffs[idxArr[k]];
                d.re = positions[k].re; d.im = positions[k].im;
                const absR = d.radius / 100 * coeffExtent();
                d.curve = computeCurve(d.re, d.im, d.pathType, absR, d.angle, d.extra);
                d.curveIndex = 0;
            }
            changed = true;
        }
    }
    if (changed) {
        uiPing(1320, 0.06);
        if (morphEnabled) solveRootsThrottled();
        if (leftTab === "morph") renderMorphPanel();
        if (leftTab === "dlist") { refreshDCoeffList(); refreshDListCurveEditor(); }
    } else { uiBuzz(); }
});

// --- D-List curve type cycler ---
let dCurveCycleTypes = [];
let dCurveCycleIdx = 0;

function buildDCurveCycleTypes() {
    const types = new Set();
    for (const d of morphTargetCoeffs) types.add(d.pathType);
    dCurveCycleTypes = [...types].sort();
    if (dCurveCycleTypes.length === 0) dCurveCycleTypes = ["none"];
}

function updateDCurveCycleLabel() {
    const label = document.getElementById("dlist-curve-cycle");
    if (dCurveCycleTypes.length === 0) { label.textContent = "\u2014"; return; }
    if (dCurveCycleIdx >= dCurveCycleTypes.length) dCurveCycleIdx = 0;
    if (dCurveCycleIdx < 0) dCurveCycleIdx = dCurveCycleTypes.length - 1;
    label.textContent = pathDisplayName(dCurveCycleTypes[dCurveCycleIdx]);
}

function selectByDCurveType(type) {
    clearRootSelection();
    selectedMorphCoeffs.clear();
    for (let i = 0; i < morphTargetCoeffs.length; i++) {
        if (morphTargetCoeffs[i].pathType === type) selectedMorphCoeffs.add(i);
    }
    updateMorphSelectionVisual();
    if (leftTab === "dlist") { refreshDCoeffList(); refreshDListCurveEditor(); }
}

document.getElementById("dlist-all-curves-btn").addEventListener("click", () => {
    if (dCurveCycleTypes.length === 0) return;
    selectByDCurveType(dCurveCycleTypes[dCurveCycleIdx]);
});

document.getElementById("dlist-curve-prev").addEventListener("click", () => {
    buildDCurveCycleTypes();
    if (dCurveCycleTypes.length === 0) return;
    dCurveCycleIdx = (dCurveCycleIdx - 1 + dCurveCycleTypes.length) % dCurveCycleTypes.length;
    updateDCurveCycleLabel();
    selectByDCurveType(dCurveCycleTypes[dCurveCycleIdx]);
});

document.getElementById("dlist-curve-next").addEventListener("click", () => {
    buildDCurveCycleTypes();
    if (dCurveCycleTypes.length === 0) return;
    dCurveCycleIdx = (dCurveCycleIdx + 1) % dCurveCycleTypes.length;
    updateDCurveCycleLabel();
    selectByDCurveType(dCurveCycleTypes[dCurveCycleIdx]);
});

// --- D-List curve editor ---
const dlePanel = document.getElementById("dlist-curve-editor");
const dlePathSel = document.getElementById("dle-path-sel");
const dleControls = document.getElementById("dle-controls");
let dleInputs = {};
let dleCurrentPath = "";
let dleRefIdx = -1;       // first selected D-node (reference for controls)

function refreshDListCurveEditor() {
    if (selectedMorphCoeffs.size === 0) {
        dlePanel.style.opacity = "0.3";
        dlePanel.style.pointerEvents = "none";
        dleRefIdx = -1;
        return;
    }
    dlePanel.style.opacity = "1";
    dlePanel.style.pointerEvents = "";

    dleRefIdx = [...selectedMorphCoeffs].sort((a, b) => a - b)[0];
    const d = morphTargetCoeffs[dleRefIdx];
    dlePathSel.value = d.pathType || "none";
    dleCurrentPath = dlePathSel.value;

    buildDleControls(dleCurrentPath);
}

dlePathSel.addEventListener("change", () => {
    dleCurrentPath = dlePathSel.value;
    buildDleControls(dleCurrentPath);
});

function buildDleControls(pathType) {
    dleControls.innerHTML = "";
    dleInputs = {};
    const schema = PATH_PARAMS[pathType] || [];
    if (schema.length === 0 || dleRefIdx < 0) return;
    const d = morphTargetCoeffs[dleRefIdx];
    for (const p of schema) {
        const val = getCoeffParam(d, p.key, p);
        if (p.type === "toggle") {
            const btn = document.createElement("button");
            btn.className = "ctx-dir" + (val ? " active" : "");
            btn.textContent = val ? p.labels[1] : p.labels[0];
            btn.addEventListener("click", () => {
                const isActive = !btn.classList.contains("active");
                btn.classList.toggle("active", isActive);
                btn.textContent = isActive ? p.labels[1] : p.labels[0];
            });
            dleControls.appendChild(btn);
            dleInputs[p.key] = btn;
        } else if (p.type === "select") {
            const row = document.createElement("label");
            row.textContent = p.label + " ";
            const sel = document.createElement("select");
            for (const opt of p.options) { const o = document.createElement("option"); o.value = opt.value; o.textContent = opt.label; sel.appendChild(o); }
            sel.value = val || p.default;
            row.appendChild(sel);
            dleControls.appendChild(row);
            dleInputs[p.key] = sel;
        } else {
            const row = document.createElement("label");
            const dleUiVal = p.toUI ? p.toUI(val) : val;
            const valSpan = document.createElement("span");
            valSpan.className = "ctx-val";
            valSpan.textContent = p.fmt(dleUiVal);
            const inp = document.createElement("input");
            inp.type = "range"; inp.min = p.min; inp.max = p.max; inp.step = p.step; inp.value = dleUiVal;
            inp.addEventListener("input", () => {
                valSpan.textContent = p.fmt(parseFloat(inp.value));
            });
            row.textContent = p.label + " ";
            row.appendChild(inp);
            row.appendChild(valSpan);
            dleControls.appendChild(row);
            dleInputs[p.key] = inp;
        }
    }
}

function dleReadParams() {
    const schema = PATH_PARAMS[dleCurrentPath] || [];
    const params = {};
    for (const p of schema) {
        if (p.type === "toggle") {
            params[p.key] = dleInputs[p.key] ? dleInputs[p.key].classList.contains("active") : p.default;
        } else if (p.type === "select") {
            params[p.key] = dleInputs[p.key] ? dleInputs[p.key].value : p.default;
        } else {
            const dleRaw = dleInputs[p.key] ? parseFloat(dleInputs[p.key].value) : null;
            params[p.key] = dleRaw !== null ? (p.fromUI ? p.fromUI(dleRaw) : dleRaw) : p.default;
        }
    }
    return params;
}

function dleApplyToCoeff(di, params) {
    const d = morphTargetCoeffs[di];
    d.pathType = dleCurrentPath;
    const schema = PATH_PARAMS[dleCurrentPath] || [];
    for (const p of schema) {
        setCoeffParam(d, p.key, params[p.key]);
    }
    if (d.pathType === "none" || d.pathType === "follow-c") {
        d.curve = [{ re: d.re, im: d.im }];
    } else {
        const absRadius = d.radius / 100 * coeffExtent();
        d.curve = computeCurve(d.re, d.im, d.pathType, absRadius, d.angle, d.extra);
    }
    d.curveIndex = 0;
}

document.getElementById("dle-update-sel").addEventListener("click", () => {
    if (selectedMorphCoeffs.size === 0) { uiBuzz(); return; }
    const params = dleReadParams();
    for (const di of selectedMorphCoeffs) {
        dleApplyToCoeff(di, params);
    }
    buildDCurveCycleTypes(); updateDCurveCycleLabel();
    if (morphEnabled) solveRootsThrottled();
    if (leftTab === "morph") renderMorphPanel();
    if (leftTab === "dlist") { updateDListPathCols(); updateDListCoords(); }
});

// ============================================================================
// END D-LIST TAB
// ============================================================================

// Bitmap tab buttons
document.getElementById("bitmap-start-btn").addEventListener("click", function () {
    if (fastModeActive) exitFastMode();
    initBitmapCanvas();
    document.getElementById("bitmap-save-btn").disabled = false;
    document.getElementById("bitmap-clear-btn").disabled = false;
    document.getElementById("bitmap-fast-btn").disabled = false;
    document.getElementById("bitmap-fast-btn").textContent = "start";
    document.getElementById("bitmap-coeff-btn").disabled = false;
});

document.getElementById("bitmap-save-btn").addEventListener("click", openBitmapSavePop);

document.getElementById("bitmap-clear-btn").addEventListener("click", function () {
    if (!bitmapCtx) { uiBuzz(); return; }
    bitmapCtx.fillStyle = bitmapCanvasColor;
    bitmapCtx.fillRect(0, 0, bitmapCtx.canvas.width, bitmapCtx.canvas.height);
    fillPersistentBuffer(bitmapCanvasColor);
    if (bitmapDisplayBuffer) fillDisplayBuffer(bitmapCanvasColor);
    bitmapFrameCount = 0;
    // Do NOT reset fastModeElapsedOffset â€” just clear pixels
});

function updateBitmapZoomLabel() {
    const el = document.getElementById("bitmap-zoom-label");
    if (!el) return;
    if (!bitmapRangeInitial || !bitmapRange) { el.textContent = "1.00\u00d7"; return; }
    const mag = bitmapRangeInitial / bitmapRange;
    el.textContent = mag.toFixed(2) + "\u00d7";
}

function bitmapZoom(factor) {
    if (!bitmapRange) { uiBuzz(); return; }
    bitmapRange *= factor;
    updateBitmapZoomLabel();
    // Clear existing pixels
    if (bitmapCtx) {
        bitmapCtx.fillStyle = bitmapCanvasColor;
        bitmapCtx.fillRect(0, 0, bitmapCtx.canvas.width, bitmapCtx.canvas.height);
        fillPersistentBuffer(bitmapCanvasColor);
        if (bitmapDisplayBuffer) fillDisplayBuffer(bitmapCanvasColor);
        bitmapFrameCount = 0;
    }
    // Restart fast mode if active so workers pick up new range
    if (fastModeActive) { exitFastMode(); enterFastMode(); }
}

document.getElementById("bitmap-zoom-in-btn").addEventListener("click", () => bitmapZoom(0.75));
document.getElementById("bitmap-zoom-out-btn").addEventListener("click", () => bitmapZoom(1.25));

document.getElementById("bitmap-fast-btn").addEventListener("click", function () {
    if (fastModeActive) {
        exitFastMode();
    } else {
        enterFastMode();
    }
});

document.getElementById("bitmap-steps-select").addEventListener("change", function () {
    if (fastModeActive) { exitFastMode(); enterFastMode(); }
});

document.getElementById("bitmap-res-select").addEventListener("change", function () {
    if (fastModeActive) { exitFastMode(); enterFastMode(); }
});

document.getElementById("bitmap-coeff-btn").addEventListener("click", function () {
    bitmapCoeffView = !bitmapCoeffView;
    this.classList.toggle("active", bitmapCoeffView);
    this.textContent = bitmapCoeffView ? "COEF" : "ROOT";
    uiPing(660, 0.08);
});

const CANVAS_BG_COLORS = [
    { hex: "#000000", label: "Black" },
    { hex: "#ffffff", label: "White" },
    { hex: "#0a0a0a", label: "Near Black" },
    { hex: "#1a1a2e", label: "Midnight" },
    { hex: "#16213e", label: "Deep Navy" },
    { hex: "#0f3460", label: "Dark Sapphire" },
    { hex: "#1b1b2f", label: "Space" },
    { hex: "#2d132c", label: "Aubergine" },
    { hex: "#1a0a2e", label: "Deep Violet" },
    { hex: "#0d1b2a", label: "Dark Teal" },
    { hex: "#1b2a1b", label: "Forest Night" },
    { hex: "#2a1b1b", label: "Dark Ember" },
    { hex: "#f5f0e8", label: "Warm White" },
    { hex: "#faf3e0", label: "Parchment" },
    { hex: "#eee8d5", label: "Antique Linen" },
    { hex: "#e8e0d0", label: "Ivory Sand" },
    { hex: "#d4c5a9", label: "Pale Khaki" },
    { hex: "#c4b7a6", label: "Warm Stone" },
    { hex: "#2b2b2b", label: "Charcoal" },
    { hex: "#3c3c3c", label: "Graphite" },
    { hex: "#4a4a4a", label: "Slate" },
    { hex: "#6b6b6b", label: "Ash" },
    { hex: "#8b8b8b", label: "Silver" },
    { hex: "#b0b0b0", label: "Mist" },
];

// --- Jiggle ---
function gaussRand() {
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
}

function jiggleTargetCoeffs() {
    // Jiggle applies to all selected coefficients
    return new Set(selectedCoeffs);
}

function computeJiggleCentroid(targets) {
    if (targets.size === 0) return { re: 0, im: 0 };
    let sre = 0, sim = 0;
    for (const idx of targets) {
        const c = coefficients[idx];
        sre += c.curve[0].re;
        sim += c.curve[0].im;
    }
    return { re: sre / targets.size, im: sim / targets.size };
}

// Compute jiggle offsets as a pure function of step number.
// For most modes, offset = f(step, params, home positions) with no accumulated state.
// For walk mode, offsets are built incrementally and cached in jiggleWalkCache.
// For random mode, each step gets fresh random values (cached until step changes).
function computeJiggleForStep(step) {
    const targets = jiggleTargetCoeffs();
    if (targets.size === 0 || jiggleMode === "none") {
        jiggleOffsets = null;
        jiggleStep = -1;
        updateJiggleStatus();
        return;
    }
    if (step === jiggleStep) return; // same step, cached offsets still valid
    jiggleStep = step;

    // step is 1-based for offset computation (step 0 = no perturbation yet)
    const t = step;
    if (!jiggleOffsets) jiggleOffsets = new Map();

    if (jiggleMode === "random") {
        const sigma = (jiggleSigma / 10) * coeffExtent();
        if (sigma <= 0) { jiggleOffsets = null; updateJiggleStatus(); return; }
        for (const idx of targets) {
            jiggleOffsets.set(idx, { re: gaussRand() * sigma, im: gaussRand() * sigma });
        }
    } else if (jiggleMode === "rotate") {
        const angle = 2 * Math.PI * t / jiggleAngleSteps;
        const cen = computeJiggleCentroid(targets);
        const cos_a = Math.cos(angle), sin_a = Math.sin(angle);
        for (const idx of targets) {
            const hre = coefficients[idx].curve[0].re, him = coefficients[idx].curve[0].im;
            const dx = hre - cen.re, dy = him - cen.im;
            jiggleOffsets.set(idx, {
                re: dx * cos_a - dy * sin_a - dx,
                im: dx * sin_a + dy * cos_a - dy
            });
        }
    } else if (jiggleMode === "walk") {
        const sigma = (jiggleSigma / 10) * coeffExtent();
        if (sigma <= 0) { jiggleOffsets = null; updateJiggleStatus(); return; }
        // Walk is inherently sequential â€” extend cache from last known step
        if (!jiggleWalkCache) jiggleWalkCache = { step: 0, offsets: new Map() };
        // If requested step is before cached step, reset (shouldn't happen normally)
        if (t < jiggleWalkCache.step) {
            jiggleWalkCache = { step: 0, offsets: new Map() };
        }
        // Build forward from cached step to current step
        for (let s = jiggleWalkCache.step + 1; s <= t; s++) {
            for (const idx of targets) {
                const prev = jiggleWalkCache.offsets.get(idx) || { re: 0, im: 0 };
                jiggleWalkCache.offsets.set(idx, {
                    re: prev.re + gaussRand() * sigma,
                    im: prev.im + gaussRand() * sigma
                });
            }
        }
        jiggleWalkCache.step = t;
        for (const idx of targets) {
            const off = jiggleWalkCache.offsets.get(idx) || { re: 0, im: 0 };
            jiggleOffsets.set(idx, { re: off.re, im: off.im });
        }
    } else if (jiggleMode === "scale-center") {
        const grow = jiggleScaleStep / 100 * coeffExtent();
        for (const idx of targets) {
            const hre = coefficients[idx].curve[0].re, him = coefficients[idx].curve[0].im;
            const d = Math.hypot(hre, him) || 1;
            jiggleOffsets.set(idx, { re: hre / d * grow * t, im: him / d * grow * t });
        }
    } else if (jiggleMode === "scale-centroid") {
        const grow = jiggleScaleStep / 100 * coeffExtent();
        const cen = computeJiggleCentroid(targets);
        for (const idx of targets) {
            const hre = coefficients[idx].curve[0].re, him = coefficients[idx].curve[0].im;
            const dx = hre - cen.re, dy = him - cen.im;
            const d = Math.hypot(dx, dy) || 1;
            jiggleOffsets.set(idx, { re: dx / d * grow * t, im: dy / d * grow * t });
        }
    } else if (jiggleMode === "circle") {
        const angle = 2 * Math.PI * t / jiggleCircleSteps;
        const cos_a = Math.cos(angle), sin_a = Math.sin(angle);
        for (const idx of targets) {
            const hre = coefficients[idx].curve[0].re, him = coefficients[idx].curve[0].im;
            jiggleOffsets.set(idx, {
                re: hre * (cos_a - 1) - him * sin_a,
                im: hre * sin_a + him * (cos_a - 1)
            });
        }
    } else if (jiggleMode === "spiral-centroid") {
        const angle = 2 * Math.PI * t / jiggleAngleSteps;
        const grow = jiggleScaleStep / 100 * coeffExtent();
        const cen = computeJiggleCentroid(targets);
        const cos_a = Math.cos(angle), sin_a = Math.sin(angle);
        for (const idx of targets) {
            const hre = coefficients[idx].curve[0].re, him = coefficients[idx].curve[0].im;
            const dx = hre - cen.re, dy = him - cen.im;
            const d = Math.hypot(dx, dy) || 1;
            const r = 1 + grow * t / d;
            jiggleOffsets.set(idx, {
                re: r * (dx * cos_a - dy * sin_a) - dx,
                im: r * (dx * sin_a + dy * cos_a) - dy
            });
        }
    } else if (jiggleMode === "spiral-center") {
        const angle = 2 * Math.PI * t / jiggleAngleSteps;
        const grow = jiggleScaleStep / 100 * coeffExtent();
        const cos_a = Math.cos(angle), sin_a = Math.sin(angle);
        for (const idx of targets) {
            const hre = coefficients[idx].curve[0].re, him = coefficients[idx].curve[0].im;
            const d = Math.hypot(hre, him) || 1;
            const r = 1 + grow * t / d;
            jiggleOffsets.set(idx, {
                re: r * (hre * cos_a - him * sin_a) - hre,
                im: r * (hre * sin_a + him * cos_a) - him
            });
        }
    } else if (jiggleMode === "breathe") {
        const amp = jiggleAmplitude / 100;
        const scale = 1 + amp * Math.sin(2 * Math.PI * t / jigglePeriod);
        const cen = computeJiggleCentroid(targets);
        for (const idx of targets) {
            const hre = coefficients[idx].curve[0].re, him = coefficients[idx].curve[0].im;
            const dx = hre - cen.re, dy = him - cen.im;
            jiggleOffsets.set(idx, { re: dx * (scale - 1), im: dy * (scale - 1) });
        }
    } else if (jiggleMode === "wobble") {
        const angle = (2 * Math.PI / jiggleAngleSteps) * Math.sin(2 * Math.PI * t / jigglePeriod);
        const cen = computeJiggleCentroid(targets);
        const cos_a = Math.cos(angle), sin_a = Math.sin(angle);
        for (const idx of targets) {
            const hre = coefficients[idx].curve[0].re, him = coefficients[idx].curve[0].im;
            const dx = hre - cen.re, dy = him - cen.im;
            jiggleOffsets.set(idx, {
                re: dx * cos_a - dy * sin_a - dx,
                im: dx * sin_a + dy * cos_a - dy
            });
        }
    } else if (jiggleMode === "lissajous") {
        const amp = (jiggleAmplitude / 100) * coeffExtent();
        const dx = amp * Math.sin(2 * Math.PI * jiggleLissFreqX * t / jigglePeriod + Math.PI / 2);
        const dy = amp * Math.sin(2 * Math.PI * jiggleLissFreqY * t / jigglePeriod);
        for (const idx of targets) {
            jiggleOffsets.set(idx, { re: dx, im: dy });
        }
    }
    updateJiggleStatus();
}

// Convenience: compute jiggle step from elapsed time
function jiggleStepFromElapsed(elapsed) {
    if (jiggleMode === "none" || jiggleInterval <= 0) return 0;
    return Math.max(0, Math.floor(elapsed / jiggleInterval));
}

function updateJiggleStatus() {
    const el = document.getElementById("jiggle-status");
    if (!el) return;
    const targets = jiggleTargetCoeffs();
    const offCount = jiggleOffsets ? jiggleOffsets.size : 0;
    const parts = [];
    parts.push(targets.size + " target" + (targets.size !== 1 ? "s" : ""));
    if (offCount > 0) parts.push(offCount + " offset" + (offCount !== 1 ? "s" : ""));
    el.textContent = parts.join(", ");
    el.style.color = offCount > 0 ? "var(--accent)" : "var(--muted)";
}

function nearestPrime(n) {
    n = Math.round(n);
    if (n <= 2) return 2;
    function ip(v) {
        if (v < 2) return false;
        if (v === 2) return true;
        if (v % 2 === 0) return false;
        for (let d = 3; d * d <= v; d += 2) if (v % d === 0) return false;
        return true;
    }
    if (ip(n)) return n;
    let lo = n - 1, hi = n + 1;
    while (true) {
        if (lo >= 2 && ip(lo)) return lo;
        if (ip(hi)) return hi;
        lo--; hi++;
    }
}

function buildJigglePanel() {
    const container = document.getElementById("jiggle-controls");
    if (!container) return;
    container.innerHTML = "";
    updateJiggleStatus();

    const inpStyle = "width:50px;background:var(--bg);color:var(--fg);border:1px solid var(--stroke);border-radius:3px;padding:2px 4px;font-size:10px;";
    const jLblStyle = "font-size:10px;color:var(--fg);";
    const hintStyle = "font-size:9px;color:var(--muted);";
    const jRowStyle = "display:flex;align-items:center;gap:6px;margin:4px 0;";

    // Mode dropdown
    const modeRow = document.createElement("div");
    modeRow.style.cssText = jRowStyle;
    const modeLbl = document.createElement("span");
    modeLbl.style.cssText = jLblStyle;
    modeLbl.textContent = "Mode";
    const modeSel = document.createElement("select");
    modeSel.style.cssText = "background:var(--bg);color:var(--fg);border:1px solid var(--stroke);border-radius:3px;padding:2px 4px;font-size:10px;";
    const jiggleModes = [
        ["none","None"],["random","Random"],["rotate","Rotate"],["walk","Walk"],
        ["scale-center","Scale (center)"],["scale-centroid","Scale (centroid)"],["circle","Circle"],["spiral-centroid","Spiral (centroid)"],
        ["spiral-center","Spiral (center)"],["breathe","Breathe"],["wobble","Wobble"],["lissajous","Lissajous"]
    ];
    for (const [val, label] of jiggleModes) {
        const opt = document.createElement("option");
        opt.value = val; opt.textContent = label;
        if (val === jiggleMode) opt.selected = true;
        modeSel.appendChild(opt);
    }
    modeRow.appendChild(modeLbl); modeRow.appendChild(modeSel);
    container.appendChild(modeRow);

    // Mode-specific controls container
    const controlsDiv = document.createElement("div");
    container.appendChild(controlsDiv);
    function buildModeControls() {
        controlsDiv.innerHTML = "";
        const stepBtnStyle = "font-size:8px;padding:0 3px;background:transparent;color:var(--muted);border:1px solid var(--stroke);border-radius:3px;cursor:pointer;margin-left:2px;line-height:14px;";
        function addStepBtns(row, inp, hint, getV, setV, mn, mx) {
            const sync = () => { const v = getV(); inp.value = v; if (hint) hint.textContent = v; };
            const bm = document.createElement("button"); bm.textContent = "\u22121"; bm.style.cssText = stepBtnStyle;
            bm.addEventListener("click", () => { setV(Math.max(mn, getV() - 1)); sync(); });
            const bp = document.createElement("button"); bp.textContent = "+1"; bp.style.cssText = stepBtnStyle;
            bp.addEventListener("click", () => { setV(Math.min(mx, getV() + 1)); sync(); });
            const bP = document.createElement("button"); bP.textContent = "P"; bP.title = "nearest prime"; bP.style.cssText = stepBtnStyle;
            bP.addEventListener("click", () => { setV(Math.max(mn, Math.min(mx, nearestPrime(getV())))); sync(); });
            row.appendChild(bm); row.appendChild(bp); row.appendChild(bP);
        }
        if (jiggleMode === "random" || jiggleMode === "walk") {
            const r = document.createElement("div"); r.style.cssText = jRowStyle;
            const l = document.createElement("span"); l.style.cssText = jLblStyle; l.textContent = "\u03C3";
            const i = document.createElement("input"); i.type = "range"; i.min = "0"; i.max = "10"; i.step = "0.01"; i.value = jiggleSigma; i.style.cssText = "width:100px;";
            const h = document.createElement("span"); h.style.cssText = hintStyle; h.textContent = jiggleSigma;
            i.addEventListener("input", () => { jiggleSigma = parseFloat(i.value) || 0; h.textContent = jiggleSigma; });
            const sigBtnStyle = "font-size:8px;padding:0 3px;background:transparent;color:var(--muted);border:1px solid var(--stroke);border-radius:3px;cursor:pointer;margin-left:2px;line-height:14px;";
            function setSigma(v) { jiggleSigma = Math.round(Math.max(0, Math.min(10, v)) * 100) / 100; i.value = String(jiggleSigma); h.textContent = jiggleSigma; }
            const sigMinus = document.createElement("button"); sigMinus.textContent = "\u22120.01"; sigMinus.style.cssText = sigBtnStyle;
            sigMinus.addEventListener("click", () => setSigma(jiggleSigma - 0.01));
            const sigPlus = document.createElement("button"); sigPlus.textContent = "+0.01"; sigPlus.style.cssText = sigBtnStyle;
            sigPlus.addEventListener("click", () => setSigma(jiggleSigma + 0.01));
            r.appendChild(l); r.appendChild(i); r.appendChild(h); r.appendChild(sigMinus); r.appendChild(sigPlus); controlsDiv.appendChild(r);
        } else if (jiggleMode === "rotate") {
            const r = document.createElement("div"); r.style.cssText = jRowStyle;
            const l = document.createElement("span"); l.style.cssText = jLblStyle; l.textContent = "steps";
            const i = document.createElement("input"); i.type = "range"; i.min = "10"; i.max = "5000"; i.step = "1"; i.value = jiggleAngleSteps; i.style.cssText = "width:100px;";
            const h = document.createElement("span"); h.style.cssText = hintStyle; h.textContent = jiggleAngleSteps;
            i.addEventListener("input", () => { jiggleAngleSteps = parseInt(i.value, 10) || 100; h.textContent = jiggleAngleSteps; });
            r.appendChild(l); r.appendChild(i); r.appendChild(h);
            addStepBtns(r, i, h, () => jiggleAngleSteps, v => { jiggleAngleSteps = v; }, 10, 5000);
            controlsDiv.appendChild(r);
        } else if (jiggleMode === "circle") {
            const r = document.createElement("div"); r.style.cssText = jRowStyle;
            const l = document.createElement("span"); l.style.cssText = jLblStyle; l.textContent = "steps";
            const i = document.createElement("input"); i.type = "range"; i.min = "10"; i.max = "5000"; i.step = "1"; i.value = jiggleCircleSteps; i.style.cssText = "width:100px;";
            const h = document.createElement("span"); h.style.cssText = hintStyle; h.textContent = jiggleCircleSteps;
            i.addEventListener("input", () => { jiggleCircleSteps = parseInt(i.value, 10) || 60; h.textContent = jiggleCircleSteps; });
            r.appendChild(l); r.appendChild(i); r.appendChild(h);
            addStepBtns(r, i, h, () => jiggleCircleSteps, v => { jiggleCircleSteps = v; }, 10, 5000);
            controlsDiv.appendChild(r);
        } else if (jiggleMode === "scale-center" || jiggleMode === "scale-centroid") {
            const r = document.createElement("div"); r.style.cssText = jRowStyle;
            const l = document.createElement("span"); l.style.cssText = jLblStyle; l.textContent = "growth";
            const i = document.createElement("input"); i.type = "range"; i.min = "0.01"; i.max = "1"; i.step = "0.01"; i.value = jiggleScaleStep; i.style.cssText = "width:100px;";
            const h = document.createElement("span"); h.style.cssText = hintStyle; h.textContent = jiggleScaleStep.toFixed(2) + "%";
            i.addEventListener("input", () => { jiggleScaleStep = parseFloat(i.value) || 0.1; h.textContent = jiggleScaleStep.toFixed(2) + "%"; });
            r.appendChild(l); r.appendChild(i); r.appendChild(h); controlsDiv.appendChild(r);
        } else if (jiggleMode === "spiral-centroid" || jiggleMode === "spiral-center") {
            const r1 = document.createElement("div"); r1.style.cssText = jRowStyle;
            const l1 = document.createElement("span"); l1.style.cssText = jLblStyle; l1.textContent = "steps";
            const i1 = document.createElement("input"); i1.type = "range"; i1.min = "10"; i1.max = "5000"; i1.step = "1"; i1.value = jiggleAngleSteps; i1.style.cssText = "width:100px;";
            const h1 = document.createElement("span"); h1.style.cssText = hintStyle; h1.textContent = jiggleAngleSteps;
            i1.addEventListener("input", () => { jiggleAngleSteps = parseInt(i1.value, 10) || 100; h1.textContent = jiggleAngleSteps; });
            r1.appendChild(l1); r1.appendChild(i1); r1.appendChild(h1);
            addStepBtns(r1, i1, h1, () => jiggleAngleSteps, v => { jiggleAngleSteps = v; }, 10, 5000);
            controlsDiv.appendChild(r1);
            const r2 = document.createElement("div"); r2.style.cssText = jRowStyle;
            const l2 = document.createElement("span"); l2.style.cssText = jLblStyle; l2.textContent = "growth";
            const i2 = document.createElement("input"); i2.type = "range"; i2.min = "0.01"; i2.max = "1"; i2.step = "0.01"; i2.value = jiggleScaleStep; i2.style.cssText = "width:100px;";
            const h2 = document.createElement("span"); h2.style.cssText = hintStyle; h2.textContent = jiggleScaleStep.toFixed(2) + "%";
            i2.addEventListener("input", () => { jiggleScaleStep = parseFloat(i2.value) || 0.1; h2.textContent = jiggleScaleStep.toFixed(2) + "%"; });
            r2.appendChild(l2); r2.appendChild(i2); r2.appendChild(h2); controlsDiv.appendChild(r2);
        } else if (jiggleMode === "breathe") {
            const r1 = document.createElement("div"); r1.style.cssText = jRowStyle;
            const l1 = document.createElement("span"); l1.style.cssText = jLblStyle; l1.textContent = "amp";
            const i1 = document.createElement("input"); i1.type = "number"; i1.step = "1"; i1.min = "1"; i1.max = "50"; i1.value = jiggleAmplitude; i1.style.cssText = inpStyle;
            i1.addEventListener("input", () => { jiggleAmplitude = Math.max(1, Math.min(50, parseInt(i1.value,10)||10)); });
            const h1 = document.createElement("span"); h1.style.cssText = hintStyle; h1.textContent = "%";
            r1.appendChild(l1); r1.appendChild(i1); r1.appendChild(h1); controlsDiv.appendChild(r1);
            const r2 = document.createElement("div"); r2.style.cssText = jRowStyle;
            const l2 = document.createElement("span"); l2.style.cssText = jLblStyle; l2.textContent = "period";
            const i2 = document.createElement("input"); i2.type = "number"; i2.step = "1"; i2.min = "2"; i2.max = "1000"; i2.value = jigglePeriod; i2.style.cssText = inpStyle;
            i2.addEventListener("input", () => { jigglePeriod = Math.max(2, Math.min(1000, parseInt(i2.value,10)||20)); });
            const h2 = document.createElement("span"); h2.style.cssText = hintStyle; h2.textContent = "cycles";
            r2.appendChild(l2); r2.appendChild(i2); r2.appendChild(h2);
            addStepBtns(r2, i2, null, () => jigglePeriod, v => { jigglePeriod = v; }, 2, 1000);
            controlsDiv.appendChild(r2);
        } else if (jiggleMode === "wobble") {
            const r1 = document.createElement("div"); r1.style.cssText = jRowStyle;
            const l1 = document.createElement("span"); l1.style.cssText = jLblStyle; l1.textContent = "steps";
            const i1 = document.createElement("input"); i1.type = "range"; i1.min = "10"; i1.max = "5000"; i1.step = "1"; i1.value = jiggleAngleSteps; i1.style.cssText = "width:100px;";
            const h1 = document.createElement("span"); h1.style.cssText = hintStyle; h1.textContent = jiggleAngleSteps;
            i1.addEventListener("input", () => { jiggleAngleSteps = parseInt(i1.value, 10) || 100; h1.textContent = jiggleAngleSteps; });
            r1.appendChild(l1); r1.appendChild(i1); r1.appendChild(h1);
            addStepBtns(r1, i1, h1, () => jiggleAngleSteps, v => { jiggleAngleSteps = v; }, 10, 5000);
            controlsDiv.appendChild(r1);
            const r2 = document.createElement("div"); r2.style.cssText = jRowStyle;
            const l2 = document.createElement("span"); l2.style.cssText = jLblStyle; l2.textContent = "period";
            const i2 = document.createElement("input"); i2.type = "number"; i2.step = "1"; i2.min = "2"; i2.max = "1000"; i2.value = jigglePeriod; i2.style.cssText = inpStyle;
            i2.addEventListener("input", () => { jigglePeriod = Math.max(2, Math.min(1000, parseInt(i2.value,10)||20)); });
            const h2 = document.createElement("span"); h2.style.cssText = hintStyle; h2.textContent = "cycles";
            r2.appendChild(l2); r2.appendChild(i2); r2.appendChild(h2);
            addStepBtns(r2, i2, null, () => jigglePeriod, v => { jigglePeriod = v; }, 2, 1000);
            controlsDiv.appendChild(r2);
        } else if (jiggleMode === "lissajous") {
            const r1 = document.createElement("div"); r1.style.cssText = jRowStyle;
            const l1 = document.createElement("span"); l1.style.cssText = jLblStyle; l1.textContent = "amp";
            const i1 = document.createElement("input"); i1.type = "number"; i1.step = "1"; i1.min = "1"; i1.max = "50"; i1.value = jiggleAmplitude; i1.style.cssText = inpStyle;
            i1.addEventListener("input", () => { jiggleAmplitude = Math.max(1, Math.min(50, parseInt(i1.value,10)||10)); });
            const h1 = document.createElement("span"); h1.style.cssText = hintStyle; h1.textContent = "%";
            r1.appendChild(l1); r1.appendChild(i1); r1.appendChild(h1); controlsDiv.appendChild(r1);
            const r2 = document.createElement("div"); r2.style.cssText = jRowStyle;
            const l2 = document.createElement("span"); l2.style.cssText = jLblStyle; l2.textContent = "steps";
            const i2 = document.createElement("input"); i2.type = "range"; i2.min = "10"; i2.max = "5000"; i2.step = "1"; i2.value = jigglePeriod; i2.style.cssText = "width:100px;";
            const h2 = document.createElement("span"); h2.style.cssText = hintStyle; h2.textContent = jigglePeriod;
            i2.addEventListener("input", () => { jigglePeriod = parseInt(i2.value, 10) || 20; h2.textContent = jigglePeriod; });
            r2.appendChild(l2); r2.appendChild(i2); r2.appendChild(h2);
            addStepBtns(r2, i2, h2, () => jigglePeriod, v => { jigglePeriod = v; }, 10, 5000);
            controlsDiv.appendChild(r2);
            const r3 = document.createElement("div"); r3.style.cssText = jRowStyle;
            const l3 = document.createElement("span"); l3.style.cssText = jLblStyle; l3.textContent = "fX";
            const i3 = document.createElement("input"); i3.type = "number"; i3.step = "1"; i3.min = "1"; i3.max = "10"; i3.value = jiggleLissFreqX; i3.style.cssText = inpStyle;
            i3.addEventListener("input", () => { jiggleLissFreqX = Math.max(1, Math.min(10, parseInt(i3.value,10)||1)); });
            r3.appendChild(l3); r3.appendChild(i3); controlsDiv.appendChild(r3);
            const r4 = document.createElement("div"); r4.style.cssText = jRowStyle;
            const l4 = document.createElement("span"); l4.style.cssText = jLblStyle; l4.textContent = "fY";
            const i4 = document.createElement("input"); i4.type = "number"; i4.step = "1"; i4.min = "1"; i4.max = "10"; i4.value = jiggleLissFreqY; i4.style.cssText = inpStyle;
            i4.addEventListener("input", () => { jiggleLissFreqY = Math.max(1, Math.min(10, parseInt(i4.value,10)||2)); });
            r4.appendChild(l4); r4.appendChild(i4); controlsDiv.appendChild(r4);
        }
    }
    buildModeControls();
    modeSel.addEventListener("change", () => { jiggleMode = modeSel.value; buildModeControls(); });

    // Interval slider
    const cycRow = document.createElement("div");
    cycRow.style.cssText = jRowStyle;
    const cycLbl = document.createElement("span");
    cycLbl.style.cssText = jLblStyle; cycLbl.textContent = "Interval";
    cycRow.appendChild(cycLbl);
    const cycSlider = document.createElement("input");
    cycSlider.type = "range"; cycSlider.min = "0.1"; cycSlider.max = "100"; cycSlider.step = "0.1";
    cycSlider.value = String(jiggleInterval);
    cycSlider.style.cssText = "width:70px;accent-color:var(--accent);";
    const cycVal = document.createElement("span");
    cycVal.style.cssText = "font-size:9px;color:var(--muted);min-width:24px;";
    cycVal.textContent = jiggleInterval + "s";
    cycSlider.addEventListener("input", () => { jiggleInterval = parseFloat(cycSlider.value); cycVal.textContent = jiggleInterval + "s"; });
    cycRow.appendChild(cycSlider); cycRow.appendChild(cycVal);
    // +/- 0.1s precision buttons
    const cycBtnStyle = "font-size:8px;padding:0 3px;background:transparent;color:var(--muted);border:1px solid var(--stroke);border-radius:3px;cursor:pointer;margin-left:2px;line-height:14px;";
    function setCycInterval(v) { jiggleInterval = Math.round(Math.max(0.1, Math.min(100, v)) * 10) / 10; cycSlider.value = String(jiggleInterval); cycVal.textContent = jiggleInterval + "s"; }
    const cycMinus = document.createElement("button"); cycMinus.textContent = "\u22120.1"; cycMinus.title = "Decrease interval by 0.1s"; cycMinus.style.cssText = cycBtnStyle;
    cycMinus.addEventListener("click", () => setCycInterval(jiggleInterval - 0.1));
    cycRow.appendChild(cycMinus);
    const cycPlus = document.createElement("button"); cycPlus.textContent = "+0.1"; cycPlus.title = "Increase interval by 0.1s"; cycPlus.style.cssText = cycBtnStyle;
    cycPlus.addEventListener("click", () => setCycInterval(jiggleInterval + 0.1));
    cycRow.appendChild(cycPlus);
    // GCD button
    const gcdBtn = document.createElement("button");
    gcdBtn.textContent = "GCD";
    gcdBtn.title = "Set interval to pattern repeat period (1000 / GCD of integer speeds)";
    gcdBtn.style.cssText = "font-size:9px;padding:1px 5px;background:transparent;color:var(--muted);border:1px solid var(--stroke);border-radius:3px;cursor:pointer;margin-left:2px;";
    gcdBtn.addEventListener("click", () => {
        function gcd(a, b) { while (b) { [a, b] = [b, a % b]; } return a; }
        const intSpeeds = [];
        for (const c of coefficients) {
            if (c.pathType === "none") continue;
            const s = Math.round(c.speed * 1000);
            if (s > 0) intSpeeds.push(s);
        }
        if (intSpeeds.length === 0) return;
        let g = intSpeeds[0];
        for (let i = 1; i < intSpeeds.length; i++) g = gcd(g, intSpeeds[i]);
        const cycle = Math.round(1000 / g);
        const clamped = Math.max(0.1, Math.min(100, cycle));
        jiggleInterval = clamped;
        cycSlider.value = String(clamped);
        cycVal.textContent = clamped + "s";
    });
    cycRow.appendChild(gcdBtn);
    container.appendChild(cycRow);
}

function rebuild() {
    S = getPanelSize();
    initPanelScales(panels.coeff);
    initPanelScales(panels.roots);

    // Clear and rebuild both SVGs
    coeffSvg.selectAll("*").remove();
    rootsSvg.selectAll("*").remove();
    if (morphPanelInited) {
        morphSvg.selectAll("*").remove();
        morphPanelInited = false;
    }
    setupPanel(coeffSvg, panels.coeff);
    setupPanel(rootsSvg, panels.roots);

    // Recreate layers
    coeffTrailLayer = coeffSvg.append("g").attr("class", "trail-layer");
    coeffLayer = coeffSvg.append("g");
    coeffChainLine = coeffLayer.append("polyline")
        .attr("class", "coeff-chain")
        .attr("fill", "none")
        .attr("stroke", "rgba(255,255,255,0.35)")
        .attr("stroke-width", 1.5)
        .attr("stroke-dasharray", "4,3")
        .style("display", "none");
    trailLayer = rootsSvg.append("g").attr("class", "trail-layer");
    rootsLayer = rootsSvg.append("g");

    renderCoefficients();
    updateCoeffSelectionVisual();

    // Re-solve roots and re-render domain coloring at new size
    solveRoots();
    rootsSvg.classed("domain-active", domainColoringEnabled);
    renderDomainColoring();
    if (trailData.length > 0) renderTrails();
    renderCoeffTrails();
    resizeStatsCanvases();
    if (activeTab === "stats") drawAllStatsPlots();
}

let resizeTimer;
window.addEventListener("resize", () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(rebuild, 150);
});

// --- Init ---

rootsSvg.classed("domain-active", domainColoringEnabled);
domainCanvas.style.display = domainColoringEnabled ? "block" : "none";
initCoefficients(currentDegree);
initMorphTarget();
renderCoefficients();
solveRoots();
renderDomainColoring();

// Install marquee selection (once â€” survives rebuild since SVG element persists)
installMarqueeSelection(coeffSvg, () => coeffLayer.selectAll("circle.coeff"), "coeff");
installMarqueeSelection(rootsSvg, () => rootsLayer.selectAll("circle.root"), "roots");
installMarqueeSelection(d3.select("#morph-panel"), () => morphLayer ? morphLayer.selectAll("circle.morph-coeff") : d3.selectAll(".morph-coeff-none"), "morph");

// Default trajectory: C3 (index 2) â€” circle, R50%, S0.5, A0.33, CW
{
    const c = coefficients[2];
    c.pathType = "circle"; c.radius = 50; c.speed = 0.5; c.angle = 0.33; c.ccw = false; c.extra = {};
    c.curve = computeCurve(c.re, c.im, "circle", 50 / 100 * coeffExtent(), 0.33, c.extra);
    c.curveIndex = 0;
    selectedCoeffs.add(2);
    lastSelectedCoeff = 2;
}
// Default trajectory: C0 (index 5) â€” circle, R15%, S0.85, A0.85, CW
{
    const c2 = coefficients[5];
    c2.pathType = "circle"; c2.radius = 15; c2.speed = 0.85; c2.angle = 0.85; c2.ccw = false; c2.extra = {};
    c2.curve = computeCurve(c2.re, c2.im, "circle", 15 / 100 * coeffExtent(), 0.85, c2.extra);
    c2.curveIndex = 0;
}
updateCoeffSelectionVisual();
updateAnimBar();
renderCoeffTrails();
</script>
</body>
</html>
